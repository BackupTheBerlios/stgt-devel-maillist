From fujita.tomonori at lab.ntt.co.jp  Thu May  3 07:10:14 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 03 May 2007 14:10:14 +0900
Subject: [Stgt-devel] vtl take 3
In-Reply-To: <f29db9a80704261810m7fd81f9ct25748bbe6503c3fe@mail.gmail.com>
References: <f29db9a80704261810m7fd81f9ct25748bbe6503c3fe@mail.gmail.com>
Message-ID: <200705030510.l435AJts014728@mbox.iij4u.or.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] vtl take 3
Date: Fri, 27 Apr 2007 11:10:15 +1000

> Post #3 of vtl patch against current scsi target git head..
>  - Sorry - it is an attachment due to patch size (80k)
> 
> Updated smc module to use 'kernel style param parser' parser.c
>  - ssc module is still to be updated.
> 
> Moved common 'scsi_sn' & 'scsi_id' from target.c to spc.c
>  - To me, the processing of module 'params' should be handled in each module.
>  - sbc / mmc both call the common (original code in target.c) routine
> in spc.c. While this is not a 'SCSI Primary Command', I chose this as
> the 'best fit' place for the common routine.

OK. I don't like to have the code to parse scsi_sn and scsi_id in all
the device types but seems that we have no choice (we could do
something like IET iotype code does, but it's not nice).


> smc improvements since last post:
>  - Configure slots & ability to add 'media' (or at least assign a
> barcode to the slot location)
>  - mode sense pages.
> 
> tgt-setup in the / directory is my 'pre-canned' script to test.
> 
> What next:
> - Over the next few days I should have enough of the smc coded which
> will allow utility 'mtx' to move media between slots / drives.
> - Then it will be onto the ssc module.
> 
> Log sense pages still to be implemented. Current code in this patch
> for LOG SENSE/SELECT is just a place holder.

I'm happy to merge your code when it can do something useful. It
doesn't need to be complete.

Thanks.


From rcj at linux.vnet.ibm.com  Fri May  4 18:07:12 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Fri, 4 May 2007 11:07:12 -0500
Subject: [Stgt-devel] Question for pass-through target design
Message-ID: <20070504160712.GB16528@austin.ibm.com>

It looks like the pass-through target support is currently broken, at
least as I've checked for ibmvstgt, but I think it's a general problem.
I wanted to check my assumptions and get ideas.

The code isn't allocating any memory to pass along to the sg code to store
the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
the pass-through target isn't going to function.  Even if we had memory
allocated, there isn't a means of getting data to be written via sg down
this code path.

What ideas are there as to how the data will get to user-space so that
we can use sg?

Regards,
Robert Jennings


From fujita.tomonori at lab.ntt.co.jp  Fri May  4 19:04:30 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 05 May 2007 02:04:30 +0900
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <20070504160712.GB16528@austin.ibm.com>
References: <20070504160712.GB16528@austin.ibm.com>
Message-ID: <200705041704.l44H4WXa003789@mbox.iij4u.or.jp>

From: Robert Jennings <rcj at linux.vnet.ibm.com>
Subject: [Stgt-devel] Question for pass-through target design
Date: Fri, 4 May 2007 11:07:12 -0500

> It looks like the pass-through target support is currently broken, at
> least as I've checked for ibmvstgt, but I think it's a general problem.
> I wanted to check my assumptions and get ideas.

Yeah, unfortunately, it works only with the iSCSI target driver (which
runs in user space).


> The code isn't allocating any memory to pass along to the sg code to store
> the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
> or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
> which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
> the pass-through target isn't going to function.  Even if we had memory
> allocated, there isn't a means of getting data to be written via sg down
> this code path.
> 
> What ideas are there as to how the data will get to user-space so that
> we can use sg?

For kernel-space drivers, we don't need to go to user-space. We can do
the pass-through in kernel space. I talked with James about this last
year and he said that if the code is implemented cleanly, he would
merges it into mainline.

Is anyone interested in implementing this?


From dougg at torque.net  Fri May  4 19:52:54 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Fri, 04 May 2007 13:52:54 -0400
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <200705041704.l44H4WXa003789@mbox.iij4u.or.jp>
References: <20070504160712.GB16528@austin.ibm.com>
	<200705041704.l44H4WXa003789@mbox.iij4u.or.jp>
Message-ID: <463B72F6.3000207@torque.net>

FUJITA Tomonori wrote:
> From: Robert Jennings <rcj at linux.vnet.ibm.com>
> Subject: [Stgt-devel] Question for pass-through target design
> Date: Fri, 4 May 2007 11:07:12 -0500
> 
>> It looks like the pass-through target support is currently broken, at
>> least as I've checked for ibmvstgt, but I think it's a general problem.
>> I wanted to check my assumptions and get ideas.
> 
> Yeah, unfortunately, it works only with the iSCSI target driver (which
> runs in user space).
> 
> 
>> The code isn't allocating any memory to pass along to the sg code to store
>> the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
>> or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
>> which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
>> the pass-through target isn't going to function.  Even if we had memory
>> allocated, there isn't a means of getting data to be written via sg down
>> this code path.
>>
>> What ideas are there as to how the data will get to user-space so that
>> we can use sg?
> 
> For kernel-space drivers, we don't need to go to user-space. We can do
> the pass-through in kernel space. I talked with James about this last
> year and he said that if the code is implemented cleanly, he would
> merges it into mainline.

We already have a pass-through in the kernel space for
kernel space drivers. It is the scsi_tgt* code. If it
could be made more flexible, such as handling multiple
boundary crossings per SCSI command, then I don't see
why another mechanism is needed. Once the events, associated
data structures and protocol are documented, then any user
space program that complies can replace tgtd.

Doug Gilbert

> Is anyone interested in implementing this?




From rcj at linux.vnet.ibm.com  Fri May  4 21:33:06 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Fri, 4 May 2007 14:33:06 -0500
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <200705041704.l44H4WXa003789@mbox.iij4u.or.jp>
References: <20070504160712.GB16528@austin.ibm.com>
	<200705041704.l44H4WXa003789@mbox.iij4u.or.jp>
Message-ID: <20070504193306.GC16528@austin.ibm.com>

* FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> From: Robert Jennings <rcj at linux.vnet.ibm.com>
> Subject: [Stgt-devel] Question for pass-through target design
> Date: Fri, 4 May 2007 11:07:12 -0500
> 
> > It looks like the pass-through target support is currently broken, at
> > least as I've checked for ibmvstgt, but I think it's a general problem.
> > I wanted to check my assumptions and get ideas.
> 
> Yeah, unfortunately, it works only with the iSCSI target driver (which
> runs in user space).
> 
> 
> > The code isn't allocating any memory to pass along to the sg code to store
> > the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
> > or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
> > which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
> > the pass-through target isn't going to function.  Even if we had memory
> > allocated, there isn't a means of getting data to be written via sg down
> > this code path.
> > 
> > What ideas are there as to how the data will get to user-space so that
> > we can use sg?
> 
> For kernel-space drivers, we don't need to go to user-space. We can do
> the pass-through in kernel space. I talked with James about this last
> year and he said that if the code is implemented cleanly, he would
> merges it into mainline.

That sounds fine, how can we make the lld in kernel space aware that the
target is pass-through?  

Should the kernel driver operate as usual and queue the command to tgtd
and then tgtd would see that it's a pass-through target and communicate
back to the lld that the command should be processed in-kernel?  I think
that's probably the simplest method of achieving this without making
the kernel drivers aware of all target configuration and status but it
would mean a trip to tgtd for every command.  Otherwise we'd want to
communicate every change in configuration for the targets to the kernel
lld's and any other operational changes for tgtd.  Thoughts?



From fujita.tomonori at lab.ntt.co.jp  Sun May  6 03:30:14 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 6 May 2007 10:30:14 +0900 (JST)
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <463B72F6.3000207@torque.net>
References: <20070504160712.GB16528@austin.ibm.com>
	<200705041704.l44H4WXa003789@mbox.iij4u.or.jp>
	<463B72F6.3000207@torque.net>
Message-ID: <20070506053629P.fujita.tomonori@lab.ntt.co.jp>

From: Douglas Gilbert <dougg at torque.net>
Subject: Re: [Stgt-devel] Question for pass-through target design
Date: Fri, 04 May 2007 13:52:54 -0400

> FUJITA Tomonori wrote:
> > From: Robert Jennings <rcj at linux.vnet.ibm.com>
> > Subject: [Stgt-devel] Question for pass-through target design
> > Date: Fri, 4 May 2007 11:07:12 -0500
> > 
> >> It looks like the pass-through target support is currently broken, at
> >> least as I've checked for ibmvstgt, but I think it's a general problem.
> >> I wanted to check my assumptions and get ideas.
> > 
> > Yeah, unfortunately, it works only with the iSCSI target driver (which
> > runs in user space).
> > 
> > 
> >> The code isn't allocating any memory to pass along to the sg code to store
> >> the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
> >> or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
> >> which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
> >> the pass-through target isn't going to function.  Even if we had memory
> >> allocated, there isn't a means of getting data to be written via sg down
> >> this code path.
> >>
> >> What ideas are there as to how the data will get to user-space so that
> >> we can use sg?
> > 
> > For kernel-space drivers, we don't need to go to user-space. We can do
> > the pass-through in kernel space. I talked with James about this last
> > year and he said that if the code is implemented cleanly, he would
> > merges it into mainline.
> 
> We already have a pass-through in the kernel space for
> kernel space drivers. It is the scsi_tgt* code.

Could you elaborate more?

What I meant that is that the kernel tgt code (scsi_tgt*) receives
SCSI commands from one lld and send them to another lld instead of
sending them to user space.


From fujita.tomonori at lab.ntt.co.jp  Sun May  6 03:39:10 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 6 May 2007 10:39:10 +0900 (JST)
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <20070504193306.GC16528@austin.ibm.com>
References: <20070504160712.GB16528@austin.ibm.com>
	<200705041704.l44H4WXa003789@mbox.iij4u.or.jp>
	<20070504193306.GC16528@austin.ibm.com>
Message-ID: <20070506054524T.fujita.tomonori@lab.ntt.co.jp>

From: Robert Jennings <rcj at linux.vnet.ibm.com>
Subject: Re: [Stgt-devel] Question for pass-through target design
Date: Fri, 4 May 2007 14:33:06 -0500

> * FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> > From: Robert Jennings <rcj at linux.vnet.ibm.com>
> > Subject: [Stgt-devel] Question for pass-through target design
> > Date: Fri, 4 May 2007 11:07:12 -0500
> > 
> > > It looks like the pass-through target support is currently broken, at
> > > least as I've checked for ibmvstgt, but I think it's a general problem.
> > > I wanted to check my assumptions and get ideas.
> > 
> > Yeah, unfortunately, it works only with the iSCSI target driver (which
> > runs in user space).
> > 
> > 
> > > The code isn't allocating any memory to pass along to the sg code to store
> > > the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
> > > or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
> > > which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
> > > the pass-through target isn't going to function.  Even if we had memory
> > > allocated, there isn't a means of getting data to be written via sg down
> > > this code path.
> > > 
> > > What ideas are there as to how the data will get to user-space so that
> > > we can use sg?
> > 
> > For kernel-space drivers, we don't need to go to user-space. We can do
> > the pass-through in kernel space. I talked with James about this last
> > year and he said that if the code is implemented cleanly, he would
> > merges it into mainline.
> 
> That sounds fine, how can we make the lld in kernel space aware that the
> target is pass-through?  
> 
> Should the kernel driver operate as usual and queue the command to tgtd
> and then tgtd would see that it's a pass-through target and communicate
> back to the lld that the command should be processed in-kernel?

I guess that it's ok to add an interface (new operations to
scsi_tgt_if.h) to tell the pass-through configuration to the kernel
tgt code from user space.


From vst at vlnb.net  Mon May  7 16:26:47 2007
From: vst at vlnb.net (Vladislav Bolkhovitin)
Date: Mon, 07 May 2007 18:26:47 +0400
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <20070504160712.GB16528@austin.ibm.com>
References: <20070504160712.GB16528@austin.ibm.com>
Message-ID: <463F3727.7010902@vlnb.net>

Robert,

I'm not familiar at all with SRP and VSCSI (never tried them or seen the
hardware), so I could easily confuse them, but I think I should point
you at
http://lists.openfabrics.org/pipermail/iwg/2007-March/000378.html. This
is SCSI RDMA Protocol (SRP) Target driver for Linux. It works over SCST,
so it should support pass-through.

Regards,
Vlad

Robert Jennings wrote:
> It looks like the pass-through target support is currently broken, at
> least as I've checked for ibmvstgt, but I think it's a general problem.
> I wanted to check my assumptions and get ideas.
> 
> The code isn't allocating any memory to pass along to the sg code to store
> the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
> or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
> which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
> the pass-through target isn't going to function.  Even if we had memory
> allocated, there isn't a means of getting data to be written via sg down
> this code path.
> 
> What ideas are there as to how the data will get to user-space so that
> we can use sg?
> 
> Regards,
> Robert Jennings
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
> 




From vst at vlnb.net  Mon May  7 16:24:44 2007
From: vst at vlnb.net (Vladislav Bolkhovitin)
Date: Mon, 07 May 2007 18:24:44 +0400
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <20070506053629P.fujita.tomonori@lab.ntt.co.jp>
References: <20070504160712.GB16528@austin.ibm.com>	<200705041704.l44H4WXa003789@mbox.iij4u.or.jp>	<463B72F6.3000207@torque.net>
	<20070506053629P.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <463F36AC.3010207@vlnb.net>

FUJITA Tomonori wrote:
>>>>It looks like the pass-through target support is currently broken, at
>>>>least as I've checked for ibmvstgt, but I think it's a general problem.
>>>>I wanted to check my assumptions and get ideas.
>>>
>>>Yeah, unfortunately, it works only with the iSCSI target driver (which
>>>runs in user space).
>>>
>>>
>>>
>>>>The code isn't allocating any memory to pass along to the sg code to store
>>>>the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
>>>>or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
>>>>which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
>>>>the pass-through target isn't going to function.  Even if we had memory
>>>>allocated, there isn't a means of getting data to be written via sg down
>>>>this code path.
>>>>
>>>>What ideas are there as to how the data will get to user-space so that
>>>>we can use sg?
>>>
>>>For kernel-space drivers, we don't need to go to user-space. We can do
>>>the pass-through in kernel space. I talked with James about this last
>>>year and he said that if the code is implemented cleanly, he would
>>>merges it into mainline.
>>
>>We already have a pass-through in the kernel space for
>>kernel space drivers. It is the scsi_tgt* code.
> 
> 
> Could you elaborate more?
> 
> What I meant that is that the kernel tgt code (scsi_tgt*) receives
> SCSI commands from one lld and send them to another lld instead of
> sending them to user space.

Although the approach of passing SCSI commands from a target LLD to an
initiator one without any significant interventions from the target
software looks to be nice and simple, you should realize how limited,
unsafe and illegal it is, since it badly violates SCSI specs.

Before I elaborate, let's have the following terminology in addition to
one described in SAM:

  - Target system - the overall system containing target and initiator
devices (and their LDDs). Target system exports one or more initiator
devices via the target device(s).

  - Target device - a SCSI device on the target system in the target mode.

  - Initiator device - a SCSI device on the target system in the
initiator mode. It actually serves commands that come from remote
initiators via target device(s).

  - Remote initiator - a SCSI initiator device connected to the target
device on the target system and uses (i.e. sends SCSI commands) exported
by it devices.

  - Target software - software that runs on the target system and
implements the necessary pass-through functionality

Let's consider a simplest case when a target system has one target
device, one initiator device and it exports the initiator device via the
target device as pass-through. The problem is that then the target
system creates a new SCSI target device, which is not the same as the
exported initiator device. Particularly, the new device could have >1
nexuses with remote initiators connected to it, while the initiator
device has no glue about them, it sees a single nexus with the target
system and only it.

And so? All the event notifications, which should be seen by all remote
initiators will be delivered to only one of them or not generated at
all, since some events are generated only for I_T nexuses other, than
one on which the command causing the event is received. The most common
example of such events is Unit Attentions. For example, after MODE
SELECT command, all remote initiators, except one, who sent the command,
shall receive "MODE PARAMETERS CHANGED" Unit Attention. Otherwise a bad
and quiet data corruption could happen.

More complicated example is SCSI reservations, doesn't matter persistent
or SPC-2 ones. Since the initiator device knows only about one nexus,
instead of actual many of them, the reservation commands should be
completely handled by target software on the target system. Having
delivery of Unit Attentions to all remote initiators especially
important for reservations, since they could mean that a reservation was
revoked by another initiator via, e.g., some task management function.

Things get even worse if we realize that (1) the initiator device could
report about its capabilities (like ACA support), which aren't supported
by the target software, hence misinform the remote initiators and again
could provoke a quiet data corruption, and (2) accesses to the initiator
devices from local programs on the target systems create another I_T
nexus, which needs to be handled as well.

(I suppose it is obvious that if the target system exports >1 initiator
devices via a single target device, since the initiator devices don't
know about each other, the target software in any case needs to
implement its own LUN addressing as well as own REPORT LUNS command
handler).

Thus, such in-kernel pass-through mode could be used only for limited
set of SCSI commands and SCSI device types with a big caution and
complete comprehension what's going on and how it should be. The latter
isn't true in the absolute majority of uses and users, so such approach
will give users a perfect weapon to shoot themselfs.

If you start addressing the above issues, I believe, you will endup with:

  - Either with complete duplicating the SCSI state machine in both user
and kernel code, eventually copying what's already done in SCST (see below)

  - Or have so complicated interactions between user space and kernel
that you will never like them (here is why:
http://lkml.org/lkml/2006/7/1/41, http://lkml.org/lkml/2007/4/24/364 and
http://lkml.org/lkml/2007/4/24/451, I totally agree with Linus),

  - Or fully drop the in-kernel pass-through and leave only the user
space one with all its drawbacks and penalties. But, I believe, in this 
case you will also have serious difficulties handling the local nexus 
case (i.e. commands originated from local applications on the target 
system) cleanly.

So, if you need in-kernel pass-through I would suggest you to look at
SCST project (http://scst.sf.net), which is currently stable and mature,
although also not fully finished yet. It was historically from the very
beginning designed for full feature in-kernel pass-through for not only
stateless SCSI devices, like disks, but also for stateful SCSI devices
(like SSC ones a.k.a. tapes), where the correct handling of all above is
essential. In additional to considerably better performance, the
complete in-kernel approach makes the code simpler, smaller and cleaner
as well as allows such things as zero-copy buffered file IO, i.e. when 
data are sent to remote initiators or received from them directly 
from/to the page cache (currently under development). For those who need 
implementing SCSI devices in the user space scst_user module is about to 
be added. Since the SCSI state machine is in kernel the interface 
provided by scst_user is very simple, it essentially consists from only 
a single IOCTL and allows to have overhead as low as a single syscall 
per SCSI command without any additional context switches. It is already 
implemented and works. For some legal reasons I can't at the moment 
publish it, but you can see its full description in the project's SVN 
docs (you can get them using command "svn co 
https://svn.sourceforge.net/svnroot/scst/trunk/doc").

Thanks to all who managed to read until this,
Vlad

P.S. This message is not to start a new flamewar, this is just an
attempt of a healthy criticism for the current mainline target approach
as well as a hope to get some healthy criticism for SCST.




From fujita.tomonori at lab.ntt.co.jp  Mon May  7 17:10:02 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 8 May 2007 00:10:02 +0900 (JST)
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <463F36AC.3010207@vlnb.net>
References: <463B72F6.3000207@torque.net>
	<20070506053629P.fujita.tomonori@lab.ntt.co.jp>
	<463F36AC.3010207@vlnb.net>
Message-ID: <20070507182837E.fujita.tomonori@lab.ntt.co.jp>

From: Vladislav Bolkhovitin <vst at vlnb.net>
Subject: Re: [Stgt-devel] Question for pass-through target design
Date: Mon, 07 May 2007 18:24:44 +0400

> FUJITA Tomonori wrote:
> >>>>It looks like the pass-through target support is currently broken, at
> >>>>least as I've checked for ibmvstgt, but I think it's a general problem.
> >>>>I wanted to check my assumptions and get ideas.
> >>>
> >>>Yeah, unfortunately, it works only with the iSCSI target driver (which
> >>>runs in user space).
> >>>
> >>>
> >>>
> >>>>The code isn't allocating any memory to pass along to the sg code to store
> >>>>the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
> >>>>or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
> >>>>which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
> >>>>the pass-through target isn't going to function.  Even if we had memory
> >>>>allocated, there isn't a means of getting data to be written via sg down
> >>>>this code path.
> >>>>
> >>>>What ideas are there as to how the data will get to user-space so that
> >>>>we can use sg?
> >>>
> >>>For kernel-space drivers, we don't need to go to user-space. We can do
> >>>the pass-through in kernel space. I talked with James about this last
> >>>year and he said that if the code is implemented cleanly, he would
> >>>merges it into mainline.
> >>
> >>We already have a pass-through in the kernel space for
> >>kernel space drivers. It is the scsi_tgt* code.
> > 
> > 
> > Could you elaborate more?
> > 
> > What I meant that is that the kernel tgt code (scsi_tgt*) receives
> > SCSI commands from one lld and send them to another lld instead of
> > sending them to user space.
> 
> Although the approach of passing SCSI commands from a target LLD to an
> initiator one without any significant interventions from the target
> software looks to be nice and simple, you should realize how limited,
> unsafe and illegal it is, since it badly violates SCSI specs.

I think that 'implemented cleanly' means that one scsi_host is assigned
to only one initiator.


From fujita.tomonori at lab.ntt.co.jp  Mon May  7 17:14:37 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 08 May 2007 00:14:37 +0900
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <463F3727.7010902@vlnb.net>
References: <20070504160712.GB16528@austin.ibm.com> <463F3727.7010902@vlnb.net>
Message-ID: <20070508001437F.fujita.tomonori@lab.ntt.co.jp>

From: Vladislav Bolkhovitin <vst at vlnb.net>
Subject: Re: [Stgt-devel] Question for pass-through target design
Date: Mon, 07 May 2007 18:26:47 +0400

> Robert,
> 
> I'm not familiar at all with SRP and VSCSI (never tried them or seen the
> hardware), so I could easily confuse them, but I think I should point
> you at
> http://lists.openfabrics.org/pipermail/iwg/2007-March/000378.html. This
> is SCSI RDMA Protocol (SRP) Target driver for Linux. It works over SCST,
> so it should support pass-through.

VSCSI stuff (ibm pSeries virtual SCSI) is related with Infiniband.


From fujita.tomonori at lab.ntt.co.jp  Mon May  7 17:17:13 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 08 May 2007 00:17:13 +0900
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <20070508001437F.fujita.tomonori@lab.ntt.co.jp>
References: <20070504160712.GB16528@austin.ibm.com> <463F3727.7010902@vlnb.net>
	<20070508001437F.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070508001713S.fujita.tomonori@lab.ntt.co.jp>

From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
Subject: Re: [Stgt-devel] Question for pass-through target design
Date: Tue, 08 May 2007 00:14:37 +0900

> From: Vladislav Bolkhovitin <vst at vlnb.net>
> Subject: Re: [Stgt-devel] Question for pass-through target design
> Date: Mon, 07 May 2007 18:26:47 +0400
> 
> > Robert,
> > 
> > I'm not familiar at all with SRP and VSCSI (never tried them or seen the
> > hardware), so I could easily confuse them, but I think I should point
> > you at
> > http://lists.openfabrics.org/pipermail/iwg/2007-March/000378.html. This
> > is SCSI RDMA Protocol (SRP) Target driver for Linux. It works over SCST,
> > so it should support pass-through.
> 
> VSCSI stuff (ibm pSeries virtual SCSI) is related with Infiniband.

Oops,

VSCSI stuff (ibm pSeries virtual SCSI) is not related with Infiniband.


From vst at vlnb.net  Mon May  7 17:27:23 2007
From: vst at vlnb.net (Vladislav Bolkhovitin)
Date: Mon, 07 May 2007 19:27:23 +0400
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <20070507182837E.fujita.tomonori@lab.ntt.co.jp>
References: <463B72F6.3000207@torque.net>	<20070506053629P.fujita.tomonori@lab.ntt.co.jp>	<463F36AC.3010207@vlnb.net>
	<20070507182837E.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <463F455B.3000209@vlnb.net>

FUJITA Tomonori wrote:
> From: Vladislav Bolkhovitin <vst at vlnb.net>
> Subject: Re: [Stgt-devel] Question for pass-through target design
> Date: Mon, 07 May 2007 18:24:44 +0400
> 
> 
>>FUJITA Tomonori wrote:
>>
>>>>>>It looks like the pass-through target support is currently broken, at
>>>>>>least as I've checked for ibmvstgt, but I think it's a general problem.
>>>>>>I wanted to check my assumptions and get ideas.
>>>>>
>>>>>Yeah, unfortunately, it works only with the iSCSI target driver (which
>>>>>runs in user space).
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>>The code isn't allocating any memory to pass along to the sg code to store
>>>>>>the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
>>>>>>or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
>>>>>>which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
>>>>>>the pass-through target isn't going to function.  Even if we had memory
>>>>>>allocated, there isn't a means of getting data to be written via sg down
>>>>>>this code path.
>>>>>>
>>>>>>What ideas are there as to how the data will get to user-space so that
>>>>>>we can use sg?
>>>>>
>>>>>For kernel-space drivers, we don't need to go to user-space. We can do
>>>>>the pass-through in kernel space. I talked with James about this last
>>>>>year and he said that if the code is implemented cleanly, he would
>>>>>merges it into mainline.
>>>>
>>>>We already have a pass-through in the kernel space for
>>>>kernel space drivers. It is the scsi_tgt* code.
>>>
>>>
>>>Could you elaborate more?
>>>
>>>What I meant that is that the kernel tgt code (scsi_tgt*) receives
>>>SCSI commands from one lld and send them to another lld instead of
>>>sending them to user space.
>>
>>Although the approach of passing SCSI commands from a target LLD to an
>>initiator one without any significant interventions from the target
>>software looks to be nice and simple, you should realize how limited,
>>unsafe and illegal it is, since it badly violates SCSI specs.
> 
> 
> I think that 'implemented cleanly' means that one scsi_host is assigned
> to only one initiator.

Sorry, I don't fully understand you. If you mean you are going to limit 
only one remote initiator per-target device, then, well, is it even more 
limited (and limiting) or not?

> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
> 



From fujita.tomonori at lab.ntt.co.jp  Mon May  7 17:37:34 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 08 May 2007 00:37:34 +0900
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <463F455B.3000209@vlnb.net>
References: <463F36AC.3010207@vlnb.net>
	<20070507182837E.fujita.tomonori@lab.ntt.co.jp>
	<463F455B.3000209@vlnb.net>
Message-ID: <20070508003734T.fujita.tomonori@lab.ntt.co.jp>

From: Vladislav Bolkhovitin <vst at vlnb.net>
Subject: Re: [Stgt-devel] Question for pass-through target design
Date: Mon, 07 May 2007 19:27:23 +0400

> FUJITA Tomonori wrote:
> > From: Vladislav Bolkhovitin <vst at vlnb.net>
> > Subject: Re: [Stgt-devel] Question for pass-through target design
> > Date: Mon, 07 May 2007 18:24:44 +0400
> > 
> > 
> >>FUJITA Tomonori wrote:
> >>
> >>>>>>It looks like the pass-through target support is currently broken, at
> >>>>>>least as I've checked for ibmvstgt, but I think it's a general problem.
> >>>>>>I wanted to check my assumptions and get ideas.
> >>>>>
> >>>>>Yeah, unfortunately, it works only with the iSCSI target driver (which
> >>>>>runs in user space).
> >>>>>
> >>>>>
> >>>>>
> >>>>>
> >>>>>>The code isn't allocating any memory to pass along to the sg code to store
> >>>>>>the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
> >>>>>>or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
> >>>>>>which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
> >>>>>>the pass-through target isn't going to function.  Even if we had memory
> >>>>>>allocated, there isn't a means of getting data to be written via sg down
> >>>>>>this code path.
> >>>>>>
> >>>>>>What ideas are there as to how the data will get to user-space so that
> >>>>>>we can use sg?
> >>>>>
> >>>>>For kernel-space drivers, we don't need to go to user-space. We can do
> >>>>>the pass-through in kernel space. I talked with James about this last
> >>>>>year and he said that if the code is implemented cleanly, he would
> >>>>>merges it into mainline.
> >>>>
> >>>>We already have a pass-through in the kernel space for
> >>>>kernel space drivers. It is the scsi_tgt* code.
> >>>
> >>>
> >>>Could you elaborate more?
> >>>
> >>>What I meant that is that the kernel tgt code (scsi_tgt*) receives
> >>>SCSI commands from one lld and send them to another lld instead of
> >>>sending them to user space.
> >>
> >>Although the approach of passing SCSI commands from a target LLD to an
> >>initiator one without any significant interventions from the target
> >>software looks to be nice and simple, you should realize how limited,
> >>unsafe and illegal it is, since it badly violates SCSI specs.
> > 
> > 
> > I think that 'implemented cleanly' means that one scsi_host is assigned
> > to only one initiator.
> 
> Sorry, I don't fully understand you. If you mean you are going to limit 
> only one remote initiator per-target device, then, well, is it even more 
> limited (and limiting) or not?

The target software assigns one scsi_host to only one remote
initiator. For FC, NPIV works nicely.


From vst at vlnb.net  Mon May  7 18:52:34 2007
From: vst at vlnb.net (Vladislav Bolkhovitin)
Date: Mon, 07 May 2007 20:52:34 +0400
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <20070508003734T.fujita.tomonori@lab.ntt.co.jp>
References: <463F36AC.3010207@vlnb.net>	<20070507182837E.fujita.tomonori@lab.ntt.co.jp>	<463F455B.3000209@vlnb.net>
	<20070508003734T.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <463F5952.9010803@vlnb.net>

FUJITA Tomonori wrote:
> From: Vladislav Bolkhovitin <vst at vlnb.net>
> Subject: Re: [Stgt-devel] Question for pass-through target design
> Date: Mon, 07 May 2007 19:27:23 +0400
> 
> 
>>FUJITA Tomonori wrote:
>>
>>>From: Vladislav Bolkhovitin <vst at vlnb.net>
>>>Subject: Re: [Stgt-devel] Question for pass-through target design
>>>Date: Mon, 07 May 2007 18:24:44 +0400
>>>
>>>
>>>
>>>>FUJITA Tomonori wrote:
>>>>
>>>>
>>>>>>>>It looks like the pass-through target support is currently broken, at
>>>>>>>>least as I've checked for ibmvstgt, but I think it's a general problem.
>>>>>>>>I wanted to check my assumptions and get ideas.
>>>>>>>
>>>>>>>Yeah, unfortunately, it works only with the iSCSI target driver (which
>>>>>>>runs in user space).
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>
>>>>>>>>The code isn't allocating any memory to pass along to the sg code to store
>>>>>>>>the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
>>>>>>>>or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
>>>>>>>>which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
>>>>>>>>the pass-through target isn't going to function.  Even if we had memory
>>>>>>>>allocated, there isn't a means of getting data to be written via sg down
>>>>>>>>this code path.
>>>>>>>>
>>>>>>>>What ideas are there as to how the data will get to user-space so that
>>>>>>>>we can use sg?
>>>>>>>
>>>>>>>For kernel-space drivers, we don't need to go to user-space. We can do
>>>>>>>the pass-through in kernel space. I talked with James about this last
>>>>>>>year and he said that if the code is implemented cleanly, he would
>>>>>>>merges it into mainline.
>>>>>>
>>>>>>We already have a pass-through in the kernel space for
>>>>>>kernel space drivers. It is the scsi_tgt* code.
>>>>>
>>>>>
>>>>>Could you elaborate more?
>>>>>
>>>>>What I meant that is that the kernel tgt code (scsi_tgt*) receives
>>>>>SCSI commands from one lld and send them to another lld instead of
>>>>>sending them to user space.
>>>>
>>>>Although the approach of passing SCSI commands from a target LLD to an
>>>>initiator one without any significant interventions from the target
>>>>software looks to be nice and simple, you should realize how limited,
>>>>unsafe and illegal it is, since it badly violates SCSI specs.
>>>
>>>
>>>I think that 'implemented cleanly' means that one scsi_host is assigned
>>>to only one initiator.
>>
>>Sorry, I don't fully understand you. If you mean you are going to limit 
>>only one remote initiator per-target device, then, well, is it even more 
>>limited (and limiting) or not?
> 
> 
> The target software assigns one scsi_host to only one remote
> initiator. For FC, NPIV works nicely.

OK, if such limitation is OK for your users, then I'm happy for you.

> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
> 



From dougg at torque.net  Mon May  7 21:19:17 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Mon, 07 May 2007 15:19:17 -0400
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <20070508001713S.fujita.tomonori@lab.ntt.co.jp>
References: <20070504160712.GB16528@austin.ibm.com>
	<463F3727.7010902@vlnb.net>	<20070508001437F.fujita.tomonori@lab.ntt.co.jp>
	<20070508001713S.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <463F7BB5.4060603@torque.net>

FUJITA Tomonori wrote:
> From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
> Subject: Re: [Stgt-devel] Question for pass-through target design
> Date: Tue, 08 May 2007 00:14:37 +0900
> 
>> From: Vladislav Bolkhovitin <vst at vlnb.net>
>> Subject: Re: [Stgt-devel] Question for pass-through target design
>> Date: Mon, 07 May 2007 18:26:47 +0400
>>
>>> Robert,
>>>
>>> I'm not familiar at all with SRP and VSCSI (never tried them or seen the
>>> hardware), so I could easily confuse them, but I think I should point
>>> you at
>>> http://lists.openfabrics.org/pipermail/iwg/2007-March/000378.html. This
>>> is SCSI RDMA Protocol (SRP) Target driver for Linux. It works over SCST,
>>> so it should support pass-through.
>> VSCSI stuff (ibm pSeries virtual SCSI) is related with Infiniband.
> 
> Oops,
> 
> VSCSI stuff (ibm pSeries virtual SCSI) is not related with Infiniband.

Tomo,
Looking at drivers/scsi/Kconfig there does seem to be
some connection:

config SCSI_IBMVSCSI
        tristate "IBM Virtual SCSI support"
        depends on PPC_PSERIES || PPC_ISERIES
        help
          This is the IBM POWER Virtual SCSI Client
...
config SCSI_IBMVSCSIS
        tristate "IBM Virtual SCSI Server support"
        depends on PPC_PSERIES && SCSI_TGT && SCSI_SRP
        help
          This is the SRP target driver for IBM pSeries virtual environments.
...


When I see SRP than I presume infiniband is involved.

Perhaps you might elaborate.

Doug Gilbert


From rcj at linux.vnet.ibm.com  Mon May  7 21:54:39 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Mon, 7 May 2007 14:54:39 -0500
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <463F7BB5.4060603@torque.net>
References: <20070504160712.GB16528@austin.ibm.com> <463F3727.7010902@vlnb.net>
	<20070508001437F.fujita.tomonori@lab.ntt.co.jp>
	<20070508001713S.fujita.tomonori@lab.ntt.co.jp>
	<463F7BB5.4060603@torque.net>
Message-ID: <20070507195439.GA28268@austin.ibm.com>

* Douglas Gilbert (dougg at torque.net) wrote:
> FUJITA Tomonori wrote:
> > From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
> > Subject: Re: [Stgt-devel] Question for pass-through target design
> > Date: Tue, 08 May 2007 00:14:37 +0900
> > 
> >> From: Vladislav Bolkhovitin <vst at vlnb.net>
> >> Subject: Re: [Stgt-devel] Question for pass-through target design
> >> Date: Mon, 07 May 2007 18:26:47 +0400
> >>
> >>> Robert,
> >>>
> >>> I'm not familiar at all with SRP and VSCSI (never tried them or seen the
> >>> hardware), so I could easily confuse them, but I think I should point
> >>> you at
> >>> http://lists.openfabrics.org/pipermail/iwg/2007-March/000378.html. This
> >>> is SCSI RDMA Protocol (SRP) Target driver for Linux. It works over SCST,
> >>> so it should support pass-through.
> >> VSCSI stuff (ibm pSeries virtual SCSI) is related with Infiniband.
> > 
> > Oops,
> > 
> > VSCSI stuff (ibm pSeries virtual SCSI) is not related with Infiniband.
> 
> Tomo,
> Looking at drivers/scsi/Kconfig there does seem to be
> some connection:
> 
> config SCSI_IBMVSCSI
>         tristate "IBM Virtual SCSI support"
>         depends on PPC_PSERIES || PPC_ISERIES
>         help
>           This is the IBM POWER Virtual SCSI Client
> ...
> config SCSI_IBMVSCSIS
>         tristate "IBM Virtual SCSI Server support"
>         depends on PPC_PSERIES && SCSI_TGT && SCSI_SRP
>         help
>           This is the SRP target driver for IBM pSeries virtual environments.
> ...
> 
> 
> When I see SRP than I presume infiniband is involved.

IBMVSCSI does use SRP as the communication standard for inter-partition
remote DMA through the system firmware, it's part of the architecture
requrements for the POWER platform.  Infiniband isn't involved, we just
use the same standard as they do.

--Robert Jennings


From vst at vlnb.net  Tue May  8 07:51:43 2007
From: vst at vlnb.net (Vladislav Bolkhovitin)
Date: Tue, 08 May 2007 09:51:43 +0400
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <463F5952.9010803@vlnb.net>
References: <463F36AC.3010207@vlnb.net>	<20070507182837E.fujita.tomonori@lab.ntt.co.jp>	<463F455B.3000209@vlnb.net>
	<20070508003734T.fujita.tomonori@lab.ntt.co.jp>
	<463F5952.9010803@vlnb.net>
Message-ID: <46400FEF.5080109@vlnb.net>

Vladislav Bolkhovitin wrote:
> FUJITA Tomonori wrote:
> 
>> From: Vladislav Bolkhovitin <vst at vlnb.net>
>> Subject: Re: [Stgt-devel] Question for pass-through target design
>> Date: Mon, 07 May 2007 19:27:23 +0400
>>
>>
>>> FUJITA Tomonori wrote:
>>>
>>>> From: Vladislav Bolkhovitin <vst at vlnb.net>
>>>> Subject: Re: [Stgt-devel] Question for pass-through target design
>>>> Date: Mon, 07 May 2007 18:24:44 +0400
>>>>
>>>>
>>>>
>>>>> FUJITA Tomonori wrote:
>>>>>
>>>>>
>>>>>>>>> It looks like the pass-through target support is currently 
>>>>>>>>> broken, at
>>>>>>>>> least as I've checked for ibmvstgt, but I think it's a general 
>>>>>>>>> problem.
>>>>>>>>> I wanted to check my assumptions and get ideas.
>>>>>>>>
>>>>>>>>
>>>>>>>> Yeah, unfortunately, it works only with the iSCSI target driver 
>>>>>>>> (which
>>>>>>>> runs in user space).
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>
>>>>>>>>> The code isn't allocating any memory to pass along to the sg 
>>>>>>>>> code to store
>>>>>>>>> the result of a read or data for a write.  Currently, dxferp 
>>>>>>>>> for sg_io_hdr
>>>>>>>>> or dout_xferp/din_xferp for sg_io_v4 are assigned to the value 
>>>>>>>>> of uaddr,
>>>>>>>>> which is set to 0 in kern_queue_cmd.  With the pointer set to 
>>>>>>>>> NULL,
>>>>>>>>> the pass-through target isn't going to function.  Even if we 
>>>>>>>>> had memory
>>>>>>>>> allocated, there isn't a means of getting data to be written 
>>>>>>>>> via sg down
>>>>>>>>> this code path.
>>>>>>>>>
>>>>>>>>> What ideas are there as to how the data will get to user-space 
>>>>>>>>> so that
>>>>>>>>> we can use sg?
>>>>>>>>
>>>>>>>>
>>>>>>>> For kernel-space drivers, we don't need to go to user-space. We 
>>>>>>>> can do
>>>>>>>> the pass-through in kernel space. I talked with James about this 
>>>>>>>> last
>>>>>>>> year and he said that if the code is implemented cleanly, he would
>>>>>>>> merges it into mainline.
>>>>>>>
>>>>>>>
>>>>>>> We already have a pass-through in the kernel space for
>>>>>>> kernel space drivers. It is the scsi_tgt* code.
>>>>>>
>>>>>>
>>>>>>
>>>>>> Could you elaborate more?
>>>>>>
>>>>>> What I meant that is that the kernel tgt code (scsi_tgt*) receives
>>>>>> SCSI commands from one lld and send them to another lld instead of
>>>>>> sending them to user space.
>>>>>
>>>>>
>>>>> Although the approach of passing SCSI commands from a target LLD to an
>>>>> initiator one without any significant interventions from the target
>>>>> software looks to be nice and simple, you should realize how limited,
>>>>> unsafe and illegal it is, since it badly violates SCSI specs.
>>>>
>>>>
>>>>
>>>> I think that 'implemented cleanly' means that one scsi_host is assigned
>>>> to only one initiator.
>>>
>>>
>>> Sorry, I don't fully understand you. If you mean you are going to 
>>> limit only one remote initiator per-target device, then, well, is it 
>>> even more limited (and limiting) or not?
>>
>>
>>
>> The target software assigns one scsi_host to only one remote
>> initiator. For FC, NPIV works nicely.
> 
> 
> OK, if such limitation is OK for your users, then I'm happy for you.

And don't forget to tell them that they must not touch the exported 
devices locally ;)

>> _______________________________________________
>> Stgt-devel mailing list
>> Stgt-devel at lists.berlios.de
>> https://lists.berlios.de/mailman/listinfo/stgt-devel
>>
> 
> 



From markh794 at gmail.com  Fri May 11 05:11:49 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 11 May 2007 13:11:49 +1000
Subject: [Stgt-devel] PATCH 0 of 6 - Initial start of VTL
Message-ID: <f29db9a80705102011q4f1e5ca3v8a2c23738f306a66@mail.gmail.com>

Six patches against current git.

commit 2ff8cb4bf6682469e2f75c47a7f155b9690cf9a1
Author: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
Date:   Wed May 2 18:41:55 2007 +0900


Patch 1 introduces some documentation with an example script to set up.
Patch 2 contains some core code realignment of current tgt code base.
Patch 3 Adds initial SSC module (Tape Drive)
Patch 4 Adds initial SMC module (Medium Changer)
Patch 5 Adds support for mode and log pages - Although log page is not
really implemented yet.
Patch 6 Adds support for SMC READ ELEMENT STATUS page.

Note: All patches need to be applied in order...

Current operational state:
The 'mtx' utility can perform an 'inventory' or the medium changer..

# lsscsi -g
[0:0:0:0]    disk    ATA      HITACHI_DK23EB-4 00K0  /dev/sda  /dev/sg0
[0:0:1:0]    cd/dvd  HL-DT-ST RW/DVD GCC-4240N D110  /dev/scd0  /dev/sg1
[5:0:0:0]    mediumx STK      L700             0010  -         /dev/sg2

# mtx -f /dev/sg2 status
Storage Changer /dev/sg2:3 Drives, 38 Slots ( 5 Import/Export )
Data Transfer Element 0:Empty
Data Transfer Element 1:Empty
Data Transfer Element 2:Empty
      Storage Element 1:Full :VolumeTag=ABC123
      Storage Element 2:Empty:VolumeTag=
      Storage Element 3:Full :VolumeTag=ULT001L3
      Storage Element 4:Empty:VolumeTag=
      Storage Element 5:Empty:VolumeTag=
      Storage Element 6:Empty:VolumeTag=
      Storage Element 7:Empty:VolumeTag=
      Storage Element 8:Empty:VolumeTag=
      Storage Element 9:Empty:VolumeTag=
      Storage Element 10:Empty:VolumeTag=
      Storage Element 11:Empty:VolumeTag=
      Storage Element 12:Empty:VolumeTag=
      Storage Element 13:Empty:VolumeTag=
      Storage Element 14:Empty:VolumeTag=
      Storage Element 15:Empty:VolumeTag=
      Storage Element 16:Empty:VolumeTag=
      Storage Element 17:Empty:VolumeTag=
      Storage Element 18:Empty:VolumeTag=
      Storage Element 19:Empty:VolumeTag=
      Storage Element 20:Empty:VolumeTag=
      Storage Element 21:Empty:VolumeTag=
      Storage Element 22:Empty:VolumeTag=
      Storage Element 23:Empty:VolumeTag=
      Storage Element 24:Empty:VolumeTag=
      Storage Element 25:Empty:VolumeTag=
      Storage Element 26:Empty:VolumeTag=
      Storage Element 27:Empty:VolumeTag=
      Storage Element 28:Empty:VolumeTag=
      Storage Element 29:Empty:VolumeTag=
      Storage Element 30:Empty:VolumeTag=
      Storage Element 31:Empty:VolumeTag=
      Storage Element 32:Empty:VolumeTag=
      Storage Element 33:Empty:VolumeTag=
      Storage Element 34 IMPORT/EXPORT:Empty:VolumeTag=
      Storage Element 35 IMPORT/EXPORT:Empty:VolumeTag=
      Storage Element 36 IMPORT/EXPORT:Empty:VolumeTag=
      Storage Element 37 IMPORT/EXPORT:Empty:VolumeTag=
      Storage Element 38 IMPORT/EXPORT:Empty:VolumeTag=


From markh794 at gmail.com  Fri May 11 05:16:07 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 11 May 2007 13:16:07 +1000
Subject: [Stgt-devel] PATCH 1 of 6 - Documentation
Message-ID: <f29db9a80705102016u75f30df7qfd0a9d4fc971ec63@mail.gmail.com>

Sorry, all included as attachments.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 1x6_documentation.diff
Type: text/x-patch
Size: 8011 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070511/62fbd787/attachment.bin>

From markh794 at gmail.com  Fri May 11 05:17:44 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 11 May 2007 13:17:44 +1000
Subject: [Stgt-devel] PATCH 2 of 6 - tgt core patch
Message-ID: <f29db9a80705102017w14b1dca1sb56bb8c199408c38@mail.gmail.com>


-------------- next part --------------
A non-text attachment was scrubbed...
Name: 2x6_base.diff
Type: text/x-patch
Size: 14805 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070511/e217ad1a/attachment.bin>

From markh794 at gmail.com  Fri May 11 05:18:52 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 11 May 2007 13:18:52 +1000
Subject: [Stgt-devel] PATCH 3 of 6 - SMC module
Message-ID: <f29db9a80705102018y19ad8c29v59e01590c1f30876@mail.gmail.com>

SMC module
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 3x6_smc.diff
Type: text/x-patch
Size: 14468 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070511/b71eca8e/attachment.bin>

From markh794 at gmail.com  Fri May 11 05:19:41 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 11 May 2007 13:19:41 +1000
Subject: [Stgt-devel] PATCH 4 of 6 -
Message-ID: <f29db9a80705102019w56fd428dm352d2e0f6b4b45af@mail.gmail.com>

SSC module
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 4x6_ssc.diff
Type: text/x-patch
Size: 19711 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070511/bfd8c8e2/attachment.bin>

From markh794 at gmail.com  Fri May 11 05:21:19 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 11 May 2007 13:21:19 +1000
Subject: [Stgt-devel] PATCH 5 of 6 - Add MODE PAGE & LOG PAGE support
Message-ID: <f29db9a80705102021l18b477c2s1eb0058bf395e139@mail.gmail.com>

* Needs to be ported to current sbc & mmc modules.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 5x6_mode_log_pg.diff
Type: text/x-patch
Size: 32288 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070511/36b2c04e/attachment.bin>

From markh794 at gmail.com  Fri May 11 05:23:17 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 11 May 2007 13:23:17 +1000
Subject: [Stgt-devel] PATCH 6 of 6 - Implement READ ELEMENT STATUS op code
Message-ID: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>

SMC module is now useful enough to return a list of 'barcode' media in
the changer.

Can't move them about yet. That will be next op code to be implemented.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 6x6_read_element_status.diff
Type: text/x-patch
Size: 8997 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070511/e2a1289a/attachment.bin>

From blackmagic02881 at gmail.com  Fri May 11 16:20:02 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 11 May 2007 10:20:02 -0400
Subject: [Stgt-devel] PATCH 4 of 6 -
In-Reply-To: <f29db9a80705102019w56fd428dm352d2e0f6b4b45af@mail.gmail.com>
References: <f29db9a80705102019w56fd428dm352d2e0f6b4b45af@mail.gmail.com>
Message-ID: <1178893202.3857.16.camel@dhcp-136.ibrix.com>

On Fri, 2007-05-11 at 13:19 +1000, Mark Harvey wrote:

<snip>

> + */
> +#include <errno.h>
> +#include <stdio.h>
> +#include <stdlib.h>
> +#include <string.h>
> +#include <stdint.h>
> +#include <unistd.h>
> +#include <linux/fs.h>
> +
> +#include "list.h"
> +#include "util.h"
> +#include "tgtd.h"
> +#include "target.h"
> +#include "driver.h"
> +#include "tgtadm.h"
> +#include "scsi.h"
> +#include "spc.h"
> +#include "ssc3.h"
> +#include "sense_codes.h"
> +#include "media.h"
> +

pls double check if all header files are needed here.

> +/* *********************************************
> + * Useful routines for SCSI OP Code processing
> + * *********************************************/
> +static struct physicalAttributes *
> +getPhyAttr(struct scsi_cmd *cmd)
> +{
> +       struct ssc_info * ssc = cmd->dev->priv_p;
> +       return ssc->phy;
> +}

make this inline?

> +
> +static int
> +check_reset(struct physicalAttributes * phy)
> +{
> +       return phy->reset;
> +}

inline again?

> +
> +/* *********************************************
> + * SCSI OP Code processing
> + * *********************************************/

comment like this can be omitted.


> +static int
> +ssc_TUR(int host_no, struct scsi_cmd *cmd)
> +{
> +       int ret = SAM_STAT_GOOD;
> +       struct physicalAttributes * phy = getPhyAttr(cmd);
> +
> +       cmd->len = 0;
> +       if (cmd->dev) {
> +               ret = device_reserved(cmd);
> +               if (ret) {
> +                       dprintf("Reservation Conflict");
> +                       return SAM_STAT_RESERVATION_CONFLICT;
> +               }
> +               if(check_reset(phy)) {
> +                       dprintf("Power-on or reset");
> +                       mk_sense_data(cmd, NOT_READY,
> E_POWERON_RESET);
> +                       ret = SAM_STAT_CHECK_CONDITION;
> +                       phy->reset = 0;
> +               } else if (! phy->onLine) {
> +                       dprintf("No media in drive");
> +                       mk_sense_data(cmd, NOT_READY,
> E_MEDIUM_NOT_PRESENT);
> +                       ret = SAM_STAT_CHECK_CONDITION;
> +               }
> +       } else {
> +               dprintf("Invalid field in cdb");
> +               mk_sense_data(cmd, ILLEGAL_REQUEST,
> E_INVALID_FIELD_IN_CDB);
> +               ret = SAM_STAT_CHECK_CONDITION;
> +       }
> +       return ret;
> +}
> +
> +static int
> +ssc_inquiry(int host_no, struct scsi_cmd *cmd)
> +{
> +       int len, ret = SAM_STAT_CHECK_CONDITION;
> +       uint8_t         *data;
> +       uint8_t         *scb = cmd->scb;
> +       unsigned char   device_type =
> cmd->c_target->dev_type_template.type;
> +       unsigned char   key = ILLEGAL_REQUEST;
> +       uint16_t        asc_ascq = E_INVALID_FIELD_IN_CDB;
> +       struct physicalAttributes * phy = getPhyAttr(cmd);
> +
> +       if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
> +               goto sense;
> +
> +       data = valloc(pagesize);
> +       if (!data) {
> +               key = HARDWARE_ERROR;
> +               asc_ascq = E_INTERNAL_TARGET_FAILURE;
> +               goto sense;
> +       }
> +       memset(data, 0, pagesize);
> +
> +       dprintf("%x %x, device_type: %d\n", scb[1], scb[2],
> device_type);
> +
> +       if (!(scb[1] & 0x3)) {
> +               int tmp = 62;

tmp set to hex or decimal in different places, could u use only one
format? ;)


> +               data[0] = device_type;
> +               data[1] = 0x80;         // Removable
> +               data[2] = 4;            // Conform to SCSI-3
> +               data[3] = tmp;
> +               data[4] = 59;
> +               data[7] = 0x02;
> +               memset(data + 8, 0x20, 28);
> +               memcpy((char *)data + 8, phy->VendorIdent, 8);
> +               memcpy((char *)data + 16, phy->ProductIdent, 16);
> +               memcpy((char *)data + 32, phy->ProductRev, 4);
> +               data[58] = 0x03;        // 0300 == No SPC-3 version
> claimed
> +               data[59] = 0x00;
> +               data[60] = 0x09;        // 0960 == iSCSI
> +               data[61] = 0x60;
> +               data[62] = 0x02;        // 0200 == No SCC version
> claimed
> +               data[63] = 0x00;
> +               data[64] = 0x04;        // 0400 == No SCC-3 version
> claimed
> +               data[65] = 0x00;
> +               len = tmp + 4;
> +               ret = SAM_STAT_GOOD;
> +       } else if (scb[1] & 0x2) {
> +               /* CmdDt bit is set */
> +               /* We do not support it now. */
> +               data[1] = 0x1;
> +               data[5] = 0;
> +               len = 6;
> +               ret = SAM_STAT_GOOD;
> +       } else if (scb[1] & 0x1) {
> +               /* EVPD bit set */
> +               if (scb[2] == 0x0) {
> +                       data[0] = device_type;
> +                       data[1] = 0x0;
> +                       data[3] = 6;
> +                       data[4] = 0x0;  // Return supported pages
> +                       data[5] = 0x80; // Serial Number
> +                       data[6] = 0x83; // Device Identification
> +                       data[7] = 0xb0; // SSC VPD
> +                       data[8] = 0xc0; // Firmware build
> +                       data[9] = 0xc1; // Subsystem Revision
> +                       len = 10;
> +                       ret = SAM_STAT_GOOD;
> +               } else if (scb[2] == 0x80) {
> +                       int tmp = SCSI_SN_LEN;
> +
> +                       data[1] = 0x80;
> +                       data[3] = SCSI_SN_LEN;
> +                       memset(data + 4, 0x20, 4);
> +                       len = 4 + SCSI_SN_LEN;
> +                       ret = SAM_STAT_GOOD;
> +
> +                       if (cmd->dev && strlen(phy->SerialNumber)) {
> +                               uint8_t *p;
> +                               char *q;
> +
> +                               p = data + 4 + tmp - 1;
> +                               q = phy->SerialNumber + SCSI_SN_LEN -
> 1;
> +
> +                               for (; tmp > 0; tmp--, q)
> +                                       *(p--) = *(q--);
> +                       }
> +               } else if (scb[2] == 0x83) {
> +                       int tmp = 40 + SCSI_SN_LEN;
> +
> +                       data[1] = 0x83;
> +                       data[3] = tmp + 4;
> +                       data[4] = 0x1;
> +                       data[5] = 0x1;
> +                       data[7] = tmp;
> +                       if (cmd->dev) {
> +                               strncpy((char *) data + 8,
> +                                               cmd->dev->scsi_id,
> +                                               SCSI_ID_LEN);
> +                               data[36] = 2;   // ASCII
> +                               data[37] = 1;
> +                               data[39] = SCSI_SN_LEN;
> +                               strncpy((char *) data + 40,
> +                                               phy->SerialNumber,
> +                                               SCSI_SN_LEN);
> +                       }
> +                       len = tmp + 8;
> +                       ret = SAM_STAT_GOOD;
> +               } else if (scb[2] == 0xb0) {    // SSC VPD
> +                       int tmp = 3;
> +                       data[1] = 0xb0;
> +                       data[2] = 0;    // Length - MSB
> +                       data[3] = tmp;  // Length - LSB
> +                       data[4] = 1;    // WORM support
> +                       len = tmp + 4;
> +                       ret = SAM_STAT_GOOD;
> +               } else if (scb[2] == 0xc0) {    // Firmware Build
> +                       int tmp = 0x20;
> +                       data[1] = 0xc0;
> +                       data[2] = 0;    // Length - MSB
> +                       data[3] = tmp;  // Length - LSB
> +                       strncpy((char *) data + 20, "2007-03-10
> 05:30", 20);
> +                       len = tmp + 4;
> +                       ret = SAM_STAT_GOOD;
> +               } else if (scb[2] == 0xc1) {    // Subsystem Revision
> +                       int tmp = 4;
> +                       data[1] = 0xc1;
> +                       data[2] = 0;    // Length - MSB
> +                       data[3] = tmp;  // Length - LSB
> +                       strncpy((char *) data + 4, "blah", 4);
> +                       len = tmp + 4;
> +                       ret = SAM_STAT_GOOD;
> +               }
> +       }
> +
> +       if (ret != SAM_STAT_GOOD)
> +               goto sense;

by goto sense u will have a memory leak here. data is not freed. seems
other places have this problem as well.

<snip>

others looks ok to me.

> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
> 



From blackmagic02881 at gmail.com  Fri May 11 16:29:18 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 11 May 2007 10:29:18 -0400
Subject: [Stgt-devel] PATCH 3 of 6 - SMC module
In-Reply-To: <f29db9a80705102018y19ad8c29v59e01590c1f30876@mail.gmail.com>
References: <f29db9a80705102018y19ad8c29v59e01590c1f30876@mail.gmail.com>
Message-ID: <1178893758.3857.23.camel@dhcp-136.ibrix.com>

my similar comment applied to this patch as well.

also seems there are some functions that duplicated in two files, can we
combine them?

also the physicalattr structure can be a common structure for ALL scsi
type devices,

Ming


On Fri, 2007-05-11 at 13:18 +1000, Mark Harvey wrote:
> SMC module
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From blackmagic02881 at gmail.com  Fri May 11 16:35:16 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 11 May 2007 10:35:16 -0400
Subject: [Stgt-devel] PATCH 6 of 6 - Implement READ ELEMENT STATUS
	op	code
In-Reply-To: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>
References: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>
Message-ID: <1178894116.3857.27.camel@dhcp-136.ibrix.com>

On Fri, 2007-05-11 at 13:23 +1000, Mark Harvey wrote:
> +/* Fill in Element Status Header - Always 8 bytes long */
> +static int
> +element_status_data_hdr(uint8_t * data, uint8_t dvcid, uint8_t
> volTag,
> +               int start, int count)
> +{
> +       int             element_sz;
> +       int             size;
> +       uint16_t        * sp;
> +       uint32_t        * lp;
> +
> +       element_sz = determine_element_sz(dvcid, volTag);
> +
> +       /* First Element address reported */
> +       sp = (uint16_t *)&data[0];
> +       *sp = __cpu_to_be16(start);

try to use data[0] = start >> 8, data[1] = start &0xff, instead. since
we can not be 100% sure that data memory address align to 2 bytes.

> +
> +       /* Number of elements available */
> +       sp = (uint16_t *)&data[2];
> +       *sp = __cpu_to_be16(count);
> +
> +       /* Byte count is the length required to return all valid data.
> +        * Allocated length is how much data the initiator will accept
> */
> +       lp = (uint32_t *)&data[4];
> +       size = ((8 + (count * element_sz)) & 0xffffff);
> +       *lp = __cpu_to_be32(size);
> +
> +return size;

code formatting issue? similarly in other place, pls go over and fix
some format issues.

like if(x) should be if (x),...

> +}
> + 



From blackmagic02881 at gmail.com  Fri May 11 16:56:03 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 11 May 2007 10:56:03 -0400
Subject: [Stgt-devel] PATCH 1 of 6 - Documentation
In-Reply-To: <f29db9a80705102016u75f30df7qfd0a9d4fc971ec63@mail.gmail.com>
References: <f29db9a80705102016u75f30df7qfd0a9d4fc971ec63@mail.gmail.com>
Message-ID: <1178895363.3857.32.camel@dhcp-136.ibrix.com>

diff --git a/doc/README.vtl b/doc/README.vtl
new file mode 100644
index 0000000..faeda9b
--- /dev/null
+++ b/doc/README.vtl

only concern is the file name. the code can setup a cd lib or mo disk
lib, so this file really should be readme.vmc.

vt stuff can be used alone so a separate readme.vt will be great.

overall, thanks a lot for the great work.


ps, since MMC, SSC, SBC (MO or removable disk) all support drive+medium
concept, we should make it a common structure.

Ming


On Fri, 2007-05-11 at 13:16 +1000, Mark Harvey wrote:
> Sorry, all included as attachments.
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From mzhang at ibrix.com  Fri May 11 17:34:12 2007
From: mzhang at ibrix.com (Ming Zhang)
Date: Fri, 11 May 2007 11:34:12 -0400
Subject: [Stgt-devel] PATCH 6 of 6 - Implement READ ELEMENT STATUS
	op	code
In-Reply-To: <1178894116.3857.27.camel@dhcp-136.ibrix.com>
References: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>
	<1178894116.3857.27.camel@dhcp-136.ibrix.com>
Message-ID: <1178897652.3857.37.camel@dhcp-136.ibrix.com>

On Fri, 2007-05-11 at 10:35 -0400, Ming Zhang wrote:
> > +       int             element_sz;
> > +       int             size;
> > +       uint16_t        * sp;
> > +       uint32_t        * lp;
> > +
> > +       element_sz = determine_element_sz(dvcid, volTag);
> > +
> > +       /* First Element address reported */
> > +       sp = (uint16_t *)&data[0];
> > +       *sp = __cpu_to_be16(start);
> 
> try to use data[0] = start >> 8, data[1] = start &0xff, instead. since
> we can not be 100% sure that data memory address align to 2 bytes.
> 

forgot about this. we allocate data aligned to page size. so this is ok.


-- 
   Ming Zhang <mzhang AT ibrix.com>
   www.ibrix.com       
   978-670-7400 x 145
   http://blackmagic02881.wordpress.com/

   



From blackmagic02881 at gmail.com  Fri May 11 18:03:11 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 11 May 2007 12:03:11 -0400
Subject: [Stgt-devel] [PATCH] replace valloc and fix memory leak
Message-ID: <1178899391.3857.43.camel@dhcp-136.ibrix.com>

Hi All

A trivial patch to replace obsoleted valloc with memalign and also fix
some potential memory leak.

Signed-off-by Ming Zhang <blackmagic02881 at gmail.com>

diff --git a/usr/mmc.c b/usr/mmc.c
index e9cc479..f245af2 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -33,6 +33,7 @@
 #include <stdint.h>
 #include <unistd.h>
 #include <linux/fs.h>
+#include <malloc.h>
 
 #include "list.h"
 #include "util.h"
@@ -66,7 +67,7 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 {
 	uint8_t *data;
 
-	data = valloc(pagesize);
+	data = memalign(pagesize, pagesize);
 	if (!data) {
 		cmd->len = 0;
 		sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
@@ -102,7 +103,7 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	uint64_t size;
 	uint32_t *data;
 
-	data = valloc(pagesize);
+	data = memalign(pagesize, pagesize);
 	if (!data) {
 		cmd->len = 0;
 		sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
diff --git a/usr/osd.c b/usr/osd.c
index 46bf0a0..39de9ad 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -24,6 +24,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <malloc.h>
 
 #include "list.h"
 #include "util.h"
@@ -38,7 +39,7 @@
 
 static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
 {
-	uint8_t *data, *scb = cmd->scb;
+	uint8_t *data = NULL, *scb = cmd->scb;
 	int len, ret = SAM_STAT_CHECK_CONDITION;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
 
@@ -46,7 +47,7 @@ static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
 	if ((scb[1] & 0x3) == 0 && scb[2] != 0)
 		goto sense;
 
-	data = valloc(pagesize);
+	data = memalign(pagesize, pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
 		asc = 0;
@@ -123,6 +124,8 @@ static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
 
 	return SAM_STAT_GOOD;
 sense:
+	if (data)
+		free(data);
 	sense_data_build(cmd, key, asc, 0);
 	cmd->len = 0;
 	return SAM_STAT_CHECK_CONDITION;
diff --git a/usr/sbc.c b/usr/sbc.c
index a22d3b0..9c905d5 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -30,6 +30,7 @@
 #include <stdint.h>
 #include <unistd.h>
 #include <linux/fs.h>
+#include <malloc.h>
 
 #include "list.h"
 #include "util.h"
@@ -138,7 +139,7 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 		goto sense;
 	}
 
-	data = valloc(pagesize);
+	data = memalign(pagesize, pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
 		asc = 0;
@@ -272,7 +273,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	} else
 		goto sense;
 
-	data = valloc(pagesize);
+	data = memalign(pagesize, pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
 		asc = 0;
@@ -332,6 +333,8 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	cmd->uaddr = (unsigned long) data;
 	return ret;
 sense:
+	if (data)
+		free(data);
 	cmd->len = 0;
 	sense_data_build(cmd, key, asc, 0);
 	return SAM_STAT_CHECK_CONDITION;
diff --git a/usr/spc.c b/usr/spc.c
index b922a45..15e2519 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -23,6 +23,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdint.h>
+#include <malloc.h>
 
 #include "list.h"
 #include "util.h"
@@ -37,7 +38,7 @@
 int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int len, ret = SAM_STAT_CHECK_CONDITION;
-	uint8_t *data;
+	uint8_t *data = NULL;
 	uint8_t *scb = cmd->scb;
 	unsigned char device_type = cmd->c_target->dev_type_template.type;
 	char *product_id = cmd->c_target->dev_type_template.pid;
@@ -46,7 +47,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
 
-	data = valloc(pagesize);
+	data = memalign(pagesize, pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
 		asc = 0;
@@ -138,6 +139,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 
 	return SAM_STAT_GOOD;
 sense:
+	if (data)
+		free(data);
 	cmd->len = 0;
 	sense_data_build(cmd, key, asc, 0);
 	return SAM_STAT_CHECK_CONDITION;
@@ -155,7 +158,7 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	if (alen < 16)
 		goto sense;
 
-	data = valloc(pagesize);
+	data = memalign(pagesize, pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
 		asc = 0;




From markh794 at gmail.com  Sat May 12 04:05:12 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 12 May 2007 12:05:12 +1000
Subject: [Stgt-devel] PATCH 1 of 6 - Documentation
In-Reply-To: <1178895363.3857.32.camel@dhcp-136.ibrix.com>
References: <f29db9a80705102016u75f30df7qfd0a9d4fc971ec63@mail.gmail.com>
	<1178895363.3857.32.camel@dhcp-136.ibrix.com>
Message-ID: <f29db9a80705111905m4d6f9206ge5296fbfbefdd161@mail.gmail.com>

On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> diff --git a/doc/README.vtl b/doc/README.vtl
> new file mode 100644
> index 0000000..faeda9b
> --- /dev/null
> +++ b/doc/README.vtl
>
> only concern is the file name. the code can setup a cd lib or mo disk
> lib, so this file really should be readme.vmc.
>
> vt stuff can be used alone so a separate readme.vt will be great.

Good call.

I'll split it apart and rename as appropriate.

>
> overall, thanks a lot for the great work.
>
>
> ps, since MMC, SSC, SBC (MO or removable disk) all support drive+medium
> concept, we should make it a common structure.
>
> Ming
>
>
> On Fri, 2007-05-11 at 13:16 +1000, Mark Harvey wrote:
> > Sorry, all included as attachments.
> > _______________________________________________
> > Stgt-devel mailing list
> > Stgt-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/stgt-devel
>
>


From markh794 at gmail.com  Sat May 12 04:09:35 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 12 May 2007 12:09:35 +1000
Subject: [Stgt-devel] PATCH 0 of 2
Message-ID: <f29db9a80705111909x7f09284aub0c43016e9c3acfb@mail.gmail.com>

Patch set on top of previous 6 sent in earlier.

Patch 1 corrects a change to spc_illegal_op() where I added a heap of code to
dprintf() the SCSI op code. I've moved this code into its own routine
dump_cdb().

Patch 2. Implement MOVE MEDIUM op code.
Allow mtx (or NetBackup's 'robtest' utility) to move media between slots.


From markh794 at gmail.com  Sat May 12 04:12:28 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 12 May 2007 12:12:28 +1000
Subject: [Stgt-devel] PATCH 1 of 2 - Move dump_cdb out of spc_illegal_op to
	its own subroutine.
Message-ID: <f29db9a80705111912g4e3be2cbj8f55561d4847d37b@mail.gmail.com>

Undo an earlier patch to spc_illegal_op() to dump the SCSI op code.

Moved the routine to dump_cdb(uint8_t * cdb) so it can still be called
if required.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: move_cdb_dump.diff
Type: text/x-patch
Size: 2069 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070512/9913d629/attachment.bin>

From markh794 at gmail.com  Sat May 12 04:14:11 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 12 May 2007 12:14:11 +1000
Subject: [Stgt-devel] PATCH 2 of 2 - Initial implementation of MOVE MEDIUM
	op code.
Message-ID: <f29db9a80705111914m5a7328dak8dd550faff49cdc6@mail.gmail.com>

Implements 'MOVE MEDIUM' op code.
 - If the media is moved into a 'DATA TRANSFER' device, this device is
not notified. This is still to be implemented.


From markh794 at gmail.com  Sat May 12 04:23:17 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 12 May 2007 12:23:17 +1000
Subject: [Stgt-devel] PATCH 3 of 6 - SMC module
In-Reply-To: <1178893758.3857.23.camel@dhcp-136.ibrix.com>
References: <f29db9a80705102018y19ad8c29v59e01590c1f30876@mail.gmail.com>
	<1178893758.3857.23.camel@dhcp-136.ibrix.com>
Message-ID: <f29db9a80705111923m26638969t71b1ad5a52c6c3b4@mail.gmail.com>

On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> my similar comment applied to this patch as well.
>
> also seems there are some functions that duplicated in two files, can we
> combine them?
>
> also the physicalattr structure can be a common structure for ALL scsi
> type devices,
>
> Ming

physical Attribute structure will be common to all (most ?) modules.

Once the patch to add a private pointer to struct scsi_lu has been
accepted, a private instance to physicalAttributes can be referenced
to by each LUN and I will update the other modules (sbc/mmc etc) to
use this structure.

Or is it the other way around ?
i.e. If I submit a patch to use this pointer, there is a greater
likely hood of this patch being applied.

Cheers
Mark
>
>
> On Fri, 2007-05-11 at 13:18 +1000, Mark Harvey wrote:
> > SMC module
> > _______________________________________________
> > Stgt-devel mailing list
> > Stgt-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/stgt-devel
>
>


From blackmagic02881 at gmail.com  Sat May 12 04:28:36 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 11 May 2007 22:28:36 -0400
Subject: [Stgt-devel] PATCH 6 of 6 - Implement READ ELEMENT STATUS
	op	code
In-Reply-To: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>
References: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>
Message-ID: <1178936916.3772.3.camel@localhost.localdomain>


On Fri, 2007-05-11 at 13:23 +1000, Mark Harvey wrote:
> SMC module is now useful enough to return a list of 'barcode' media in
> the changer.

one potential issue for this command is the data can be larger than 1
page if it is a large tl with thousands of elements. pls double check it
is handled.


> 
> Can't move them about yet. That will be next op code to be implemented.
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From blackmagic02881 at gmail.com  Sat May 12 04:29:15 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 11 May 2007 22:29:15 -0400
Subject: [Stgt-devel] PATCH 2 of 2 - Initial implementation of
	MOVE	MEDIUM op code.
In-Reply-To: <f29db9a80705111914m5a7328dak8dd550faff49cdc6@mail.gmail.com>
References: <f29db9a80705111914m5a7328dak8dd550faff49cdc6@mail.gmail.com>
Message-ID: <1178936955.3772.5.camel@localhost.localdomain>

forgot to attach?

On Sat, 2007-05-12 at 12:14 +1000, Mark Harvey wrote:
> Implements 'MOVE MEDIUM' op code.
>  - If the media is moved into a 'DATA TRANSFER' device, this device is
> not notified. This is still to be implemented.
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From blackmagic02881 at gmail.com  Sat May 12 04:31:16 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 11 May 2007 22:31:16 -0400
Subject: [Stgt-devel] PATCH 3 of 6 - SMC module
In-Reply-To: <f29db9a80705111923m26638969t71b1ad5a52c6c3b4@mail.gmail.com>
References: <f29db9a80705102018y19ad8c29v59e01590c1f30876@mail.gmail.com>
	<1178893758.3857.23.camel@dhcp-136.ibrix.com>
	<f29db9a80705111923m26638969t71b1ad5a52c6c3b4@mail.gmail.com>
Message-ID: <1178937076.3772.8.camel@localhost.localdomain>

On Sat, 2007-05-12 at 12:23 +1000, Mark Harvey wrote:
> On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > my similar comment applied to this patch as well.
> >
> > also seems there are some functions that duplicated in two files, can we
> > combine them?
> >
> > also the physicalattr structure can be a common structure for ALL scsi
> > type devices,
> >
> > Ming
> 
> physical Attribute structure will be common to all (most ?) modules.

in c++ concept, we should have a class device and then each device add
some special stuff. i agree with u that each module (device ) should
have such stuff.

> 
> Once the patch to add a private pointer to struct scsi_lu has been
> accepted, a private instance to physicalAttributes can be referenced
> to by each LUN and I will update the other modules (sbc/mmc etc) to
> use this structure.
> 
> Or is it the other way around ?
> i.e. If I submit a patch to use this pointer, there is a greater
> likely hood of this patch being applied.
> 

see which way tomof like.

> Cheers
> Mark
> >
> >
> > On Fri, 2007-05-11 at 13:18 +1000, Mark Harvey wrote:
> > > SMC module
> > > _______________________________________________
> > > Stgt-devel mailing list
> > > Stgt-devel at lists.berlios.de
> > > https://lists.berlios.de/mailman/listinfo/stgt-devel
> >
> >



From markh794 at gmail.com  Sat May 12 04:36:52 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 12 May 2007 12:36:52 +1000
Subject: [Stgt-devel] PATCH 6 of 6 - Implement READ ELEMENT STATUS op
	code
In-Reply-To: <1178936916.3772.3.camel@localhost.localdomain>
References: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>
	<1178936916.3772.3.camel@localhost.localdomain>
Message-ID: <f29db9a80705111936w376fdd4fs507fa976b70c561@mail.gmail.com>

On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
>
> On Fri, 2007-05-11 at 13:23 +1000, Mark Harvey wrote:
> > SMC module is now useful enough to return a list of 'barcode' media in
> > the changer.
>
> one potential issue for this command is the data can be larger than 1
> page if it is a large tl with thousands of elements. pls double check it
> is handled.

You are correct.

Initially, I attempted to estimate at the amount of memory required
(based on the number of slots * max record size), however I kept
getting a core dump and eventually tracked it down to the following
routine in iscsid.c
   ======================================
static void iscsi_free_cmd_task(struct iscsi_task *task)
{
        target_cmd_done(&task->scmd);

        list_del(&task->c_hlist);
        if (task->data) {
                if ((unsigned long) task->data != task->addr)
                        free((void *) (unsigned long) task->addr);
        }
        iscsi_free_task(task);
}
   ======================================

I keept getting a glibc double free error and was not quite sure where
to go from here.

This was to be the subject of another email I had not written as yet,
but since you brought it up :)

>
>
> >
> > Can't move them about yet. That will be next op code to be implemented.
> > _______________________________________________
> > Stgt-devel mailing list
> > Stgt-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/stgt-devel
>
>


From markh794 at gmail.com  Sat May 12 04:40:07 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 12 May 2007 12:40:07 +1000
Subject: [Stgt-devel] PATCH 2 of 2 - Initial implementation of MOVE
	MEDIUM op code.
In-Reply-To: <1178936955.3772.5.camel@localhost.localdomain>
References: <f29db9a80705111914m5a7328dak8dd550faff49cdc6@mail.gmail.com>
	<1178936955.3772.5.camel@localhost.localdomain>
Message-ID: <f29db9a80705111940y2beb05d5h3dfb743d3fdf46cd@mail.gmail.com>

On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> forgot to attach?
>
> On Sat, 2007-05-12 at 12:14 +1000, Mark Harvey wrote:
> > Implements 'MOVE MEDIUM' op code.
> >  - If the media is moved into a 'DATA TRANSFER' device, this device is
> > not notified. This is still to be implemented.

Many thanks..

BTW: Does anyone know a way via gmail web interface that I can in-line
the patch code ?

When I attempt to highlight the patch and paste in email body, all
'tab' chars are replaced with spaces.

Many thanks
Mark

> > _______________________________________________
> > Stgt-devel mailing list
> > Stgt-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/stgt-devel
>
>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: move_medium.diff
Type: text/x-patch
Size: 4563 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070512/54fa3c39/attachment.bin>

From blackmagic02881 at gmail.com  Sat May 12 04:41:00 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 11 May 2007 22:41:00 -0400
Subject: [Stgt-devel] PATCH 6 of 6 - Implement READ ELEMENT STATUS
	op	code
In-Reply-To: <f29db9a80705111936w376fdd4fs507fa976b70c561@mail.gmail.com>
References: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>
	<1178936916.3772.3.camel@localhost.localdomain>
	<f29db9a80705111936w376fdd4fs507fa976b70c561@mail.gmail.com>
Message-ID: <1178937660.3772.11.camel@localhost.localdomain>

On Sat, 2007-05-12 at 12:36 +1000, Mark Harvey wrote:
> On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> >
> > On Fri, 2007-05-11 at 13:23 +1000, Mark Harvey wrote:
> > > SMC module is now useful enough to return a list of 'barcode' media in
> > > the changer.
> >
> > one potential issue for this command is the data can be larger than 1
> > page if it is a large tl with thousands of elements. pls double check it
> > is handled.
> 
> You are correct.
> 
> Initially, I attempted to estimate at the amount of memory required
> (based on the number of slots * max record size), however I kept
> getting a core dump and eventually tracked it down to the following
> routine in iscsid.c
>    ======================================
> static void iscsi_free_cmd_task(struct iscsi_task *task)
> {
>         target_cmd_done(&task->scmd);
> 
>         list_del(&task->c_hlist);
>         if (task->data) {
>                 if ((unsigned long) task->data != task->addr)
>                         free((void *) (unsigned long) task->addr);
>         }
>         iscsi_free_task(task);
> }
>    ======================================
> 
> I keept getting a glibc double free error and was not quite sure where
> to go from here.

if u like, u can get it implemented in the right way and i can help u on
the crash.


> 
> This was to be the subject of another email I had not written as yet,
> but since you brought it up :)
> 
> >
> >
> > >
> > > Can't move them about yet. That will be next op code to be implemented.
> > > _______________________________________________
> > > Stgt-devel mailing list
> > > Stgt-devel at lists.berlios.de
> > > https://lists.berlios.de/mailman/listinfo/stgt-devel
> >
> >



From blackmagic02881 at gmail.com  Sat May 12 04:42:29 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 11 May 2007 22:42:29 -0400
Subject: [Stgt-devel] PATCH 2 of 2 - Initial implementation of
	MOVE	MEDIUM op code.
In-Reply-To: <f29db9a80705111940y2beb05d5h3dfb743d3fdf46cd@mail.gmail.com>
References: <f29db9a80705111914m5a7328dak8dd550faff49cdc6@mail.gmail.com>
	<1178936955.3772.5.camel@localhost.localdomain>
	<f29db9a80705111940y2beb05d5h3dfb743d3fdf46cd@mail.gmail.com>
Message-ID: <1178937749.3772.13.camel@localhost.localdomain>

On Sat, 2007-05-12 at 12:40 +1000, Mark Harvey wrote:
> On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > forgot to attach?
> >
> > On Sat, 2007-05-12 at 12:14 +1000, Mark Harvey wrote:
> > > Implements 'MOVE MEDIUM' op code.
> > >  - If the media is moved into a 'DATA TRANSFER' device, this device is
> > > not notified. This is still to be implemented.
> 
> Many thanks..
> 
> BTW: Does anyone know a way via gmail web interface that I can in-line
> the patch code ?
> 
> When I attempt to highlight the patch and paste in email body, all
> 'tab' chars are replaced with spaces.

i do not know. i tried and failed. so i go back to my mail client.

maybe gmail has a pre-format option we do not know?

> 
> Many thanks
> Mark
> 
> > > _______________________________________________
> > > Stgt-devel mailing list
> > > Stgt-devel at lists.berlios.de
> > > https://lists.berlios.de/mailman/listinfo/stgt-devel
> >
> >



From markh794 at gmail.com  Sat May 12 04:47:25 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 12 May 2007 12:47:25 +1000
Subject: [Stgt-devel] PATCH 6 of 6 - Implement READ ELEMENT STATUS op
	code
In-Reply-To: <1178937660.3772.11.camel@localhost.localdomain>
References: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>
	<1178936916.3772.3.camel@localhost.localdomain>
	<f29db9a80705111936w376fdd4fs507fa976b70c561@mail.gmail.com>
	<1178937660.3772.11.camel@localhost.localdomain>
Message-ID: <f29db9a80705111947p4fbb06d6w67579763bb46f40@mail.gmail.com>

On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> On Sat, 2007-05-12 at 12:36 +1000, Mark Harvey wrote:
> > On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > >
> > > On Fri, 2007-05-11 at 13:23 +1000, Mark Harvey wrote:
> > > > SMC module is now useful enough to return a list of 'barcode' media in
> > > > the changer.
> > >
> > > one potential issue for this command is the data can be larger than 1
> > > page if it is a large tl with thousands of elements. pls double check it
> > > is handled.
> >
> > You are correct.
> >
> > Initially, I attempted to estimate at the amount of memory required
> > (based on the number of slots * max record size), however I kept
> > getting a core dump and eventually tracked it down to the following
> > routine in iscsid.c
> >    ======================================
> > static void iscsi_free_cmd_task(struct iscsi_task *task)
> > {
> >         target_cmd_done(&task->scmd);
> >
> >         list_del(&task->c_hlist);
> >         if (task->data) {
> >                 if ((unsigned long) task->data != task->addr)
> >                         free((void *) (unsigned long) task->addr);
> >         }
> >         iscsi_free_task(task);
> > }
> >    ======================================
> >
> > I keept getting a glibc double free error and was not quite sure where
> > to go from here.
>
> if u like, u can get it implemented in the right way and i can help u on
> the crash.

Many thanks.

I will take you up on this offer.

I most likely won't have any 'spare' time to work on this over the
weekend but will forward the patch on ASAP.

BTW: I sort of check for an overflow. I first check to see it the
initiator has allocated more memory then the 'pagesize' and fail the
command. This check will not catch the case where the initiator does
not know how much space to allocate and makes the initial call just to
see what size is returned by the target.


>
>
> >
> > This was to be the subject of another email I had not written as yet,
> > but since you brought it up :)
> >
> > >
> > >
> > > >
> > > > Can't move them about yet. That will be next op code to be implemented.
> > > > _______________________________________________
> > > > Stgt-devel mailing list
> > > > Stgt-devel at lists.berlios.de
> > > > https://lists.berlios.de/mailman/listinfo/stgt-devel
> > >
> > >
>
>


From blackmagic02881 at gmail.com  Sat May 12 04:52:05 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 11 May 2007 22:52:05 -0400
Subject: [Stgt-devel] PATCH 6 of 6 - Implement READ ELEMENT STATUS
	op	code
In-Reply-To: <f29db9a80705111947p4fbb06d6w67579763bb46f40@mail.gmail.com>
References: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>
	<1178936916.3772.3.camel@localhost.localdomain>
	<f29db9a80705111936w376fdd4fs507fa976b70c561@mail.gmail.com>
	<1178937660.3772.11.camel@localhost.localdomain>
	<f29db9a80705111947p4fbb06d6w67579763bb46f40@mail.gmail.com>
Message-ID: <1178938325.3772.16.camel@localhost.localdomain>

On Sat, 2007-05-12 at 12:47 +1000, Mark Harvey wrote:
> On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > On Sat, 2007-05-12 at 12:36 +1000, Mark Harvey wrote:
> > > On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > >
> > > > On Fri, 2007-05-11 at 13:23 +1000, Mark Harvey wrote:
> > > > > SMC module is now useful enough to return a list of 'barcode' media in
> > > > > the changer.
> > > >
> > > > one potential issue for this command is the data can be larger than 1
> > > > page if it is a large tl with thousands of elements. pls double check it
> > > > is handled.
> > >
> > > You are correct.
> > >
> > > Initially, I attempted to estimate at the amount of memory required
> > > (based on the number of slots * max record size), however I kept
> > > getting a core dump and eventually tracked it down to the following
> > > routine in iscsid.c
> > >    ======================================
> > > static void iscsi_free_cmd_task(struct iscsi_task *task)
> > > {
> > >         target_cmd_done(&task->scmd);
> > >
> > >         list_del(&task->c_hlist);
> > >         if (task->data) {
> > >                 if ((unsigned long) task->data != task->addr)
> > >                         free((void *) (unsigned long) task->addr);
> > >         }
> > >         iscsi_free_task(task);
> > > }
> > >    ======================================
> > >
> > > I keept getting a glibc double free error and was not quite sure where
> > > to go from here.
> >
> > if u like, u can get it implemented in the right way and i can help u on
> > the crash.
> 
> Many thanks.
> 
> I will take you up on this offer.
> 
> I most likely won't have any 'spare' time to work on this over the
> weekend but will forward the patch on ASAP.

sure. no problem. hope u patch can be merged soon, patch one by one is
pretty painful. ;)

> 
> BTW: I sort of check for an overflow. I first check to see it the
> initiator has allocated more memory then the 'pagesize' and fail the
> command. This check will not catch the case where the initiator does
> not know how much space to allocate and makes the initial call just to
> see what size is returned by the target.
> 

maybe u can have a look at how report luns get done. it has same issue.



> 
> >
> >
> > >
> > > This was to be the subject of another email I had not written as yet,
> > > but since you brought it up :)
> > >
> > > >
> > > >
> > > > >
> > > > > Can't move them about yet. That will be next op code to be implemented.
> > > > > _______________________________________________
> > > > > Stgt-devel mailing list
> > > > > Stgt-devel at lists.berlios.de
> > > > > https://lists.berlios.de/mailman/listinfo/stgt-devel
> > > >
> > > >
> >
> >



From markh794 at gmail.com  Sat May 12 05:02:44 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 12 May 2007 13:02:44 +1000
Subject: [Stgt-devel] PATCH 6 of 6 - Implement READ ELEMENT STATUS op
	code
In-Reply-To: <1178938325.3772.16.camel@localhost.localdomain>
References: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>
	<1178936916.3772.3.camel@localhost.localdomain>
	<f29db9a80705111936w376fdd4fs507fa976b70c561@mail.gmail.com>
	<1178937660.3772.11.camel@localhost.localdomain>
	<f29db9a80705111947p4fbb06d6w67579763bb46f40@mail.gmail.com>
	<1178938325.3772.16.camel@localhost.localdomain>
Message-ID: <f29db9a80705112002w5e9f6039yc1c8c6f027ee7580@mail.gmail.com>

On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> On Sat, 2007-05-12 at 12:47 +1000, Mark Harvey wrote:
> > On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > On Sat, 2007-05-12 at 12:36 +1000, Mark Harvey wrote:
> > > > On 5/12/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > > >
> > > > > On Fri, 2007-05-11 at 13:23 +1000, Mark Harvey wrote:
> > > > > > SMC module is now useful enough to return a list of 'barcode' media in
> > > > > > the changer.
> > > > >
> > > > > one potential issue for this command is the data can be larger than 1
> > > > > page if it is a large tl with thousands of elements. pls double check it
> > > > > is handled.
> > > >
> > > > You are correct.
> > > >
> > > > Initially, I attempted to estimate at the amount of memory required
> > > > (based on the number of slots * max record size), however I kept
> > > > getting a core dump and eventually tracked it down to the following
> > > > routine in iscsid.c
> > > >    ======================================
> > > > static void iscsi_free_cmd_task(struct iscsi_task *task)
> > > > {
> > > >         target_cmd_done(&task->scmd);
> > > >
> > > >         list_del(&task->c_hlist);
> > > >         if (task->data) {
> > > >                 if ((unsigned long) task->data != task->addr)
> > > >                         free((void *) (unsigned long) task->addr);
> > > >         }
> > > >         iscsi_free_task(task);
> > > > }
> > > >    ======================================
> > > >
> > > > I keept getting a glibc double free error and was not quite sure where
> > > > to go from here.
> > >
> > > if u like, u can get it implemented in the right way and i can help u on
> > > the crash.
> >
> > Many thanks.
> >
> > I will take you up on this offer.
> >
> > I most likely won't have any 'spare' time to work on this over the
> > weekend but will forward the patch on ASAP.
>
> sure. no problem. hope u patch can be merged soon, patch one by one is
> pretty painful. ;)
>
> >
> > BTW: I sort of check for an overflow. I first check to see it the
> > initiator has allocated more memory then the 'pagesize' and fail the
> > command. This check will not catch the case where the initiator does
> > not know how much space to allocate and makes the initial call just to
> > see what size is returned by the target.
> >
>
> maybe u can have a look at how report luns get done. it has same issue.
>

spc_report_luns() {
[snip]
        data = valloc(pagesize);
[snip]
                if (!(alen -= 8))
                        overflow = 1;
                if (!(rbuflen -= 8)) {
                        fprintf(stderr, "FIXME: too many luns\n");
                        exit(-1);
                }
[snip]

OK this adds another op code that needs to be fixed once a valid
solution is identified...

>
>
> >
> > >
> > >
> > > >
> > > > This was to be the subject of another email I had not written as yet,
> > > > but since you brought it up :)
> > > >
> > > > >
> > > > >
> > > > > >
> > > > > > Can't move them about yet. That will be next op code to be implemented.
> > > > > > _______________________________________________
> > > > > > Stgt-devel mailing list
> > > > > > Stgt-devel at lists.berlios.de
> > > > > > https://lists.berlios.de/mailman/listinfo/stgt-devel
> > > > >
> > > > >
> > >
> > >
>
>


From waldi at berlios.de  Sat May 12 14:52:05 2007
From: waldi at berlios.de (Bastian Blank)
Date: Sat, 12 May 2007 14:52:05 +0200
Subject: [Stgt-devel] PATCH 6 of 6 - Implement READ ELEMENT STATUS
	op	code
In-Reply-To: <1178897652.3857.37.camel@dhcp-136.ibrix.com>
References: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>
	<1178894116.3857.27.camel@dhcp-136.ibrix.com>
	<1178897652.3857.37.camel@dhcp-136.ibrix.com>
Message-ID: <20070512125205.GA22855@wavehammer.waldi.eu.org>

On Fri, May 11, 2007 at 11:34:12AM -0400, Ming Zhang wrote:
> forgot about this. we allocate data aligned to page size. so this is ok.

I'm not sure but this may violate the C aliasing rules. The same address
is accessed as uint8_t and uint16_t. The result of this violation is
undefined behaviour.

Bastian

-- 
Knowledge, sir, should be free to all!
		-- Harry Mudd, "I, Mudd", stardate 4513.3


From blackmagic02881 at gmail.com  Sun May 13 02:45:50 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Sat, 12 May 2007 20:45:50 -0400
Subject: [Stgt-devel] PATCH 6 of 6 - Implement READ ELEMENT
	STATUS	op	code
In-Reply-To: <20070512125205.GA22855@wavehammer.waldi.eu.org>
References: <f29db9a80705102023v1d003f61w1a529278e7368de7@mail.gmail.com>
	<1178894116.3857.27.camel@dhcp-136.ibrix.com>
	<1178897652.3857.37.camel@dhcp-136.ibrix.com>
	<20070512125205.GA22855@wavehammer.waldi.eu.org>
Message-ID: <1179017150.3897.4.camel@localhost.localdomain>

On Sat, 2007-05-12 at 14:52 +0200, Bastian Blank wrote:
> On Fri, May 11, 2007 at 11:34:12AM -0400, Ming Zhang wrote:
> > forgot about this. we allocate data aligned to page size. so this is ok.
> 
> I'm not sure but this may violate the C aliasing rules. The same address
> is accessed as uint8_t and uint16_t. The result of this violation is
> undefined behaviour.

right. so for sanity purpose, better to fix it.

> 
> Bastian
> 



From fujita.tomonori at lab.ntt.co.jp  Sun May 13 09:13:00 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 13 May 2007 16:13:00 +0900
Subject: [Stgt-devel] [PATCH] replace valloc and fix memory leak
In-Reply-To: <1178899391.3857.43.camel@dhcp-136.ibrix.com>
References: <1178899391.3857.43.camel@dhcp-136.ibrix.com>
Message-ID: <200705130713.l4D7DCDE011880@mbox.iij4u.or.jp>

From: Ming Zhang <blackmagic02881 at gmail.com>
Subject: [Stgt-devel] [PATCH] replace valloc and fix memory leak
Date: Fri, 11 May 2007 12:03:11 -0400

> Hi All
> 
> A trivial patch to replace obsoleted valloc with memalign and also fix
> some potential memory leak.

memalign is also obsoleted.


From fujita.tomonori at lab.ntt.co.jp  Sun May 13 09:37:49 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 13 May 2007 16:37:49 +0900
Subject: [Stgt-devel] PATCH 2 of 6 - tgt core patch
In-Reply-To: <f29db9a80705102017w14b1dca1sb56bb8c199408c38@mail.gmail.com>
References: <f29db9a80705102017w14b1dca1sb56bb8c199408c38@mail.gmail.com>
Message-ID: <200705130738.l4D7c1W1012622@mbox.iij4u.or.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] PATCH 2 of 6 - tgt core patch
Date: Fri, 11 May 2007 13:17:44 +1000

Thanks a lot for your work.

Can we focus on tgt core changes first? If VTL code doesn't break tgt,
I'm happy to merge it.


> diff --git a/doc/tgt-setup b/doc/tgt-setup
> index e27f104..bb1074c 100755
> --- a/doc/tgt-setup
> +++ b/doc/tgt-setup
> @@ -2,7 +2,7 @@
>  
>  set -x
>  
> -export PATH=`pwd`/usr:$PATH
> +export PATH=`pwd`/../usr:$PATH
>  
>  P=`ps -ef|grep -v grep|grep tgtd|wc -l`
>  if [ "X"$P == "X0" ]; then

I think that we need a new directory for scripts.


> diff --git a/usr/Makefile b/usr/Makefile
> index 7ff74cb..62d0805 100644
> --- a/usr/Makefile
> +++ b/usr/Makefile
> @@ -61,3 +61,9 @@ endif
>  
>  clean:
>  	rm -f *.o $(PROGRAMS) iscsi/*.o ibmvio/*.o xen/*.o
> +
> +distclean:
> +	rm -f *.o $(PROGRAMS) iscsi/*.o ibmvio/*.o xen/*.o TAGS *.rej

We need this? git-clean ?


> +tags:
> +	etags *.c *.h iscsi/*.c iscsi/*.h ibmvio/*.c xen/*.c xen/*.h

I use gtags instead of etags. There are various tools for tags so I
don't think that we need something like this.


> diff --git a/usr/mmc.c b/usr/mmc.c
> index e9cc479..d53d0f3 100644
> --- a/usr/mmc.c
> +++ b/usr/mmc.c
> @@ -121,10 +121,24 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
>  	return SAM_STAT_GOOD;
>  }
>  
> +static int device_mmc_init(struct scsi_lu *lu)
> +{
> +	lu->d_sense = 1;
> +	return 0;
> +}
> +
> +static int device_mmc_shutdown(struct scsi_lu *lu)
> +{
> +	return 0;
> +}
> +
>  struct device_type_template mmc_template = {
>  	.type	= TYPE_ROM,
>  	.name	= "cdrom/dvd",
>  	.pid	= "VIRTUAL-CDROM",
> +	.device_init = device_mmc_init,
> +	.device_shutdown = device_mmc_shutdown,
> +	.device_config = spc_device_config,
>  	.ops	= {
>  		{spc_test_unit,},
>  		{spc_illegal_op,},
> diff --git a/usr/osd.c b/usr/osd.c
> index 46bf0a0..64e7b2a 100644
> --- a/usr/osd.c
> +++ b/usr/osd.c
> @@ -145,15 +145,22 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
>  	return cmd->c_target->bst->bs_cmd_submit(cmd);
>  }
>  
> -static void device_osd_init(struct scsi_lu *lu)
> +static int device_osd_init(struct scsi_lu *lu)
>  {
>  	lu->d_sense = 1;
> +	return 0;
> +}
> +
> +static int device_osd_shutdown(struct scsi_lu *lu)
> +{
> +	return 0;
>  }
>  
>  struct device_type_template osd_template = {
>  	.type		= TYPE_OSD,
>  	.name		= "osd",
>  	.device_init	= device_osd_init,
> +	.device_shutdown	= device_osd_shutdown,
>  	.ops		= {
>  		[0x00 ... 0x0f] = {spc_illegal_op},
>  
> diff --git a/usr/sbc.c b/usr/sbc.c
> index a22d3b0..879943a 100644
> --- a/usr/sbc.c
> +++ b/usr/sbc.c
> @@ -337,10 +337,21 @@ sense:
>  	return SAM_STAT_CHECK_CONDITION;
>  }
>  
> +static int sbc_init(struct scsi_lu *lu) {
> +	return 0;
> +}
> +
> +static int sbc_shutdown(struct scsi_lu *lu) {
> +	return 0;
> +}
> +
>  struct device_type_template sbc_template = {
>  	.type	= TYPE_DISK,
>  	.name	= "disk",
>  	.pid	= "VIRTUAL-DISK",
> +	.device_init = sbc_init,
> +	.device_shutdown = sbc_shutdown,
> +	.device_config = spc_device_config,
>  	.ops	= {
>  		{spc_test_unit,},
>  		{spc_illegal_op,},
> diff --git a/usr/sense_codes.h b/usr/sense_codes.h
> new file mode 100644
> index 0000000..0791dc3
> --- /dev/null
> +++ b/usr/sense_codes.h
> @@ -0,0 +1,105 @@
> +/*
> + * The SCSI sense key Additional Sense Code / Additional Sense Code Qualifier
> + *
> + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; version 2 of the License.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, write to the Free Software
> + * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
> + */
> +
> +#define mk_sense_data(cmd, key, qual) \
> +	sense_data_build(cmd, key, ((qual >> 8) & 0xff), qual && 0xff)
> +
> +/*
> + * SENSE keys
> + */
> +#define NO_SENSE		0x00
> +#define	RECOVERED_ERROR		0x01
> +#define NOT_READY		0x02
> +#define MEDIUM_ERROR		0x03
> +#define	HARDWARE_ERROR		0x04
> +#define ILLEGAL_REQUEST		0x05
> +#define UNIT_ATTENTION		0x06
> +#define DATA_PROTECT		0x07
> +#define	BLANK_CHECK		0x08
> +
> +/* No Sense Errors */
> +#define NO_ADDITIONAL_SENSE		0x0000
> +#define E_MARK				0x0001
> +#define E_EOM				0x0002
> +#define E_BOM				0x0004
> +#define E_END_OF_DATA			0x0005
> +#define E_OP_IN_PROGRESS		0x0016
> +#define E_DRIVE_REQUIRES_CLEANING	0x8282
> +
> +/* Recovered Errors */
> +#define E_WRITE_ERROR			0x0c00
> +#define E_READ_ERROR			0x1100
> +#define E_RECOVERED_WITH_RETRYS		0x1701
> +#define E_MEDIA_LOAD_EJECT_ERROR	0x5300
> +#define E_FAILURE_PREDICTION		0x5d00
> +
> +/* Not ready */
> +#define E_CAUSE_NOT_REPORTABLE		0x0400
> +#define E_BECOMING_READY		0x0401
> +#define E_INITIALIZING_REQUIRED		0x0402
> +#define E_CLEANING_CART_INSTALLED	0x3003
> +#define E_CLEANING_FAILURE		0x3007
> +#define E_MEDIUM_NOT_PRESENT		0x3a00
> +#define E_LOGICAL_UNIT_NOT_CONFIG	0x3e00
> +
> +/* Medium Errors */
> +#define E_WRITE_ERROR			0x0c00
> +#define E_UNRECOVERED_READ		0x1100
> +#define E_RECORDED_ENTITY_NOT_FOUND	0x1400
> +#define E_UNKNOWN_FORMAT		0x3001
> +#define E_IMCOMPATIBLE_FORMAT		0x3002
> +#define E_MEDIUM_FORMAT_CORRUPT		0x3100
> +#define E_SEQUENTIAL_POSITION_ERR	0x3b00
> +#define E_WRITE_APPEND_ERR		0x5000
> +#define E_CARTRIDGE_FAULT		0x5200
> +#define E_MEDIA_LOAD_OR_EJECT_FAILED	0x5300
> +
> +/* Hardware Failure */
> +#define E_COMPRESSION_CHECK		0x0c04
> +#define E_DECOMPRESSION_CRC		0x110d
> +#define E_MECHANICAL_POSITIONING_ERROR	0x1501
> +#define E_MANUAL_INTERVENTION_REQ	0x0403
> +#define E_HARDWARE_FAILURE		0x4000
> +#define E_INTERNAL_TARGET_FAILURE	0x4400
> +#define E_ERASE_FAILURE			0x5100
> +
> +/* Illegal Request */
> +#define E_PARAMETER_LIST_LENGTH_ERR	0x1a00
> +#define E_INVALID_OP_CODE		0x2000
> +#define E_INVALID_FIELD_IN_CDB		0x2400
> +#define E_LUN_NOT_SUPPORTED		0x2500
> +#define E_INVALID_FIELD_IN_PARMS	0x2600
> +#define E_SAVING_PARMS_UNSUP		0x3900
> +#define E_MEDIUM_DEST_FULL		0x3b0d
> +#define E_MEDIUM_SRC_EMPTY		0x3b0e
> +#define E_POSITION_PAST_BOM		0x3b0c
> +#define E_MEDIUM_REMOVAL_PREVENTED	0x5302
> +#define E_BAD_MICROCODE_DETECTED	0x8283
> +
> +/* Unit Attention */
> +#define E_NOT_READY_TO_TRANSITION	0x2800
> +#define E_POWERON_RESET			0x2900
> +#define E_MODE_PARAMETERS_CHANGED	0x2a01
> +#define E_MICROCODE_DOWNLOADED		0x3f01
> +#define E_FAILURE_PREDICTION_FALSE	0x5dff
> +#define E_INQUIRY_DATA_HAS_CHANGED	0x3f03
> +
> +/* Data Protect */
> +#define E_WRITE_PROTECT			0x2700
> +#define E_MEDIUM_OVERWRITE_ATTEMPTED	0x300c
> diff --git a/usr/spc.c b/usr/spc.c
> index b922a45..7dd920a 100644
> --- a/usr/spc.c
> +++ b/usr/spc.c
> @@ -26,11 +26,14 @@
>  
>  #include "list.h"
>  #include "util.h"
> +#include "parser.h"
>  #include "tgtd.h"
>  #include "target.h"
> +#include "tgtadm.h"
>  #include "driver.h"
>  #include "scsi.h"
>  #include "spc.h"
> +#include "sense_codes.h"
>  
>  #define PRODUCT_REV	"0"
>  
> @@ -240,7 +243,74 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
>  
>  int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
>  {
> +	uint8_t	*cdb = cmd->scb;
> +
> +	switch((cdb[0] & 0xe0) >> 5) {

how about using cmd->scb_len?


> +	case 0:	/* 6byte commands */
> +		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x",
> +			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5]);
> +		break;
> +	case 1: /* 10byte commands */
> +	case 2:
> +		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
> +				" %02x %02x %02x %02x", 
> +			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
> +			cdb[6], cdb[7], cdb[8], cdb[9]);
> +		break;
> +	case 3:	/* Exception to the rule */
> +	case 4:	/* 16byte commands */
> +		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
> +				" %02x %02x %02x %02x %02x %02x" 
> +				" %02x %02x %02x %02x",
> +			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
> +			cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11],
> +			cdb[12], cdb[13], cdb[14], cdb[15]);
> +		break;
> +	case 5:	/* 12byte commands */
> +		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
> +				" %02x %02x %02x %02x %02x %02x" ,
> +			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
> +			cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11]);
> +		break;
> +	}
>  	cmd->len = 0;
>  	sense_data_build(cmd, ILLEGAL_REQUEST, 0x20, 0);
>  	return SAM_STAT_CHECK_CONDITION;
>  }
> +
> +enum {
> +	Opt_scsiid, Opt_scsisn, Opt_err,
> +};
> +
> +static match_table_t tokens = {
> +	{Opt_scsiid, "scsi_id=%s"},
> +	{Opt_scsisn, "scsi_sn=%s"},
> +	{Opt_err, NULL},
> +};
> +
> +int spc_device_config(struct scsi_lu *lu, char * params) {
> +	int	err = 0;
> +	char	*p;
> +
> +	while ((p = strsep(&params, ",")) != NULL) {
> +		substring_t args[MAX_OPT_ARGS];
> +		int token;
> +		if (!*p)
> +			continue;
> +		dprintf("*p : %s\n", p);
> +		token = match_token(p, tokens, args);
> +		switch (token) {
> +		case Opt_scsiid:
> +			match_strncpy(lu->scsi_id, &args[0],
> +				      sizeof(lu->scsi_id) - 1);
> +			break;
> +		case Opt_scsisn:
> +			match_strncpy(lu->scsi_sn, &args[0],
> +				      sizeof(lu->scsi_sn) - 1);
> +			break;
> +		default:
> +			err = TGTADM_INVALID_REQUEST;
> +		}
> +	}
> +	return err;
> +}
> diff --git a/usr/spc.h b/usr/spc.h
> index f81e74c..5ced810 100644
> --- a/usr/spc.h
> +++ b/usr/spc.h
> @@ -7,5 +7,8 @@ extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
>  extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
>  extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
>  extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
> +extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd,
> +						struct list_head * head);
> +extern int spc_device_config(struct scsi_lu *lu, char * params);
>  
>  #endif
> diff --git a/usr/target.c b/usr/target.c
> index 23f450f..d3be173 100644
> --- a/usr/target.c
> +++ b/usr/target.c
> @@ -29,7 +29,6 @@
>  #include <sys/socket.h>
>  
>  #include "list.h"
> -#include "parser.h"
>  #include "util.h"
>  #include "tgtd.h"
>  #include "driver.h"
> @@ -249,11 +248,13 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
>  
>  	snprintf(lu->scsi_id, sizeof(lu->scsi_id),
>  		 "deadbeaf%d:%" PRIu64, tid, lun);
> +	snprintf(lu->scsi_sn, sizeof(lu->scsi_sn),
> +		"beaf%d%" PRIu64, tid, lun);
>  
>  	tgt_cmd_queue_init(&lu->cmd_queue);
>  
>  	if (target->dev_type_template.device_init)
> -		target->dev_type_template.device_init(lu);
> +		err = target->dev_type_template.device_init(lu);
>  
>  	list_for_each_entry(pos, &target->device_list, device_siblings) {
>  		if (lu->lun < pos->lun)
> @@ -269,6 +270,7 @@ int tgt_device_destroy(int tid, uint64_t lun)
>  {
>  	struct target *target;
>  	struct scsi_lu *lu;
> +	int	err;
>  
>  	dprintf("%u %" PRIu64 "\n", tid, lun);
>  
> @@ -281,12 +283,14 @@ int tgt_device_destroy(int tid, uint64_t lun)
>  	if (!list_empty(&lu->cmd_queue.queue) || lu->cmd_queue.active_cmd)
>  		return TGTADM_LUN_ACTIVE;
>  
> +	err = target->dev_type_template.device_shutdown(lu);
> +
>  	free(lu->path);
>  	list_del(&lu->device_siblings);
>  
>  	target->bst->bs_close(lu);
>  	free(lu);
> -	return 0;
> +	return err;
>  }
>  
>  int device_reserve(struct scsi_cmd *cmd)
> @@ -339,20 +343,9 @@ int device_reserved(struct scsi_cmd *cmd)
>  	return -EBUSY;
>  }
>  
> -enum {
> -	Opt_scsiid, Opt_scsisn, Opt_err,
> -};
> -
> -static match_table_t tokens = {
> -	{Opt_scsiid, "scsi_id=%s"},
> -	{Opt_scsisn, "scsi_sn=%s"},
> -	{Opt_err, NULL},
> -};
> -
>  int tgt_device_update(int tid, uint64_t dev_id, char *params)
>  {
> -	int err = 0;
> -	char *p;
> +	int err = TGTADM_INVALID_REQUEST;
>  	struct target *target;
>  	struct scsi_lu *lu;
>  
> @@ -366,26 +359,8 @@ int tgt_device_update(int tid, uint64_t dev_id, char *params)
>  		return TGTADM_NO_LUN;
>  	}
>  
> -	while ((p = strsep(&params, ",")) != NULL) {
> -		substring_t args[MAX_OPT_ARGS];
> -		int token;
> -		if (!*p)
> -			continue;
> -		token = match_token(p, tokens, args);
> -
> -		switch (token) {
> -		case Opt_scsiid:
> -			match_strncpy(lu->scsi_id, &args[0],
> -				      sizeof(lu->scsi_id) - 1);
> -			break;
> -		case Opt_scsisn:
> -			match_strncpy(lu->scsi_sn, &args[0],
> -				      sizeof(lu->scsi_sn) - 1);
> -			break;
> -		default:
> -			err = TGTADM_INVALID_REQUEST;
> -		}
> -	}
> +	if (target->dev_type_template.device_config)
> +		err = target->dev_type_template.device_config(lu, params);
>  
>  	return err;
>  }
> @@ -474,8 +449,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
>  		cmd_post_perform(q, cmd);
>  
>  		dprintf("%" PRIx64 " %x %" PRIx64 " %" PRIu64 " %u %d %d\n",
> -			cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset, cmd->len,
> -			result, cmd->async);
> +			cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset,
> +			cmd->len, result, cmd->async);
>  
>  		set_cmd_processed(cmd);
>  		if (!cmd->async)
> @@ -483,7 +458,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
>  	} else {
>  		set_cmd_queued(cmd);
>  		dprintf("blocked %" PRIx64 " %x %" PRIu64 " %d\n",
> -			cmd->tag, cmd->scb[0], cmd->dev ? cmd->dev->lun : UINT64_MAX,
> +			cmd->tag, cmd->scb[0],
> +			cmd->dev ? cmd->dev->lun : UINT64_MAX,
>  			q->active_cmd);
>  
>  		list_add_tail(&cmd->qlist, &q->queue);
> diff --git a/usr/tgtadm.c b/usr/tgtadm.c
> index e55a785..3d551cc 100644
> --- a/usr/tgtadm.c
> +++ b/usr/tgtadm.c
> @@ -103,6 +103,7 @@ struct option const long_options[] = {
>  	{"initiator-address", required_argument, NULL, 'I'},
>  	{"user", required_argument, NULL, 'u'},
>  	{"password", required_argument, NULL, 'p'},
> +	{"params", required_argument, NULL, 'P'},
>  
>  	{"bus", required_argument, NULL, 'B'},
>  	{"target-type", required_argument, NULL, 'Y'},
> @@ -110,7 +111,7 @@ struct option const long_options[] = {
>  	{NULL, 0, NULL, 0},
>  };
>  
> -static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:B:Y:O";
> +static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:P:B:Y:O";
>  
>  static void usage(int status)
>  {
> @@ -355,7 +356,7 @@ int main(int argc, char **argv)
>  	int op, total, tid, rest, mode, t_type, ac_dir;
>  	uint32_t cid, hostno;
>  	uint64_t sid, lun;
> -	char *name, *value, *path, *targetname, *params, *address;
> +	char *name, *value, *path, *targetname, *params, *address, *targetOps;
>  	char *user, *password;
>  	char buf[BUFSIZE + sizeof(struct tgtadm_req)];
>  	struct tgtadm_req *req;
> @@ -365,7 +366,7 @@ int main(int argc, char **argv)
>  	t_type = TYPE_DISK;
>  	ac_dir = ACCOUNT_TYPE_INCOMING;
>  	rest = BUFSIZE;
> -	name = value = path = targetname = address = NULL;
> +	name = value = path = targetname = address = targetOps = NULL;
>  	user = password = NULL;
>  
>  	memset(buf, 0, sizeof(buf));
> @@ -396,6 +397,9 @@ int main(int argc, char **argv)
>  		case 'l':
>  			lun = strtoull(optarg, NULL, 10);
>  			break;
> +		case 'P':
> +			targetOps = optarg;
> +			break;
>  		case 'n':
>  			name = optarg;
>  			break;
> @@ -570,6 +574,10 @@ int main(int argc, char **argv)
>  	if (password)
>  		shprintf(total, params, rest, "%spassword=%s",
>  			 rest == BUFSIZE ? "" : ",", password);
> +	// Trailing ',' makes parsing params in modules easier..
> +	if (targetOps)
> +		shprintf(total, params, rest, "%stargetOps %s,",
> +			 rest == BUFSIZE ? "" : ",", targetOps);
>  
>  	req->len = sizeof(*req) + total;
>  
> diff --git a/usr/tgtd.h b/usr/tgtd.h
> index 06e0dd9..808fd7f 100644
> --- a/usr/tgtd.h
> +++ b/usr/tgtd.h
> @@ -49,6 +49,8 @@ struct scsi_lu {
>  
>  	/* TODO: needs a structure for lots of device parameters */
>  	uint8_t d_sense;
> +
> +	void * priv_p;
>  };
>  
>  struct scsi_cmd {
> @@ -121,7 +123,9 @@ struct device_type_template {
>  	char *name;
>  	char *pid;
>  
> -	void (*device_init)(struct scsi_lu *dev);
> +	int (*device_init)(struct scsi_lu *lu);
> +	int (*device_shutdown)(struct scsi_lu *lu);
> +	int (*device_config)(struct scsi_lu *lu, char *arg);
>  
>  	struct device_type_operations ops[256];
>  };


From blackmagic02881 at gmail.com  Sun May 13 16:17:39 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Sun, 13 May 2007 10:17:39 -0400
Subject: [Stgt-devel] [PATCH] replace valloc and fix memory leak
In-Reply-To: <200705130713.l4D7DCDE011880@mbox.iij4u.or.jp>
References: <1178899391.3857.43.camel@dhcp-136.ibrix.com>
	<200705130713.l4D7DCDE011880@mbox.iij4u.or.jp>
Message-ID: <1179065859.3807.0.camel@localhost.localdomain>

On Sun, 2007-05-13 at 16:13 +0900, FUJITA Tomonori wrote:
> From: Ming Zhang <blackmagic02881 at gmail.com>
> Subject: [Stgt-devel] [PATCH] replace valloc and fix memory leak
> Date: Fri, 11 May 2007 12:03:11 -0400
> 
> > Hi All
> > 
> > A trivial patch to replace obsoleted valloc with memalign and also fix
> > some potential memory leak.
> 
> memalign is also obsoleted.

oops, overlooked that.

will you apply that memory leak fix? i can submit a separated patch if
you want.

Ming



From notice at microsoftwindowslottery.co.uk  Mon May 14 20:00:01 2007
From: notice at microsoftwindowslottery.co.uk (MICROSOFT WINDOWS LOTTERY BOARD)
Date: Mon, 14 May 2007 10:00:01 -0800
Subject: YOU HAVE WON THE YAHOO MSN INC & MICROSOFT WINDOWS LOTTERY OF 500,000.00
Message-ID: <DEDI257nqYsZOf1iIzc0000a032@cp62.webhost4life.com>

Yahoo/Msn Lottery
Incoporation 
Baley House, Har Road
Sutton, Greater London
SM1 4te
United Kingdom.
This is to inform you that you have won a prize money of Five Hundred 
thousand, Great Britain Pound Sterlings(?500,000.00) for the month of 
May 2007 Lottery promotion which is organized by YAHOO/MSN LOTTERY INC 
& WINDOWS LIVE.
YAHOO/MSN & MICROSOFT WINDOWS, collects all the email addresses of the 
people that are active online, among the millions that subscribed to 
Yahoo,Hotmail and other host of email, we only select five people every 
Month as our winners through electronic balloting System without the 
winner applying,we congratulate you for being one of the people 
selected.
You are to contact the events manager on or before your date of Claim, 
Winners Shall be paid in accordance with his/her Settlement Centre.
Yahoo/Msn Lottery Prize must be claimed no later than 10 days from date 
of Draw Notification after the Draw date in which Prize has won. Any 
prize not claimed within this period will be forfeited.
These are your identification numbers:
 
Batch number.....................YM 09102XN
Reff number.......................YM35447XN
Winning number...................YM09788
These numbers fall within your Location file, you are requested to 
contact the events manager, send your winning identification numbers to 
him,to enable him verify your claims.How ever you will have to fill and 
submit this form to the events manager for verification & direction on 
how you can claim your winning fund.
1. Full name..............
2. Contact Address........
3. Age....................
4. Telephone Number.......
5. Marital Status.........
6. Sex....................
7. Next Of Kin............
8. Zip Code...............
9. Occupation.............
10. Company...............
11.State:.................
12.Country................
13.Nationality............
14. Your Reference and Batch number are at the top of this mail:
(CONTACT EVENTS MANAGER) 
Name:Mr Smith Wallace
Email:fudiciaryoffice_microsoftwindows at yahoo.co.uk
Phone Number:+447024060769
Thank you and Accept my hearty congratulations once again! 
Yours faithfully, 
Mrs.Lillian Hunt
(Yahoo/Msn Lottery Games/Lottery Coordinator).




From markh794 at gmail.com  Tue May 15 06:20:40 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Tue, 15 May 2007 14:20:40 +1000
Subject: [Stgt-devel] PATCH 2 of 6 - tgt core patch
In-Reply-To: <200705130738.l4D7c1W1012622@mbox.iij4u.or.jp>
References: <f29db9a80705102017w14b1dca1sb56bb8c199408c38@mail.gmail.com>
	<200705130738.l4D7c1W1012622@mbox.iij4u.or.jp>
Message-ID: <f29db9a80705142120j5b9340cfjdabe885f61b40c29@mail.gmail.com>

On 5/13/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: [Stgt-devel] PATCH 2 of 6 - tgt core patch
> Date: Fri, 11 May 2007 13:17:44 +1000
>
> Thanks a lot for your work.
>
> Can we focus on tgt core changes first? If VTL code doesn't break tgt,
> I'm happy to merge it.

Great

>
>
> > diff --git a/doc/tgt-setup b/doc/tgt-setup
> > index e27f104..bb1074c 100755
> > --- a/doc/tgt-setup
> > +++ b/doc/tgt-setup
> > @@ -2,7 +2,7 @@
> >
> >  set -x
> >
> > -export PATH=`pwd`/usr:$PATH
> > +export PATH=`pwd`/../usr:$PATH
> >
> >  P=`ps -ef|grep -v grep|grep tgtd|wc -l`
> >  if [ "X"$P == "X0" ]; then
>
> I think that we need a new directory for scripts.

Any preference for the directory name ?
I was thinking along the lines of 'scripts'

>
>
> > diff --git a/usr/Makefile b/usr/Makefile
> > index 7ff74cb..62d0805 100644
> > --- a/usr/Makefile
> > +++ b/usr/Makefile
> > @@ -61,3 +61,9 @@ endif
> >
> >  clean:
> >       rm -f *.o $(PROGRAMS) iscsi/*.o ibmvio/*.o xen/*.o
> > +
> > +distclean:
> > +     rm -f *.o $(PROGRAMS) iscsi/*.o ibmvio/*.o xen/*.o TAGS *.rej
>
> We need this? git-clean ?

Not really.. I just did not clean up the Makefile patch before I sent it fully.
I use this before a "git commit -a".
Consider it gone.

>
>
> > +tags:
> > +     etags *.c *.h iscsi/*.c iscsi/*.h ibmvio/*.c xen/*.c xen/*.h
>
> I use gtags instead of etags. There are various tools for tags so I
> don't think that we need something like this.

Gone.

>
>
> > diff --git a/usr/mmc.c b/usr/mmc.c
> > index e9cc479..d53d0f3 100644
> > --- a/usr/mmc.c
> > +++ b/usr/mmc.c
> > @@ -121,10 +121,24 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
> >       return SAM_STAT_GOOD;
> >  }
> >
> > +static int device_mmc_init(struct scsi_lu *lu)
> > +{
> > +     lu->d_sense = 1;
> > +     return 0;
> > +}
> > +
> > +static int device_mmc_shutdown(struct scsi_lu *lu)
> > +{
> > +     return 0;
> > +}
> > +
> >  struct device_type_template mmc_template = {
> >       .type   = TYPE_ROM,
> >       .name   = "cdrom/dvd",
> >       .pid    = "VIRTUAL-CDROM",
> > +     .device_init = device_mmc_init,
> > +     .device_shutdown = device_mmc_shutdown,
> > +     .device_config = spc_device_config,
> >       .ops    = {
> >               {spc_test_unit,},
> >               {spc_illegal_op,},
> > diff --git a/usr/osd.c b/usr/osd.c
> > index 46bf0a0..64e7b2a 100644
> > --- a/usr/osd.c
> > +++ b/usr/osd.c
> > @@ -145,15 +145,22 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
> >       return cmd->c_target->bst->bs_cmd_submit(cmd);
> >  }
> >
> > -static void device_osd_init(struct scsi_lu *lu)
> > +static int device_osd_init(struct scsi_lu *lu)
> >  {
> >       lu->d_sense = 1;
> > +     return 0;
> > +}
> > +
> > +static int device_osd_shutdown(struct scsi_lu *lu)
> > +{
> > +     return 0;
> >  }
> >
> >  struct device_type_template osd_template = {
> >       .type           = TYPE_OSD,
> >       .name           = "osd",
> >       .device_init    = device_osd_init,
> > +     .device_shutdown        = device_osd_shutdown,
> >       .ops            = {
> >               [0x00 ... 0x0f] = {spc_illegal_op},
> >
> > diff --git a/usr/sbc.c b/usr/sbc.c
> > index a22d3b0..879943a 100644
> > --- a/usr/sbc.c
> > +++ b/usr/sbc.c
> > @@ -337,10 +337,21 @@ sense:
> >       return SAM_STAT_CHECK_CONDITION;
> >  }
> >
> > +static int sbc_init(struct scsi_lu *lu) {
> > +     return 0;
> > +}
> > +
> > +static int sbc_shutdown(struct scsi_lu *lu) {
> > +     return 0;
> > +}
> > +
> >  struct device_type_template sbc_template = {
> >       .type   = TYPE_DISK,
> >       .name   = "disk",
> >       .pid    = "VIRTUAL-DISK",
> > +     .device_init = sbc_init,
> > +     .device_shutdown = sbc_shutdown,
> > +     .device_config = spc_device_config,
> >       .ops    = {
> >               {spc_test_unit,},
> >               {spc_illegal_op,},
> > diff --git a/usr/sense_codes.h b/usr/sense_codes.h
> > new file mode 100644
> > index 0000000..0791dc3
> > --- /dev/null
> > +++ b/usr/sense_codes.h
> > @@ -0,0 +1,105 @@
> > +/*
> > + * The SCSI sense key Additional Sense Code / Additional Sense Code Qualifier
> > + *
> > + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
> > + *
> > + * This program is free software; you can redistribute it and/or modify
> > + * it under the terms of the GNU General Public License as published by
> > + * the Free Software Foundation; version 2 of the License.
> > + *
> > + * This program is distributed in the hope that it will be useful,
> > + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> > + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> > + * GNU General Public License for more details.
> > + *
> > + * You should have received a copy of the GNU General Public License
> > + * along with this program; if not, write to the Free Software
> > + * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
> > + */
> > +
> > +#define mk_sense_data(cmd, key, qual) \
> > +     sense_data_build(cmd, key, ((qual >> 8) & 0xff), qual && 0xff)
> > +
> > +/*
> > + * SENSE keys
> > + */
> > +#define NO_SENSE             0x00
> > +#define      RECOVERED_ERROR         0x01
> > +#define NOT_READY            0x02
> > +#define MEDIUM_ERROR         0x03
> > +#define      HARDWARE_ERROR          0x04
> > +#define ILLEGAL_REQUEST              0x05
> > +#define UNIT_ATTENTION               0x06
> > +#define DATA_PROTECT         0x07
> > +#define      BLANK_CHECK             0x08
> > +
> > +/* No Sense Errors */
> > +#define NO_ADDITIONAL_SENSE          0x0000
> > +#define E_MARK                               0x0001
> > +#define E_EOM                                0x0002
> > +#define E_BOM                                0x0004
> > +#define E_END_OF_DATA                        0x0005
> > +#define E_OP_IN_PROGRESS             0x0016
> > +#define E_DRIVE_REQUIRES_CLEANING    0x8282
> > +
> > +/* Recovered Errors */
> > +#define E_WRITE_ERROR                        0x0c00
> > +#define E_READ_ERROR                 0x1100
> > +#define E_RECOVERED_WITH_RETRYS              0x1701
> > +#define E_MEDIA_LOAD_EJECT_ERROR     0x5300
> > +#define E_FAILURE_PREDICTION         0x5d00
> > +
> > +/* Not ready */
> > +#define E_CAUSE_NOT_REPORTABLE               0x0400
> > +#define E_BECOMING_READY             0x0401
> > +#define E_INITIALIZING_REQUIRED              0x0402
> > +#define E_CLEANING_CART_INSTALLED    0x3003
> > +#define E_CLEANING_FAILURE           0x3007
> > +#define E_MEDIUM_NOT_PRESENT         0x3a00
> > +#define E_LOGICAL_UNIT_NOT_CONFIG    0x3e00
> > +
> > +/* Medium Errors */
> > +#define E_WRITE_ERROR                        0x0c00
> > +#define E_UNRECOVERED_READ           0x1100
> > +#define E_RECORDED_ENTITY_NOT_FOUND  0x1400
> > +#define E_UNKNOWN_FORMAT             0x3001
> > +#define E_IMCOMPATIBLE_FORMAT                0x3002
> > +#define E_MEDIUM_FORMAT_CORRUPT              0x3100
> > +#define E_SEQUENTIAL_POSITION_ERR    0x3b00
> > +#define E_WRITE_APPEND_ERR           0x5000
> > +#define E_CARTRIDGE_FAULT            0x5200
> > +#define E_MEDIA_LOAD_OR_EJECT_FAILED 0x5300
> > +
> > +/* Hardware Failure */
> > +#define E_COMPRESSION_CHECK          0x0c04
> > +#define E_DECOMPRESSION_CRC          0x110d
> > +#define E_MECHANICAL_POSITIONING_ERROR       0x1501
> > +#define E_MANUAL_INTERVENTION_REQ    0x0403
> > +#define E_HARDWARE_FAILURE           0x4000
> > +#define E_INTERNAL_TARGET_FAILURE    0x4400
> > +#define E_ERASE_FAILURE                      0x5100
> > +
> > +/* Illegal Request */
> > +#define E_PARAMETER_LIST_LENGTH_ERR  0x1a00
> > +#define E_INVALID_OP_CODE            0x2000
> > +#define E_INVALID_FIELD_IN_CDB               0x2400
> > +#define E_LUN_NOT_SUPPORTED          0x2500
> > +#define E_INVALID_FIELD_IN_PARMS     0x2600
> > +#define E_SAVING_PARMS_UNSUP         0x3900
> > +#define E_MEDIUM_DEST_FULL           0x3b0d
> > +#define E_MEDIUM_SRC_EMPTY           0x3b0e
> > +#define E_POSITION_PAST_BOM          0x3b0c
> > +#define E_MEDIUM_REMOVAL_PREVENTED   0x5302
> > +#define E_BAD_MICROCODE_DETECTED     0x8283
> > +
> > +/* Unit Attention */
> > +#define E_NOT_READY_TO_TRANSITION    0x2800
> > +#define E_POWERON_RESET                      0x2900
> > +#define E_MODE_PARAMETERS_CHANGED    0x2a01
> > +#define E_MICROCODE_DOWNLOADED               0x3f01
> > +#define E_FAILURE_PREDICTION_FALSE   0x5dff
> > +#define E_INQUIRY_DATA_HAS_CHANGED   0x3f03
> > +
> > +/* Data Protect */
> > +#define E_WRITE_PROTECT                      0x2700
> > +#define E_MEDIUM_OVERWRITE_ATTEMPTED 0x300c
> > diff --git a/usr/spc.c b/usr/spc.c
> > index b922a45..7dd920a 100644
> > --- a/usr/spc.c
> > +++ b/usr/spc.c
> > @@ -26,11 +26,14 @@
> >
> >  #include "list.h"
> >  #include "util.h"
> > +#include "parser.h"
> >  #include "tgtd.h"
> >  #include "target.h"
> > +#include "tgtadm.h"
> >  #include "driver.h"
> >  #include "scsi.h"
> >  #include "spc.h"
> > +#include "sense_codes.h"
> >
> >  #define PRODUCT_REV  "0"
> >
> > @@ -240,7 +243,74 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
> >
> >  int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
> >  {
> > +     uint8_t *cdb = cmd->scb;
> > +
> > +     switch((cdb[0] & 0xe0) >> 5) {
>
> how about using cmd->scb_len?

I shall update.

>
>
> > +     case 0: /* 6byte commands */
> > +             dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x",
> > +                     cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5]);
> > +             break;
> > +     case 1: /* 10byte commands */
> > +     case 2:
> > +             dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
> > +                             " %02x %02x %02x %02x",
> > +                     cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
> > +                     cdb[6], cdb[7], cdb[8], cdb[9]);
> > +             break;
> > +     case 3: /* Exception to the rule */
> > +     case 4: /* 16byte commands */
> > +             dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
> > +                             " %02x %02x %02x %02x %02x %02x"
> > +                             " %02x %02x %02x %02x",
> > +                     cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
> > +                     cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11],
> > +                     cdb[12], cdb[13], cdb[14], cdb[15]);
> > +             break;
> > +     case 5: /* 12byte commands */
> > +             dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
> > +                             " %02x %02x %02x %02x %02x %02x" ,
> > +                     cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
> > +                     cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11]);
> > +             break;
> > +     }
> >       cmd->len = 0;
> >       sense_data_build(cmd, ILLEGAL_REQUEST, 0x20, 0);
> >       return SAM_STAT_CHECK_CONDITION;
> >  }
> > +
> > +enum {
> > +     Opt_scsiid, Opt_scsisn, Opt_err,
> > +};
> > +
> > +static match_table_t tokens = {
> > +     {Opt_scsiid, "scsi_id=%s"},
> > +     {Opt_scsisn, "scsi_sn=%s"},
> > +     {Opt_err, NULL},
> > +};
> > +
> > +int spc_device_config(struct scsi_lu *lu, char * params) {
> > +     int     err = 0;
> > +     char    *p;
> > +
> > +     while ((p = strsep(&params, ",")) != NULL) {
> > +             substring_t args[MAX_OPT_ARGS];
> > +             int token;
> > +             if (!*p)
> > +                     continue;
> > +             dprintf("*p : %s\n", p);
> > +             token = match_token(p, tokens, args);
> > +             switch (token) {
> > +             case Opt_scsiid:
> > +                     match_strncpy(lu->scsi_id, &args[0],
> > +                                   sizeof(lu->scsi_id) - 1);
> > +                     break;
> > +             case Opt_scsisn:
> > +                     match_strncpy(lu->scsi_sn, &args[0],
> > +                                   sizeof(lu->scsi_sn) - 1);
> > +                     break;
> > +             default:
> > +                     err = TGTADM_INVALID_REQUEST;
> > +             }
> > +     }
> > +     return err;
> > +}
> > diff --git a/usr/spc.h b/usr/spc.h
> > index f81e74c..5ced810 100644
> > --- a/usr/spc.h
> > +++ b/usr/spc.h
> > @@ -7,5 +7,8 @@ extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
> >  extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
> >  extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
> >  extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
> > +extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd,
> > +                                             struct list_head * head);
> > +extern int spc_device_config(struct scsi_lu *lu, char * params);
> >
> >  #endif
> > diff --git a/usr/target.c b/usr/target.c
> > index 23f450f..d3be173 100644
> > --- a/usr/target.c
> > +++ b/usr/target.c
> > @@ -29,7 +29,6 @@
> >  #include <sys/socket.h>
> >
> >  #include "list.h"
> > -#include "parser.h"
> >  #include "util.h"
> >  #include "tgtd.h"
> >  #include "driver.h"
> > @@ -249,11 +248,13 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
> >
> >       snprintf(lu->scsi_id, sizeof(lu->scsi_id),
> >                "deadbeaf%d:%" PRIu64, tid, lun);
> > +     snprintf(lu->scsi_sn, sizeof(lu->scsi_sn),
> > +             "beaf%d%" PRIu64, tid, lun);
> >
> >       tgt_cmd_queue_init(&lu->cmd_queue);
> >
> >       if (target->dev_type_template.device_init)
> > -             target->dev_type_template.device_init(lu);
> > +             err = target->dev_type_template.device_init(lu);
> >
> >       list_for_each_entry(pos, &target->device_list, device_siblings) {
> >               if (lu->lun < pos->lun)
> > @@ -269,6 +270,7 @@ int tgt_device_destroy(int tid, uint64_t lun)
> >  {
> >       struct target *target;
> >       struct scsi_lu *lu;
> > +     int     err;
> >
> >       dprintf("%u %" PRIu64 "\n", tid, lun);
> >
> > @@ -281,12 +283,14 @@ int tgt_device_destroy(int tid, uint64_t lun)
> >       if (!list_empty(&lu->cmd_queue.queue) || lu->cmd_queue.active_cmd)
> >               return TGTADM_LUN_ACTIVE;
> >
> > +     err = target->dev_type_template.device_shutdown(lu);
> > +
> >       free(lu->path);
> >       list_del(&lu->device_siblings);
> >
> >       target->bst->bs_close(lu);
> >       free(lu);
> > -     return 0;
> > +     return err;
> >  }
> >
> >  int device_reserve(struct scsi_cmd *cmd)
> > @@ -339,20 +343,9 @@ int device_reserved(struct scsi_cmd *cmd)
> >       return -EBUSY;
> >  }
> >
> > -enum {
> > -     Opt_scsiid, Opt_scsisn, Opt_err,
> > -};
> > -
> > -static match_table_t tokens = {
> > -     {Opt_scsiid, "scsi_id=%s"},
> > -     {Opt_scsisn, "scsi_sn=%s"},
> > -     {Opt_err, NULL},
> > -};
> > -
> >  int tgt_device_update(int tid, uint64_t dev_id, char *params)
> >  {
> > -     int err = 0;
> > -     char *p;
> > +     int err = TGTADM_INVALID_REQUEST;
> >       struct target *target;
> >       struct scsi_lu *lu;
> >
> > @@ -366,26 +359,8 @@ int tgt_device_update(int tid, uint64_t dev_id, char *params)
> >               return TGTADM_NO_LUN;
> >       }
> >
> > -     while ((p = strsep(&params, ",")) != NULL) {
> > -             substring_t args[MAX_OPT_ARGS];
> > -             int token;
> > -             if (!*p)
> > -                     continue;
> > -             token = match_token(p, tokens, args);
> > -
> > -             switch (token) {
> > -             case Opt_scsiid:
> > -                     match_strncpy(lu->scsi_id, &args[0],
> > -                                   sizeof(lu->scsi_id) - 1);
> > -                     break;
> > -             case Opt_scsisn:
> > -                     match_strncpy(lu->scsi_sn, &args[0],
> > -                                   sizeof(lu->scsi_sn) - 1);
> > -                     break;
> > -             default:
> > -                     err = TGTADM_INVALID_REQUEST;
> > -             }
> > -     }
> > +     if (target->dev_type_template.device_config)
> > +             err = target->dev_type_template.device_config(lu, params);
> >
> >       return err;
> >  }
> > @@ -474,8 +449,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
> >               cmd_post_perform(q, cmd);
> >
> >               dprintf("%" PRIx64 " %x %" PRIx64 " %" PRIu64 " %u %d %d\n",
> > -                     cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset, cmd->len,
> > -                     result, cmd->async);
> > +                     cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset,
> > +                     cmd->len, result, cmd->async);
> >
> >               set_cmd_processed(cmd);
> >               if (!cmd->async)
> > @@ -483,7 +458,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
> >       } else {
> >               set_cmd_queued(cmd);
> >               dprintf("blocked %" PRIx64 " %x %" PRIu64 " %d\n",
> > -                     cmd->tag, cmd->scb[0], cmd->dev ? cmd->dev->lun : UINT64_MAX,
> > +                     cmd->tag, cmd->scb[0],
> > +                     cmd->dev ? cmd->dev->lun : UINT64_MAX,
> >                       q->active_cmd);
> >
> >               list_add_tail(&cmd->qlist, &q->queue);
> > diff --git a/usr/tgtadm.c b/usr/tgtadm.c
> > index e55a785..3d551cc 100644
> > --- a/usr/tgtadm.c
> > +++ b/usr/tgtadm.c
> > @@ -103,6 +103,7 @@ struct option const long_options[] = {
> >       {"initiator-address", required_argument, NULL, 'I'},
> >       {"user", required_argument, NULL, 'u'},
> >       {"password", required_argument, NULL, 'p'},
> > +     {"params", required_argument, NULL, 'P'},
> >
> >       {"bus", required_argument, NULL, 'B'},
> >       {"target-type", required_argument, NULL, 'Y'},
> > @@ -110,7 +111,7 @@ struct option const long_options[] = {
> >       {NULL, 0, NULL, 0},
> >  };
> >
> > -static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:B:Y:O";
> > +static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:P:B:Y:O";
> >
> >  static void usage(int status)
> >  {
> > @@ -355,7 +356,7 @@ int main(int argc, char **argv)
> >       int op, total, tid, rest, mode, t_type, ac_dir;
> >       uint32_t cid, hostno;
> >       uint64_t sid, lun;
> > -     char *name, *value, *path, *targetname, *params, *address;
> > +     char *name, *value, *path, *targetname, *params, *address, *targetOps;
> >       char *user, *password;
> >       char buf[BUFSIZE + sizeof(struct tgtadm_req)];
> >       struct tgtadm_req *req;
> > @@ -365,7 +366,7 @@ int main(int argc, char **argv)
> >       t_type = TYPE_DISK;
> >       ac_dir = ACCOUNT_TYPE_INCOMING;
> >       rest = BUFSIZE;
> > -     name = value = path = targetname = address = NULL;
> > +     name = value = path = targetname = address = targetOps = NULL;
> >       user = password = NULL;
> >
> >       memset(buf, 0, sizeof(buf));
> > @@ -396,6 +397,9 @@ int main(int argc, char **argv)
> >               case 'l':
> >                       lun = strtoull(optarg, NULL, 10);
> >                       break;
> > +             case 'P':
> > +                     targetOps = optarg;
> > +                     break;
> >               case 'n':
> >                       name = optarg;
> >                       break;
> > @@ -570,6 +574,10 @@ int main(int argc, char **argv)
> >       if (password)
> >               shprintf(total, params, rest, "%spassword=%s",
> >                        rest == BUFSIZE ? "" : ",", password);
> > +     // Trailing ',' makes parsing params in modules easier..
> > +     if (targetOps)
> > +             shprintf(total, params, rest, "%stargetOps %s,",
> > +                      rest == BUFSIZE ? "" : ",", targetOps);
> >
> >       req->len = sizeof(*req) + total;
> >
> > diff --git a/usr/tgtd.h b/usr/tgtd.h
> > index 06e0dd9..808fd7f 100644
> > --- a/usr/tgtd.h
> > +++ b/usr/tgtd.h
> > @@ -49,6 +49,8 @@ struct scsi_lu {
> >
> >       /* TODO: needs a structure for lots of device parameters */
> >       uint8_t d_sense;
> > +
> > +     void * priv_p;
> >  };
> >
> >  struct scsi_cmd {
> > @@ -121,7 +123,9 @@ struct device_type_template {
> >       char *name;
> >       char *pid;
> >
> > -     void (*device_init)(struct scsi_lu *dev);
> > +     int (*device_init)(struct scsi_lu *lu);
> > +     int (*device_shutdown)(struct scsi_lu *lu);
> > +     int (*device_config)(struct scsi_lu *lu, char *arg);
> >
> >       struct device_type_operations ops[256];
> >  };
>


I'll re-post the patches to 'stgt core'.

Thanks
Mark


From fujita.tomonori at lab.ntt.co.jp  Tue May 15 08:22:29 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 15 May 2007 15:22:29 +0900
Subject: [Stgt-devel] PATCH 2 of 6 - tgt core patch
In-Reply-To: <f29db9a80705142120j5b9340cfjdabe885f61b40c29@mail.gmail.com>
References: <f29db9a80705102017w14b1dca1sb56bb8c199408c38@mail.gmail.com>
	<200705130738.l4D7c1W1012622@mbox.iij4u.or.jp>
	<f29db9a80705142120j5b9340cfjdabe885f61b40c29@mail.gmail.com>
Message-ID: <20070515152229T.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] PATCH 2 of 6 - tgt core patch
Date: Tue, 15 May 2007 14:20:40 +1000

> On 5/13/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > From: "Mark Harvey" <markh794 at gmail.com>
> > Subject: [Stgt-devel] PATCH 2 of 6 - tgt core patch
> > Date: Fri, 11 May 2007 13:17:44 +1000
> >
> > Thanks a lot for your work.
> >
> > Can we focus on tgt core changes first? If VTL code doesn't break tgt,
> > I'm happy to merge it.
> 
> Great
> 
> >
> >
> > > diff --git a/doc/tgt-setup b/doc/tgt-setup
> > > index e27f104..bb1074c 100755
> > > --- a/doc/tgt-setup
> > > +++ b/doc/tgt-setup
> > > @@ -2,7 +2,7 @@
> > >
> > >  set -x
> > >
> > > -export PATH=`pwd`/usr:$PATH
> > > +export PATH=`pwd`/../usr:$PATH
> > >
> > >  P=`ps -ef|grep -v grep|grep tgtd|wc -l`
> > >  if [ "X"$P == "X0" ]; then
> >
> > I think that we need a new directory for scripts.
> 
> Any preference for the directory name ?
> I was thinking along the lines of 'scripts'

'scripts' is fine by me.


From mangoo at wpkg.org  Tue May 15 16:06:26 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Tue, 15 May 2007 16:06:26 +0200
Subject: [Stgt-devel] how to stop tgtd cleanly?
Message-ID: <4649BE62.2000208@wpkg.org>

What is the way to stop tgtd cleanly (i.e., not by using pkill -9 tgtd)?


-- 
Tomasz Chmielewski
http://wpkg.org


From fujita.tomonori at lab.ntt.co.jp  Tue May 15 16:32:40 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 15 May 2007 23:32:40 +0900
Subject: [Stgt-devel] how to stop tgtd cleanly?
In-Reply-To: <4649BE62.2000208@wpkg.org>
References: <4649BE62.2000208@wpkg.org>
Message-ID: <20070515233240Y.fujita.tomonori@lab.ntt.co.jp>

From: Tomasz Chmielewski <mangoo at wpkg.org>
Subject: [Stgt-devel] how to stop tgtd cleanly?
Date: Tue, 15 May 2007 16:06:26 +0200

> What is the way to stop tgtd cleanly (i.e., not by using pkill -9 tgtd)?

No other way. It's not elegant, but why doesn't it work for you?


From mangoo at wpkg.org  Tue May 15 16:35:11 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Tue, 15 May 2007 16:35:11 +0200
Subject: [Stgt-devel] stgt and large devices?
Message-ID: <4649C51F.80200@wpkg.org>

I have a large device (650 GB or so) which I used to export with IET 
like that:

Target iqn.2006-08.net.syneticon:thecus.backup
Lun 0 Path=/dev/mapper/LVM2-backup,Type=fileio
Alias backup


As I wanted to try stgt, I stopped IET, started tgtd, and tgtadm:

tgtadm --op new --mode target --tid 1 -T 
iqn.2006-08.net.syneticon:thecus.backup
tgtadm --op new --mode logicalunit --tid 1 --lun 0 -b 
/dev/mapper/LVM2-backup
tgtadm --op bind --mode target --tid 1 -I ALL


The initiator can connect, but the content of the disk is different from 
that on the real disk - I can't mount the filesystem.

when I browse through the beginning of a disk, I can see some familiar 
content, but it is nevertheless different.


With smaller targets (I tried up to 25 GB), everything is fine.


Was stgt tested with big devices?


-- 
Tomasz Chmielewski
http://wpkg.org


From mangoo at wpkg.org  Tue May 15 16:37:50 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Tue, 15 May 2007 16:37:50 +0200
Subject: [Stgt-devel] how to stop tgtd cleanly?
In-Reply-To: <20070515233240Y.fujita.tomonori@lab.ntt.co.jp>
References: <4649BE62.2000208@wpkg.org>
	<20070515233240Y.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <4649C5BE.1030407@wpkg.org>

FUJITA Tomonori schrieb:
> From: Tomasz Chmielewski <mangoo at wpkg.org>
> Subject: [Stgt-devel] how to stop tgtd cleanly?
> Date: Tue, 15 May 2007 16:06:26 +0200
> 
>> What is the way to stop tgtd cleanly (i.e., not by using pkill -9 tgtd)?
> 
> No other way. It's not elegant, but why doesn't it work for you?

Well, it's not elegant :)

I'm being hit by some bug in open-iscsi - sometimes, when I disconnect 
such uncleanly, iscsid process freezes, and I have to restart the 
machine. But I'm not yet so sure if that's related.


-- 
Tomasz Chmielewski
http://wpkg.org


From fujita.tomonori at lab.ntt.co.jp  Tue May 15 18:29:44 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 16 May 2007 01:29:44 +0900
Subject: [Stgt-devel] how to stop tgtd cleanly?
In-Reply-To: <4649C5BE.1030407@wpkg.org>
References: <4649BE62.2000208@wpkg.org>
	<20070515233240Y.fujita.tomonori@lab.ntt.co.jp>
	<4649C5BE.1030407@wpkg.org>
Message-ID: <20070516012944K.fujita.tomonori@lab.ntt.co.jp>

From: Tomasz Chmielewski <mangoo at wpkg.org>
Subject: Re: [Stgt-devel] how to stop tgtd cleanly?
Date: Tue, 15 May 2007 16:37:50 +0200

> FUJITA Tomonori schrieb:
> > From: Tomasz Chmielewski <mangoo at wpkg.org>
> > Subject: [Stgt-devel] how to stop tgtd cleanly?
> > Date: Tue, 15 May 2007 16:06:26 +0200
> > 
> >> What is the way to stop tgtd cleanly (i.e., not by using pkill -9 tgtd)?
> > 
> > No other way. It's not elegant, but why doesn't it work for you?
> 
> Well, it's not elegant :)

Well, sending a signal to stop software is quite common in Unix. I
don't think that we need another way to stop tgtd.


From fujita.tomonori at lab.ntt.co.jp  Wed May 16 09:09:07 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 16 May 2007 16:09:07 +0900
Subject: [Stgt-devel] stgt and large devices?
In-Reply-To: <4649C51F.80200@wpkg.org>
References: <4649C51F.80200@wpkg.org>
Message-ID: <20070516160907P.fujita.tomonori@lab.ntt.co.jp>

From: Tomasz Chmielewski <mangoo at wpkg.org>
Subject: [Stgt-devel] stgt and large devices?
Date: Tue, 15 May 2007 16:35:11 +0200

> I have a large device (650 GB or so) which I used to export with IET 
> like that:
> 
> Target iqn.2006-08.net.syneticon:thecus.backup
> Lun 0 Path=/dev/mapper/LVM2-backup,Type=fileio
> Alias backup
> 
> 
> As I wanted to try stgt, I stopped IET, started tgtd, and tgtadm:
> 
> tgtadm --op new --mode target --tid 1 -T 
> iqn.2006-08.net.syneticon:thecus.backup
> tgtadm --op new --mode logicalunit --tid 1 --lun 0 -b 
> /dev/mapper/LVM2-backup
> tgtadm --op bind --mode target --tid 1 -I ALL
> 
> 
> The initiator can connect, but the content of the disk is different from 
> that on the real disk - I can't mount the filesystem.
> 
> when I browse through the beginning of a disk, I can see some familiar 
> content, but it is nevertheless different.
> 
> 
> With smaller targets (I tried up to 25 GB), everything is fine.
> 
> 
> Was stgt tested with big devices?

Strage. It works for me.

On the target box:

aris:~# ./tgt/usr/tgtadm --op show --mode target
Target 1: iqn.2001-04.com.example:storage.disk2.paris.sys1.xyz
    System information:
        Type: disk
        Driver: iscsi
        Status: running
    I_T nexus information:
    LUN information:
        LUN: 0
            SCSI ID: deadbeaf1:0
            SCSI SN:
            Size: 682G
            Backing store: /dev/mapper/tgt-l0
    Account information:
    ACL information:
        ALL


On the initiator box:

tulip:/home/fujita# mkfs.ext3 /dev/sdg1
mke2fs 1.40-WIP (14-Nov-2006)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
89391104 inodes, 178781352 blocks
8939067 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=4294967296
5456 block groups
32768 blocks per group, 32768 fragments per group
16384 inodes per group
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,
        4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968,
        102400000

Writing inode tables: done
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 37 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.

tulip:/home/fujita# mount /dev/sdg1 /mnt/

tulip:/home/fujita# df
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda1            276543576   5888396 256607544   3% /
tmpfs                  3571036         0   3571036   0% /lib/init/rw
udev                     10240       124     10116   2% /dev
tmpfs                  3571036         0   3571036   0% /dev/shm
/dev/sdg1            703904704    201864 667946572   1% /mnt


Then I unmount /dev/sdg1 on the initiator box and run IET with
/dev/mapper/tgt-l0. I can /dev/sg1 again on the initiator box.




From mangoo at wpkg.org  Wed May 16 09:47:03 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Wed, 16 May 2007 09:47:03 +0200
Subject: [Stgt-devel] stgt and large devices?
In-Reply-To: <20070516160907P.fujita.tomonori@lab.ntt.co.jp>
References: <4649C51F.80200@wpkg.org>
	<20070516160907P.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <464AB6F7.2000105@wpkg.org>

FUJITA Tomonori schrieb:
> From: Tomasz Chmielewski <mangoo at wpkg.org>
> Subject: [Stgt-devel] stgt and large devices?
> Date: Tue, 15 May 2007 16:35:11 +0200
> 
>> I have a large device (650 GB or so) which I used to export with IET 
>> like that:
>>
>> Target iqn.2006-08.net.syneticon:thecus.backup
>> Lun 0 Path=/dev/mapper/LVM2-backup,Type=fileio
>> Alias backup
>>
>>
>> As I wanted to try stgt, I stopped IET, started tgtd, and tgtadm:
>>
>> tgtadm --op new --mode target --tid 1 -T 
>> iqn.2006-08.net.syneticon:thecus.backup
>> tgtadm --op new --mode logicalunit --tid 1 --lun 0 -b 
>> /dev/mapper/LVM2-backup
>> tgtadm --op bind --mode target --tid 1 -I ALL
>>
>>
>> The initiator can connect, but the content of the disk is different from 
>> that on the real disk - I can't mount the filesystem.
>>
>> when I browse through the beginning of a disk, I can see some familiar 
>> content, but it is nevertheless different.
>>
>>
>> With smaller targets (I tried up to 25 GB), everything is fine.
>>
>>
>> Was stgt tested with big devices?
> 
> Strage. It works for me.

Any thoughts what might be wrong with my setup?

BTW, this was tested on LE ARM architecture (compilation was fine, no 
problems at all).


-- 
Tomasz Chmielewski
http://wpkg.org



From waldi at berlios.de  Wed May 16 10:36:50 2007
From: waldi at berlios.de (Bastian Blank)
Date: Wed, 16 May 2007 10:36:50 +0200
Subject: [Stgt-devel] stgt and large devices?
In-Reply-To: <4649C51F.80200@wpkg.org>
References: <4649C51F.80200@wpkg.org>
Message-ID: <20070516083650.GA13459@wavehammer.waldi.eu.org>

On Tue, May 15, 2007 at 04:35:11PM +0200, Tomasz Chmielewski wrote:
> when I browse through the beginning of a disk, I can see some familiar 
> content, but it is nevertheless different.

Are you able to describe the differences?

Bastian

-- 
A princess should not be afraid -- not with a brave knight to protect her.
		-- McCoy, "Shore Leave", stardate 3025.3


From mangoo at wpkg.org  Wed May 16 12:15:12 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Wed, 16 May 2007 12:15:12 +0200
Subject: [Stgt-devel] stgt and large devices?
In-Reply-To: <20070516083650.GA13459@wavehammer.waldi.eu.org>
References: <4649C51F.80200@wpkg.org>
	<20070516083650.GA13459@wavehammer.waldi.eu.org>
Message-ID: <464AD9B0.7070303@wpkg.org>

Bastian Blank schrieb:
> On Tue, May 15, 2007 at 04:35:11PM +0200, Tomasz Chmielewski wrote:
>> when I browse through the beginning of a disk, I can see some familiar 
>> content, but it is nevertheless different.
> 
> Are you able to describe the differences?

Well, it's hard to describe the difference in binary data.

First, I did a "dd" of a first 10 MB of the disk or so, for IET and 
tgtd, compared md5sums - different.

Which shouldn't happen, as I didn't even mount the disks.


Then, I opened the files I created with dd in an editor - totally 
different, not just a couple of bytes here and there.


So let's make an experiment: create a 10 MB file out of /etc/services 
(basically, "cat" it several times after each other, until the text 
document has 10 MB).

Then, do (part - disk available via iSCSI):

IET:

# dd if=/services-big of=part
# dd if=part of=/part.iet bs=1k count=10000

When inspected with hexedit, we see text/services file.


tgtd:

# dd if=part of=/part.tgtd bs=1k count=10000

When inspected with hexedit, file is different.


# diff -u part.iet part.tgtd > part.diff

It resulted in a 600 kB diff file.



Whereas part.iet begins as /etc/services file, part.tgtd doesn't - it 
starts like that:

rror interpretation service
afs3-errors     7006/udp                        # error interpretation 
service
afs3-bos        7007/tcp                        # basic overseer process


It begins 1630 lines later.

# dd if=part of=/part.tgtd2 bs=1k count=10000
# dd if=part of=/part.tgtd3 bs=1k count=10000

# md5sum /part.*
bf38437967c33219c1852d0000b3e593  /part.tgtd2
c4a9207d7fb97f645b4b30142874d3fd  /part.tgtd3

# diff -u /part.tgtd2 /part.tgtd3 > /part-gt.diff

# ls -l /part-gt.diff
-rw-r--r-- 1 root root 218099 May 16 12:11 /part-gt.diff


Generally, the data seems *almost* intact, but the order is incorrect etc.


So I have two observations:

- it doesn't happen on x86
- it happens on ARM
- it doesn't depend on size of the device as I though at the beginning


-- 
Tomasz Chmielewski
http://wpkg.org


From blackmagic02881 at gmail.com  Wed May 16 15:45:32 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 16 May 2007 09:45:32 -0400
Subject: [Stgt-devel] stgt and large devices?
In-Reply-To: <464AD9B0.7070303@wpkg.org>
References: <4649C51F.80200@wpkg.org>
	<20070516083650.GA13459@wavehammer.waldi.eu.org>
	<464AD9B0.7070303@wpkg.org>
Message-ID: <1179323132.3697.10.camel@dhcp-136.ibrix.com>

On Wed, 2007-05-16 at 12:15 +0200, Tomasz Chmielewski wrote:
> Bastian Blank schrieb:
> > On Tue, May 15, 2007 at 04:35:11PM +0200, Tomasz Chmielewski wrote:
> >> when I browse through the beginning of a disk, I can see some familiar 
> >> content, but it is nevertheless different.
> > 
> > Are you able to describe the differences?
> 
> Well, it's hard to describe the difference in binary data.
> 
> First, I did a "dd" of a first 10 MB of the disk or so, for IET and 
> tgtd, compared md5sums - different.
> 
> Which shouldn't happen, as I didn't even mount the disks.
> 
> 
> Then, I opened the files I created with dd in an editor - totally 
> different, not just a couple of bytes here and there.
> 
> 
> So let's make an experiment: create a 10 MB file out of /etc/services 
> (basically, "cat" it several times after each other, until the text 
> document has 10 MB).
> 
> Then, do (part - disk available via iSCSI):
> 
> IET:
> 
> # dd if=/services-big of=part
> # dd if=part of=/part.iet bs=1k count=10000
> 
> When inspected with hexedit, we see text/services file.
> 
> 
> tgtd:
> 
> # dd if=part of=/part.tgtd bs=1k count=10000
> 
> When inspected with hexedit, file is different.
> 
> 
> # diff -u part.iet part.tgtd > part.diff
> 
> It resulted in a 600 kB diff file.
> 
> 
> 
> Whereas part.iet begins as /etc/services file, part.tgtd doesn't - it 
> starts like that:
> 
> rror interpretation service
> afs3-errors     7006/udp                        # error interpretation 
> service
> afs3-bos        7007/tcp                        # basic overseer process
> 
> 
> It begins 1630 lines later.
> 
> # dd if=part of=/part.tgtd2 bs=1k count=10000
> # dd if=part of=/part.tgtd3 bs=1k count=10000
> 
> # md5sum /part.*
> bf38437967c33219c1852d0000b3e593  /part.tgtd2
> c4a9207d7fb97f645b4b30142874d3fd  /part.tgtd3
> 
> # diff -u /part.tgtd2 /part.tgtd3 > /part-gt.diff
> 
> # ls -l /part-gt.diff
> -rw-r--r-- 1 root root 218099 May 16 12:11 /part-gt.diff
> 
> 
> Generally, the data seems *almost* intact, but the order is incorrect etc.

i will write a small code to write some pattern into the disk, for
example, 1st 1MB all 'a', 2nd all 'b',...

write on both and do hexedit and u can see the difference easier.



> 
> 
> So I have two observations:
> 
> - it doesn't happen on x86
> - it happens on ARM
> - it doesn't depend on size of the device as I though at the beginning
> 
> 



From mangoo at wpkg.org  Thu May 17 14:43:00 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Thu, 17 May 2007 14:43:00 +0200
Subject: [Stgt-devel] [Iscsitarget-devel] call for testers for tgt
In-Reply-To: <20070503202445Z.fujita.tomonori@lab.ntt.co.jp>
References: <20070503185754P.fujita.tomonori@lab.ntt.co.jp>	<4639B5CA.1050105@wpkg.org>	<20070503194545Y.fujita.tomonori@lab.ntt.co.jp>
	<20070503202445Z.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <464C4DD4.6010106@wpkg.org>

FUJITA Tomonori schrieb:
> From: Tomasz Chmielewski <mangoo at wpkg.org>
> Subject: Re: [Iscsitarget-devel] call for testers for tgt
> Date: Thu, 03 May 2007 12:40:13 +0200
> 
>> FUJITA Tomonori schrieb:
>>> I'm looking for testers for tgt iSCSI target code.
>>>
>>> tgt has been developed to replace IET, as mentioned several times on
>>> this mailing list.
>>>
>>> The iSCSI target code runs in user space. So you have no kernel
>>> crashes unlike IET and it's easy to compile the source code.
>> What performance can we expect? Same as IET? Worse?
> 
> Should be comparable.
> 
> At least, sg_turs gave the comparable results (you can find more in
> the stgt-devel mailing list):
> 
> 
>>> paris:~# sg_turs -t -n=1000 /dev/sg3
>>> time to perform commands was 0.125131 secs; 7991.62 operations/sec
>>> Completed 1000 Test Unit Ready commands with 0 errors
>>>
>>> - IET
>>>
>>> paris:~# sg_turs -t -n=1000 /dev/sg3
>>> time to perform commands was 0.128747 secs; 7767.17 operations/sec
>>> Completed 1000 Test Unit Ready commands with 0 errors
> 
> IET uses the user-space APIs in the kernel-space. It doesn't try
> to use the optimal in-kernel APIs. open-iscsi does (e.g. performing
> PDUs in	RX_SOFTIRQ) so the networking code is more complex.
> 
> Unless you use 10Gbit, I don't think you need to worry about the
> performance. Let me know if you find the performance difference.

I made a very simple test using "dd":

Target - native HDD speed

# dd if=nagios-swap of=/dev/null
1024000+0 records in
1024000+0 records out
524288000 bytes (524 MB) copied, 8.03441 seconds, 65.3 MB/s


IET 0.4.15:

# dd if=part of=/dev/null
1024000+0 records in
1024000+0 records out
524288000 bytes (524 MB) copied, 12,0278 seconds, 43,6 MB/s


tgtd 20070503:

# dd if=part of=/dev/null
1024000+0 records in
1024000+0 records out
524288000 bytes (524 MB) copied, 22,8263 seconds, 23,0 MB/s


Each test was performed three times, and gave similar results (~0,3 MB 
difference can be discarded).


Tests were carried over 1 Gb link.

Target is running: 600 MHz Celeron M CPU with 256 MB RAM.

Initiator is running: 3.20 Ghz Pentium 4 CPU, with 3 GB RAM.


Neither the target nor initiator were performing any other tasks when 
the tests were made.


-- 
Tomasz Chmielewski
http://wpkg.org


From fujita.tomonori at lab.ntt.co.jp  Thu May 17 15:35:27 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 17 May 2007 22:35:27 +0900
Subject: [Stgt-devel] [Iscsitarget-devel] call for testers for tgt
In-Reply-To: <464C4DD4.6010106@wpkg.org>
References: <20070503194545Y.fujita.tomonori@lab.ntt.co.jp>
	<20070503202445Z.fujita.tomonori@lab.ntt.co.jp>
	<464C4DD4.6010106@wpkg.org>
Message-ID: <20070517223527R.fujita.tomonori@lab.ntt.co.jp>

From: Tomasz Chmielewski <mangoo at wpkg.org>
Subject: Re: [Stgt-devel] [Iscsitarget-devel] call for testers for tgt
Date: Thu, 17 May 2007 14:43:00 +0200

> FUJITA Tomonori schrieb:
> > From: Tomasz Chmielewski <mangoo at wpkg.org>
> > Subject: Re: [Iscsitarget-devel] call for testers for tgt
> > Date: Thu, 03 May 2007 12:40:13 +0200
> > 
> >> FUJITA Tomonori schrieb:
> >>> I'm looking for testers for tgt iSCSI target code.
> >>>
> >>> tgt has been developed to replace IET, as mentioned several times on
> >>> this mailing list.
> >>>
> >>> The iSCSI target code runs in user space. So you have no kernel
> >>> crashes unlike IET and it's easy to compile the source code.
> >> What performance can we expect? Same as IET? Worse?
> > 
> > Should be comparable.
> > 
> > At least, sg_turs gave the comparable results (you can find more in
> > the stgt-devel mailing list):
> > 
> > 
> >>> paris:~# sg_turs -t -n=1000 /dev/sg3
> >>> time to perform commands was 0.125131 secs; 7991.62 operations/sec
> >>> Completed 1000 Test Unit Ready commands with 0 errors
> >>>
> >>> - IET
> >>>
> >>> paris:~# sg_turs -t -n=1000 /dev/sg3
> >>> time to perform commands was 0.128747 secs; 7767.17 operations/sec
> >>> Completed 1000 Test Unit Ready commands with 0 errors
> > 
> > IET uses the user-space APIs in the kernel-space. It doesn't try
> > to use the optimal in-kernel APIs. open-iscsi does (e.g. performing
> > PDUs in	RX_SOFTIRQ) so the networking code is more complex.
> > 
> > Unless you use 10Gbit, I don't think you need to worry about the
> > performance. Let me know if you find the performance difference.
> 
> I made a very simple test using "dd":
> 
> Target - native HDD speed
> 
> # dd if=nagios-swap of=/dev/null
> 1024000+0 records in
> 1024000+0 records out
> 524288000 bytes (524 MB) copied, 8.03441 seconds, 65.3 MB/s
> 
> 
> IET 0.4.15:
> 
> # dd if=part of=/dev/null
> 1024000+0 records in
> 1024000+0 records out
> 524288000 bytes (524 MB) copied, 12,0278 seconds, 43,6 MB/s
> 
> 
> tgtd 20070503:
> 
> # dd if=part of=/dev/null
> 1024000+0 records in
> 1024000+0 records out
> 524288000 bytes (524 MB) copied, 22,8263 seconds, 23,0 MB/s
> 
> 
> Each test was performed three times, and gave similar results (~0,3 MB 
> difference can be discarded).
> 
> 
> Tests were carried over 1 Gb link.
> 
> Target is running: 600 MHz Celeron M CPU with 256 MB RAM.
> 
> Initiator is running: 3.20 Ghz Pentium 4 CPU, with 3 GB RAM.
> 
> 
> Neither the target nor initiator were performing any other tasks when 
> the tests were made.

Can you try the following patch?


diff --git a/usr/bs_sync.c b/usr/bs_sync.c
index 6789b5b..c86617b 100644
--- a/usr/bs_sync.c
+++ b/usr/bs_sync.c
@@ -38,7 +38,7 @@
 #include "tgtd.h"
 #include "scsi.h"
 
-#define NR_WORKER_THREADS	4
+#define NR_WORKER_THREADS	8
 
 struct bs_sync_info {
 	pthread_t ack_thread;


From mangoo at wpkg.org  Thu May 17 16:15:33 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Thu, 17 May 2007 16:15:33 +0200
Subject: [Stgt-devel] [Iscsitarget-devel] call for testers for tgt
In-Reply-To: <20070517223527R.fujita.tomonori@lab.ntt.co.jp>
References: <20070503194545Y.fujita.tomonori@lab.ntt.co.jp>	<20070503202445Z.fujita.tomonori@lab.ntt.co.jp>	<464C4DD4.6010106@wpkg.org>
	<20070517223527R.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <464C6385.5030204@wpkg.org>

FUJITA Tomonori schrieb:

> Can you try the following patch?

> -#define NR_WORKER_THREADS	4
> +#define NR_WORKER_THREADS	8

In that case, performance dropped by about 2 MB/s.


-- 
Tomasz Chmielewski
http://wpkg.org


From fujita.tomonori at lab.ntt.co.jp  Thu May 17 17:03:16 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 18 May 2007 00:03:16 +0900
Subject: [Stgt-devel] [Iscsitarget-devel] call for testers for tgt
In-Reply-To: <464C6385.5030204@wpkg.org>
References: <464C4DD4.6010106@wpkg.org>
	<20070517223527R.fujita.tomonori@lab.ntt.co.jp>
	<464C6385.5030204@wpkg.org>
Message-ID: <20070518000316G.fujita.tomonori@lab.ntt.co.jp>

From: Tomasz Chmielewski <mangoo at wpkg.org>
Subject: Re: [Stgt-devel] [Iscsitarget-devel] call for testers for tgt
Date: Thu, 17 May 2007 16:15:33 +0200

> FUJITA Tomonori schrieb:
> 
> > Can you try the following patch?
> 
> > -#define NR_WORKER_THREADS	4
> > +#define NR_WORKER_THREADS	8
> 
> In that case, performance dropped by about 2 MB/s.

Are you sure that you use the same iSCSI parameters, TCP parameters,
etc?

On my side:

- IET

| 2007/05/18-08:39:43 | STAT  | 5471 | v1.2.8 | /dev/sdg | Total read
throughput: 88199987.2B/s (84.11MB/s), IOPS 21533.2/s.

- tgt

| 2007/05/18-08:40:40 | STAT  | 5513 | v1.2.8 | /dev/sdg | Total read
throughput: 81151795.2B/s (77.39MB/s), IOPS 19812.5/s.


Needs to improve tgt, but not so bad.


From mangoo at wpkg.org  Thu May 17 17:36:53 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Thu, 17 May 2007 17:36:53 +0200
Subject: [Stgt-devel] [Iscsitarget-devel] Wiki - Data Consistency and
	IOMode=wb
In-Reply-To: <20070518001627R.fujita.tomonori@lab.ntt.co.jp>
References: <d0adb90f0705170708se75ffemc7d0adf7706ce684@mail.gmail.com>	<200705171428.l4HESWiW029875@mbox.iij4u.or.jp>	<464C6C7D.4010700@wpkg.org>
	<20070518001627R.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <464C7695.6090604@wpkg.org>

FUJITA Tomonori schrieb:

> I gave up setting up a wiki site. If someone wants to run IET wiki
> site, it's fine by me.

How about a common wiki for iSCSI - would cover:

Targets:
- IET
- tgtd

Initiators:
- open-iscsi


I think I could make it somewhere on my site; when it works and everyone 
likes it, it could be moved/hosted somewhere else.


-- 
Tomasz Chmielewski
http://wpkg.org


From rcj at linux.vnet.ibm.com  Fri May 18 20:17:45 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Fri, 18 May 2007 13:17:45 -0500
Subject: [Stgt-devel] [patch 1/2] passthrough target notification function
Message-ID: <20070518181745.GA5340@austin.ibm.com>

We spoke about this last week on the mailing list in relation to 
pass-through for kernel lld's.  This would notify scsi_tgt of any
target logical units that should be handled in the kernel.  Here is a
first pass, this is the user-space portion.

Send target state updates to the kernel (in-kernel pass-through enablement)

 When a target is bound to an lld which resides in the kernel all of the 
 devices that will be handled in the kernel (pass-through) will be
 communicated to scsi_tgt.  Whenever a logicalunit is created or destroyed
 which has a target bound to an in-kernel lld, scsi_tgt will be notified.

 -Adding request and response handlers to pass information to the kernel
   -lu_update_notify function pointer to the tgt_driver structure.  
     This allows llds to track updates to logical units when needed.
   -kspace_send_lu_update(...) to be used by lu_update_notify.
     It should send enough info to the kernel to create or destroy a
     logicalunit mapping in the kernel.
   -kspace_recv_lu_update(...) will handle kernel responses to changes.
     The response isn't processed before the request returns back the user
     this is a bit limited, in that it can't warn the user of tgtadm of
     the failure before tgtadm returns.  In the case that the request
     asked for a device to be created or bound and the response from
     the kernel indicates a failure the device is destroyed.

 -The scsi_lu struct has several new fields.
   Adding local_host_no, local_channel, local_scsi_id, and local_lun to 
   store the scsi device data for the SG device associated with the 
   logicalunit.  Also added in_kernel_bypass flag to show that this device
   will use in-kernel processing of requests when an lld is kernel-based.

 -Updated the open function for sgv3/sgv4 to populate new scsi_lu fields.
   SG will get the use SG_GET_SCSI_ID to gather data for the new fields.

 -Modified tgt_device_create, tgt_device_destroy, tgt_bind_host_to_target,
  and tgt_target_destroy to call the lld's lu_update_notify function.

---
 usr/driver.h        |    1 +
 usr/ibmvio/ibmvio.c |    1 +
 usr/spt_sgv3.c      |   13 ++++++++
 usr/spt_sgv4.c      |   13 ++++++++
 usr/target.c        |   87 ++++++++++++++++++++++++++++++++++++++++++++--------
 usr/tgtd.h          |   14 ++++++++
 usr/tgtif.c         |   72 +++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 188 insertions(+), 13 deletions(-)

Index: b/usr/driver.h
===================================================================
--- a/usr/driver.h
+++ b/usr/driver.h
@@ -16,6 +16,7 @@ struct tgt_driver {
 
 	int (*cmd_end_notify)(uint64_t nid, int result, struct scsi_cmd *);
 	int (*mgmt_end_notify)(struct mgmt_req *);
+	int (*lu_update_notify)(struct scsi_lu *, int, int);
 
 	struct backingstore_template *default_bst;
 };
Index: b/usr/ibmvio/ibmvio.c
===================================================================
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -277,5 +277,6 @@ struct tgt_driver ibmvio = {
 	.target_create		= ibmvio_target_create,
 	.cmd_end_notify		= kspace_send_cmd_res,
 	.mgmt_end_notify	= kspace_send_tsk_mgmt_res,
+	.lu_update_notify	= kspace_send_lu_update,
 	.default_bst		= &mmap_bst,
 };
Index: b/usr/spt_sgv3.c
===================================================================
--- a/usr/spt_sgv3.c
+++ b/usr/spt_sgv3.c
@@ -74,6 +74,7 @@ int spt_sg_open(struct scsi_lu *lu, char
 {
 	int err;
 	int nr_queue_cmd;
+	Sg_scsi_id scsi_id;
 
 	*size = 0;
 	*fd = open(path, O_RDWR | O_NONBLOCK);
@@ -88,6 +89,18 @@ int spt_sg_open(struct scsi_lu *lu, char
 		goto close_fd;
 	}
 
+	err = ioctl(*fd, SG_GET_SCSI_ID, &scsi_id);
+	if (err) {
+		eprintf("can't get the scsi id for %s\n", path);
+		goto close_fd;
+	}
+
+	lu->in_kernel_bypass = 1;
+	lu->local_host_no = scsi_id.host_no;
+	lu->local_channel = scsi_id.channel;
+	lu->local_scsi_id = scsi_id.scsi_id;
+	lu->local_lun = scsi_id.lun;
+
 	err = tgt_event_add(*fd, EPOLLIN, sgv3_handler, lu);
 	if (err) {
 		free(lu);
Index: b/usr/spt_sgv4.c
===================================================================
--- a/usr/spt_sgv4.c
+++ b/usr/spt_sgv4.c
@@ -82,6 +82,7 @@ int spt_sg_open(struct scsi_lu *lu, char
 	struct timeval t;
 	struct sg_io_v4 hdr, *h;
 	int nr_queue_cmd;
+	Sg_scsi_id scsi_id;
 
 	/* we assume something like /dev/sda */
 	eprintf("%Zd %Zd %Zd\n", sizeof(hdr), sizeof(*h), sizeof(struct sg_io_v4));
@@ -165,6 +166,18 @@ int spt_sg_open(struct scsi_lu *lu, char
 		goto close_fd;
 	}
 
+	err = ioctl(*fd, SG_GET_SCSI_ID, &scsi_id);
+	if (err) {
+		eprintf("can't get the scsi id for %s\n", path);
+		goto close_fd;
+	}
+
+	lu->in_kernel_bypass = 1;
+	lu->local_host_no = scsi_id.host_no;
+	lu->local_channel = scsi_id.channel;
+	lu->local_scsi_id = scsi_id.scsi_id;
+	lu->local_lun = scsi_id.lun;
+
 	err = tgt_event_add(*fd, EPOLLIN, sgv4_handler, lu);
 	if (err) {
 		free(lu);
Index: b/usr/target.c
===================================================================
--- a/usr/target.c
+++ b/usr/target.c
@@ -42,7 +42,7 @@ extern struct device_type_template sbc_t
 
 static LIST_HEAD(target_list);
 
-static struct target *target_lookup(int tid)
+struct target *target_lookup(int tid)
 {
 	struct target *target;
 	list_for_each_entry(target, &target_list, target_siblings)
@@ -121,7 +121,7 @@ int it_nexus_destroy(int tid, uint64_t i
 	return 0;
 }
 
-static struct scsi_lu *device_lookup(struct target *target, uint64_t lun)
+struct scsi_lu *device_lookup(struct target *target, uint64_t lun)
 {
 	struct scsi_lu *lu;
 
@@ -207,12 +207,37 @@ __device_lookup(int tid, uint64_t lun, s
 	return lu;
 }
 
+/*
+ * if we have lots of host, use something like radix tree for
+ * efficiency.
+ */
+static LIST_HEAD(bound_host_list);
+
+struct bound_host {
+	int host_no;
+	struct target *target;
+	struct list_head bhost_siblings;
+};
+
+int target_host_no(struct *target) {
+	struct bound_host *bhost;
+	int host_no = -1;
+	list_for_each_entry(bhost, &bound_host_list, bhost_siblings) {
+		if (bhost->target == target) {
+			host_no = bhost->host_no;
+			break;
+		}
+	}
+	return host_no;
+}
+
 int tgt_device_create(int tid, uint64_t lun, char *args)
 {
 	char *p;
 	int err;
 	struct target *target;
 	struct scsi_lu *lu, *pos;
+	int host_no;
 
 	dprintf("%d %" PRIu64 "\n", tid, lun);
 
@@ -255,6 +280,17 @@ int tgt_device_create(int tid, uint64_t 
 	if (target->dev_type_template.device_init)
 		target->dev_type_template.device_init(lu);
 
+	if (lu->in_kernel_bypass) {
+		host_no = target_host_no(target);
+
+		if (host_no >= 0 &&
+		    (tgt_drivers[target->lid])->lu_update_notify) {
+			(tgt_drivers[target->lid])->lu_update_notify(lu,
+			                                     host_no,
+			                                     TGT_LU_OP_CREATE);
+		}
+	}
+
 	list_for_each_entry(pos, &target->device_list, device_siblings) {
 		if (lu->lun < pos->lun)
 			break;
@@ -269,6 +305,7 @@ int tgt_device_destroy(int tid, uint64_t
 {
 	struct target *target;
 	struct scsi_lu *lu;
+	int host_no;
 
 	dprintf("%u %" PRIu64 "\n", tid, lun);
 
@@ -284,6 +321,17 @@ int tgt_device_destroy(int tid, uint64_t
 	free(lu->path);
 	list_del(&lu->device_siblings);
 
+	if (lu->in_kernel_bypass) {
+		host_no = target_host_no(target);
+
+		if (host_no >= 0 &&
+		    (tgt_drivers[target->lid])->lu_update_notify) {
+			(tgt_drivers[target->lid])->lu_update_notify(lu,
+			                                     host_no,
+			                                     TGT_LU_OP_DESTROY);
+		}
+	}
+
 	target->bst->bs_close(lu);
 	free(lu);
 	return 0;
@@ -969,17 +1017,20 @@ char *acl_get(int tid, int idx)
 	return NULL;
 }
 
-/*
- * if we have lots of host, use something like radix tree for
- * efficiency.
- */
-static LIST_HEAD(bound_host_list);
+static void tgt_bound_host_update_lu(struct bound_host *bhost, int op)
+{
+	struct tgt_driver *drv;
+	struct scsi_lu *lu;
 
-struct bound_host {
-	int host_no;
-	struct target *target;
-	struct list_head bhost_siblings;
-};
+	drv = tgt_drivers[bhost->target->lid];
+	if(drv->lu_update_notify) {
+		list_for_each_entry(lu, &bhost->target->device_list,
+		                    device_siblings) {
+			if(lu->in_kernel_bypass)
+				drv->lu_update_notify(lu, bhost->host_no, op);
+		}
+	}
+}
 
 int tgt_bind_host_to_target(int tid, int host_no)
 {
@@ -1006,6 +1057,8 @@ int tgt_bind_host_to_target(int tid, int
 	bhost->host_no = host_no;
 	bhost->target = target;
 
+	tgt_bound_host_update_lu(bhost, TGT_LU_OP_CREATE);
+
 	list_add(&bhost->bhost_siblings, &bound_host_list);
 
 	dprintf("bound the scsi host %d to the target %d\n", host_no, host_no);
@@ -1023,6 +1076,9 @@ int tgt_unbind_host_to_target(int tid, i
 				eprintf("the target has IT_nexus\n");
 				return -EBUSY;
 			}
+
+			tgt_bound_host_update_lu(bhost, TGT_LU_OP_DESTROY);
+
 			list_del(&bhost->bhost_siblings);
 			free(bhost);
 			return 0;
@@ -1309,7 +1365,12 @@ int tgt_target_destroy(int lld_no, int t
 	while (!list_empty(&target->device_list)) {
 		lu = list_entry(target->device_list.next, struct scsi_lu,
 				device_siblings);
-		tgt_device_destroy(tid, lu->lun);
+		ret = tgt_device_destroy(tid, lu->lun);
+		if (ret == TGTADM_LUN_ACTIVE) {
+			eprintf("lun %#lld on target %d is still active\n",
+				lu->lun, tid);
+			return ret;
+		}
 	}
 
 	if (tgt_drivers[lld_no]->target_destroy) {
Index: b/usr/tgtd.h
===================================================================
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -38,6 +38,14 @@ struct scsi_lu {
 	char scsi_sn[SCSI_SN_LEN];
 	char *path;
 
+	/* the scsi id of the local device backing this logical unit,
+	 * used for pass-through when notifying kernel llds */
+	char in_kernel_bypass;
+	int local_host_no;
+	int local_channel;
+	int local_scsi_id;
+	int local_lun;
+
 	/* the list of devices belonging to a target */
 	struct list_head device_siblings;
 
@@ -51,6 +59,9 @@ struct scsi_lu {
 	uint8_t d_sense;
 };
 
+#define TGT_LU_OP_DESTROY	0x0000
+#define TGT_LU_OP_CREATE	0x0001
+
 struct scsi_cmd {
 	struct target *c_target;
 	/* linked it_nexus->cmd_hash_list */
@@ -128,6 +139,7 @@ struct device_type_template {
 
 extern int kspace_send_tsk_mgmt_res(struct mgmt_req *mreq);
 extern int kspace_send_cmd_res(uint64_t nid, int result, struct scsi_cmd *);
+extern int kspace_send_lu_update(struct scsi_lu *, int, int);
 
 extern int ipc_init(void);
 extern int tgt_device_create(int tid, uint64_t lun, char *args);
@@ -136,6 +148,7 @@ extern int tgt_device_update(int tid, ui
 extern int device_reserve(struct scsi_cmd *cmd);
 extern int device_release(int tid, uint64_t itn_id, uint64_t lun, int force);
 extern int device_reserved(struct scsi_cmd *cmd);
+extern struct scsi_lu *device_lookup(struct target *target, uint64_t lun);
 
 extern int tgt_target_create(int lld, int tid, char *args, int t_type);
 extern int tgt_target_destroy(int lld, int tid);
@@ -152,6 +165,7 @@ extern void tgt_event_del(int fd);
 extern int tgt_event_modify(int fd, int events);
 extern int target_cmd_queue(int tid, struct scsi_cmd *cmd);
 extern void target_cmd_done(struct scsi_cmd *cmd);
+extern struct target *target_lookup(int tid);
 struct scsi_cmd *target_cmd_lookup(int tid, uint64_t itn_id, uint64_t tag);
 extern void target_mgmt_request(int tid, uint64_t itn_id, uint64_t req_id,
 				int function, uint8_t *lun, uint64_t tag,
Index: b/usr/tgtif.c
===================================================================
--- a/usr/tgtif.c
+++ b/usr/tgtif.c
@@ -33,6 +33,7 @@
 #include <sys/stat.h>
 #include <sys/sysmacros.h>
 #include <linux/types.h>
+#include <linux/errno.h>
 #ifndef aligned_u64
 #define aligned_u64 unsigned long long __attribute__((aligned(8)))
 #endif
@@ -88,6 +89,74 @@ static int kreq_send(struct tgt_event *p
 	return 0;
 }
 
+int kspace_send_lu_update(struct scsi_lu *lu, int host_no, int op) {
+	struct tgt_event ev;
+	int ret;
+
+	memset(&ev, 0, sizeof(ev));
+
+	ev.hdr.type = TGT_UEVENT_LU_UPDT_REQ;
+	ev.p.lu_updt_req.op = op;
+	ev.p.lu_updt_req.local_host_no = lu->local_host_no;
+	ev.p.lu_updt_req.local_channel = lu->local_channel;
+	ev.p.lu_updt_req.local_scsi_id = lu->local_scsi_id;
+	ev.p.lu_updt_req.local_lun = lu->local_lun;
+	ev.p.lu_updt_req.tgt_lun = lu->lun;
+	ev.p.lu_updt_req.tgt_host_no = host_no;
+
+	ret = kreq_send(&ev);
+
+	return ret;
+}
+
+/* Process returning event from the kernel for logicalunit update operations.
+ * Find the original update and mark complete and store the return value
+ * from the kernel.
+ */
+int kspace_recv_lu_update(struct tgt_event *ev)
+{
+	int host_no;
+	uint64_t lun;
+	int tid;
+	void *tgt;
+	struct scsi_lu *lu;
+
+	/*
+	 * Reverse the operation (limited function)
+	 *
+	 * If there was a error binding the logical unit with a physical sg
+	 * device in the kernel, update the device to reflect that.
+	 *
+	 * Can't recreate a deleted device, what if the target has been
+	 * deleted already?  At best this can delete an added device,
+	 * but not add a deleted device.
+	 */
+	if (ev->p.lu_updt_rsp.result &&
+			ev->p.lu_updt_rsp.op == TGT_LU_OP_CREATE) {
+		host_no = ev->p.lu_updt_rsp.tgt_host_no;
+		lun = ev->p.lu_updt_rsp.tgt_lun;
+		tid = tgt_bound_target_lookup(host_no);
+		tgt = target_lookup(tid);
+		if(!tgt) {
+			/* target does not exist */
+			return -ENOENT;
+		}
+
+		lu = device_lookup(tgt, lun);
+		if (lu) {
+			dprintf("Kernel result of create for "
+			        "(%d:%#08llx) was %d, removing device\n.",
+				host_no, lun, ev->p.lu_updt_rsp.result);
+			/* Do not notify kernel */
+			lu->in_kernel_bypass = 0;
+			tgt_device_destroy(tid, lun);
+		}
+	}
+
+	return 0;
+}
+
+
 int kspace_send_tsk_mgmt_res(struct mgmt_req *mreq)
 {
 	struct tgt_event ev;
@@ -281,6 +350,9 @@ retry:
 	case TGT_KEVENT_TSK_MGMT_REQ:
 		kern_mgmt_request(ev);
 		break;
+	case TGT_KEVENT_LU_UPDT_RSP:
+		kspace_recv_lu_update(ev);
+		break;
 	default:
 		eprintf("unknown event %u\n", ev->hdr.type);
 	}


From rcj at linux.vnet.ibm.com  Fri May 18 20:22:50 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Fri, 18 May 2007 13:22:50 -0500
Subject: [Stgt-devel] [patch 2/2] passthrough target notification function
In-Reply-To: <20070518181745.GA5340@austin.ibm.com>
References: <20070518181745.GA5340@austin.ibm.com>
Message-ID: <20070518182250.GB5340@austin.ibm.com>

Add target logicalunit state management to scsi_tgt
 (required for in-kernel pass-through)
 
 Take the data from user space and correlate this with kernel
 structures for scsi devices and then properly managing their use.
 This will keep the kernel drivers from needing to go to userspace for
 pass-through targets.

 -Use scsi_[un]register_interface to get notifications for each scsi
  device added/removed; scsi_tgt will maintain a list of all existing
  scsi devices.
  
 -Update scsi_tgt_if.h for new u->k/k->u messages

 -Create/destroy requests from tgtd will associate scsi devices with
  tgt logicalunits through scsi_tgt_kspace_lu_update().  Results of the
  operation are sent back with scsi_tgt_uspace_send_lu_update_resp().

---
 drivers/scsi/scsi_tgt_if.c   |   28 ++++++
 drivers/scsi/scsi_tgt_lib.c  |  209 +++++++++++++++++++++++++++++++++++++++++++
 drivers/scsi/scsi_tgt_priv.h |    5 +
 include/scsi/scsi_tgt.h      |   12 ++
 include/scsi/scsi_tgt_if.h   |   22 +++++
 5 files changed, 276 insertions(+)

Index: b/drivers/scsi/scsi_tgt_if.c
===================================================================
--- a/drivers/scsi/scsi_tgt_if.c
+++ b/drivers/scsi/scsi_tgt_if.c
@@ -199,6 +199,25 @@ int scsi_tgt_uspace_send_it_nexus_reques
 	return err;
 }
 
+int scsi_tgt_uspace_send_lu_update_resp(int tgt_host_no, u64 tgt_lun,
+                                        int op, int result)
+{
+	struct tgt_event ev;
+	int err;
+
+	memset(&ev, 0, sizeof(ev));
+	ev.p.lu_updt_rsp.op = op;
+	ev.p.lu_updt_rsp.result = result;
+	ev.p.lu_updt_rsp.tgt_host_no = tgt_host_no;
+	ev.p.lu_updt_rsp.tgt_lun = tgt_lun;
+	err = tgt_uspace_send_event(TGT_KEVENT_LU_UPDT_RSP, &ev);
+	if (err)
+		eprintk("tx buf is full, could not send\n");
+
+	return err;
+
+}
+
 static int event_recv_msg(struct tgt_event *ev)
 {
 	int err = 0;
@@ -226,6 +245,15 @@ static int event_recv_msg(struct tgt_eve
 						   ev->p.it_nexus_rsp.itn_id,
 						   ev->p.it_nexus_rsp.result);
 		break;
+	case TGT_UEVENT_LU_UPDT_REQ:
+		err = scsi_tgt_kspace_lu_update(ev->p.lu_updt_req.tgt_host_no,
+				ev->p.lu_updt_req.tgt_lun,
+				ev->p.lu_updt_req.local_host_no,
+				ev->p.lu_updt_req.local_channel,
+				ev->p.lu_updt_req.local_scsi_id,
+				ev->p.lu_updt_req.local_lun,
+				ev->p.lu_updt_req.op);
+		break;
 	default:
 		eprintk("unknown type %d\n", ev->hdr.type);
 		err = -EINVAL;
Index: b/drivers/scsi/scsi_tgt_lib.c
===================================================================
--- a/drivers/scsi/scsi_tgt_lib.c
+++ b/drivers/scsi/scsi_tgt_lib.c
@@ -20,12 +20,14 @@
  * 02110-1301 USA
  */
 #include <linux/blkdev.h>
+#include <linux/delay.h>
 #include <linux/hash.h>
 #include <linux/module.h>
 #include <linux/pagemap.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
+#include <scsi/scsi_driver.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tgt.h>
 
@@ -635,6 +637,205 @@ done:
 	return err;
 }
 
+static LIST_HEAD(scsi_dev_list);
+static spinlock_t sdev_list_lock = SPIN_LOCK_UNLOCKED;
+
+/*
+ * Search the scsi_dev_list for a scsi_dev_node for our target lun.
+ * Need to hold sdev_list_lock prior to entry.
+ */
+struct scsi_dev_node *scsi_tgt_lun_to_dev(int host_no, u64 lun)
+{
+	struct scsi_dev_node *tmp_sdn;
+	lun = (lun) >> 56 & 0x001f; /* The incoming lun needs to be
+				       stripped down to just the part
+				       stored in the scsi_dev_node */
+
+	list_for_each_entry(tmp_sdn, &scsi_dev_list, node)
+	if(tmp_sdn->host_no == host_no) {
+		if(tmp_sdn->tgt_lun == lun) {
+			return tmp_sdn;
+		}
+	}
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(scsi_tgt_lun_to_dev);
+
+/*
+ * Callback when a scsi_device is added to the system
+ */
+static int add_scsi_device(struct class_device *cdev,
+                           struct class_interface *cl_intf)
+{
+	struct scsi_device *sdev = to_scsi_device(cdev->dev);
+	struct scsi_dev_node *sdevnode =
+	        kmalloc(sizeof(struct scsi_dev_node), GFP_ATOMIC);
+	unsigned long flags;
+
+	printk(KERN_DEBUG "add_scsi_device got %p, %d:%d:%d:%d, sdn=%p\n",
+			sdev, sdev->host->host_no, sdev->channel, sdev->id,
+			sdev->lun, sdevnode);
+
+	sdevnode->sdev = sdev;
+	sdevnode->host_no = -1;
+	sdevnode->tgt_lun = 0;
+
+	spin_lock_irqsave(&sdev_list_lock, flags);
+	list_add_tail(&sdevnode->node, &scsi_dev_list);
+	spin_unlock_irqrestore(&sdev_list_lock, flags);
+	return 0;
+}
+
+/*
+ * Callback when a scsi_device is removed from the system
+ */
+static void rem_scsi_device(struct class_device *cdev,
+                            struct class_interface *cl_intf)
+{
+	struct scsi_dev_node *tmp_sdn;
+	struct scsi_device *sdev = to_scsi_device(cdev->dev);
+	unsigned long flags;
+
+	printk(KERN_DEBUG "rem_scsi_device got %p, %d:%d:%d:%d\n",
+			sdev, sdev->host->host_no, sdev->channel, sdev->id,
+			sdev->lun);
+
+	spin_lock_irqsave(&sdev_list_lock, flags);
+	list_for_each_entry(tmp_sdn, &scsi_dev_list, node) {
+		if (sdev == tmp_sdn->sdev) {
+			/* XXX RCJ need to add code to track usage */
+			list_del(&tmp_sdn->node);
+			kfree(tmp_sdn);
+			goto out;
+		}
+	}
+
+	printk(KERN_WARNING "rem_scsi_device: Could not find scsi device "
+	       "%p %d:%d:%d:%d\n", sdev, sdev->host->host_no,
+		   sdev->channel, sdev->id, sdev->lun);
+
+out:
+	spin_unlock_irqrestore(&sdev_list_lock, flags);
+	return;
+}
+
+static struct class_interface tgt_scsi_interface = {
+	.add = add_scsi_device,
+	.remove = rem_scsi_device,
+};
+
+static int scsi_tgt_lu_create(int tgt_host_no, u64 tgt_lun,
+                              int local_host_no, int local_channel,
+                              int local_scsi_id, int local_lun)
+{
+	struct scsi_dev_node *sdnp;
+	int err = 0;
+
+	sdnp = scsi_tgt_lun_to_dev(tgt_host_no, tgt_lun);
+	if (sdnp) {
+		printk(KERN_ERR "Attempt to add logical unit where "
+				"one exists, %d 0x%lx\n",
+				tgt_host_no, (u64)tgt_lun);
+		return -EEXIST;
+	}
+
+	err = -ENOENT;
+
+	list_for_each_entry(sdnp, &scsi_dev_list, node) {
+		if (sdnp->sdev->host->host_no == local_host_no &&
+		    sdnp->sdev->channel == local_channel &&
+		    sdnp->sdev->id == local_scsi_id &&
+		    sdnp->sdev->lun == local_lun) {
+			sdnp->host_no = tgt_host_no;
+			sdnp->tgt_lun = tgt_lun;
+			err = 0;
+			break;
+		}
+	}
+	if (err)
+		printk(KERN_ERR "Unable to find scsi device "
+		                "(%d:%d:%d:%d) to associate with "
+		                "target (%d:0x%lx) from tgt)\n",
+	               local_host_no, local_channel, local_scsi_id,
+		       local_lun, tgt_host_no, (u64)tgt_lun);
+
+	return err;
+}
+
+static int scsi_tgt_lu_destroy(int tgt_host_no, u64 tgt_lun)
+{
+	struct scsi_dev_node *sdnp;
+
+	sdnp = scsi_tgt_lun_to_dev(tgt_host_no, tgt_lun);
+	if (sdnp)
+		sdnp->host_no = -1;
+	else {
+		printk(KERN_ERR "Unable to find target configuration "
+				"to be removed (%d:0%lx)\n",
+				tgt_host_no, (u64)tgt_lun);
+		return -ENOENT;
+	}
+
+	return 0;
+}
+
+int scsi_tgt_kspace_lu_update(int tgt_host_no, u64 tgt_lun,
+                              int local_host_no, int local_channel,
+                              int local_scsi_id, int local_lun,
+                              int op)
+{
+	int flags, updt, send, retry;
+
+
+	if (op == 1) { /* TGT_LU_OP_CREATE */
+		spin_lock_irqsave(&sdev_list_lock, flags);
+		updt = scsi_tgt_lu_create(tgt_host_no, tgt_lun,
+				local_host_no, local_channel,
+				local_scsi_id, local_lun);
+		send = scsi_tgt_uspace_send_lu_update_resp(tgt_host_no,
+				tgt_lun, op, updt);
+		/*
+		 * If the send failed and the lu_update create was sucessful,
+		 * undo the changes.
+		 */
+		if (send && !updt)
+			scsi_tgt_lu_destroy(tgt_host_no, tgt_lun);
+
+		spin_unlock_irqrestore(&sdev_list_lock, flags);
+		return send;
+	} else if (op == 0) { /* TGT_LU_OP_DESTROY */
+		spin_lock_irqsave(&sdev_list_lock, flags);
+		updt = scsi_tgt_lu_destroy(tgt_host_no, tgt_lun);
+
+		/* Try to send the result, retry for 5 seconds if busy */
+		for (retry = 24; retry; retry--) {
+			send = scsi_tgt_uspace_send_lu_update_resp(tgt_host_no,
+					tgt_lun, op, updt);
+			if (send == 0)
+				break;
+
+			msleep(250);
+		}
+
+		/*
+		 * If the send failed and the lu_update destroy was sucessful,
+		 * retry sending the response, else re-add target.
+		 * Since the sdev_list_lock is held through this entire
+		 * operation the device can be re-added safely.
+		 * */
+		if (send && !updt)
+			scsi_tgt_lu_create(tgt_host_no, tgt_lun,
+					local_host_no, local_channel,
+					local_scsi_id, local_lun);
+
+		spin_unlock_irqrestore(&sdev_list_lock, flags);
+		return send;
+	}
+
+	printk(KERN_ERR "Unknown option for lu_update %d\n", op);
+	return -EINVAL;
+}
+
 static int __init scsi_tgt_init(void)
 {
 	int err;
@@ -655,6 +856,13 @@ static int __init scsi_tgt_init(void)
 	if (err)
 		goto destroy_wq;
 
+	err = scsi_register_interface(&tgt_scsi_interface);
+	if (err)
+		printk(KERN_WARNING "Could not register for scsi device "
+		       "notification (%d)\n", err);
+	else
+		printk(KERN_WARNING "registered scsi for scsi device notification");
+
 	return 0;
 
 destroy_wq:
@@ -667,6 +875,7 @@ free_kmemcache:
 static void __exit scsi_tgt_exit(void)
 {
 	destroy_workqueue(scsi_tgtd);
+	scsi_unregister_interface(&tgt_scsi_interface);
 	scsi_tgt_if_exit();
 	kmem_cache_destroy(scsi_tgt_cmd_cache);
 }
Index: b/drivers/scsi/scsi_tgt_priv.h
===================================================================
--- a/drivers/scsi/scsi_tgt_priv.h
+++ b/drivers/scsi/scsi_tgt_priv.h
@@ -30,3 +30,8 @@ extern int scsi_tgt_kspace_tsk_mgmt(int 
 extern int scsi_tgt_uspace_send_it_nexus_request(int host_no, u64 it_nexus_id,
 						 int function, char *initiator);
 extern int scsi_tgt_kspace_it_nexus_rsp(int host_no, u64 it_nexus_id, int result);
+extern int scsi_tgt_kspace_lu_update(int tgt_host_no, u64 tgt_lun,
+				     int local_host_no, int local_channel,
+				     int local_scsi_id, int local_lun, int op);
+extern int scsi_tgt_uspace_send_lu_update_resp(int tgt_host_no, u64 tgt_lun,
+					       int op, int result);
Index: b/include/scsi/scsi_tgt.h
===================================================================
--- a/include/scsi/scsi_tgt.h
+++ b/include/scsi/scsi_tgt.h
@@ -4,6 +4,17 @@
 
 #include <linux/dma-mapping.h>
 
+/*
+ * scsi_dev_node maps scsi_device structures to their represenation from
+ * the tgt framework
+ */
+struct scsi_dev_node {
+	struct list_head node;
+	struct scsi_device *sdev;
+	u64 tgt_lun;
+	int host_no;
+};
+
 struct Scsi_Host;
 struct scsi_cmnd;
 struct scsi_lun;
@@ -19,3 +30,4 @@ extern struct scsi_cmnd *scsi_host_get_c
 extern void scsi_host_put_command(struct Scsi_Host *, struct scsi_cmnd *);
 extern int scsi_tgt_it_nexus_create(struct Scsi_Host *, u64, char *);
 extern int scsi_tgt_it_nexus_destroy(struct Scsi_Host *, u64);
+extern struct scsi_dev_node * scsi_tgt_lun_to_dev(int, u64);
Index: b/include/scsi/scsi_tgt_if.h
===================================================================
--- a/include/scsi/scsi_tgt_if.h
+++ b/include/scsi/scsi_tgt_if.h
@@ -26,12 +26,14 @@
 #define	TGT_UEVENT_CMD_RSP		0x0001
 #define	TGT_UEVENT_IT_NEXUS_RSP		0x0002
 #define	TGT_UEVENT_TSK_MGMT_RSP		0x0003
+#define	TGT_UEVENT_LU_UPDT_REQ		0x0004
 
 /* kernel -> user */
 #define	TGT_KEVENT_CMD_REQ		0x1001
 #define	TGT_KEVENT_CMD_DONE		0x1002
 #define	TGT_KEVENT_IT_NEXUS_REQ		0x1003
 #define	TGT_KEVENT_TSK_MGMT_REQ		0x1004
+#define	TGT_KEVENT_LU_UPDT_RSP		0x1005
 
 struct tgt_event_hdr {
 	uint16_t version;
@@ -40,6 +42,11 @@ struct tgt_event_hdr {
 	uint16_t len;
 } __attribute__ ((aligned (sizeof(uint64_t))));
 
+enum {
+	TGT_LU_OP_DESTROY,
+	TGT_LU_OP_CREATE
+};
+
 struct tgt_event {
 	struct tgt_event_hdr hdr;
 
@@ -68,6 +75,15 @@ struct tgt_event {
 			aligned_u64 itn_id;
 			__u32 function;
 		} it_nexus_rsp;
+		struct {
+			int op;
+			int local_host_no;
+			int local_channel;
+			int local_scsi_id;
+			int local_lun;
+			int tgt_host_no;
+			aligned_u64 tgt_lun;
+		} lu_updt_req;
 
 		/* kernel -> user */
 		struct {
@@ -100,6 +116,12 @@ struct tgt_event {
 			__u32 max_cmds;
 			__u8 initiator_id[16];
 		} it_nexus_req;
+		struct {
+			int op;
+			int result;
+			int tgt_host_no;
+			aligned_u64 tgt_lun;
+		} lu_updt_rsp;
 	} p;
 } __attribute__ ((aligned (sizeof(uint64_t))));
 


From mangoo at wpkg.org  Mon May 21 11:24:35 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Mon, 21 May 2007 11:24:35 +0200
Subject: [Stgt-devel] subtle differences between IET and tgtd behaviour
 (from initiator's perspective)
Message-ID: <46516553.7070002@wpkg.org>

I noticed there are some subtle differences between IET and tgtd - from 
the initiator's perspective.

I tried using both targets - IET and tgtd - everything works fine, 
stable etc.


I have a diskless workstation started entirely via iSCSI. It starts and 
works fine both with IET and tgtd.
The problem is when I want to shut down the machine.


When the initiator uses IET, it shut downs properly.

With the initiator uses tgtd, it stalls somewhere at:

Umounting proc filesystem                 [ OK ]
Halting system...
md: stopping all md devices.
Synchronizing SCSI cache for disk sda:


And it just waits there forever (that's with no changes on the 
initiator; only the target program was changed).


Ideas?


-- 
Tomasz Chmielewski
htp://wpkg.org


From fujita.tomonori at lab.ntt.co.jp  Mon May 21 11:37:27 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 21 May 2007 18:37:27 +0900
Subject: [Stgt-devel] [Iscsitarget-devel] subtle differences between IET
 and tgtd behaviour (from initiator's perspective)
In-Reply-To: <46516553.7070002@wpkg.org>
References: <46516553.7070002@wpkg.org>
Message-ID: <20070521183727J.fujita.tomonori@lab.ntt.co.jp>

From: Tomasz Chmielewski <mangoo at wpkg.org>
Subject: [Iscsitarget-devel] subtle differences between IET and tgtd behaviour (from initiator's perspective)
Date: Mon, 21 May 2007 11:24:35 +0200

> I noticed there are some subtle differences between IET and tgtd - from 
> the initiator's perspective.
> 
> I tried using both targets - IET and tgtd - everything works fine, 
> stable etc.
> 
> 
> I have a diskless workstation started entirely via iSCSI. It starts and 
> works fine both with IET and tgtd.
> The problem is when I want to shut down the machine.
> 
> 
> When the initiator uses IET, it shut downs properly.
> 
> With the initiator uses tgtd, it stalls somewhere at:
> 
> Umounting proc filesystem                 [ OK ]
> Halting system...
> md: stopping all md devices.
> Synchronizing SCSI cache for disk sda:
> 
> 
> And it just waits there forever (that's with no changes on the 
> initiator; only the target program was changed).

Can you send IET and tgt tcpdump logs (tcpdump -s 1600 -w hoge.log)
when you shut down the initiator box?


From mangoo at wpkg.org  Mon May 21 11:59:44 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Mon, 21 May 2007 11:59:44 +0200
Subject: [Stgt-devel] [Iscsitarget-devel] subtle differences between IET
 and tgtd behaviour (from initiator's perspective)
In-Reply-To: <20070521183727J.fujita.tomonori@lab.ntt.co.jp>
References: <46516553.7070002@wpkg.org>
	<20070521183727J.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <46516D90.4050702@wpkg.org>

FUJITA Tomonori schrieb:

(...)

>> When the initiator uses IET, it shut downs properly.
>>
>> With the initiator uses tgtd, it stalls somewhere at:
>>
>> Umounting proc filesystem                 [ OK ]
>> Halting system...
>> md: stopping all md devices.
>> Synchronizing SCSI cache for disk sda:
>>
>>
>> And it just waits there forever (that's with no changes on the 
>> initiator; only the target program was changed).
> 
> Can you send IET and tgt tcpdump logs (tcpdump -s 1600 -w hoge.log)
> when you shut down the initiator box?

I guess the output will be similar, but in case of tgtd, a bit shorter. 
Below a try to  explain why.

When the machine stalls at "Synchronizing SCSI cache...", it is possible 
to press ctrl + SysRq + s - kernel will report:

SysRq : Emergency Sync
Emergency Sync Complete

Which is not really true, as the machine doesn't have a network 
connection anymore (can't ping it; confirmed by pulling out the network 
cable, and pressing ctrl + SysRq + s - kernel claims that Emergency Sync 
was complete).


So I guess the real reason lies somewhere in my shutdown scripts: with 
IET, it manages to sync the iSCSI drive before the network link 
disappears, and with tgtd, it can't make it.

Hmm. My shutdown scripts are broken, and with tgtd it's just easier to 
prove it.


-- 
Tomasz Chmielewski
http://wpkg.org


From fujita.tomonori at lab.ntt.co.jp  Mon May 21 14:21:24 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 21 May 2007 21:21:24 +0900 (JST)
Subject: [Stgt-devel] [patch 1/2] passthrough target notification
 function
In-Reply-To: <20070518181745.GA5340@austin.ibm.com>
References: <20070518181745.GA5340@austin.ibm.com>
Message-ID: <20070521074623S.fujita.tomonori@lab.ntt.co.jp>

From: Robert Jennings <rcj at linux.vnet.ibm.com>
Subject: [Stgt-devel] [patch 1/2] passthrough target notification function
Date: Fri, 18 May 2007 13:17:45 -0500

> We spoke about this last week on the mailing list in relation to 
> pass-through for kernel lld's.  This would notify scsi_tgt of any
> target logical units that should be handled in the kernel.  Here is a
> first pass, this is the user-space portion.
> 
> Send target state updates to the kernel (in-kernel pass-through enablement)

Thanks a lot.


From rcj at linux.vnet.ibm.com  Tue May 22 21:56:56 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Tue, 22 May 2007 14:56:56 -0500
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <20070507182837E.fujita.tomonori@lab.ntt.co.jp>
References: <463B72F6.3000207@torque.net>
	<20070506053629P.fujita.tomonori@lab.ntt.co.jp>
	<463F36AC.3010207@vlnb.net>
	<20070507182837E.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070522195656.GD5758@austin.ibm.com>

Missed a fair bit of this thread when it was first sent, bad mail
filter I think (or pebkac).

* FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> From: Vladislav Bolkhovitin <vst at vlnb.net>
> Subject: Re: [Stgt-devel] Question for pass-through target design
> Date: Mon, 07 May 2007 18:24:44 +0400
> 
> > FUJITA Tomonori wrote:
> > >>>>It looks like the pass-through target support is currently broken, at
> > >>>>least as I've checked for ibmvstgt, but I think it's a general problem.
> > >>>>I wanted to check my assumptions and get ideas.
> > >>>
> > >>>Yeah, unfortunately, it works only with the iSCSI target driver (which
> > >>>runs in user space).
> > >>>
> > >>>
> > >>>
> > >>>>The code isn't allocating any memory to pass along to the sg code to store
> > >>>>the result of a read or data for a write.  Currently, dxferp for sg_io_hdr
> > >>>>or dout_xferp/din_xferp for sg_io_v4 are assigned to the value of uaddr,
> > >>>>which is set to 0 in kern_queue_cmd.  With the pointer set to NULL,
> > >>>>the pass-through target isn't going to function.  Even if we had memory
> > >>>>allocated, there isn't a means of getting data to be written via sg down
> > >>>>this code path.
> > >>>>
> > >>>>What ideas are there as to how the data will get to user-space so that
> > >>>>we can use sg?
> > >>>
> > >>>For kernel-space drivers, we don't need to go to user-space. We can do
> > >>>the pass-through in kernel space. I talked with James about this last
> > >>>year and he said that if the code is implemented cleanly, he would
> > >>>merges it into mainline.
> > >>
> > >>We already have a pass-through in the kernel space for
> > >>kernel space drivers. It is the scsi_tgt* code.
> > > 
> > > 
> > > Could you elaborate more?
> > > 
> > > What I meant that is that the kernel tgt code (scsi_tgt*) receives
> > > SCSI commands from one lld and send them to another lld instead of
> > > sending them to user space.
> > 
> > Although the approach of passing SCSI commands from a target LLD to an
> > initiator one without any significant interventions from the target
> > software looks to be nice and simple, you should realize how limited,
> > unsafe and illegal it is, since it badly violates SCSI specs.
> 
> I think that 'implemented cleanly' means that one scsi_host is assigned
> to only one initiator.

Vladislav listed a number of issues that are inherent in an implementation
that does not have a 1:1 relationship of initiators to targets.  The vscsi
architecture defines the 1:1 relationship; it's imposible to have more
than one initiator per target.  Are there any barriers that we will need
to address if this were the case?

Regards,
Rob Jennings


From waldi at berlios.de  Tue May 22 22:21:48 2007
From: waldi at berlios.de (Bastian Blank)
Date: Tue, 22 May 2007 22:21:48 +0200
Subject: [Stgt-devel] 2.6.22-rc2 + it_nexus patch broken
Message-ID: <20070522202148.GA8694@wavehammer.waldi.eu.org>

Hi folks

If I understand git correctly, there are one three commits missing in
mainline, two it_nexus support and the rdma fix. I applied them on my
2.6.22-rc2 and the only result with ibmvio and new utils is:

| scsi_tgt_uspace_send_cmd(127) tx buf is full, could not send
| handle_cmd_queue(208) cannot queue cmd c0000000026c7000 -4

Bastian

-- 
Another Armenia, Belgium ... the weak innocents who always seem to be
located on a natural invasion route.
		-- Kirk, "Errand of Mercy", stardate 3198.4


From michaelc at cs.wisc.edu  Tue May 22 22:49:24 2007
From: michaelc at cs.wisc.edu (Mike Christie)
Date: Tue, 22 May 2007 15:49:24 -0500
Subject: [Stgt-devel] [Iscsitarget-devel] Wiki - Data Consistency and
	IOMode=wb
In-Reply-To: <464C7695.6090604@wpkg.org>
References: <d0adb90f0705170708se75ffemc7d0adf7706ce684@mail.gmail.com>	<200705171428.l4HESWiW029875@mbox.iij4u.or.jp>	<464C6C7D.4010700@wpkg.org>
	<20070518001627R.fujita.tomonori@lab.ntt.co.jp>
	<464C7695.6090604@wpkg.org>
Message-ID: <46535754.7050204@cs.wisc.edu>

Tomasz Chmielewski wrote:
> FUJITA Tomonori schrieb:
> 
>> I gave up setting up a wiki site. If someone wants to run IET wiki
>> site, it's fine by me.
> 
> How about a common wiki for iSCSI - would cover:
> 
> Targets:
> - IET
> - tgtd
> 
> Initiators:
> - open-iscsi
> 
> 
> I think I could make it somewhere on my site; when it works and everyone 
> likes it, it could be moved/hosted somewhere else.
> 
> 

Sorry about the late post. I have been missing mails I guess. I think a
common wiki would be nice.


From blackmagic02881 at gmail.com  Tue May 22 23:12:23 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Tue, 22 May 2007 17:12:23 -0400
Subject: [Stgt-devel] [Iscsitarget-devel] Wiki - Data Consistency
	and	IOMode=wb
In-Reply-To: <46535754.7050204@cs.wisc.edu>
References: <d0adb90f0705170708se75ffemc7d0adf7706ce684@mail.gmail.com>
	<200705171428.l4HESWiW029875@mbox.iij4u.or.jp>	<464C6C7D.4010700@wpkg.org>
	<20070518001627R.fujita.tomonori@lab.ntt.co.jp>
	<464C7695.6090604@wpkg.org> <46535754.7050204@cs.wisc.edu>
Message-ID: <1179868343.3846.45.camel@dhcp-136.ibrix.com>

On Tue, 2007-05-22 at 15:49 -0500, Mike Christie wrote:
> Tomasz Chmielewski wrote:
> > FUJITA Tomonori schrieb:
> > 
> >> I gave up setting up a wiki site. If someone wants to run IET wiki
> >> site, it's fine by me.
> > 
> > How about a common wiki for iSCSI - would cover:
> > 
> > Targets:
> > - IET
> > - tgtd
> > 
> > Initiators:
> > - open-iscsi
> > 
> > 
> > I think I could make it somewhere on my site; when it works and everyone 
> > likes it, it could be moved/hosted somewhere else.
> > 
> > 
> 
> Sorry about the late post. I have been missing mails I guess. I think a
> common wiki would be nice.

@all, we have a project which is available at http://storageos.com/, we
thought to add more stuff into it before making it public. but now seems
to be a good time to do it.

any suggestion and comment is welcomed.


Ming



> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From fujita.tomonori at lab.ntt.co.jp  Wed May 23 01:05:19 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 23 May 2007 08:05:19 +0900
Subject: [Stgt-devel] 2.6.22-rc2 + it_nexus patch broken
In-Reply-To: <20070522202148.GA8694@wavehammer.waldi.eu.org>
References: <20070522202148.GA8694@wavehammer.waldi.eu.org>
Message-ID: <20070523080519W.fujita.tomonori@lab.ntt.co.jp>

From: Bastian Blank <waldi at berlios.de>
Subject: [Stgt-devel] 2.6.22-rc2 + it_nexus patch broken
Date: Tue, 22 May 2007 22:21:48 +0200

> Hi folks
> 
> If I understand git correctly, there are one three commits missing in
> mainline, two it_nexus supportn and the rdma fix.

The rdma fix is in James' fixes tree. So we have it in mainline
shortly.

The two it_nexus support patches are too hacky for mainline. I'll do
in a different way.


> I applied them on my 2.6.22-rc2 and the only result with ibmvio and
> new utils is:

I'll rebase my target tree soon.


From fujita.tomonori at lab.ntt.co.jp  Wed May 23 01:08:25 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 23 May 2007 08:08:25 +0900
Subject: [Stgt-devel] [Iscsitarget-devel] Wiki - Data
	Consistency	and	IOMode=wb
In-Reply-To: <1179868343.3846.45.camel@dhcp-136.ibrix.com>
References: <464C7695.6090604@wpkg.org> <46535754.7050204@cs.wisc.edu>
	<1179868343.3846.45.camel@dhcp-136.ibrix.com>
Message-ID: <20070523080825G.fujita.tomonori@lab.ntt.co.jp>

From: Ming Zhang <blackmagic02881 at gmail.com>
Subject: Re: [Iscsitarget-devel] [Stgt-devel] Wiki - Data Consistency	and	IOMode=wb
Date: Tue, 22 May 2007 17:12:23 -0400

> On Tue, 2007-05-22 at 15:49 -0500, Mike Christie wrote:
> > Tomasz Chmielewski wrote:
> > > FUJITA Tomonori schrieb:
> > > 
> > >> I gave up setting up a wiki site. If someone wants to run IET wiki
> > >> site, it's fine by me.
> > > 
> > > How about a common wiki for iSCSI - would cover:
> > > 
> > > Targets:
> > > - IET
> > > - tgtd
> > > 
> > > Initiators:
> > > - open-iscsi
> > > 
> > > 
> > > I think I could make it somewhere on my site; when it works and everyone 
> > > likes it, it could be moved/hosted somewhere else.
> > > 
> > > 
> > 
> > Sorry about the late post. I have been missing mails I guess. I think a
> > common wiki would be nice.
> 
> @all, we have a project which is available at http://storageos.com/, we
> thought to add more stuff into it before making it public. but now seems
> to be a good time to do it.
> 
> any suggestion and comment is welcomed.

Not Wiki?


From blackmagic02881 at gmail.com  Wed May 23 02:51:35 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Tue, 22 May 2007 20:51:35 -0400
Subject: [Stgt-devel] [Iscsitarget-devel] Wiki - Data
	Consistency	and	IOMode=wb
In-Reply-To: <20070523080825G.fujita.tomonori@lab.ntt.co.jp>
References: <464C7695.6090604@wpkg.org> <46535754.7050204@cs.wisc.edu>
	<1179868343.3846.45.camel@dhcp-136.ibrix.com>
	<20070523080825G.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <1179881495.3804.10.camel@localhost.localdomain>

On Wed, 2007-05-23 at 08:08 +0900, FUJITA Tomonori wrote:
> From: Ming Zhang <blackmagic02881 at gmail.com>
> Subject: Re: [Iscsitarget-devel] [Stgt-devel] Wiki - Data Consistency	and	IOMode=wb
> Date: Tue, 22 May 2007 17:12:23 -0400
> 
> > On Tue, 2007-05-22 at 15:49 -0500, Mike Christie wrote:
> > > Tomasz Chmielewski wrote:
> > > > FUJITA Tomonori schrieb:
> > > > 
> > > >> I gave up setting up a wiki site. If someone wants to run IET wiki
> > > >> site, it's fine by me.
> > > > 
> > > > How about a common wiki for iSCSI - would cover:
> > > > 
> > > > Targets:
> > > > - IET
> > > > - tgtd
> > > > 
> > > > Initiators:
> > > > - open-iscsi
> > > > 
> > > > 
> > > > I think I could make it somewhere on my site; when it works and everyone 
> > > > likes it, it could be moved/hosted somewhere else.
> > > > 
> > > > 
> > > 
> > > Sorry about the late post. I have been missing mails I guess. I think a
> > > common wiki would be nice.
> > 
> > @all, we have a project which is available at http://storageos.com/, we
> > thought to add more stuff into it before making it public. but now seems
> > to be a good time to do it.
> > 
> > any suggestion and comment is welcomed.
> 
> Not Wiki?

we did not decide which way is better yet. sure we can switch to a wiki
or a more fledged CMS if desired.

the whole point is to make linux a better OS for storage appliance. now
several individual projects already did a lot in its own field while a
one-stop place to gather/communicate all necessary information will be
nice.


Ming





From markh794 at gmail.com  Wed May 23 04:56:32 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 23 May 2007 12:56:32 +1000
Subject: [Stgt-devel] [Patch 0/8 ] Core stgt update
Message-ID: <f29db9a80705221956u166a22dbs3c75c53398170d8e@mail.gmail.com>

Again - Sorry for the inclusion of attachments. gmail corrupts tab chars...

This patch has grown way beyond what I was initially planning on submitting.
The attachment included with this is a single patch with all the below.

Note: Patchs against:

  =========================
commit 2ff8cb4bf6682469e2f75c47a7f155b9690cf9a1
Author: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
Date:   Wed May 2 18:41:55 2007 +0900

    update the iSCSI descriptions

    Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
  ========================

Patch 1 : Setup .device_init, device_shutdown & device_config to the
device template.
             Move target setup to each 'module' although they all
currently call a common routine in spc.c. The smc module will add to
this when submitted in later patches.
             Also some 'cruft' in spc_illegal_op to log the SCSI
command being rejected. (I can't figure out an easy way of removing
this section of the patch without a lot of fiddling. This will be
cleaned up with one of the following patch (2 x 8) in this patch set.

Patch 2 : Combine INQUIRY into a common spc_inquiry routine.
              Ability to define if a device can handle removable media
              Moved scsi_sn, scsi_id and d_sense (now sense_format)
into a common struct with other INQUIRY related data.
              Moved / split up tgtadm.h into two sections. As the
tgtadm error codes are required by other modules, I've moved the error
code into tgtadm_error.h so I don't have to include the whold tgtadm.h
in with the SCSI target.

Patch 3 : Added the ability to change/tune SCSI Inquiry params:
            Vendor Identification
            Product Identification
            Product Revision
            Sense format
            If media is 'removable'

Patch 4 : Add support for MODE SENSE(6) and MODE SENSE(10) commands.
            This is a major change in that the mode pages are
configured/defined at setup time using the following example for MODE
PAGE 3.

# Format mode page
tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
       --params ModePage=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0


Patch 5 : Clean up scripts/tgt-core-test script to remove any
un-implemented options.
              Clean up MODE SENSE params to sane values.
              TUR now checks for Power-on/Reset flag.

Patch 6 : Update sense_data_build to use #defined ASC/ASCQ and
standardise on one
common error if data = valloc() fails to 'HARDWARE / INTERNAL_TARGET_FAILURE'

Patch 7 : Force Disable Block Descriptor to be set for MMC mode sense
as per t10 doco.

Patch 8 : Attempt to document the 'configuration' options for each
target. - Work in progress..
-------------- next part --------------
A non-text attachment was scrubbed...
Name: big.diff
Type: text/x-patch
Size: 67832 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070523/842888c6/attachment.bin>

From markh794 at gmail.com  Wed May 23 04:58:18 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 23 May 2007 12:58:18 +1000
Subject: [Stgt-devel] [Patch 1/8 ] Setup .device_init,
	device_shutdown & device_config to the device template.
Message-ID: <f29db9a80705221958h5f5b808cwf8a448d0c2f0ab@mail.gmail.com>

Move target setup to each 'module' although they all currently call a
common routine in spc.c. The smc module will add to this when
submitted in later patches.

Also some 'cruft' in spc_illegal_op to log the SCSI command being
rejected. (I can't figure out an easy way of removing this section of
the patch without a lot of fiddling. This will be cleaned up with one
of the following patch (2 x 8) in this patch set.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 1x8.diff
Type: text/x-patch
Size: 12364 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070523/a0e302a4/attachment.bin>

From markh794 at gmail.com  Wed May 23 05:01:35 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 23 May 2007 13:01:35 +1000
Subject: [Stgt-devel] [Patch 2/8 ] Combine INQUIRY into a common spc_inquiry
	routine.
Message-ID: <f29db9a80705222001g1e17804fma320dfa62a0538a3@mail.gmail.com>

Ability to define if a device can handle removable media

Moved scsi_sn, scsi_id and d_sense (now sense_format) into a common
struct with other INQUIRY related data.

Moved / split up tgtadm.h into two sections. As the tgtadm error codes
are required by other modules, I've moved the error code into
tgtadm_error.h so I don't have to include the whole tgtadm.h in with
each SCSI target module.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 2x8.diff
Type: text/x-patch
Size: 19227 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070523/1f536370/attachment.bin>

From markh794 at gmail.com  Wed May 23 05:04:10 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 23 May 2007 13:04:10 +1000
Subject: [Stgt-devel] [Patch 2/8 ] Combine INQUIRY into a common spc_inquiry
	routine.
Message-ID: <f29db9a80705222004p31d9a314k46c480ddfd4ace41@mail.gmail.com>

Ability to define if a device can handle removable media

Moved scsi_sn, scsi_id and d_sense (now sense_format) into a common
struct with other INQUIRY related data.

Moved / split up tgtadm.h into two sections. As the tgtadm error codes
are required by other modules, I've moved the error code into
tgtadm_error.h so I don't have to include the whole tgtadm.h in with
the SCSI target
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 2x8.diff
Type: text/x-patch
Size: 19227 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070523/902c0197/attachment.bin>

From markh794 at gmail.com  Wed May 23 05:06:06 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 23 May 2007 13:06:06 +1000
Subject: [Stgt-devel] [Patch 3/8 ] Added the ability to change/tune SCSI
	Inquiry params:
Message-ID: <f29db9a80705222006h179fc6d0i7e726279524982d5@mail.gmail.com>

Ability to dynamically define following attributes.

            Vendor Identification
            Product Identification
            Product Revision
            Sense format
            If media is 'removable'
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 3x8.diff
Type: text/x-patch
Size: 1761 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070523/509e08d1/attachment.bin>

From markh794 at gmail.com  Wed May 23 05:08:19 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 23 May 2007 13:08:19 +1000
Subject: [Stgt-devel] [Patch 4/8 ] Add support for MODE SENSE(6) and MODE
	SENSE(10) commands.
Message-ID: <f29db9a80705222008v91ee5d4ra2e2894fb16e668f@mail.gmail.com>

This is a major change.

The mode pages are configured/defined at setup time using tgtadm.

The following example sets up MODE PAGE 3.

# Format mode page
tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
       --params ModePage=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 4x8.diff
Type: text/x-patch
Size: 31756 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070523/acf7d840/attachment.bin>

From markh794 at gmail.com  Wed May 23 05:09:36 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 23 May 2007 13:09:36 +1000
Subject: [Stgt-devel] [Patch 5/8 ] Clean up scripts/tgt-core-test script to
	remove any un-implemented options.
Message-ID: <f29db9a80705222009m6f91d6fdi5258786ac674b5c8@mail.gmail.com>

Clean up MODE SENSE params to sane values.

TUR now checks for Power-on/Reset flag.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 5x8.diff
Type: text/x-patch
Size: 9505 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070523/c02216f0/attachment.bin>

From markh794 at gmail.com  Wed May 23 05:12:55 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 23 May 2007 13:12:55 +1000
Subject: [Stgt-devel] [Patch 6/8 ] Update sense_data_build to use #defined
	ASC/ASCQ
Message-ID: <f29db9a80705222012x745aa013h2289ca9ee755e770@mail.gmail.com>

sense_data_build now accepts the ASC/ASCQ in a single uint16_t as a
single value.
Values are defined in sense_codes.h

standardise on one common error if data = valloc() fails to

 'HARDWARE / INTERNAL_TARGET_FAILURE'
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 6x8.diff
Type: text/x-patch
Size: 11965 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070523/3ad9c236/attachment.bin>

From markh794 at gmail.com  Wed May 23 05:15:31 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 23 May 2007 13:15:31 +1000
Subject: [Stgt-devel] [Patch 7/8 ] Force Disable Block Descriptor to be set
	for MMC mode sense as per t10 doco.
Message-ID: <f29db9a80705222015w3faa1b92q9eb594b8325fe161@mail.gmail.com>

Make sure the 'DBD' bit is set before passing cmd to spc_mode_sense()
as MMC devices
do not support this bit being cleared. - Just in case a mode sense
command is received with this bit cleared.

I use to return an error - INVALID FIELD IN CDB
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 7x8.diff
Type: text/x-patch
Size: 687 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070523/83f431e3/attachment.bin>

From markh794 at gmail.com  Wed May 23 05:16:51 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 23 May 2007 13:16:51 +1000
Subject: [Stgt-devel] [Patch 8/8 ] Attempt to document target configuration.
Message-ID: <f29db9a80705222016s449e1410ne515c18b9694cfae@mail.gmail.com>

Very much a 'work in progress'..

Thanks
Mark Harvey
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 8x8.diff
Type: text/x-patch
Size: 2410 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070523/5f91b340/attachment.bin>

From myoung at wildernessvoice.com  Wed May 23 05:17:05 2007
From: myoung at wildernessvoice.com (Mike Young)
Date: Tue, 22 May 2007 21:17:05 -0600
Subject: [Stgt-devel] [Iscsitarget-devel] Wiki - Data Consistency	and
 IOMode=wb
In-Reply-To: <1179881495.3804.10.camel@localhost.localdomain>
References: <464C7695.6090604@wpkg.org> <46535754.7050204@cs.wisc.edu>	
	<1179868343.3846.45.camel@dhcp-136.ibrix.com>	
	<20070523080825G.fujita.tomonori@lab.ntt.co.jp>
	<1179881495.3804.10.camel@localhost.localdomain>
Message-ID: <4653B231.6080203@wildernessvoice.com>

As Ming mentioned, we hadn't set anything in concrete. Ming originally 
asked me to setup a wiki for organizing information. In fact, he asked 
me to do this a while back.

I went a slightly different route to allow for a more collaborative and 
organized site, but the software had limitations.

I've just replaced the site's software with Drupal-based CMS engine. 
There's a collaborative Book function much like wiki. But then there's 
more. There's a forum module I've turned on as well syndication, blog, etc.

Frankly, there's far too many features to make use of up front. But I 
like the fact that as needs grow, the site can grow to support us all. 
I've also locked down project space at Google and have signed this site 
up for Amazon's S3 and EC2 services. So, as things move forward, we 
should have plenty of bandwidth and storage space.

We also have QA resources in Hyderabad that we can spin up as necessary. 
And to a certain extent I can provide hardware to enable some of the 
efforts. This includes access to dedicated hardware and access to VM 
instances for development.

Did I mention we've got some cool GUI stuff in process?

Anyway, there is so much that can be leveraged, and that already is 
being leveraged. If there are more needs, please let me know and I'll be 
happy to look into getting them resolved.

I believe this site will be flexible enough to allow each of the project 
owners to continue to be visionaries in their respective areas, but will 
allow us to have a centrally organized portal. Should be easier than 
googling. Should be ;)

-Mike

Ming Zhang wrote:
> On Wed, 2007-05-23 at 08:08 +0900, FUJITA Tomonori wrote:
>> From: Ming Zhang <blackmagic02881 at gmail.com>
>> Subject: Re: [Iscsitarget-devel] [Stgt-devel] Wiki - Data Consistency	and	IOMode=wb
>> Date: Tue, 22 May 2007 17:12:23 -0400
>>
>>> On Tue, 2007-05-22 at 15:49 -0500, Mike Christie wrote:
>>>> Tomasz Chmielewski wrote:
>>>>> FUJITA Tomonori schrieb:
>>>>>
>>>>>> I gave up setting up a wiki site. If someone wants to run IET wiki
>>>>>> site, it's fine by me.
>>>>> How about a common wiki for iSCSI - would cover:
>>>>>
>>>>> Targets:
>>>>> - IET
>>>>> - tgtd
>>>>>
>>>>> Initiators:
>>>>> - open-iscsi
>>>>>
>>>>>
>>>>> I think I could make it somewhere on my site; when it works and everyone 
>>>>> likes it, it could be moved/hosted somewhere else.
>>>>>
>>>>>
>>>> Sorry about the late post. I have been missing mails I guess. I think a
>>>> common wiki would be nice.
>>> @all, we have a project which is available at http://storageos.com/, we
>>> thought to add more stuff into it before making it public. but now seems
>>> to be a good time to do it.
>>>
>>> any suggestion and comment is welcomed.
>> Not Wiki?
> 
> we did not decide which way is better yet. sure we can switch to a wiki
> or a more fledged CMS if desired.
> 
> the whole point is to make linux a better OS for storage appliance. now
> several individual projects already did a lot in its own field while a
> one-stop place to gather/communicate all necessary information will be
> nice.
> 
> 
> Ming
> 
> 
> 
> 


From vst at vlnb.net  Wed May 23 12:45:42 2007
From: vst at vlnb.net (Vladislav Bolkhovitin)
Date: Wed, 23 May 2007 14:45:42 +0400
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <20070522195656.GD5758@austin.ibm.com>
References: <463B72F6.3000207@torque.net>
	<20070506053629P.fujita.tomonori@lab.ntt.co.jp>
	<463F36AC.3010207@vlnb.net>
	<20070507182837E.fujita.tomonori@lab.ntt.co.jp>
	<20070522195656.GD5758@austin.ibm.com>
Message-ID: <46541B56.7000501@vlnb.net>

Robert Jennings wrote:
>>>>What I meant that is that the kernel tgt code (scsi_tgt*) receives
>>>>SCSI commands from one lld and send them to another lld instead of
>>>>sending them to user space.
>>>
>>>Although the approach of passing SCSI commands from a target LLD to an
>>>initiator one without any significant interventions from the target
>>>software looks to be nice and simple, you should realize how limited,
>>>unsafe and illegal it is, since it badly violates SCSI specs.
>>
>>I think that 'implemented cleanly' means that one scsi_host is assigned
>>to only one initiator.
> 
> Vladislav listed a number of issues that are inherent in an implementation
> that does not have a 1:1 relationship of initiators to targets.  The vscsi
> architecture defines the 1:1 relationship; it's imposible to have more
> than one initiator per target.

Just few small notes:

1. As I already wrote, complete 1:1 relationship isn't practically 
possible, because there is always a local access on the target (i.e. one 
more initiator) and you can't disable it on practice.

2. 1:1 relationship is a serious limitation for usage cases like an SPI 
tape library serving backup for several servers on an FC net.

Vlad


From fujita.tomonori at lab.ntt.co.jp  Wed May 23 13:01:22 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 23 May 2007 20:01:22 +0900
Subject: [Stgt-devel] 2.6.22-rc2 + it_nexus patch broken
In-Reply-To: <20070522202148.GA8694@wavehammer.waldi.eu.org>
References: <20070522202148.GA8694@wavehammer.waldi.eu.org>
Message-ID: <200705231101.l4NB1NN8008097@mbox.iij4u.or.jp>

From: Bastian Blank <waldi at berlios.de>
Subject: [Stgt-devel] 2.6.22-rc2 + it_nexus patch broken
Date: Tue, 22 May 2007 22:21:48 +0200

> Hi folks
> 
> If I understand git correctly, there are one three commits missing in
> mainline, two it_nexus support and the rdma fix. I applied them on my
> 2.6.22-rc2 and the only result with ibmvio and new utils is:

Strage, rc2 + three patches work for me.


From jidong.xiao at gmail.com  Wed May 23 15:53:34 2007
From: jidong.xiao at gmail.com (jidong xiao)
Date: Wed, 23 May 2007 21:53:34 +0800
Subject: [Stgt-devel] Question about the basic concept of SCSI layer and
	Block layer
Message-ID: <4104961b0705230653y26d0f6f9k92c56d6d913b5d8f@mail.gmail.com>

Hi,All,
  I have a question, what's the relationship between SCSI layer and Block
layer?I remember initially there are three types of device drivers, say,
char device driver, block device driver, network device driver, so there is
a directory "drivers/block",but recent years,most part of the code for block
devices have been moved out of the directory drivers/block, but there is
still a block I/O layer, so I am wondering what's the relationship between
Block layer and other subsystem, like how to connect block layer and
filesystem(VFS or the actually file system), how to bridge it with scsi
layer, for example, the scsi disk driver, sd.o. Who can please kindly
explain this for me, thank you very much!

Best Regards
Jason
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070523/71503cf8/attachment.html>

From jidong.xiao at gmail.com  Wed May 23 15:55:09 2007
From: jidong.xiao at gmail.com (jidong xiao)
Date: Wed, 23 May 2007 21:55:09 +0800
Subject: [Stgt-devel] Question about the basic concept of SCSI layer and
	Block layer
In-Reply-To: <4104961b0705230653y26d0f6f9k92c56d6d913b5d8f@mail.gmail.com>
References: <4104961b0705230653y26d0f6f9k92c56d6d913b5d8f@mail.gmail.com>
Message-ID: <4104961b0705230655j32ae30f9p78b7f7d906a92a92@mail.gmail.com>

Hi,All,
  I have a question, what's the relationship between SCSI layer and
Block layer?I remember initially there are three types of device
drivers, say, char device driver, block device driver, network device
driver, so there is a directory "drivers/block",but recent years,most
part of the code for block devices have been moved out of the
directory drivers/block, but there is still a block I/O layer, so I am
wondering what's the relationship between Block layer and other
subsystem, like how to connect block layer and filesystem(VFS or the
actually file system), how to bridge it with scsi layer, for example,
the scsi disk driver, sd.o. Who can please kindly explain this for me,
thank you very much!

Best Regards
Jason


From blackmagic02881 at gmail.com  Wed May 23 15:55:35 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 23 May 2007 09:55:35 -0400
Subject: [Stgt-devel] [Patch 2/8 ] Combine INQUIRY into a
	common	spc_inquiry routine.
In-Reply-To: <f29db9a80705222001g1e17804fma320dfa62a0538a3@mail.gmail.com>
References: <f29db9a80705222001g1e17804fma320dfa62a0538a3@mail.gmail.com>
Message-ID: <1179928535.3847.3.camel@dhcp-136.ibrix.com>

On Wed, 2007-05-23 at 13:01 +1000, Mark Harvey wrote:
> +struct physicalAttributes {
> +       char    scsi_id[SCSI_ID_LEN];
> +       char    scsi_sn[SCSI_SN_LEN];
> +
> +       /* SCSI Inquiry Params */
> +       char    VendorIdent[9];
> +       char    ProductIdent[17];
> +       char    ProductRev[5];
> +       uint16_t        version_desc1;
> +       uint16_t        version_desc2;
> +       uint16_t        version_desc3;
> +       uint16_t        version_desc4;
> +       uint16_t        version_desc5;
> +       uint16_t        version_desc6;

can we make it uint16_t *version_desc, which point to a dynamically
allocated array with last entry as 0?



> +
> +       char    isRemovable;    /* Removable media */
> +       char    onLine;
> +       char    reset;          /* Power-on or reset */
> +       char    sense_format;   /* sense data format */
> +};
> + 



From blackmagic02881 at gmail.com  Wed May 23 16:00:18 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 23 May 2007 10:00:18 -0400
Subject: [Stgt-devel] Question about the basic concept of SCSI layer	and
	Block layer
In-Reply-To: <4104961b0705230655j32ae30f9p78b7f7d906a92a92@mail.gmail.com>
References: <4104961b0705230653y26d0f6f9k92c56d6d913b5d8f@mail.gmail.com>
	<4104961b0705230655j32ae30f9p78b7f7d906a92a92@mail.gmail.com>
Message-ID: <1179928818.3847.5.camel@dhcp-136.ibrix.com>

On Wed, 2007-05-23 at 21:55 +0800, jidong xiao wrote:
> Hi,All,
>   I have a question, what's the relationship between SCSI layer and
> Block layer?I remember initially there are three types of device
> drivers, say, char device driver, block device driver, network device
> driver, so there is a directory "drivers/block",but recent years,most
> part of the code for block devices have been moved out of the
> directory drivers/block, but there is still a block I/O layer, so I am
> wondering what's the relationship between Block layer and other
> subsystem, like how to connect block layer and filesystem(VFS or the
> actually file system), how to bridge it with scsi layer, for example,
> the scsi disk driver, sd.o. Who can please kindly explain this for me,
> thank you very much!


u had better send these questions to kernel newbie or scsi list. the
other 2 you included are not related at all.

> 
> Best Regards
> Jason
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From markh794 at gmail.com  Thu May 24 00:42:22 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 24 May 2007 08:42:22 +1000
Subject: [Stgt-devel] [Patch 2/8 ] Combine INQUIRY into a common
	spc_inquiry routine.
In-Reply-To: <1179928535.3847.3.camel@dhcp-136.ibrix.com>
References: <f29db9a80705222001g1e17804fma320dfa62a0538a3@mail.gmail.com>
	<1179928535.3847.3.camel@dhcp-136.ibrix.com>
Message-ID: <f29db9a80705231542m2eb348dav3ee2ce3a9efea94c@mail.gmail.com>

On 5/23/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> On Wed, 2007-05-23 at 13:01 +1000, Mark Harvey wrote:
> > +struct physicalAttributes {
> > +       char    scsi_id[SCSI_ID_LEN];
> > +       char    scsi_sn[SCSI_SN_LEN];
> > +
> > +       /* SCSI Inquiry Params */
> > +       char    VendorIdent[9];
> > +       char    ProductIdent[17];
> > +       char    ProductRev[5];
> > +       uint16_t        version_desc1;
> > +       uint16_t        version_desc2;
> > +       uint16_t        version_desc3;
> > +       uint16_t        version_desc4;
> > +       uint16_t        version_desc5;
> > +       uint16_t        version_desc6;
>
> can we make it uint16_t *version_desc, which point to a dynamically
> allocated array with last entry as 0?

Looking back over the SPC-3 Inquiry data ( Sec 6.4.2 ), I should have
defined this as
               uint16_t       version_desc[8];

Thanks for pointing that out...

Mark


From blackmagic02881 at gmail.com  Thu May 24 02:20:19 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 23 May 2007 20:20:19 -0400
Subject: [Stgt-devel] [Patch 2/8 ] Combine INQUIRY into a
	common	spc_inquiry routine.
In-Reply-To: <f29db9a80705231542m2eb348dav3ee2ce3a9efea94c@mail.gmail.com>
References: <f29db9a80705222001g1e17804fma320dfa62a0538a3@mail.gmail.com>
	<1179928535.3847.3.camel@dhcp-136.ibrix.com>
	<f29db9a80705231542m2eb348dav3ee2ce3a9efea94c@mail.gmail.com>
Message-ID: <1179966019.3830.2.camel@localhost.localdomain>

On Thu, 2007-05-24 at 08:42 +1000, Mark Harvey wrote:
> On 5/23/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > On Wed, 2007-05-23 at 13:01 +1000, Mark Harvey wrote:
> > > +struct physicalAttributes {
> > > +       char    scsi_id[SCSI_ID_LEN];
> > > +       char    scsi_sn[SCSI_SN_LEN];
> > > +
> > > +       /* SCSI Inquiry Params */
> > > +       char    VendorIdent[9];
> > > +       char    ProductIdent[17];
> > > +       char    ProductRev[5];
> > > +       uint16_t        version_desc1;
> > > +       uint16_t        version_desc2;
> > > +       uint16_t        version_desc3;
> > > +       uint16_t        version_desc4;
> > > +       uint16_t        version_desc5;
> > > +       uint16_t        version_desc6;
> >
> > can we make it uint16_t *version_desc, which point to a dynamically
> > allocated array with last entry as 0?
> 
> Looking back over the SPC-3 Inquiry data ( Sec 6.4.2 ), I should have
> defined this as
>                uint16_t       version_desc[8];


looks good to me.

> 
> Thanks for pointing that out...
> 
> Mark

thx u for the work.



From markh794 at gmail.com  Thu May 24 08:05:47 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 24 May 2007 16:05:47 +1000
Subject: [Stgt-devel] Update SCSI Inquiry version descriptor to an array
Message-ID: <f29db9a80705232305y2548ef5br313357f454d5d8f@mail.gmail.com>

As per discussions with Ming,

Changed
 version_desc1
 version_desc2
 version_desc3
 version_desc4
etc


to
 version_desc[]

Apply to previous patch sets sent to list.

Cheers
Mark
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 1x2.diff
Type: text/x-patch
Size: 4148 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070524/502cfa22/attachment.bin>

From markh794 at gmail.com  Thu May 24 08:07:20 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 24 May 2007 16:07:20 +1000
Subject: [Stgt-devel] Brown paper bag fix...
Message-ID: <f29db9a80705232307v55d0c6bdld0de30e407f1012c@mail.gmail.com>

What can I say.

I thought I'd tested/compiled before I posted the patches....

diff --git a/usr/mmc.c b/usr/mmc.c
index f148645..fa0971d 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -104,7 +104,7 @@ static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)

        /* MMC devices do not support BLOCK DESCRIPTOR
         * So make sure we have DISABLE BLOCK DESCRIPTOR bit set */
-       sbc[1] | 8;
+       scb[1] |= 8;

        return spc_mode_sense(host_no, cmd);
 }


Cheers
Mark
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 2x2.diff
Type: text/x-patch
Size: 363 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070524/fc9285fb/attachment.bin>

From blackmagic02881 at gmail.com  Thu May 24 14:09:47 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 24 May 2007 08:09:47 -0400
Subject: [Stgt-devel] Brown paper bag fix...
In-Reply-To: <f29db9a80705232307v55d0c6bdld0de30e407f1012c@mail.gmail.com>
References: <f29db9a80705232307v55d0c6bdld0de30e407f1012c@mail.gmail.com>
Message-ID: <1180008587.3803.3.camel@localhost.localdomain>

On Thu, 2007-05-24 at 16:07 +1000, Mark Harvey wrote:
> What can I say.
> 
> I thought I'd tested/compiled before I posted the patches....
> 
> diff --git a/usr/mmc.c b/usr/mmc.c
> index f148645..fa0971d 100644
> --- a/usr/mmc.c
> +++ b/usr/mmc.c
> @@ -104,7 +104,7 @@ static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)
> 
>         /* MMC devices do not support BLOCK DESCRIPTOR
>          * So make sure we have DISABLE BLOCK DESCRIPTOR bit set */
> -       sbc[1] | 8;
> +       scb[1] |= 8;
> 
>         return spc_mode_sense(host_no, cmd);
>  }
> 

i would pass a flag about whether have DBD. i saw DBD is used and not
used all the time. so assume it is always there is not safe.


> 
> Cheers
> Mark
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From rcj at linux.vnet.ibm.com  Thu May 24 21:01:36 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Thu, 24 May 2007 14:01:36 -0500
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <46541B56.7000501@vlnb.net>
References: <463B72F6.3000207@torque.net>
	<20070506053629P.fujita.tomonori@lab.ntt.co.jp>
	<463F36AC.3010207@vlnb.net>
	<20070507182837E.fujita.tomonori@lab.ntt.co.jp>
	<20070522195656.GD5758@austin.ibm.com> <46541B56.7000501@vlnb.net>
Message-ID: <20070524190136.GA13684@austin.ibm.com>

* Vladislav Bolkhovitin (vst at vlnb.net) wrote:
> Robert Jennings wrote:
> >>>>What I meant that is that the kernel tgt code (scsi_tgt*) receives
> >>>>SCSI commands from one lld and send them to another lld instead of
> >>>>sending them to user space.
> >>>
> >>>Although the approach of passing SCSI commands from a target LLD to an
> >>>initiator one without any significant interventions from the target
> >>>software looks to be nice and simple, you should realize how limited,
> >>>unsafe and illegal it is, since it badly violates SCSI specs.
> >>
> >>I think that 'implemented cleanly' means that one scsi_host is assigned
> >>to only one initiator.
> >
> >Vladislav listed a number of issues that are inherent in an implementation
> >that does not have a 1:1 relationship of initiators to targets.  The vscsi
> >architecture defines the 1:1 relationship; it's imposible to have more
> >than one initiator per target.
> 
> Just few small notes:
> 
> 1. As I already wrote, complete 1:1 relationship isn't practically 
> possible, because there is always a local access on the target (i.e. one 
> more initiator) and you can't disable it on practice.

I was proposing a 1:1 relationship of initiator to target within the
target framework for in-kernel pass-through.  We would still have the
case that local access on the target is possible; an administrator with
privileges neccessary to create a target would have the responsibility
to not then access the device locally.  

This is no different than if I create my root file system on /dev/sda1,
I should not also 'dd' data to /dev/sda1 while the system is running.
It's a bad idea, but nothing stops me; however this is something that
only a root level user can do.  This would be the same, these targets in
pass-through have permissions by default that do not allow local access
by non-root users.

> 2. 1:1 relationship is a serious limitation for usage cases like an SPI 
> tape library serving backup for several servers on an FC net.

Restricting the relationship to 1:1 would be for pass-through devices
only, this would not necessarily dictate other target types which could
be used for such cases.

--Rob


From blackmagic02881 at gmail.com  Fri May 25 00:08:23 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 24 May 2007 18:08:23 -0400
Subject: [Stgt-devel] Have a look at storageos.com
Message-ID: <1180044503.3803.38.camel@localhost.localdomain>

Hi All

Please have a look at www.storageos.com.

Though it is not a wiki. It is more than a wiki. See
http://www.storageos.com/?q=node/9 for example. With external services
like sf.net or google to provide bugzilla, svn, mailing list, it should
be a good starting point. Also you need to register to post/comment, so
hopefully spam can be controlled to an minimum level.

Thanks!

Ming





From johan at capvert.se  Fri May 25 07:39:58 2007
From: johan at capvert.se (johan at capvert.se)
Date: Fri, 25 May 2007 07:39:58 +0200
Subject: [Stgt-devel] Ang: [Iscsitarget-devel] Have a look at storageos.com
Message-ID: <OF96DCC785.61561833-ONC12572E6.001EB67A@capvert.ins>

Ming Zhang <blackmagic02881 at gmail.com>
S?nt av: iscsitarget-devel-bounces at lists.sourceforge.net
2007-05-25 00:08
S?nd svar till blackmagic02881

 
        Till:   iscsitarget-devel at lists.sourceforge.net, open-iscsi 
<open-iscsi at googlegroups.com>, linux-stgt <stgt-devel at lists.berlios.de>
        Kopia:  "Nicholas A. Bellinger" <nab at kernel.org>, Mike Young 
<myoung at wildernessvoice.com>, Mike Mazarick <mazarick at bellsouth.net>
        ?rende: [Iscsitarget-devel] Have a look at storageos.com


Hi All

Please have a look at www.storageos.com.

Though it is not a wiki. It is more than a wiki. See
http://www.storageos.com/?q=node/9 for example. With external services
like sf.net or google to provide bugzilla, svn, mailing list, it should
be a good starting point. Also you need to register to post/comment, so
hopefully spam can be controlled to an minimum level.

Thanks!

Ming


Looks nice. A good idea. Who is behind this? 

                Johan 




-------------------------------------------------------------------------
This SF.net email is sponsored by DB2 Express
Download DB2 Express C - the FREE version of DB2 express and take
control of your XML. No limits. Just data. Click to get it now.
http://sourceforge.net/powerbar/db2/
_______________________________________________
Iscsitarget-devel mailing list
Iscsitarget-devel at lists.sourceforge.net
https://lists.sourceforge.net/lists/listinfo/iscsitarget-devel


-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070525/c7dc6938/attachment.html>

From blackmagic02881 at gmail.com  Fri May 25 15:44:53 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 25 May 2007 09:44:53 -0400
Subject: [Stgt-devel] Ang: [Iscsitarget-devel] Have a look at
	storageos.com
In-Reply-To: <OF96DCC785.61561833-ONC12572E6.001EB67A@capvert.ins>
References: <OF96DCC785.61561833-ONC12572E6.001EB67A@capvert.ins>
Message-ID: <1180100693.3874.10.camel@dhcp-136.ibrix.com>

On Fri, 2007-05-25 at 07:39 +0200, johan at capvert.se wrote:
> 
> 
> 
> 
> Ming Zhang
> <blackmagic02881 at gmail.com> 
> S?nt av:
> iscsitarget-devel-bounces at lists.sourceforge.net 
> 
> 2007-05-25 00:08 
> S?nd svar till
> blackmagic02881 
> 
> 
> 
>          
>         Till:
>  iscsitarget-devel at lists.sourceforge.net, open-iscsi <open-iscsi at googlegroups.com>, linux-stgt <stgt-devel at lists.berlios.de> 
>         Kopia:
>  "Nicholas A.
> Bellinger"
> <nab at kernel.org>, Mike
> Young
> <myoung at wildernessvoice.com>, Mike Mazarick <mazarick at bellsouth.net> 
>         ?rende:
>  [Iscsitarget-devel]
> Have a look at
> storageos.com
> 
> 
> 
> Hi All
> 
> Please have a look at www.storageos.com.
> 
> Though it is not a wiki. It is more than a wiki. See
> http://www.storageos.com/?q=node/9 for example. With external services
> like sf.net or google to provide bugzilla, svn, mailing list, it
> should
> be a good starting point. Also you need to register to post/comment,
> so
> hopefully spam can be controlled to an minimum level.
> 
> Thanks!
> 
> Ming
> 
> 
> Looks nice. A good idea. Who is behind this? 

who? so far Mike Young, Ross, Rafiu, and I. but anybody who want to make
linux a better OS for storage is welcomed! anyway it is a OSS project.
we just see something duplicated again and again so wish to merge the
effort to build a better one.

ming


> 
>                 Johan         
> 
> 
> 
> 
> -------------------------------------------------------------------------
> This SF.net email is sponsored by DB2 Express
> Download DB2 Express C - the FREE version of DB2 express and take
> control of your XML. No limits. Just data. Click to get it now.
> http://sourceforge.net/powerbar/db2/
> _______________________________________________
> Iscsitarget-devel mailing list
> Iscsitarget-devel at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/iscsitarget-devel
> 
> 



From johan at capvert.se  Fri May 25 16:29:16 2007
From: johan at capvert.se (johan at capvert.se)
Date: Fri, 25 May 2007 16:29:16 +0200
Subject: [Stgt-devel] Ang: Re: Ang: [Iscsitarget-devel] Have a look at
	storageos.com
Message-ID: <OF9B8706DC.F84554D1-ONC12572E6.004E97F8@capvert.ins>

 Ming Zhang <blackmagic02881 at gmail.com>
2007-05-25 15:44
S?nd svar till blackmagic02881

 
        Till:   johan at capvert.se
        Kopia:  iscsitarget-devel at lists.sourceforge.net, 
iscsitarget-devel-bounces at lists.sourceforge.net, Mike Mazarick 
<mazarick at bellsouth.net>, Mike Young <myoung at wildernessvoice.com>, 
"Nicholas A. Bellinger" <nab at kernel.org>, open-iscsi 
<open-iscsi at googlegroups.com>, linux-stgt <stgt-devel at lists.berlios.de>, 
Rafiu Fakunle <rafiu at openfiler.com>
        ?rende: Re: Ang: [Iscsitarget-devel] Have a look at storageos.com


On Fri, 2007-05-25 at 07:39 +0200, johan at capvert.se wrote:
> 
> 
> 
> 
> Ming Zhang
> <blackmagic02881 at gmail.com> 
> S?nt av:
> iscsitarget-devel-bounces at lists.sourceforge.net 
> 
> 2007-05-25 00:08 
> S?nd svar till
> blackmagic02881 
> 
> 
> 
> 
>         Till:
>  iscsitarget-devel at lists.sourceforge.net, open-iscsi 
<open-iscsi at googlegroups.com>, linux-stgt <stgt-devel at lists.berlios.de> 
>         Kopia:
>  "Nicholas A.
> Bellinger"
> <nab at kernel.org>, Mike
> Young
> <myoung at wildernessvoice.com>, Mike Mazarick <mazarick at bellsouth.net> 
>         ?rende:
>  [Iscsitarget-devel]
> Have a look at
> storageos.com
> 
> 
> 
> Hi All
> 
> Please have a look at www.storageos.com.
> 
> Though it is not a wiki. It is more than a wiki. See
> http://www.storageos.com/?q=node/9 for example. With external services
> like sf.net or google to provide bugzilla, svn, mailing list, it
> should
> be a good starting point. Also you need to register to post/comment,
> so
> hopefully spam can be controlled to an minimum level.
> 
> Thanks!
> 
> Ming
> 
> 
> Looks nice. A good idea. Who is behind this? 

who? so far Mike Young, Ross, Rafiu, and I. but anybody who want to make
linux a better OS for storage is welcomed! anyway it is a OSS project.
we just see something duplicated again and again so wish to merge the
effort to build a better one.

ming



How about asking Vlad at scst to join the site as well?


        Johan





> 
> 
> 
> 
> 
> 
> 
-------------------------------------------------------------------------
> This SF.net email is sponsored by DB2 Express
> Download DB2 Express C - the FREE version of DB2 express and take
> control of your XML. No limits. Just data. Click to get it now.
> http://sourceforge.net/powerbar/db2/
> _______________________________________________
> Iscsitarget-devel mailing list
> Iscsitarget-devel at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/iscsitarget-devel
> 
> 



-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070525/2fca5e05/attachment.html>

From vst at vlnb.net  Fri May 25 16:38:20 2007
From: vst at vlnb.net (Vladislav Bolkhovitin)
Date: Fri, 25 May 2007 18:38:20 +0400
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <20070524190136.GA13684@austin.ibm.com>
References: <463B72F6.3000207@torque.net>
	<20070506053629P.fujita.tomonori@lab.ntt.co.jp>
	<463F36AC.3010207@vlnb.net>
	<20070507182837E.fujita.tomonori@lab.ntt.co.jp>
	<20070522195656.GD5758@austin.ibm.com> <46541B56.7000501@vlnb.net>
	<20070524190136.GA13684@austin.ibm.com>
Message-ID: <4656F4DC.5000407@vlnb.net>

Robert Jennings wrote:
> * Vladislav Bolkhovitin (vst at vlnb.net) wrote:
> 
>>Robert Jennings wrote:
>>
>>>>>>What I meant that is that the kernel tgt code (scsi_tgt*) receives
>>>>>>SCSI commands from one lld and send them to another lld instead of
>>>>>>sending them to user space.
>>>>>
>>>>>Although the approach of passing SCSI commands from a target LLD to an
>>>>>initiator one without any significant interventions from the target
>>>>>software looks to be nice and simple, you should realize how limited,
>>>>>unsafe and illegal it is, since it badly violates SCSI specs.
>>>>
>>>>I think that 'implemented cleanly' means that one scsi_host is assigned
>>>>to only one initiator.
>>>
>>>Vladislav listed a number of issues that are inherent in an implementation
>>>that does not have a 1:1 relationship of initiators to targets.  The vscsi
>>>architecture defines the 1:1 relationship; it's imposible to have more
>>>than one initiator per target.
>>
>>Just few small notes:
>>
>>1. As I already wrote, complete 1:1 relationship isn't practically 
>>possible, because there is always a local access on the target (i.e. one 
>>more initiator) and you can't disable it on practice.
> 
> I was proposing a 1:1 relationship of initiator to target within the
> target framework for in-kernel pass-through.  We would still have the
> case that local access on the target is possible; an administrator with
> privileges neccessary to create a target would have the responsibility
> to not then access the device locally.  
> 
> This is no different than if I create my root file system on /dev/sda1,
> I should not also 'dd' data to /dev/sda1 while the system is running.
> It's a bad idea, but nothing stops me; however this is something that
> only a root level user can do.  This would be the same, these targets in
> pass-through have permissions by default that do not allow local access
> by non-root users.

In principle, yes, but, as usually, on practice it's not so easy. In 
your file system example the device is accessed via the FS, which 
provides a shared mode, and everybody doesn't have any need to do 
anything directly with the device. But in case of non-disk devices they 
are always accessed directly, so to explain your limitation you will 
have to write it with HUGE letters everywhere. Once one SCST user 
cleared Unit Attention on his exported tape device using st driver and 
asked then me why it isn't delivered to his remote initiator.

>>2. 1:1 relationship is a serious limitation for usage cases like an SPI 
>>tape library serving backup for several servers on an FC net.
> 
> Restricting the relationship to 1:1 would be for pass-through devices
> only, this would not necessarily dictate other target types which could
> be used for such cases.

The tape library from my example is the pass-through device. You can't 
access a parallel SCSI (SPI) device on an Fibre Channel (FC) in any 
other mode, right?

Vlad


From vst at vlnb.net  Fri May 25 16:46:58 2007
From: vst at vlnb.net (Vladislav Bolkhovitin)
Date: Fri, 25 May 2007 18:46:58 +0400
Subject: [Stgt-devel] [Scst-devel] Ang: Re: Ang: [Iscsitarget-devel]
 Have a look at storageos.com
In-Reply-To: <1180104072.3874.38.camel@dhcp-136.ibrix.com>
References: <OF9B8706DC.F84554D1-ONC12572E6.004E97F8@capvert.ins>
	<1180104072.3874.38.camel@dhcp-136.ibrix.com>
Message-ID: <4656F6E2.1010704@vlnb.net>

Ming Zhang wrote:
> 
> On Fri, 2007-05-25 at 16:29 +0200, johan at capvert.se wrote:
> 
> 
>>>Hi All
>>>
>>>Please have a look at www.storageos.com.
>>>
>>>Though it is not a wiki. It is more than a wiki. See
>>>http://www.storageos.com/?q=node/9 for example. With external
>>
>>services
>>
>>>like sf.net or google to provide bugzilla, svn, mailing list, it
>>>should
>>>be a good starting point. Also you need to register to post/comment,
>>>so
>>>hopefully spam can be controlled to an minimum level.
>>>
>>>Thanks!
>>>
>>>Ming
>>>
>>>
>>>Looks nice. A good idea. Who is behind this? 
>>
>>who? so far Mike Young, Ross, Rafiu, and I. but anybody who want to
>>make
>>linux a better OS for storage is welcomed! anyway it is a OSS project.
>>we just see something duplicated again and again so wish to merge the
>>effort to build a better one.
>>
>>ming 
>>
>>
>>
>>How about asking Vlad at scst to join the site as well? 
> 
> 
> sure. as i said, everyone is welcomed!

Unfortunately, I don't have time for writing any docs/blogs, sorry. But 
I would only welcome everybody who wish to write about SCST there.

>>
>>        Johan 
>>
>>
>>
>>
> 
> 
> 
> 
> -------------------------------------------------------------------------
> This SF.net email is sponsored by DB2 Express
> Download DB2 Express C - the FREE version of DB2 express and take
> control of your XML. No limits. Just data. Click to get it now.
> http://sourceforge.net/powerbar/db2/
> _______________________________________________
> Scst-devel mailing list
> Scst-devel at lists.sourceforge.net
> https://lists.sourceforge.net/lists/listinfo/scst-devel
> 



From myoung at wildernessvoice.com  Fri May 25 19:41:02 2007
From: myoung at wildernessvoice.com (Mike Young)
Date: Fri, 25 May 2007 11:41:02 -0600
Subject: [Stgt-devel] Ang: [Iscsitarget-devel] Have a look at
	storageos.com
In-Reply-To: <1180100693.3874.10.camel@dhcp-136.ibrix.com>
References: <OF96DCC785.61561833-ONC12572E6.001EB67A@capvert.ins>
	<1180100693.3874.10.camel@dhcp-136.ibrix.com>
Message-ID: <46571FAE.6@wildernessvoice.com>

An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070525/980ae13d/attachment.html>

From blackmagic02881 at gmail.com  Fri May 25 19:47:50 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 25 May 2007 13:47:50 -0400
Subject: [Stgt-devel] Ang: [Iscsitarget-devel] Have a look at
	storageos.com
In-Reply-To: <46571FAE.6@wildernessvoice.com>
References: <OF96DCC785.61561833-ONC12572E6.001EB67A@capvert.ins>
	<1180100693.3874.10.camel@dhcp-136.ibrix.com>
	<46571FAE.6@wildernessvoice.com>
Message-ID: <1180115270.3874.54.camel@dhcp-136.ibrix.com>

actually, now the cc list is too long and email will get rejected. also
cross posting in multiple lists is not that nice. so this will be my
last cross list post on this topic.

i strongly suggest anyone who have interest on this topic, go ahead
register in http://groups.google.com/group/storageos mailing list, or
post stuff directly on sites.

@Mike, could you post this email in your blog as a start?

thanks all!

Ming


On Fri, 2007-05-25 at 11:41 -0600, Mike Young wrote:
> Over the years, I've done several OSS-based storage companies. Back in
> the late 90's I founded NetAttach, which was acquired by VA Linux. It
> was the first one to go the route of leveraging OSS and then turning
> back to the community. Years later, Rafiu at Openfiler leveraged what
> we did previously and made a much better version of an OSS storage
> solution. While he did that, I was driving new functionality into our
> OS at Snap Appliance and then turning back into open source. Was also
> driving OSS models to Intel and others after Xyratex acquired another
> one of my companies. Want to do this more broadly now as I hate, hate,
> hate proprietary storage software.
> 
> Collectively, we're doing some exciting things in open source that are
> storage related. I see some new things and I see a lot of replication
> as well. Some good, some not so much. Sometimes the changes are good,
> but not understood.
> 
> Anyway, I found that managing all of these projects via mail lists was
> a horrible way to go. Any time I needed to track down a new patch set,
> like Ross' compat or blockio patches, I had to search through mail
> archives and then figure out the latest versions, etc. Just thought a
> central site would be better for all of this. And with blog style of
> posts available, I like that folks can post their questions and fixes
> right next to the posted patches. I think it's a lot easier to
> navigate and follow the evolution of a patch set.
> 
> This is just a way to unite protocols, file systems, middleware, and
> applications into a storage-specific operating system or Linux
> distribution. It was actually Ming's idea. We were on a call together
> nearly a year ago when he proposed it and I locked down the domain
> name. We're just now getting to the point of bringing everything
> together.
> 
> I, by no means, envision this as being the end-all of open source
> storage. I really think it's way for us to share a lot more ideas and
> provide a forum to address here. How many times have we seen a
> question on IET that was really meant for open-iscsi? Or what about an
> EVMS plugin question that wandered past us? Well, the very notion that
> someone wants to manage IET or STGT via EVMS means it can belong here.
> Such an idea or thread is very relevant to us because we're focused on
> Leveraging, Integrating, Managing and Tuning. 
> 
> Over the next few days, I'm hoping we can sort of post a roadmap of
> where we'd like to go and what we'd like to possibly see. As with
> other items we post, it's open to feedback. I learned a long time ago
> to remain receptive of new ideas. You'd be surprised where the best
> ones will come from. I hope you'll all embrace this site and
> contribute. And by all means pick an area and lead it, drive it and be
> the visionary. I think that would be great.
> 
> Best regards,
> 
> Mike
> 
> 
> 
> Ming Zhang wrote: 
> > On Fri, 2007-05-25 at 07:39 +0200, johan at capvert.se wrote:
> >   
> > > 
> > > 
> > > Ming Zhang
> > > <blackmagic02881 at gmail.com> 
> > > S?nt av:
> > > iscsitarget-devel-bounces at lists.sourceforge.net 
> > > 
> > > 2007-05-25 00:08 
> > > S?nd svar till
> > > blackmagic02881 
> > > 
> > > 
> > > 
> > >          
> > >         Till:
> > >  iscsitarget-devel at lists.sourceforge.net, open-iscsi <open-iscsi at googlegroups.com>, linux-stgt <stgt-devel at lists.berlios.de> 
> > >         Kopia:
> > >  "Nicholas A.
> > > Bellinger"
> > > <nab at kernel.org>, Mike
> > > Young
> > > <myoung at wildernessvoice.com>, Mike Mazarick <mazarick at bellsouth.net> 
> > >         ?rende:
> > >  [Iscsitarget-devel]
> > > Have a look at
> > > storageos.com
> > > 
> > > 
> > > 
> > > Hi All
> > > 
> > > Please have a look at www.storageos.com.
> > > 
> > > Though it is not a wiki. It is more than a wiki. See
> > > http://www.storageos.com/?q=node/9 for example. With external services
> > > like sf.net or google to provide bugzilla, svn, mailing list, it
> > > should
> > > be a good starting point. Also you need to register to post/comment,
> > > so
> > > hopefully spam can be controlled to an minimum level.
> > > 
> > > Thanks!
> > > 
> > > Ming
> > > 
> > > 
> > > Looks nice. A good idea. Who is behind this? 
> > >     
> > 
> > who? so far Mike Young, Ross, Rafiu, and I. but anybody who want to make
> > linux a better OS for storage is welcomed! anyway it is a OSS project.
> > we just see something duplicated again and again so wish to merge the
> > effort to build a better one.
> > 
> > ming
> > 
> > 
> >   
> > >                 Johan         
> > > 
> > > 
> > > 
> > > 
> > > -------------------------------------------------------------------------
> > > This SF.net email is sponsored by DB2 Express
> > > Download DB2 Express C - the FREE version of DB2 express and take
> > > control of your XML. No limits. Just data. Click to get it now.
> > > http://sourceforge.net/powerbar/db2/
> > > _______________________________________________
> > > Iscsitarget-devel mailing list
> > > Iscsitarget-devel at lists.sourceforge.net
> > > https://lists.sourceforge.net/lists/listinfo/iscsitarget-devel
> > > 
> > > 
> > >     
> > 
> > 
> >   



From pw at osc.edu  Fri May 25 22:32:36 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Fri, 25 May 2007 16:32:36 -0400
Subject: [Stgt-devel] [Patch 2/8 ] Combine INQUIRY into a
	common	spc_inquiry routine.
In-Reply-To: <f29db9a80705222001g1e17804fma320dfa62a0538a3@mail.gmail.com>
References: <f29db9a80705222001g1e17804fma320dfa62a0538a3@mail.gmail.com>
Message-ID: <20070525203236.GC3065@osc.edu>

markh794 at gmail.com wrote on Wed, 23 May 2007 13:01 +1000:
> Moved scsi_sn, scsi_id and d_sense (now sense_format) into a common
> struct with other INQUIRY related data.
[..]
> +static int osd_device_init(struct scsi_lu *lu)
>  {
> -	lu->d_sense = 1;
> +
> +	if (spc_device_init(lu))
> +		return -ENOMEM;
> +
> +	memcpy(lu->attributes->ProductIdent, "OSD", 16); 
> +	lu->attributes->sense_format = 1;
> +	lu->attributes->version_desc1 = 0x0340;	/* OSD */
> +	lu->attributes->version_desc2 = 0x0960;	/* iSCSI */
> +	lu->attributes->version_desc3 = 0x0300;	/* SPC-3 */
> +
>  	return 0;
>  }

Good stuff.  I like the common INQUIRY handling.  It was something
Tomo asked for once I added yet another inquiry handler for OSD.

Another tweak that will be needed is the ability to support more
page codes.  OSD needs to provide 0xb0 and 0xb1.  This means
modifying 0x0 (supported VPD pages) to add two more supported pages
to the list.  And it needs very OSD-internal code to produce the
right responses for 0xb0 and 0xb1.  So I've been holding off pushing
that change because it is difficult to generalize well.  If you have
ideas, they would be most welcome.

By all means, this patch is a step in the right direction, though.

		-- Pete


From markh794 at gmail.com  Fri May 25 23:48:19 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 26 May 2007 07:48:19 +1000
Subject: [Stgt-devel] [Patch 2/8 ] Combine INQUIRY into a common
	spc_inquiry routine.
In-Reply-To: <20070525203236.GC3065@osc.edu>
References: <f29db9a80705222001g1e17804fma320dfa62a0538a3@mail.gmail.com>
	<20070525203236.GC3065@osc.edu>
Message-ID: <f29db9a80705251448r743a04a0of9a07dfd3798cd24@mail.gmail.com>

On 5/26/07, Pete Wyckoff <pw at osc.edu> wrote:
> markh794 at gmail.com wrote on Wed, 23 May 2007 13:01 +1000:
> > Moved scsi_sn, scsi_id and d_sense (now sense_format) into a common
> > struct with other INQUIRY related data.
> [..]
> > +static int osd_device_init(struct scsi_lu *lu)
> >  {
> > -     lu->d_sense = 1;
> > +
> > +     if (spc_device_init(lu))
> > +             return -ENOMEM;
> > +
> > +     memcpy(lu->attributes->ProductIdent, "OSD", 16);
> > +     lu->attributes->sense_format = 1;
> > +     lu->attributes->version_desc1 = 0x0340; /* OSD */
> > +     lu->attributes->version_desc2 = 0x0960; /* iSCSI */
> > +     lu->attributes->version_desc3 = 0x0300; /* SPC-3 */
> > +
> >       return 0;
> >  }
>
> Good stuff.  I like the common INQUIRY handling.  It was something
> Tomo asked for once I added yet another inquiry handler for OSD.
>
> Another tweak that will be needed is the ability to support more
> page codes.  OSD needs to provide 0xb0 and 0xb1.  This means
> modifying 0x0 (supported VPD pages) to add two more supported pages
> to the list.  And it needs very OSD-internal code to produce the
> right responses for 0xb0 and 0xb1.  So I've been holding off pushing
> that change because it is difficult to generalize well.  If you have
> ideas, they would be most welcome.
>
> By all means, this patch is a step in the right direction, though.
>
>                 -- Pete
>

Thanks for the vote of confidence.

As you may be aware, my main aim is to create a Virtual Library
(Tape/CD/MO etc.)

The SSC devices will also require extra VPD pages...

I have not had any ideas regarding how to support multiple VPD pages
which I feel is 'good'.

I was thinking yet another list, similar to the MODE list, but this
seems a bit of an over-kill for a few bytes of data / VPD.


The other concern I had regarding the SCSI Version, related to the
underlying transport. At the moment, I have hard-coded iSCSI version,
however it would be 'nice' to be able to insert which ever underlying
protocol was being used to connect to the target...

Can anybody suggest an easy way of detecting the underlying protocol
at runtime ?

Cheers
Mark


From blackmagic02881 at gmail.com  Sat May 26 03:29:29 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 25 May 2007 21:29:29 -0400
Subject: [Stgt-devel] [Patch 2/8 ] Combine INQUIRY into a
	common	spc_inquiry routine.
In-Reply-To: <f29db9a80705251448r743a04a0of9a07dfd3798cd24@mail.gmail.com>
References: <f29db9a80705222001g1e17804fma320dfa62a0538a3@mail.gmail.com>
	<20070525203236.GC3065@osc.edu>
	<f29db9a80705251448r743a04a0of9a07dfd3798cd24@mail.gmail.com>
Message-ID: <1180142969.3798.1.camel@localhost.localdomain>

On Sat, 2007-05-26 at 07:48 +1000, Mark Harvey wrote:
> On 5/26/07, Pete Wyckoff <pw at osc.edu> wrote:
> > markh794 at gmail.com wrote on Wed, 23 May 2007 13:01 +1000:
> > > Moved scsi_sn, scsi_id and d_sense (now sense_format) into a common
> > > struct with other INQUIRY related data.
> > [..]
> > > +static int osd_device_init(struct scsi_lu *lu)
> > >  {
> > > -     lu->d_sense = 1;
> > > +
> > > +     if (spc_device_init(lu))
> > > +             return -ENOMEM;
> > > +
> > > +     memcpy(lu->attributes->ProductIdent, "OSD", 16);
> > > +     lu->attributes->sense_format = 1;
> > > +     lu->attributes->version_desc1 = 0x0340; /* OSD */
> > > +     lu->attributes->version_desc2 = 0x0960; /* iSCSI */
> > > +     lu->attributes->version_desc3 = 0x0300; /* SPC-3 */
> > > +
> > >       return 0;
> > >  }
> >
> > Good stuff.  I like the common INQUIRY handling.  It was something
> > Tomo asked for once I added yet another inquiry handler for OSD.
> >
> > Another tweak that will be needed is the ability to support more
> > page codes.  OSD needs to provide 0xb0 and 0xb1.  This means
> > modifying 0x0 (supported VPD pages) to add two more supported pages
> > to the list.  And it needs very OSD-internal code to produce the
> > right responses for 0xb0 and 0xb1.  So I've been holding off pushing
> > that change because it is difficult to generalize well.  If you have
> > ideas, they would be most welcome.
> >
> > By all means, this patch is a step in the right direction, though.
> >
> >                 -- Pete
> >
> 
> Thanks for the vote of confidence.
> 
> As you may be aware, my main aim is to create a Virtual Library
> (Tape/CD/MO etc.)
> 
> The SSC devices will also require extra VPD pages...
> 
> I have not had any ideas regarding how to support multiple VPD pages
> which I feel is 'good'.
> 
> I was thinking yet another list, similar to the MODE list, but this
> seems a bit of an over-kill for a few bytes of data / VPD.
> 

> 
> The other concern I had regarding the SCSI Version, related to the
> underlying transport. At the moment, I have hard-coded iSCSI version,
> however it would be 'nice' to be able to insert which ever underlying
> protocol was being used to connect to the target...
> 
> Can anybody suggest an easy way of detecting the underlying protocol
> at runtime ?

u need front end pass this info to back end. for example, a run time
session opaque structure with a function to grab protocol string. 


> 
> Cheers
> Mark
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From markh794 at gmail.com  Sat May 26 04:45:45 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 26 May 2007 12:45:45 +1000
Subject: [Stgt-devel] [Patch 2/8 ] Combine INQUIRY into a common
	spc_inquiry routine.
In-Reply-To: <1180142969.3798.1.camel@localhost.localdomain>
References: <f29db9a80705222001g1e17804fma320dfa62a0538a3@mail.gmail.com>
	<20070525203236.GC3065@osc.edu>
	<f29db9a80705251448r743a04a0of9a07dfd3798cd24@mail.gmail.com>
	<1180142969.3798.1.camel@localhost.localdomain>
Message-ID: <f29db9a80705251945q56973d48s8840a34fcfde8473@mail.gmail.com>

>
> >
> > The other concern I had regarding the SCSI Version, related to the
> > underlying transport. At the moment, I have hard-coded iSCSI version,
> > however it would be 'nice' to be able to insert which ever underlying
> > protocol was being used to connect to the target...
> >
> > Can anybody suggest an easy way of detecting the underlying protocol
> > at runtime ?
>
> u need front end pass this info to back end. for example, a run time
> session opaque structure with a function to grab protocol string.

Yeah, I thought it might be something like that..

I'll add that to my 'wish' list of things to add and move on with
getting the SMC module functional.


Cheers
Mark

>
>
> >
> > Cheers
> > Mark
> > _______________________________________________
> > Stgt-devel mailing list
> > Stgt-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/stgt-devel
>
>


From markh794 at gmail.com  Sat May 26 06:32:02 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 26 May 2007 14:32:02 +1000
Subject: [Stgt-devel] [Patch 1/1] SMC module support
Message-ID: <f29db9a80705252132k2c0faf22u63abf99c45b969c5@mail.gmail.com>

This patch is to be applied on top of the 8 patch set sent in earlier.

It adds support for an SMC module.

The module only supports the SMC unique READ ELEMENT STATUS and MOVE
MEDIUM op codes to date.

This should complete the SCSI op codes for MANDATORY implemenation
(Except SEND DIAGNOSTIC).


There is a script (tgt-core-test) located in the 'scripts' directory
as an example of setting up the robot.

To do:
 - Signal the DATA TRANSFER device when media is loaded.

I have perform minimum testing using 'mtx', sg3_utils package &
NetBackup 'robtest' robot test utility.


I can generate a new patch based from tomo's git head if it makes it
easier for anybody to apply / test.

Cheers
Mark
-------------- next part --------------
A non-text attachment was scrubbed...
Name: mmc.diff
Type: text/x-patch
Size: 37937 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070526/82610699/attachment.bin>

From markh794 at gmail.com  Sat May 26 06:43:31 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 26 May 2007 14:43:31 +1000
Subject: [Stgt-devel] [Patch 1/1] SMC module support
Message-ID: <f29db9a80705252143w54e42bc9p75ed8b15c3719923@mail.gmail.com>

Why o why do I only spot the typos after sending...

> The module only supports the SMC unique READ ELEMENT STATUS and MOVE
> MEDIUM op codes to date.
Should read:
This module adds the SMC unique READ ELEMENT STATUS and MOVE MEDIUM op
codes on top of the SPC op codes already implemented.

> This should complete the SCSI op codes for MANDATORY implemenation
s/implemenation/implementation/

I have also left in a 'dprintf()' within the smc_device_config() which
was used when debugging and should/will be removed. I don't think it
is worth spamming this list with another patch just for this entry.
	dprintf("After spc_device_config() : %s\n", smc_params);

Cheers
Mark


From fujita.tomonori at lab.ntt.co.jp  Wed May 30 02:11:27 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 30 May 2007 09:11:27 +0900 (JST)
Subject: [Stgt-devel] [Patch 1/8 ] Setup .device_init,
 device_shutdown & device_config to the device template.
In-Reply-To: <f29db9a80705221958h5f5b808cwf8a448d0c2f0ab@mail.gmail.com>
References: <f29db9a80705221958h5f5b808cwf8a448d0c2f0ab@mail.gmail.com>
Message-ID: <20070529210615Q.fujita.tomonori@lab.ntt.co.jp>

Thanks for the patches. Sorry for the delay.

> diff --git a/usr/mmc.c b/usr/mmc.c
> index e9cc479..d53d0f3 100644
> --- a/usr/mmc.c
> +++ b/usr/mmc.c
> @@ -121,10 +121,24 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
>  	return SAM_STAT_GOOD;
>  }
>  

trailing spaces


> +static int device_mmc_init(struct scsi_lu *lu)
> +{
> +	lu->d_sense = 1;
> +	return 0;
> +}
> +
> +static int device_mmc_shutdown(struct scsi_lu *lu)
> +{
> +	return 0;
> +}

In general, the kernel uses init/exit pair, I guess. So I prefer it.


>  struct device_type_template mmc_template = {
>  	.type	= TYPE_ROM,
>  	.name	= "cdrom/dvd",
>  	.pid	= "VIRTUAL-CDROM",
> +	.device_init = device_mmc_init,
> +	.device_shutdown = device_mmc_shutdown,
> +	.device_config = spc_device_config,

lu_init/lu_exit/lu_config looks better?

Yeah, it would be better to rename device_* functions too. I take care
about that.


>  	.ops	= {
>  		{spc_test_unit,},
>  		{spc_illegal_op,},
> diff --git a/usr/osd.c b/usr/osd.c
> index 46bf0a0..64e7b2a 100644
> --- a/usr/osd.c
> +++ b/usr/osd.c
> @@ -145,15 +145,22 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
>  	return cmd->c_target->bst->bs_cmd_submit(cmd);
>  }
>  

trailing spaces

All the patches seem to have tons of trailing spaces.


> +int spc_mode_sense(int host_no, struct scsi_cmd *cmd, struct list_head * mode_head)
> +{
> +	int		ret = SAM_STAT_GOOD, len;

Should be:

int ret = SAM_STAT_GOOD, len;


> +	uint8_t		pcode = cmd->scb[2] & 0x3f;
> +	uint64_t	size;
> +	uint8_t		*data = NULL;
> +	unsigned char	key = ILLEGAL_REQUEST;
> +	uint16_t	asc_ascq = E_INVALID_FIELD_IN_CDB;
> +	struct	mode	* m;

Can you read the Linux coding style document, fix and resubmit the
patches? If this is the last patchset that you send (hopefully not),
I'll fix them this time.

Please try `git-apply --whitespace=error` before submitting a patch to
avoid trailing spaces.


From markh794 at gmail.com  Wed May 30 05:07:06 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 30 May 2007 13:07:06 +1000
Subject: [Stgt-devel] [Patch 1/8 ] Setup .device_init,
	device_shutdown & device_config to the device template.
In-Reply-To: <20070529210615Q.fujita.tomonori@lab.ntt.co.jp>
References: <f29db9a80705221958h5f5b808cwf8a448d0c2f0ab@mail.gmail.com>
	<20070529210615Q.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80705292007q668d539dw61c08957fa0a7d00@mail.gmail.com>

Thanks for the feedback.

My aim is to produce code of sufficient quality to be integrated with
this project.

This is my first attempt at submitting code to any project, so I
appreciate your feedback & patience.

On 5/30/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> Thanks for the patches. Sorry for the delay.
>
> > diff --git a/usr/mmc.c b/usr/mmc.c
> > index e9cc479..d53d0f3 100644
> > --- a/usr/mmc.c
> > +++ b/usr/mmc.c
> > @@ -121,10 +121,24 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
> >       return SAM_STAT_GOOD;
> >  }
> >
>
> trailing spaces

OK - "trailing spaces" is a subject I'm unsure about.

Looking at the code, a 'cat -E mmc.c' shows no trailing spaces...

The "trailing spaces" appears in various mailing lists many times (not
just this one), so any tips, references to this subject is most
welcome.
  ============================
[snip]
        size = cmd->dev->size >> MMC_BLK_SHIFT;$
$
        data[0] = (size >> 32) ?$
                __cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);$
        data[1] = __cpu_to_be32(1U << MMC_BLK_SHIFT);$
        cmd->len = 8;$
$
        return SAM_STAT_GOOD;$
}$
$
  ============================
>
>
> > +static int device_mmc_init(struct scsi_lu *lu)
> > +{
> > +     lu->d_sense = 1;
> > +     return 0;
> > +}
> > +
> > +static int device_mmc_shutdown(struct scsi_lu *lu)
> > +{
> > +     return 0;
> > +}
>
> In general, the kernel uses init/exit pair, I guess. So I prefer it.

Easily changed..

>
>
> >  struct device_type_template mmc_template = {
> >       .type   = TYPE_ROM,
> >       .name   = "cdrom/dvd",
> >       .pid    = "VIRTUAL-CDROM",
> > +     .device_init = device_mmc_init,
> > +     .device_shutdown = device_mmc_shutdown,
> > +     .device_config = spc_device_config,
>
> lu_init/lu_exit/lu_config looks better?

OK.

>
> Yeah, it would be better to rename device_* functions too. I take care
> about that.

Yeah, I saw this and I have made it consistent


>
> >       .ops    = {
> >               {spc_test_unit,},
> >               {spc_illegal_op,},
> > diff --git a/usr/osd.c b/usr/osd.c
> > index 46bf0a0..64e7b2a 100644
> > --- a/usr/osd.c
> > +++ b/usr/osd.c
> > @@ -145,15 +145,22 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
> >       return cmd->c_target->bst->bs_cmd_submit(cmd);
> >  }
> >
>
> trailing spaces
>
> All the patches seem to have tons of trailing spaces.

Request for assistance in identifying why these are occurring in a
previous comment..

>
>
> > +int spc_mode_sense(int host_no, struct scsi_cmd *cmd, struct list_head * mode_head)
> > +{
> > +     int             ret = SAM_STAT_GOOD, len;
>
> Should be:
>
> int ret = SAM_STAT_GOOD, len;

OK, I've a habit of inserting a '<tab>' char here. I'll correct my ways. :)

>
>
> > +     uint8_t         pcode = cmd->scb[2] & 0x3f;
> > +     uint64_t        size;
> > +     uint8_t         *data = NULL;
> > +     unsigned char   key = ILLEGAL_REQUEST;
> > +     uint16_t        asc_ascq = E_INVALID_FIELD_IN_CDB;
> > +     struct  mode    * m;
>
> Can you read the Linux coding style document, fix and resubmit the
> patches? If this is the last patchset that you send (hopefully not),
> I'll fix them this time.

Hopefully it is just the beginning.

My aim is for complete SMC / SSC / SPC + other SCSI-3 support.

>
> Please try `git-apply --whitespace=error` before submitting a patch to
> avoid trailing spaces.
>

Cheers
Mark


From fujita.tomonori at lab.ntt.co.jp  Wed May 30 05:44:18 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 30 May 2007 12:44:18 +0900 (JST)
Subject: [Stgt-devel] [Patch 1/8 ] Setup .device_init,
 device_shutdown & device_config to the device template.
In-Reply-To: <f29db9a80705292007q668d539dw61c08957fa0a7d00@mail.gmail.com>
References: <f29db9a80705221958h5f5b808cwf8a448d0c2f0ab@mail.gmail.com>
	<20070529210615Q.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80705292007q668d539dw61c08957fa0a7d00@mail.gmail.com>
Message-ID: <20070530004313V.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] [Patch 1/8 ] Setup .device_init,	device_shutdown & device_config to the device template.
Date: Wed, 30 May 2007 13:07:06 +1000

> This is my first attempt at submitting code to any project, so I
> appreciate your feedback & patience.

No problem. Thanks a lot for the hard work.


> On 5/30/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > Thanks for the patches. Sorry for the delay.
> >
> > > diff --git a/usr/mmc.c b/usr/mmc.c
> > > index e9cc479..d53d0f3 100644
> > > --- a/usr/mmc.c
> > > +++ b/usr/mmc.c
> > > @@ -121,10 +121,24 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
> > >       return SAM_STAT_GOOD;
> > >  }
> > >
> >
> > trailing spaces
> 
> OK - "trailing spaces" is a subject I'm unsure about.
> 
> Looking at the code, a 'cat -E mmc.c' shows no trailing spaces...

Sorry, this part is ok. There are two trailing spaces in the first
patch.

fujita at arbre:~/git/tgt$ git-apply --whitespace=error ~/1x8.diff
Adds trailing whitespace.
/home/fujita/1x8.diff:115:                              " %02x %02x %02x %02x",
Adds trailing whitespace.
/home/fujita/1x8.diff:122:                              " %02x %02x %02x %02x %02x %02x"
fatal: 2 lines add trailing whitespaces.

Putting (setq-default show-trailing-whitespace t) to .emacs might
help. You can do the same thing with vi though I can't recall how.


> > > +     uint8_t         pcode = cmd->scb[2] & 0x3f;
> > > +     uint64_t        size;
> > > +     uint8_t         *data = NULL;
> > > +     unsigned char   key = ILLEGAL_REQUEST;
> > > +     uint16_t        asc_ascq = E_INVALID_FIELD_IN_CDB;
> > > +     struct  mode    * m;
> >
> > Can you read the Linux coding style document, fix and resubmit the
> > patches? If this is the last patchset that you send (hopefully not),
> > I'll fix them this time.
> 
> Hopefully it is just the beginning.
> 
> My aim is for complete SMC / SSC / SPC + other SCSI-3 support.

Thanks, I'm looking forward to it.


From rcj at linux.vnet.ibm.com  Thu May 31 03:26:29 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Wed, 30 May 2007 20:26:29 -0500
Subject: [Stgt-devel] [patch 1/2] passthrough target notification
	function
In-Reply-To: <20070521074623S.fujita.tomonori@lab.ntt.co.jp>
References: <20070518181745.GA5340@austin.ibm.com>
	<20070521074623S.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070531012629.GA10833@austin.ibm.com>

* FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> From: Robert Jennings <rcj at linux.vnet.ibm.com>
> Subject: [Stgt-devel] [patch 1/2] passthrough target notification function
> Date: Fri, 18 May 2007 13:17:45 -0500
> 
> > We spoke about this last week on the mailing list in relation to 
> > pass-through for kernel lld's.  This would notify scsi_tgt of any
> > target logical units that should be handled in the kernel.  Here is a
> > first pass, this is the user-space portion.
> > 
> > Send target state updates to the kernel (in-kernel pass-through enablement)
> 
> Thanks a lot.
> 
> From a quick look, you try to bind an lld to a scsi_host? If so, we
> can't (yeah, user-space code does something like that, but it's
> wrong. it needs be fixed). We need to bind a scsi_host to a tgt
> scsi_host (please read the previous pass-through discussion).

If I'm understanding you correctly, the target software assigns one
scsi_host to only one remote initiator.  This would mean that you want to
assign an entire physical adapter on the target side to a tgt scsi_host
that an initiator will see?  And then this would be a 1:1 relationship
of initiator to target.  Is this all correct?

--Rob Jennings


From fujita.tomonori at lab.ntt.co.jp  Thu May 31 04:07:34 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 31 May 2007 11:07:34 +0900
Subject: [Stgt-devel] [patch 1/2] passthrough target notification
 function
In-Reply-To: <20070531012629.GA10833@austin.ibm.com>
References: <20070518181745.GA5340@austin.ibm.com>
	<20070521074623S.fujita.tomonori@lab.ntt.co.jp>
	<20070531012629.GA10833@austin.ibm.com>
Message-ID: <20070531110734I.fujita.tomonori@lab.ntt.co.jp>

From: Robert Jennings <rcj at linux.vnet.ibm.com>
Subject: Re: [Stgt-devel] [patch 1/2] passthrough target notification function
Date: Wed, 30 May 2007 20:26:29 -0500

> * FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> > From: Robert Jennings <rcj at linux.vnet.ibm.com>
> > Subject: [Stgt-devel] [patch 1/2] passthrough target notification function
> > Date: Fri, 18 May 2007 13:17:45 -0500
> > 
> > > We spoke about this last week on the mailing list in relation to 
> > > pass-through for kernel lld's.  This would notify scsi_tgt of any
> > > target logical units that should be handled in the kernel.  Here is a
> > > first pass, this is the user-space portion.
> > > 
> > > Send target state updates to the kernel (in-kernel pass-through enablement)
> > 
> > Thanks a lot.
> > 
> > From a quick look, you try to bind an lld to a scsi_host? If so, we
> > can't (yeah, user-space code does something like that, but it's
> > wrong. it needs be fixed). We need to bind a scsi_host to a tgt
> > scsi_host (please read the previous pass-through discussion).
> 
> If I'm understanding you correctly, the target software assigns one
> scsi_host to only one remote initiator.  This would mean that you want to
> assign an entire physical adapter on the target side to a tgt scsi_host
> that an initiator will see?  And then this would be a 1:1 relationship
> of initiator to target.  Is this all correct?

Yeah, that's all correct though an entire physical adapter would be an
entire virtual adapter with NPIV.


From markh794 at gmail.com  Thu May 31 04:27:23 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 31 May 2007 12:27:23 +1000
Subject: [Stgt-devel] [Patch 0/2] Re-format / resubmit patch.
Message-ID: <f29db9a80705301927l7ef9bb82h96b0f5eb6329ceb8@mail.gmail.com>

Another attempt to submit part of the 8 part patch sent earlier.

This time, hopefully I have excluded the white space issues and
brought coding standards to acceptable standards :)

Learning about git all the time. This time I've found the
"git-format-patch -p " option and trying that.

Please let me know if I have the wrong options or if this is in fact
the preferred method of generating patch sets.

Note: These two patches do not cover all code submitted in the
previous 8 patch set.

I want to confirm I'm on the right track before re-working all previous patches.

Cheers
Mark
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0001-Add-new-module-entry-points-for-configuration.patch
Type: text/x-patch
Size: 22202 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070531/4da48615/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0002-Add-ability-to-dynamically-set-SCSI-Inquiry-params.patch
Type: text/x-patch
Size: 5729 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070531/4da48615/attachment-0001.bin>

From markh794 at gmail.com  Thu May 31 04:29:48 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 31 May 2007 12:29:48 +1000
Subject: [Stgt-devel] [Patch 1/2]
	Add-new-module-entry-points-for-configuration
Message-ID: <f29db9a80705301929v3e828bb3l574a59cdee1e9dfd@mail.gmail.com>

Add new module entry points.
  <module>_lu_init(struct scsi_lu *lu) - called at setup time.
  <module>_lu_exit(struct scsi_lu *lu) - called at shutdown time.
  <module>_lu_config(struct scsi_lu *lu) - Any module unique configuration.

Moved logical unit configuration from target -> <module>
  Along with above entry point <module>_lu_config(), will allow module
  specific configuration.
  No new functionality added yet.

Add a dump_cdb(struct scsi_cmd *cmd) - Called from spc_illegal_op()

Update - All modules use common INQUIRY routine.

Signed-off-by: Mark Harvey <markh at laptop.(none)>

diff --git a/usr/mmc.c b/usr/mmc.c
index e9cc479..5c6c3d2 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -121,11 +121,32 @@ static int mmc_read_capacity(int host_no, struct
scsi_cmd *cmd)
        return SAM_STAT_GOOD;
 }

+static int mmc_lu_init(struct scsi_lu *lu)
+{
+       if (spc_lu_init(lu))
+               return -ENOMEM;
+
+       memcpy(lu->attributes->ProductIdent, "VIRTUAL-CDROM", 16);
+       lu->attributes->sense_format = 1;
+       lu->attributes->version_desc[0] = 0x02A0; /* MMC3, no version claimed */
+       lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
+       lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
+
+       return 0;
+}
+
+static int mmc_lu_exit(struct scsi_lu *lu)
+{
+       return 0;
+}
+
 struct device_type_template mmc_template = {
-       .type   = TYPE_ROM,
-       .name   = "cdrom/dvd",
-       .pid    = "VIRTUAL-CDROM",
-       .ops    = {
+       .type = TYPE_ROM,
+       .name = "cdrom/dvd",
+       .lu_init = mmc_lu_init,
+       .lu_exit = mmc_lu_exit,
+       .lu_config = spc_lu_config,
+       .ops = {
                {spc_test_unit,},
                {spc_illegal_op,},
                {spc_illegal_op,},
diff --git a/usr/osd.c b/usr/osd.c
index 46bf0a0..1889d5e 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -20,6 +20,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
  */
+#include <errno.h>
 #include <inttypes.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -33,101 +34,6 @@
 #include "scsi.h"
 #include "spc.h"

-#define PRODUCT_ID     "OSD"
-#define PRODUCT_REV    "0"
-
-static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
-{
-       uint8_t *data, *scb = cmd->scb;
-       int len, ret = SAM_STAT_CHECK_CONDITION;
-       unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
-
-       /* EVPD means need a page code */
-       if ((scb[1] & 0x3) == 0 && scb[2] != 0)
-               goto sense;
-
-       data = valloc(pagesize);
-       if (!data) {
-               key = HARDWARE_ERROR;
-               asc = 0;
-               goto sense;
-       }
-       memset(data, 0, pagesize);
-
-       dprintf("%x %x\n", scb[1], scb[2]);
-
-       data[0] = TYPE_OSD;
-       if (!cmd->dev)
-               data[0] = TYPE_NO_LUN;
-
-       if ((scb[1] & 0x1) == 0) {
-               data[2] = 5;  /* modern version */
-               data[3] = 0x02;  /* modern response format */
-               data[7] = 0x02;  /* support command queueing */
-               memset(data + 8, 0x20, 28);
-               memcpy(data + 8,
-                      VENDOR_ID, min_t(size_t, strlen(VENDOR_ID), 8));
-               memcpy(data + 16,
-                      PRODUCT_ID, min_t(size_t, strlen(PRODUCT_ID), 16));
-               memcpy(data + 32,
-                      PRODUCT_REV, min_t(size_t, strlen(PRODUCT_REV), 4));
-               len = 36;
-               if (cmd->dev) {
-                       data[58] = 0x03;
-                       data[59] = 0x40;  /* osd */
-                       data[60] = 0x09;
-                       data[61] = 0x60;  /* iscsi */
-                       data[62] = 0x03;
-                       data[63] = 0x00;  /* spc3 */
-                       len = 64;
-               }
-               data[4] = len - 5;  /* additional length */
-               ret = SAM_STAT_GOOD;
-       } else {
-               if (!cmd->dev)
-                       goto sense;
-
-               data[1] = scb[2];
-               if (scb[2] == 0x0) {
-                       /* supported VPD pages */
-                       data[3] = 3;
-                       data[4] = 0x0;
-                       data[5] = 0x80;
-                       data[6] = 0x83;
-                       len = 7;
-                       ret = SAM_STAT_GOOD;
-               } else if (scb[2] == 0x80) {
-                       /* unit serial number "    " */
-                       data[3] = 4;
-                       memset(data + 4, 0x20, 4);
-                       len = 8;
-                       ret = SAM_STAT_GOOD;
-               } else if (scb[2] == 0x83) {
-                       /* device identification */
-                       data[3] = SCSI_ID_LEN + 4;
-                       data[4] = 0x1;
-                       data[5] = 0x1;
-                       data[7] = SCSI_ID_LEN;
-                       if (cmd->dev)
-                               memcpy(data + 8, cmd->dev->scsi_id,
SCSI_ID_LEN);
-                       len = SCSI_ID_LEN + 8;
-                       ret = SAM_STAT_GOOD;
-               }
-       }
-
-       if (ret != SAM_STAT_GOOD)
-               goto sense;
-
-       cmd->len = min_t(int, len, scb[4]);
-       cmd->uaddr = (unsigned long) data;
-
-       return SAM_STAT_GOOD;
-sense:
-       sense_data_build(cmd, key, asc, 0);
-       cmd->len = 0;
-       return SAM_STAT_CHECK_CONDITION;
-}
-
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 {
        unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
@@ -145,22 +51,37 @@ static int osd_varlen_cdb(int host_no, struct
scsi_cmd *cmd)
        return cmd->c_target->bst->bs_cmd_submit(cmd);
 }

-static void device_osd_init(struct scsi_lu *lu)
+static int osd_lu_init(struct scsi_lu *lu)
+{
+       if (spc_lu_init(lu))
+               return -ENOMEM;
+
+       memcpy(lu->attributes->ProductIdent, "OSD", 16);
+       lu->attributes->sense_format = 1;
+       lu->attributes->version_desc[0] = 0x0340; /* OSD */
+       lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
+       lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
+
+       return 0;
+}
+
+static int osd_lu_exit(struct scsi_lu *lu)
 {
-       lu->d_sense = 1;
+       return 0;
 }

 struct device_type_template osd_template = {
-       .type           = TYPE_OSD,
-       .name           = "osd",
-       .device_init    = device_osd_init,
-       .ops            = {
+       .type = TYPE_OSD,
+       .name = "osd",
+       .lu_init = osd_lu_init,
+       .lu_exit = osd_lu_exit,
+       .ops = {
                [0x00 ... 0x0f] = {spc_illegal_op},

                /* 0x10 */
                {spc_illegal_op,},
                {spc_illegal_op,},
-               {osd_inquiry,},
+               {spc_inquiry,},
                {spc_illegal_op,},
                {spc_illegal_op,},
                {spc_illegal_op,},
diff --git a/usr/parser.h b/usr/parser.h
index 1ff6016..bf210bf 100644
--- a/usr/parser.h
+++ b/usr/parser.h
@@ -17,7 +17,7 @@ struct match_token {
 typedef struct match_token match_table_t[];

 /* Maximum number of arguments that match_token will find in a pattern */
-enum {MAX_OPT_ARGS = 3};
+enum {MAX_OPT_ARGS = 17};

 /* Describe the location within a string of a substring */
 typedef struct {
diff --git a/usr/sbc.c b/usr/sbc.c
index a22d3b0..111f2a7 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -337,11 +337,31 @@ sense:
        return SAM_STAT_CHECK_CONDITION;
 }

+static int sbc_lu_init(struct scsi_lu *lu)
+{
+       if (spc_lu_init(lu))
+               return -ENOMEM;
+
+       memcpy(lu->attributes->ProductIdent, "VIRTUAL-DISK", 16);
+       lu->attributes->version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
+       lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
+       lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
+
+       return 0;
+}
+
+static int sbc_lu_exit(struct scsi_lu *lu)
+{
+       return 0;
+}
+
 struct device_type_template sbc_template = {
-       .type   = TYPE_DISK,
-       .name   = "disk",
-       .pid    = "VIRTUAL-DISK",
-       .ops    = {
+       .type = TYPE_DISK,
+       .name = "disk",
+       .lu_init = sbc_lu_init,
+       .lu_exit = sbc_lu_exit,
+       .lu_config = spc_lu_config,
+       .ops = {
                {spc_test_unit,},
                {spc_illegal_op,},
                {spc_illegal_op,},
diff --git a/usr/scsi.c b/usr/scsi.c
index 1a6929f..728dfe9 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -40,7 +40,7 @@

 void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc,
uint8_t asq)
 {
-       if (cmd->dev && cmd->dev->d_sense) {
+       if (cmd->dev && cmd->dev->attributes->sense_format) {
                /* descriptor format */

                cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
@@ -121,3 +121,4 @@ int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd)
        unsigned char op = cmd->scb[0];
        return cmd->c_target->dev_type_template.ops[op].cmd_perform(host_no,
cmd);
 }
+
diff --git a/usr/spc.c b/usr/spc.c
index b922a45..ab633a4 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -19,6 +19,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
  */
+#include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -27,12 +28,15 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "parser.h"
 #include "target.h"
 #include "driver.h"
+#include "tgtadm_error.h"
 #include "scsi.h"
 #include "spc.h"

 #define PRODUCT_REV    "0"
+#define BLK_SHIFT      9

 int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
@@ -40,7 +44,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
        uint8_t *data;
        uint8_t *scb = cmd->scb;
        unsigned char device_type = cmd->c_target->dev_type_template.type;
-       char *product_id = cmd->c_target->dev_type_template.pid;
+       struct physicalAttributes * attributes = cmd->dev->attributes;
        unsigned char key = ILLEGAL_REQUEST, asc = 0x24;

        if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
@@ -57,22 +61,21 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
        dprintf("%x %x\n", scb[1], scb[2]);

        if (!(scb[1] & 0x3)) {
+               int i;
                data[0] = device_type;
-               data[2] = 4;
+               data[1] = (attributes->isRemovable) ? 0x80 : 0;
+               data[2] = 5;    /* SPC-3 */
                data[3] = 0x42;
-               data[4] = 59;
                data[7] = 0x02;
                memset(data + 8, 0x20, 28);
-               strncpy((char *)data + 8, VENDOR_ID, 8);
-               strncpy((char *)data + 16, product_id, 16);
-               strncpy((char *)data + 32, PRODUCT_REV, 4);
-               data[58] = 0x03;
-               data[59] = 0x20;
-               data[60] = 0x09;
-               data[61] = 0x60;
-               data[62] = 0x03;
-               data[63] = 0x00;
-               len = 64;
+               strncpy((char *)data + 8, attributes->VendorIdent, 8);
+               strncpy((char *)data + 16, attributes->ProductIdent, 16);
+               strncpy((char *)data + 32, attributes->ProductRev, 4);
+               for (i=0, len=58; i < VERSION_DESCRIPTOR_LEN; i++, len += 2) {
+                       data[len] = (attributes->version_desc[i] >> 8) & 0xff;
+                       data[len+1] = attributes->version_desc[i] & 0xff;
+               }
+               data[4] = len - 5;      /* Additional Length */
                ret = SAM_STAT_GOOD;
        } else if (scb[1] & 0x2) {
                /* CmdDt bit is set */
@@ -101,13 +104,13 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
                        len = 4 + SCSI_SN_LEN;
                        ret = SAM_STAT_GOOD;

-                       if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
+                       if (cmd->dev && strlen(cmd->dev->attributes->scsi_sn)) {
                                uint8_t *p;
                                char *q;

                                p = data + 4 + tmp - 1;
-                               q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
-
+                               q = cmd->dev->attributes->scsi_sn +
+                                                               SCSI_SN_LEN - 1;
                                for (; tmp > 0; tmp--, q)
                                        *(p--) = *(q--);
                        }
@@ -120,7 +123,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
                        data[5] = 0x1;
                        data[7] = tmp;
                        if (cmd->dev)
-                               strncpy((char *) data + 8, cmd->dev->scsi_id,
+                               strncpy((char *) data + 8,
+                                       cmd->dev->attributes->scsi_id,
                                        SCSI_ID_LEN);
                        len = tmp + 8;
                        ret = SAM_STAT_GOOD;
@@ -238,9 +242,98 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
        return SAM_STAT_GOOD;
 }

+void dump_cdb(struct scsi_cmd *cmd)
+{
+       uint8_t * cdb = cmd->scb;
+
+       switch(cmd->scb_len) {
+       case 6:
+               dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x",
+                       cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5]);
+               break;
+       case 10:
+               dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
+                               " %02x %02x %02x %02x",
+                       cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
+                       cdb[6], cdb[7], cdb[8], cdb[9]);
+               break;
+       case 12:
+               dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
+                               " %02x %02x %02x %02x %02x %02x",
+                       cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
+                       cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11]);
+               break;
+       case 16:
+               dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
+                               " %02x %02x %02x %02x %02x %02x"
+                               " %02x %02x %02x %02x",
+                       cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
+                       cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11],
+                       cdb[12], cdb[13], cdb[14], cdb[15]);
+               break;
+       }
+}
+
 int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 {
+       dump_cdb(cmd);
        cmd->len = 0;
        sense_data_build(cmd, ILLEGAL_REQUEST, 0x20, 0);
        return SAM_STAT_CHECK_CONDITION;
 }
+
+enum {
+       Opt_scsiid, Opt_scsisn, Opt_err,
+};
+
+static match_table_t tokens = {
+       {Opt_scsiid, "scsi_id=%s"},
+       {Opt_scsisn, "scsi_sn=%s"},
+       {Opt_err, NULL},
+};
+
+int spc_lu_config(struct scsi_lu *lu, char * params) {
+       int err = 0;
+       char *p;
+
+       if (! strncmp("targetOps", params, 9))
+               params = params + 10;
+
+       while ((p = strsep(&params, ",")) != NULL) {
+               substring_t args[MAX_OPT_ARGS];
+               int token;
+               if (!*p)
+                       continue;
+               dprintf("*p : %s\n", p);
+               token = match_token(p, tokens, args);
+               switch (token) {
+               case Opt_scsiid:
+                       match_strncpy(lu->attributes->scsi_id, &args[0],
+                                     sizeof(lu->attributes->scsi_id) - 1);
+                       break;
+               case Opt_scsisn:
+                       match_strncpy(lu->attributes->scsi_sn, &args[0],
+                                     sizeof(lu->attributes->scsi_sn) - 1);
+                       break;
+               default:
+                       err = TGTADM_INVALID_REQUEST;
+               }
+       }
+       return err;
+}
+
+int spc_lu_init(struct scsi_lu * lu)
+{
+       lu->attributes = zalloc(sizeof(struct physicalAttributes));
+       if(! lu->attributes)
+               return -ENOMEM;
+
+       memcpy(lu->attributes->VendorIdent, VENDOR_ID, 8);
+       memcpy(lu->attributes->ProductRev, "0001", 4);
+       lu->attributes->isRemovable = 0;
+       lu->attributes->sense_format = 0;
+       lu->attributes->onLine = 0;
+       lu->attributes->reset = 1;
+
+       return 0;
+}
diff --git a/usr/spc.h b/usr/spc.h
index f81e74c..1036b70 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -7,5 +7,8 @@ extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
 extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
 extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
+extern int spc_lu_init(struct scsi_lu *lu);
+extern int spc_lu_config(struct scsi_lu *lu, char * params);
+extern void dump_cdb(struct scsi_cmd *cmd);

 #endif
diff --git a/usr/target.c b/usr/target.c
index 23f450f..8eb0cd7 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -29,7 +29,6 @@
 #include <sys/socket.h>

 #include "list.h"
-#include "parser.h"
 #include "util.h"
 #include "tgtd.h"
 #include "driver.h"
@@ -247,13 +246,19 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
        lu->lun = lun;
        lu->lu_state = SCSI_LU_RUNNING;

-       snprintf(lu->scsi_id, sizeof(lu->scsi_id),
-                "deadbeaf%d:%" PRIu64, tid, lun);
-
        tgt_cmd_queue_init(&lu->cmd_queue);

-       if (target->dev_type_template.device_init)
-               target->dev_type_template.device_init(lu);
+       if (target->dev_type_template.lu_init)
+               err = target->dev_type_template.lu_init(lu);
+
+       if(! err) {
+               snprintf(lu->attributes->scsi_id,
+                       sizeof(lu->attributes->scsi_id),
+                       "deadbeaf%d:%" PRIu64, tid, lun);
+               snprintf(lu->attributes->scsi_sn,
+                       sizeof(lu->attributes->scsi_sn),
+                       "beaf%d%" PRIu64, tid, lun);
+       }

        list_for_each_entry(pos, &target->device_list, device_siblings) {
                if (lu->lun < pos->lun)
@@ -262,13 +267,14 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
        list_add_tail(&lu->device_siblings, &pos->device_siblings);

        dprintf("Add a logical unit %" PRIu64 " to the target %d\n", lun, tid);
-       return 0;
+       return err;
 }

 int tgt_device_destroy(int tid, uint64_t lun)
 {
        struct target *target;
        struct scsi_lu *lu;
+       int     err;

        dprintf("%u %" PRIu64 "\n", tid, lun);

@@ -281,12 +287,14 @@ int tgt_device_destroy(int tid, uint64_t lun)
        if (!list_empty(&lu->cmd_queue.queue) || lu->cmd_queue.active_cmd)
                return TGTADM_LUN_ACTIVE;

+       err = target->dev_type_template.lu_exit(lu);
+
        free(lu->path);
        list_del(&lu->device_siblings);

        target->bst->bs_close(lu);
        free(lu);
-       return 0;
+       return err;
 }

 int device_reserve(struct scsi_cmd *cmd)
@@ -339,20 +347,9 @@ int device_reserved(struct scsi_cmd *cmd)
        return -EBUSY;
 }

-enum {
-       Opt_scsiid, Opt_scsisn, Opt_err,
-};
-
-static match_table_t tokens = {
-       {Opt_scsiid, "scsi_id=%s"},
-       {Opt_scsisn, "scsi_sn=%s"},
-       {Opt_err, NULL},
-};
-
 int tgt_device_update(int tid, uint64_t dev_id, char *params)
 {
-       int err = 0;
-       char *p;
+       int err = TGTADM_INVALID_REQUEST;
        struct target *target;
        struct scsi_lu *lu;

@@ -366,26 +363,8 @@ int tgt_device_update(int tid, uint64_t dev_id,
char *params)
                return TGTADM_NO_LUN;
        }

-       while ((p = strsep(&params, ",")) != NULL) {
-               substring_t args[MAX_OPT_ARGS];
-               int token;
-               if (!*p)
-                       continue;
-               token = match_token(p, tokens, args);
-
-               switch (token) {
-               case Opt_scsiid:
-                       match_strncpy(lu->scsi_id, &args[0],
-                                     sizeof(lu->scsi_id) - 1);
-                       break;
-               case Opt_scsisn:
-                       match_strncpy(lu->scsi_sn, &args[0],
-                                     sizeof(lu->scsi_sn) - 1);
-                       break;
-               default:
-                       err = TGTADM_INVALID_REQUEST;
-               }
-       }
+       if (target->dev_type_template.lu_config)
+               err = target->dev_type_template.lu_config(lu, params);

        return err;
 }
@@ -474,8 +453,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
                cmd_post_perform(q, cmd);

                dprintf("%" PRIx64 " %x %" PRIx64 " %" PRIu64 " %u %d %d\n",
-                       cmd->tag, cmd->scb[0], cmd->uaddr,
cmd->offset, cmd->len,
-                       result, cmd->async);
+                       cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset,
+                       cmd->len, result, cmd->async);

                set_cmd_processed(cmd);
                if (!cmd->async)
@@ -483,7 +462,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
        } else {
                set_cmd_queued(cmd);
                dprintf("blocked %" PRIx64 " %x %" PRIu64 " %d\n",
-                       cmd->tag, cmd->scb[0], cmd->dev ?
cmd->dev->lun : UINT64_MAX,
+                       cmd->tag, cmd->scb[0],
+                       cmd->dev ? cmd->dev->lun : UINT64_MAX,
                        q->active_cmd);

                list_add_tail(&cmd->qlist, &q->queue);
@@ -1148,8 +1128,8 @@ int tgt_target_show_all(char *buf, int rest)
                                 _TAB3 "Size: %s\n"
                                 _TAB3 "Backing store: %s\n",
                                 lu->lun,
-                                lu->scsi_id,
-                                lu->scsi_sn,
+                                lu->attributes->scsi_id,
+                                lu->attributes->scsi_sn,
                                 print_disksize(lu->size),
                                 lu->path);

diff --git a/usr/tgtadm.c b/usr/tgtadm.c
index e55a785..3d551cc 100644
--- a/usr/tgtadm.c
+++ b/usr/tgtadm.c
@@ -103,6 +103,7 @@ struct option const long_options[] = {
        {"initiator-address", required_argument, NULL, 'I'},
        {"user", required_argument, NULL, 'u'},
        {"password", required_argument, NULL, 'p'},
+       {"params", required_argument, NULL, 'P'},

        {"bus", required_argument, NULL, 'B'},
        {"target-type", required_argument, NULL, 'Y'},
@@ -110,7 +111,7 @@ struct option const long_options[] = {
        {NULL, 0, NULL, 0},
 };

-static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:B:Y:O";
+static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:P:B:Y:O";

 static void usage(int status)
 {
@@ -355,7 +356,7 @@ int main(int argc, char **argv)
        int op, total, tid, rest, mode, t_type, ac_dir;
        uint32_t cid, hostno;
        uint64_t sid, lun;
-       char *name, *value, *path, *targetname, *params, *address;
+       char *name, *value, *path, *targetname, *params, *address, *targetOps;
        char *user, *password;
        char buf[BUFSIZE + sizeof(struct tgtadm_req)];
        struct tgtadm_req *req;
@@ -365,7 +366,7 @@ int main(int argc, char **argv)
        t_type = TYPE_DISK;
        ac_dir = ACCOUNT_TYPE_INCOMING;
        rest = BUFSIZE;
-       name = value = path = targetname = address = NULL;
+       name = value = path = targetname = address = targetOps = NULL;
        user = password = NULL;

        memset(buf, 0, sizeof(buf));
@@ -396,6 +397,9 @@ int main(int argc, char **argv)
                case 'l':
                        lun = strtoull(optarg, NULL, 10);
                        break;
+               case 'P':
+                       targetOps = optarg;
+                       break;
                case 'n':
                        name = optarg;
                        break;
@@ -570,6 +574,10 @@ int main(int argc, char **argv)
        if (password)
                shprintf(total, params, rest, "%spassword=%s",
                         rest == BUFSIZE ? "" : ",", password);
+       // Trailing ',' makes parsing params in modules easier..
+       if (targetOps)
+               shprintf(total, params, rest, "%stargetOps %s,",
+                        rest == BUFSIZE ? "" : ",", targetOps);

        req->len = sizeof(*req) + total;

diff --git a/usr/tgtadm.h b/usr/tgtadm.h
index fb83753..d53cb40 100644
--- a/usr/tgtadm.h
+++ b/usr/tgtadm.h
@@ -4,31 +4,7 @@
 #define TGT_IPC_NAMESPACE      "TGT_IPC_ABSTRACT_NAMESPACE"
 #define TGT_LLD_NAME_LEN       64

-enum tgtadm_errno {
-       TGTADM_SUCCESS,
-       TGTADM_UNKNOWN_ERR,
-       TGTADM_NOMEM,
-       TGTADM_NO_DRIVER,
-       TGTADM_NO_TARGET,
-
-       TGTADM_NO_LUN,
-       TGTADM_NO_SESSION,
-       TGTADM_NO_CONNECTION,
-       TGTADM_TARGET_EXIST,
-       TGTADM_LUN_EXIST,
-
-       TGTADM_ACL_EXIST,
-       TGTADM_USER_EXIST,
-       TGTADM_NO_USER,
-       TGTADM_TOO_MANY_USER,
-       TGTADM_INVALID_REQUEST,
-
-       TGTADM_OUTACCOUNT_EXIST,
-       TGTADM_TARGET_ACTIVE,
-       TGTADM_LUN_ACTIVE,
-       TGTADM_UNSUPPORTED_OPERATION,
-       TGTADM_UNKNOWN_PARAM,
-};
+#include "tgtadm_error.h"

 enum tgtadm_op {
        OP_NEW,
diff --git a/usr/tgtadm_error.h b/usr/tgtadm_error.h
new file mode 100644
index 0000000..319a4ad
--- /dev/null
+++ b/usr/tgtadm_error.h
@@ -0,0 +1,30 @@
+#ifndef TGTADM_ERROR_H
+#define TGTADM_ERROR_H
+
+enum tgtadm_errno {
+       TGTADM_SUCCESS,
+       TGTADM_UNKNOWN_ERR,
+       TGTADM_NOMEM,
+       TGTADM_NO_DRIVER,
+       TGTADM_NO_TARGET,
+
+       TGTADM_NO_LUN,
+       TGTADM_NO_SESSION,
+       TGTADM_NO_CONNECTION,
+       TGTADM_TARGET_EXIST,
+       TGTADM_LUN_EXIST,
+
+       TGTADM_ACL_EXIST,
+       TGTADM_USER_EXIST,
+       TGTADM_NO_USER,
+       TGTADM_TOO_MANY_USER,
+       TGTADM_INVALID_REQUEST,
+
+       TGTADM_OUTACCOUNT_EXIST,
+       TGTADM_TARGET_ACTIVE,
+       TGTADM_LUN_ACTIVE,
+       TGTADM_UNSUPPORTED_OPERATION,
+       TGTADM_UNKNOWN_PARAM,
+};
+
+#endif
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 06e0dd9..8cda864 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -5,6 +5,7 @@

 #define SCSI_ID_LEN    24
 #define SCSI_SN_LEN    8
+#define VERSION_DESCRIPTOR_LEN 8

 #define VENDOR_ID      "IET"

@@ -29,13 +30,27 @@ struct tgt_cmd_queue {
        struct list_head queue;
 };

+struct physicalAttributes {
+       char    scsi_id[SCSI_ID_LEN];
+       char    scsi_sn[SCSI_SN_LEN];
+
+       /* SCSI Inquiry Params */
+       char    VendorIdent[9];
+       char    ProductIdent[17];
+       char    ProductRev[5];
+       uint16_t        version_desc[VERSION_DESCRIPTOR_LEN];
+
+       char    isRemovable;    /* Removable media */
+       char    onLine;
+       char    reset;          /* Power-on or reset */
+       char    sense_format;   /* sense data format */
+};
+
 struct scsi_lu {
        int fd;
        uint64_t addr; /* persistent mapped address */
        uint64_t size;
        uint64_t lun;
-       char scsi_id[SCSI_ID_LEN];
-       char scsi_sn[SCSI_SN_LEN];
        char *path;

        /* the list of devices belonging to a target */
@@ -48,7 +63,7 @@ struct scsi_lu {
        uint64_t reserve_id;

        /* TODO: needs a structure for lots of device parameters */
-       uint8_t d_sense;
+       struct physicalAttributes * attributes;
 };

 struct scsi_cmd {
@@ -121,7 +136,9 @@ struct device_type_template {
        char *name;
        char *pid;

-       void (*device_init)(struct scsi_lu *dev);
+       int (*lu_init)(struct scsi_lu *lu);
+       int (*lu_exit)(struct scsi_lu *lu);
+       int (*lu_config)(struct scsi_lu *lu, char *arg);

        struct device_type_operations ops[256];
 };
-- 
1.5.1.3

markh at laptop:~/patch/2007-5-31$


From markh794 at gmail.com  Thu May 31 04:31:05 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 31 May 2007 12:31:05 +1000
Subject: [Stgt-devel] [Patch 2/2]
	Add-ability-to-dynamically-set-SCSI-Inquiry-params
Message-ID: <f29db9a80705301931v5fdb9b80l39b33c70d25d0e20@mail.gmail.com>

From: Mark Harvey <markh at laptop.(none)>
Date: Thu, 31 May 2007 12:11:21 +1000
Subject: [PATCH] Add ability to dynamically set SCSI Inquiry params.

Added support to configure:
  Vendor Identification
  Product Identification
  Product Revision
  Format of returned 'sense data'
  Define if the lu is capable of supporting removable media
  Define/set if the lu is online / offline.
  Params are passed using the 'tgtadm' utility:

  VendorIdent="string"
  ProductIdent="string"
  ProductRev="string"
  Removable=<0|1> - 0 == non-removable, 1 == removable media
  SenseFormat=<0|1> - 0 == Clasic sense format, 1 == New sense format
  Online=<0|1> - 0 == Unit offline, 1 == Unit Online

e.g.
tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
        --params VendorIdent=QUANTUM,ProductIdent=HD100,ProductRev=0010
tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
        --params Removable=1,SenseFormat=1,Online=1

Example script (scripts/tgt-core-test) to set up HDD & CD device.

Signed-off-by: Mark Harvey <markh at laptop.(none)>

diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
new file mode 100755
index 0000000..37a007c
--- /dev/null
+++ b/scripts/tgt-core-test
@@ -0,0 +1,74 @@
+#!/bin/bash
+
+P=`ps -ef|grep -v grep|grep tgtd|wc -l`
+if [ "X"$P == "X0" ]; then
+       tgtd -d 1
+fi
+
+if [ ! -d /d/01 ]; then
+       mkdir -p /d/01
+fi
+
+if [ ! -f /d/01/hd_block ]; then
+       dd if=/dev/zero of=/d/01/hd_block bs=1M count=8
+fi
+if [ ! -f /d/01/cd_block0 ]; then
+       dd if=/dev/zero of=/d/01/cd_block0 bs=1M count=8
+fi
+if [ ! -f /d/01/cd_block1 ]; then
+       dd if=/dev/zero of=/d/01/cd_block1 bs=1M count=8
+fi
+if [ ! -f /d/01/cd_block2 ]; then
+       dd if=/dev/zero of=/d/01/cd_block2 bs=1M count=8
+fi
+
+set -x
+
+sleep 1
+
+###################################################################################
+# Set up SBC HDD device
+###################################################################################
+TID=1
+
+tgtadm --lld iscsi --mode target --op new --tid $TID \
+               -T iqn.2007-03:marks-vtl_sbc:`hostname` --target-type disk
+
+sleep 1
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b
/d/01/hd_block
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0
--params scsi_sn=FRED00,scsi_id=Fred
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
+       --params
VendorIdent=QUANTUM,ProductIdent=HD100,ProductRev=0010,Removable=1,SenseFormat=1
+
+
+tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
+
+
+###################################################################################
+# Set up MMC CD/DVD device
+###################################################################################
+TID=2
+
+tgtadm --lld iscsi --mode target --op new --tid $TID \
+               -T iqn.2007-03:marks-vtl_mmc:`hostname` --target-type cd
+
+sleep 1
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b
/d/01/cd_block0
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
+       --params
VendorIdent=VirtualCD,ProductIdent=CD101,ProductRev=0010,scsi_sn=XYZZY10,Removable=1
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 1 -b
/d/01/cd_block1
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 1 \
+       --params
VendorIdent=VirtualCD,ProductIdent=CD101,ProductRev=0010,scsi_sn=XYZZY11,Removable=1
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 2 -b
/d/01/cd_block2
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 2 \
+       --params
VendorIdent=VirtualCD,ProductIdent=CD101,ProductRev=0010,scsi_sn=XYZZY12,Removable=1
+
+tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
+
+tgtadm --lld iscsi --mode target --op show
+
+
diff --git a/usr/spc.c b/usr/spc.c
index ab633a4..bccce10 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -283,18 +283,29 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 }

 enum {
-       Opt_scsiid, Opt_scsisn, Opt_err,
+       Opt_scsiid, Opt_scsisn,
+       Opt_VendorIdent, Opt_ProductIdent,
+       Opt_ProductRev, Opt_SenseFormat,
+       Opt_Removable, Opt_Online,
+       Opt_err,
 };

 static match_table_t tokens = {
        {Opt_scsiid, "scsi_id=%s"},
        {Opt_scsisn, "scsi_sn=%s"},
+       {Opt_VendorIdent, "VendorIdent=%s"},
+       {Opt_ProductIdent, "ProductIdent=%s"},
+       {Opt_ProductRev, "ProductRev=%s"},
+       {Opt_SenseFormat, "SenseFormat=%s"},
+       {Opt_Removable, "Removable=%s"},
+       {Opt_Online, "Online=%s"},
        {Opt_err, NULL},
 };

 int spc_lu_config(struct scsi_lu *lu, char * params) {
        int err = 0;
        char *p;
+       char buf[20];

        if (! strncmp("targetOps", params, 9))
                params = params + 10;
@@ -315,6 +326,30 @@ int spc_lu_config(struct scsi_lu *lu, char * params) {
                        match_strncpy(lu->attributes->scsi_sn, &args[0],
                                      sizeof(lu->attributes->scsi_sn) - 1);
                        break;
+               case Opt_VendorIdent:
+                       match_strncpy(lu->attributes->VendorIdent, &args[0],
+                                       sizeof(lu->attributes->VendorIdent));
+                       break;
+               case Opt_ProductIdent:
+                       match_strncpy(lu->attributes->ProductIdent, &args[0],
+                                       sizeof(lu->attributes->ProductIdent));
+                       break;
+               case Opt_ProductRev:
+                       match_strncpy(lu->attributes->ProductRev, &args[0],
+                                       sizeof(lu->attributes->ProductRev));
+                       break;
+               case Opt_SenseFormat:
+                       match_strncpy(buf, &args[0],  sizeof(buf));
+                       lu->attributes->sense_format = atoi(buf);
+                       break;
+               case Opt_Removable:
+                       match_strncpy(buf, &args[0],  sizeof(buf));
+                       lu->attributes->isRemovable = atoi(buf);
+                       break;
+               case Opt_Online:
+                       match_strncpy(buf, &args[0],  sizeof(buf));
+                       lu->attributes->onLine = atoi(buf);
+                       break;
                default:
                        err = TGTADM_INVALID_REQUEST;
                }
-- 
1.5.1.3


From rcj at linux.vnet.ibm.com  Thu May 31 04:33:49 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Wed, 30 May 2007 21:33:49 -0500
Subject: [Stgt-devel] [patch 1/2] passthrough target notification
	function
In-Reply-To: <20070531110734I.fujita.tomonori@lab.ntt.co.jp>
References: <20070518181745.GA5340@austin.ibm.com>
	<20070521074623S.fujita.tomonori@lab.ntt.co.jp>
	<20070531012629.GA10833@austin.ibm.com>
	<20070531110734I.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070531023349.GC10833@austin.ibm.com>

* FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> From: Robert Jennings <rcj at linux.vnet.ibm.com>
> Subject: Re: [Stgt-devel] [patch 1/2] passthrough target notification function
> Date: Wed, 30 May 2007 20:26:29 -0500
> 
> > * FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> > > From: Robert Jennings <rcj at linux.vnet.ibm.com>
> > > Subject: [Stgt-devel] [patch 1/2] passthrough target notification function
> > > Date: Fri, 18 May 2007 13:17:45 -0500
> > > 
> > > > We spoke about this last week on the mailing list in relation to 
> > > > pass-through for kernel lld's.  This would notify scsi_tgt of any
> > > > target logical units that should be handled in the kernel.  Here is a
> > > > first pass, this is the user-space portion.
> > > > 
> > > > Send target state updates to the kernel (in-kernel pass-through enablement)
> > > 
> > > Thanks a lot.
> > > 
> > > From a quick look, you try to bind an lld to a scsi_host? If so, we
> > > can't (yeah, user-space code does something like that, but it's
> > > wrong. it needs be fixed). We need to bind a scsi_host to a tgt
> > > scsi_host (please read the previous pass-through discussion).
> > 
> > If I'm understanding you correctly, the target software assigns one
> > scsi_host to only one remote initiator.  This would mean that you want to
> > assign an entire physical adapter on the target side to a tgt scsi_host
> > that an initiator will see?  And then this would be a 1:1 relationship
> > of initiator to target.  Is this all correct?
> 
> Yeah, that's all correct though an entire physical adapter would be an
> entire virtual adapter with NPIV.

For ibmvstgt, NPIV wouldn't be involved so I would have to dedicate
an entire scsi adapter and all storage attached to it for each
initiator?


From fujita.tomonori at lab.ntt.co.jp  Thu May 31 05:22:44 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 31 May 2007 12:22:44 +0900
Subject: [Stgt-devel] [Patch 0/2] Re-format / resubmit patch.
In-Reply-To: <f29db9a80705301927l7ef9bb82h96b0f5eb6329ceb8@mail.gmail.com>
References: <f29db9a80705301927l7ef9bb82h96b0f5eb6329ceb8@mail.gmail.com>
Message-ID: <20070531122244N.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 0/2] Re-format / resubmit patch.
Date: Thu, 31 May 2007 12:27:23 +1000

> From eaa5ed94a6ce59ab2025ecfb11fc0b3a400fce14 Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh at laptop.(none)>
> Date: Thu, 31 May 2007 06:31:57 +1000
> Subject: [PATCH] Add new module entry points for configuration.

You don't need a period in a subject.


> Add new module entry points.
>   <module>_lu_init(struct scsi_lu *lu) - called at setup time.
>   <module>_lu_exit(struct scsi_lu *lu) - called at shutdown time.
>   <module>_lu_config(struct scsi_lu *lu) - Any module unique configuration.
> 
> Moved logical unit configuration from target -> <module>
>   Along with above entry point <module>_lu_config(), will allow module
>   specific configuration.
>   No new functionality added yet.
> 
> Add a dump_cdb(struct scsi_cmd *cmd) - Called from spc_illegal_op()
> 
> Update - All modules use common INQUIRY routine.
> 
> Signed-off-by: Mark Harvey <markh at laptop.(none)>

Please a proper address. setting GIT_AUTHOR_NAME and GIT_AUTHOR_EMAIL
would work for you.

BTW, I'll put your email address to the git tree so please use the
proper address instead of something like 'markh794 at gmail dot com'
for Copyright.


> diff --git a/usr/mmc.c b/usr/mmc.c
> index e9cc479..5c6c3d2 100644
> --- a/usr/mmc.c
> +++ b/usr/mmc.c
> @@ -121,11 +121,32 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
>  	return SAM_STAT_GOOD;
>  }
>  
> +static int mmc_lu_init(struct scsi_lu *lu)
> +{
> +	if (spc_lu_init(lu))
> +		return -ENOMEM;
> +
> +	memcpy(lu->attributes->ProductIdent, "VIRTUAL-CDROM", 16);
> +	lu->attributes->sense_format = 1;
> +	lu->attributes->version_desc[0] = 0x02A0; /* MMC3, no version claimed */
> +	lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
> +	lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
> +
> +	return 0;
> +}
> +
> +static int mmc_lu_exit(struct scsi_lu *lu)
> +{
> +	return 0;
> +}
> +
>  struct device_type_template mmc_template = {
> -	.type	= TYPE_ROM,
> -	.name	= "cdrom/dvd",
> -	.pid	= "VIRTUAL-CDROM",
> -	.ops	= {
> +	.type = TYPE_ROM,
> +	.name = "cdrom/dvd",
> +	.lu_init = mmc_lu_init,
> +	.lu_exit = mmc_lu_exit,
> +	.lu_config = spc_lu_config,
> +	.ops = {
>  		{spc_test_unit,},
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
> diff --git a/usr/osd.c b/usr/osd.c
> index 46bf0a0..1889d5e 100644
> --- a/usr/osd.c
> +++ b/usr/osd.c
> @@ -20,6 +20,7 @@
>   * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
>   * 02110-1301 USA
>   */
> +#include <errno.h>
>  #include <inttypes.h>
>  #include <stdio.h>
>  #include <stdlib.h>
> @@ -33,101 +34,6 @@
>  #include "scsi.h"
>  #include "spc.h"
>  
> -#define PRODUCT_ID	"OSD"
> -#define PRODUCT_REV	"0"
> -
> -static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
> -{
> -	uint8_t *data, *scb = cmd->scb;
> -	int len, ret = SAM_STAT_CHECK_CONDITION;
> -	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
> -
> -	/* EVPD means need a page code */
> -	if ((scb[1] & 0x3) == 0 && scb[2] != 0)
> -		goto sense;
> -
> -	data = valloc(pagesize);
> -	if (!data) {
> -		key = HARDWARE_ERROR;
> -		asc = 0;
> -		goto sense;
> -	}
> -	memset(data, 0, pagesize);
> -
> -	dprintf("%x %x\n", scb[1], scb[2]);
> -
> -	data[0] = TYPE_OSD;
> -	if (!cmd->dev)
> -		data[0] = TYPE_NO_LUN;
> -
> -	if ((scb[1] & 0x1) == 0) {
> -		data[2] = 5;  /* modern version */
> -		data[3] = 0x02;  /* modern response format */
> -		data[7] = 0x02;  /* support command queueing */
> -		memset(data + 8, 0x20, 28);
> -		memcpy(data + 8,
> -		       VENDOR_ID, min_t(size_t, strlen(VENDOR_ID), 8));
> -		memcpy(data + 16,
> -		       PRODUCT_ID, min_t(size_t, strlen(PRODUCT_ID), 16));
> -		memcpy(data + 32,
> -		       PRODUCT_REV, min_t(size_t, strlen(PRODUCT_REV), 4));
> -		len = 36;
> -		if (cmd->dev) {
> -			data[58] = 0x03;
> -			data[59] = 0x40;  /* osd */
> -			data[60] = 0x09;
> -			data[61] = 0x60;  /* iscsi */
> -			data[62] = 0x03;
> -			data[63] = 0x00;  /* spc3 */
> -			len = 64;
> -		}
> -		data[4] = len - 5;  /* additional length */
> -		ret = SAM_STAT_GOOD;
> -	} else {
> -		if (!cmd->dev)
> -			goto sense;
> -
> -		data[1] = scb[2];
> -		if (scb[2] == 0x0) {
> -			/* supported VPD pages */
> -			data[3] = 3;
> -			data[4] = 0x0;
> -			data[5] = 0x80;
> -			data[6] = 0x83;
> -			len = 7;
> -			ret = SAM_STAT_GOOD;
> -		} else if (scb[2] == 0x80) {
> -			/* unit serial number "    " */
> -			data[3] = 4;
> -			memset(data + 4, 0x20, 4);
> -			len = 8;
> -			ret = SAM_STAT_GOOD;
> -		} else if (scb[2] == 0x83) {
> -			/* device identification */
> -			data[3] = SCSI_ID_LEN + 4;
> -			data[4] = 0x1;
> -			data[5] = 0x1;
> -			data[7] = SCSI_ID_LEN;
> -			if (cmd->dev)
> -				memcpy(data + 8, cmd->dev->scsi_id, SCSI_ID_LEN);
> -			len = SCSI_ID_LEN + 8;
> -			ret = SAM_STAT_GOOD;
> -		}
> -	}
> -
> -	if (ret != SAM_STAT_GOOD)
> -		goto sense;
> -
> -	cmd->len = min_t(int, len, scb[4]);
> -	cmd->uaddr = (unsigned long) data;
> -
> -	return SAM_STAT_GOOD;
> -sense:
> -	sense_data_build(cmd, key, asc, 0);
> -	cmd->len = 0;
> -	return SAM_STAT_CHECK_CONDITION;
> -}
> -
>  static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
>  {
>  	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
> @@ -145,22 +51,37 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
>  	return cmd->c_target->bst->bs_cmd_submit(cmd);
>  }
>  
> -static void device_osd_init(struct scsi_lu *lu)
> +static int osd_lu_init(struct scsi_lu *lu)
> +{
> +	if (spc_lu_init(lu))
> +		return -ENOMEM;
> +
> +	memcpy(lu->attributes->ProductIdent, "OSD", 16);
> +	lu->attributes->sense_format = 1;
> +	lu->attributes->version_desc[0] = 0x0340; /* OSD */
> +	lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
> +	lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
> +
> +	return 0;
> +}
> +
> +static int osd_lu_exit(struct scsi_lu *lu)
>  {
> -	lu->d_sense = 1;
> +	return 0;
>  }
>  
>  struct device_type_template osd_template = {
> -	.type		= TYPE_OSD,
> -	.name		= "osd",
> -	.device_init	= device_osd_init,
> -	.ops		= {

You can use tabs here. So let them alone.


> +	.type = TYPE_OSD,
> +	.name = "osd",
> +	.lu_init = osd_lu_init,
> +	.lu_exit = osd_lu_exit,
> +	.ops = {
>  		[0x00 ... 0x0f] = {spc_illegal_op},
>  
>  		/* 0x10 */
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
> -		{osd_inquiry,},
> +		{spc_inquiry,},
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
> diff --git a/usr/parser.h b/usr/parser.h
> index 1ff6016..bf210bf 100644
> --- a/usr/parser.h
> +++ b/usr/parser.h
> @@ -17,7 +17,7 @@ struct match_token {
>  typedef struct match_token match_table_t[];
>  
>  /* Maximum number of arguments that match_token will find in a pattern */
> -enum {MAX_OPT_ARGS = 3};
> +enum {MAX_OPT_ARGS = 17};
>  
>  /* Describe the location within a string of a substring */
>  typedef struct {
> diff --git a/usr/sbc.c b/usr/sbc.c
> index a22d3b0..111f2a7 100644
> --- a/usr/sbc.c
> +++ b/usr/sbc.c
> @@ -337,11 +337,31 @@ sense:
>  	return SAM_STAT_CHECK_CONDITION;
>  }
>  
> +static int sbc_lu_init(struct scsi_lu *lu)
> +{
> +	if (spc_lu_init(lu))
> +		return -ENOMEM;
> +
> +	memcpy(lu->attributes->ProductIdent, "VIRTUAL-DISK", 16);
> +	lu->attributes->version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
> +	lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
> +	lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
> +
> +	return 0;
> +}
> +
> +static int sbc_lu_exit(struct scsi_lu *lu)
> +{
> +	return 0;
> +}
> +
>  struct device_type_template sbc_template = {
> -	.type	= TYPE_DISK,
> -	.name	= "disk",
> -	.pid	= "VIRTUAL-DISK",
> -	.ops	= {
> +	.type = TYPE_DISK,
> +	.name = "disk",
> +	.lu_init = sbc_lu_init,
> +	.lu_exit = sbc_lu_exit,
> +	.lu_config = spc_lu_config,
> +	.ops = {
>  		{spc_test_unit,},
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
> diff --git a/usr/scsi.c b/usr/scsi.c
> index 1a6929f..728dfe9 100644
> --- a/usr/scsi.c
> +++ b/usr/scsi.c
> @@ -40,7 +40,7 @@
>  
>  void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
>  {
> -	if (cmd->dev && cmd->dev->d_sense) {
> +	if (cmd->dev && cmd->dev->attributes->sense_format) {
>  		/* descriptor format */
>  
>  		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
> @@ -121,3 +121,4 @@ int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd)
>  	unsigned char op = cmd->scb[0];
>  	return cmd->c_target->dev_type_template.ops[op].cmd_perform(host_no, cmd);
>  }
> +
> diff --git a/usr/spc.c b/usr/spc.c
> index b922a45..ab633a4 100644
> --- a/usr/spc.c
> +++ b/usr/spc.c
> @@ -19,6 +19,7 @@
>   * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
>   * 02110-1301 USA
>   */
> +#include <errno.h>
>  #include <stdio.h>
>  #include <stdlib.h>
>  #include <string.h>
> @@ -27,12 +28,15 @@
>  #include "list.h"
>  #include "util.h"
>  #include "tgtd.h"
> +#include "parser.h"
>  #include "target.h"
>  #include "driver.h"
> +#include "tgtadm_error.h"
>  #include "scsi.h"
>  #include "spc.h"
>  
>  #define PRODUCT_REV	"0"
> +#define BLK_SHIFT	9
>  
>  int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  {
> @@ -40,7 +44,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  	uint8_t *data;
>  	uint8_t *scb = cmd->scb;
>  	unsigned char device_type = cmd->c_target->dev_type_template.type;
> -	char *product_id = cmd->c_target->dev_type_template.pid;
> +	struct physicalAttributes * attributes = cmd->dev->attributes;
>  	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
>  
>  	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
> @@ -57,22 +61,21 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  	dprintf("%x %x\n", scb[1], scb[2]);
>  
>  	if (!(scb[1] & 0x3)) {
> +		int i;
>  		data[0] = device_type;
> -		data[2] = 4;
> +		data[1] = (attributes->isRemovable) ? 0x80 : 0;
> +		data[2] = 5;	/* SPC-3 */
>  		data[3] = 0x42;
> -		data[4] = 59;
>  		data[7] = 0x02;
>  		memset(data + 8, 0x20, 28);
> -		strncpy((char *)data + 8, VENDOR_ID, 8);
> -		strncpy((char *)data + 16, product_id, 16);
> -		strncpy((char *)data + 32, PRODUCT_REV, 4);
> -		data[58] = 0x03;
> -		data[59] = 0x20;
> -		data[60] = 0x09;
> -		data[61] = 0x60;
> -		data[62] = 0x03;
> -		data[63] = 0x00;
> -		len = 64;
> +		strncpy((char *)data + 8, attributes->VendorIdent, 8);
> +		strncpy((char *)data + 16, attributes->ProductIdent, 16);
> +		strncpy((char *)data + 32, attributes->ProductRev, 4);
> +		for (i=0, len=58; i < VERSION_DESCRIPTOR_LEN; i++, len += 2) {
> +			data[len] = (attributes->version_desc[i] >> 8) & 0xff;
> +			data[len+1] = attributes->version_desc[i] & 0xff;
> +		}
> +		data[4] = len - 5;	/* Additional Length */
>  		ret = SAM_STAT_GOOD;
>  	} else if (scb[1] & 0x2) {
>  		/* CmdDt bit is set */
> @@ -101,13 +104,13 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  			len = 4 + SCSI_SN_LEN;
>  			ret = SAM_STAT_GOOD;
>  
> -			if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
> +			if (cmd->dev && strlen(cmd->dev->attributes->scsi_sn)) {
>  				uint8_t *p;
>  				char *q;
>  
>  				p = data + 4 + tmp - 1;
> -				q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
> -
> +				q = cmd->dev->attributes->scsi_sn +
> +								SCSI_SN_LEN - 1;
>  				for (; tmp > 0; tmp--, q)
>  					*(p--) = *(q--);
>  			}
> @@ -120,7 +123,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  			data[5] = 0x1;
>  			data[7] = tmp;
>  			if (cmd->dev)
> -				strncpy((char *) data + 8, cmd->dev->scsi_id,
> +				strncpy((char *) data + 8,
> +					cmd->dev->attributes->scsi_id,
>  				        SCSI_ID_LEN);
>  			len = tmp + 8;
>  			ret = SAM_STAT_GOOD;
> @@ -238,9 +242,98 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
>  	return SAM_STAT_GOOD;
>  }
>  
> +void dump_cdb(struct scsi_cmd *cmd)
> +{
> +	uint8_t * cdb = cmd->scb;
> +
> +	switch(cmd->scb_len) {
> +	case 6:
> +		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x",
> +			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5]);
> +		break;
> +	case 10:
> +		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
> +				" %02x %02x %02x %02x",
> +			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
> +			cdb[6], cdb[7], cdb[8], cdb[9]);
> +		break;
> +	case 12:
> +		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
> +				" %02x %02x %02x %02x %02x %02x",
> +			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
> +			cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11]);
> +		break;
> +	case 16:
> +		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
> +				" %02x %02x %02x %02x %02x %02x"
> +				" %02x %02x %02x %02x",
> +			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
> +			cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11],
> +			cdb[12], cdb[13], cdb[14], cdb[15]);
> +		break;
> +	}
> +}
> +
>  int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
>  {
> +	dump_cdb(cmd);
>  	cmd->len = 0;
>  	sense_data_build(cmd, ILLEGAL_REQUEST, 0x20, 0);
>  	return SAM_STAT_CHECK_CONDITION;
>  }
> +
> +enum {
> +	Opt_scsiid, Opt_scsisn, Opt_err,
> +};
> +
> +static match_table_t tokens = {
> +	{Opt_scsiid, "scsi_id=%s"},
> +	{Opt_scsisn, "scsi_sn=%s"},
> +	{Opt_err, NULL},
> +};
> +
> +int spc_lu_config(struct scsi_lu *lu, char * params) {
> +	int err = 0;
> +	char *p;
> +
> +	if (! strncmp("targetOps", params, 9))
> +		params = params + 10;

Should be:

+	if (!strncmp("targetOps", params, 9))


> +	while ((p = strsep(&params, ",")) != NULL) {
> +		substring_t args[MAX_OPT_ARGS];
> +		int token;
> +		if (!*p)
> +			continue;
> +		dprintf("*p : %s\n", p);
> +		token = match_token(p, tokens, args);
> +		switch (token) {
> +		case Opt_scsiid:
> +			match_strncpy(lu->attributes->scsi_id, &args[0],
> +				      sizeof(lu->attributes->scsi_id) - 1);
> +			break;
> +		case Opt_scsisn:
> +			match_strncpy(lu->attributes->scsi_sn, &args[0],
> +				      sizeof(lu->attributes->scsi_sn) - 1);
> +			break;
> +		default:
> +			err = TGTADM_INVALID_REQUEST;
> +		}
> +	}
> +	return err;
> +}
> +
> +int spc_lu_init(struct scsi_lu * lu)
> +{
> +	lu->attributes = zalloc(sizeof(struct physicalAttributes));
> +	if(! lu->attributes)
> +		return -ENOMEM;

ditto.


> +	memcpy(lu->attributes->VendorIdent, VENDOR_ID, 8);
> +	memcpy(lu->attributes->ProductRev, "0001", 4);
> +	lu->attributes->isRemovable = 0;
> +	lu->attributes->sense_format = 0;
> +	lu->attributes->onLine = 0;
> +	lu->attributes->reset = 1;
> +
> +	return 0;
> +}
> diff --git a/usr/spc.h b/usr/spc.h
> index f81e74c..1036b70 100644
> --- a/usr/spc.h
> +++ b/usr/spc.h
> @@ -7,5 +7,8 @@ extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
>  extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
>  extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
>  extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
> +extern int spc_lu_init(struct scsi_lu *lu);
> +extern int spc_lu_config(struct scsi_lu *lu, char * params);
> +extern void dump_cdb(struct scsi_cmd *cmd);
>  
>  #endif
> diff --git a/usr/target.c b/usr/target.c
> index 23f450f..8eb0cd7 100644
> --- a/usr/target.c
> +++ b/usr/target.c
> @@ -29,7 +29,6 @@
>  #include <sys/socket.h>
>  
>  #include "list.h"
> -#include "parser.h"
>  #include "util.h"
>  #include "tgtd.h"
>  #include "driver.h"
> @@ -247,13 +246,19 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
>  	lu->lun = lun;
>  	lu->lu_state = SCSI_LU_RUNNING;
>  
> -	snprintf(lu->scsi_id, sizeof(lu->scsi_id),
> -		 "deadbeaf%d:%" PRIu64, tid, lun);
> -
>  	tgt_cmd_queue_init(&lu->cmd_queue);
>  
> -	if (target->dev_type_template.device_init)
> -		target->dev_type_template.device_init(lu);
> +	if (target->dev_type_template.lu_init)
> +		err = target->dev_type_template.lu_init(lu);
> +
> +	if(! err) {

ditto.


> +		snprintf(lu->attributes->scsi_id,
> +			sizeof(lu->attributes->scsi_id),
> +			"deadbeaf%d:%" PRIu64, tid, lun);
> +		snprintf(lu->attributes->scsi_sn,
> +			sizeof(lu->attributes->scsi_sn),
> +			"beaf%d%" PRIu64, tid, lun);
> +	}
>  
>  	list_for_each_entry(pos, &target->device_list, device_siblings) {
>  		if (lu->lun < pos->lun)
> @@ -262,13 +267,14 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
>  	list_add_tail(&lu->device_siblings, &pos->device_siblings);
>  
>  	dprintf("Add a logical unit %" PRIu64 " to the target %d\n", lun, tid);
> -	return 0;
> +	return err;
>  }
>  
>  int tgt_device_destroy(int tid, uint64_t lun)
>  {
>  	struct target *target;
>  	struct scsi_lu *lu;
> +	int	err;

Should be:

> +	int err;



>  	dprintf("%u %" PRIu64 "\n", tid, lun);
>  
> @@ -281,12 +287,14 @@ int tgt_device_destroy(int tid, uint64_t lun)
>  	if (!list_empty(&lu->cmd_queue.queue) || lu->cmd_queue.active_cmd)
>  		return TGTADM_LUN_ACTIVE;
>  
> +	err = target->dev_type_template.lu_exit(lu);
> +
>  	free(lu->path);
>  	list_del(&lu->device_siblings);
>  
>  	target->bst->bs_close(lu);
>  	free(lu);
> -	return 0;
> +	return err;
>  }
>  
>  int device_reserve(struct scsi_cmd *cmd)
> @@ -339,20 +347,9 @@ int device_reserved(struct scsi_cmd *cmd)
>  	return -EBUSY;
>  }
>  
> -enum {
> -	Opt_scsiid, Opt_scsisn, Opt_err,
> -};
> -
> -static match_table_t tokens = {
> -	{Opt_scsiid, "scsi_id=%s"},
> -	{Opt_scsisn, "scsi_sn=%s"},
> -	{Opt_err, NULL},
> -};
> -
>  int tgt_device_update(int tid, uint64_t dev_id, char *params)
>  {
> -	int err = 0;
> -	char *p;
> +	int err = TGTADM_INVALID_REQUEST;
>  	struct target *target;
>  	struct scsi_lu *lu;
>  
> @@ -366,26 +363,8 @@ int tgt_device_update(int tid, uint64_t dev_id, char *params)
>  		return TGTADM_NO_LUN;
>  	}
>  
> -	while ((p = strsep(&params, ",")) != NULL) {
> -		substring_t args[MAX_OPT_ARGS];
> -		int token;
> -		if (!*p)
> -			continue;
> -		token = match_token(p, tokens, args);
> -
> -		switch (token) {
> -		case Opt_scsiid:
> -			match_strncpy(lu->scsi_id, &args[0],
> -				      sizeof(lu->scsi_id) - 1);
> -			break;
> -		case Opt_scsisn:
> -			match_strncpy(lu->scsi_sn, &args[0],
> -				      sizeof(lu->scsi_sn) - 1);
> -			break;
> -		default:
> -			err = TGTADM_INVALID_REQUEST;
> -		}
> -	}
> +	if (target->dev_type_template.lu_config)
> +		err = target->dev_type_template.lu_config(lu, params);
>  
>  	return err;
>  }
> @@ -474,8 +453,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
>  		cmd_post_perform(q, cmd);
>  
>  		dprintf("%" PRIx64 " %x %" PRIx64 " %" PRIu64 " %u %d %d\n",
> -			cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset, cmd->len,
> -			result, cmd->async);
> +			cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset,
> +			cmd->len, result, cmd->async);
>  
>  		set_cmd_processed(cmd);
>  		if (!cmd->async)
> @@ -483,7 +462,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
>  	} else {
>  		set_cmd_queued(cmd);
>  		dprintf("blocked %" PRIx64 " %x %" PRIu64 " %d\n",
> -			cmd->tag, cmd->scb[0], cmd->dev ? cmd->dev->lun : UINT64_MAX,
> +			cmd->tag, cmd->scb[0],
> +			cmd->dev ? cmd->dev->lun : UINT64_MAX,
>  			q->active_cmd);
>  
>  		list_add_tail(&cmd->qlist, &q->queue);
> @@ -1148,8 +1128,8 @@ int tgt_target_show_all(char *buf, int rest)
>  				 _TAB3 "Size: %s\n"
>  				 _TAB3 "Backing store: %s\n",
>  				 lu->lun,
> -				 lu->scsi_id,
> -				 lu->scsi_sn,
> +				 lu->attributes->scsi_id,
> +				 lu->attributes->scsi_sn,
>  				 print_disksize(lu->size),
>  				 lu->path);
>  
> diff --git a/usr/tgtadm.c b/usr/tgtadm.c
> index e55a785..3d551cc 100644
> --- a/usr/tgtadm.c
> +++ b/usr/tgtadm.c
> @@ -103,6 +103,7 @@ struct option const long_options[] = {
>  	{"initiator-address", required_argument, NULL, 'I'},
>  	{"user", required_argument, NULL, 'u'},
>  	{"password", required_argument, NULL, 'p'},
> +	{"params", required_argument, NULL, 'P'},
>  
>  	{"bus", required_argument, NULL, 'B'},
>  	{"target-type", required_argument, NULL, 'Y'},
> @@ -110,7 +111,7 @@ struct option const long_options[] = {
>  	{NULL, 0, NULL, 0},
>  };
>  
> -static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:B:Y:O";
> +static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:P:B:Y:O";
>  
>  static void usage(int status)
>  {
> @@ -355,7 +356,7 @@ int main(int argc, char **argv)
>  	int op, total, tid, rest, mode, t_type, ac_dir;
>  	uint32_t cid, hostno;
>  	uint64_t sid, lun;
> -	char *name, *value, *path, *targetname, *params, *address;
> +	char *name, *value, *path, *targetname, *params, *address, *targetOps;
>  	char *user, *password;
>  	char buf[BUFSIZE + sizeof(struct tgtadm_req)];
>  	struct tgtadm_req *req;
> @@ -365,7 +366,7 @@ int main(int argc, char **argv)
>  	t_type = TYPE_DISK;
>  	ac_dir = ACCOUNT_TYPE_INCOMING;
>  	rest = BUFSIZE;
> -	name = value = path = targetname = address = NULL;
> +	name = value = path = targetname = address = targetOps = NULL;
>  	user = password = NULL;
>  
>  	memset(buf, 0, sizeof(buf));
> @@ -396,6 +397,9 @@ int main(int argc, char **argv)
>  		case 'l':
>  			lun = strtoull(optarg, NULL, 10);
>  			break;
> +		case 'P':
> +			targetOps = optarg;
> +			break;
>  		case 'n':
>  			name = optarg;
>  			break;
> @@ -570,6 +574,10 @@ int main(int argc, char **argv)
>  	if (password)
>  		shprintf(total, params, rest, "%spassword=%s",
>  			 rest == BUFSIZE ? "" : ",", password);
> +	// Trailing ',' makes parsing params in modules easier..
> +	if (targetOps)
> +		shprintf(total, params, rest, "%stargetOps %s,",
> +			 rest == BUFSIZE ? "" : ",", targetOps);
>  
>  	req->len = sizeof(*req) + total;
>  
> diff --git a/usr/tgtadm.h b/usr/tgtadm.h
> index fb83753..d53cb40 100644
> --- a/usr/tgtadm.h
> +++ b/usr/tgtadm.h
> @@ -4,31 +4,7 @@
>  #define TGT_IPC_NAMESPACE	"TGT_IPC_ABSTRACT_NAMESPACE"
>  #define TGT_LLD_NAME_LEN	64
>  
> -enum tgtadm_errno {
> -	TGTADM_SUCCESS,
> -	TGTADM_UNKNOWN_ERR,
> -	TGTADM_NOMEM,
> -	TGTADM_NO_DRIVER,
> -	TGTADM_NO_TARGET,
> -
> -	TGTADM_NO_LUN,
> -	TGTADM_NO_SESSION,
> -	TGTADM_NO_CONNECTION,
> -	TGTADM_TARGET_EXIST,
> -	TGTADM_LUN_EXIST,
> -
> -	TGTADM_ACL_EXIST,
> -	TGTADM_USER_EXIST,
> -	TGTADM_NO_USER,
> -	TGTADM_TOO_MANY_USER,
> -	TGTADM_INVALID_REQUEST,
> -
> -	TGTADM_OUTACCOUNT_EXIST,
> -	TGTADM_TARGET_ACTIVE,
> -	TGTADM_LUN_ACTIVE,
> -	TGTADM_UNSUPPORTED_OPERATION,
> -	TGTADM_UNKNOWN_PARAM,
> -};
> +#include "tgtadm_error.h"
>  
>  enum tgtadm_op {
>  	OP_NEW,
> diff --git a/usr/tgtadm_error.h b/usr/tgtadm_error.h
> new file mode 100644
> index 0000000..319a4ad
> --- /dev/null
> +++ b/usr/tgtadm_error.h
> @@ -0,0 +1,30 @@
> +#ifndef TGTADM_ERROR_H
> +#define TGTADM_ERROR_H
> +
> +enum tgtadm_errno {
> +	TGTADM_SUCCESS,
> +	TGTADM_UNKNOWN_ERR,
> +	TGTADM_NOMEM,
> +	TGTADM_NO_DRIVER,
> +	TGTADM_NO_TARGET,
> +
> +	TGTADM_NO_LUN,
> +	TGTADM_NO_SESSION,
> +	TGTADM_NO_CONNECTION,
> +	TGTADM_TARGET_EXIST,
> +	TGTADM_LUN_EXIST,
> +
> +	TGTADM_ACL_EXIST,
> +	TGTADM_USER_EXIST,
> +	TGTADM_NO_USER,
> +	TGTADM_TOO_MANY_USER,
> +	TGTADM_INVALID_REQUEST,
> +
> +	TGTADM_OUTACCOUNT_EXIST,
> +	TGTADM_TARGET_ACTIVE,
> +	TGTADM_LUN_ACTIVE,
> +	TGTADM_UNSUPPORTED_OPERATION,
> +	TGTADM_UNKNOWN_PARAM,
> +};
> +
> +#endif
> diff --git a/usr/tgtd.h b/usr/tgtd.h
> index 06e0dd9..8cda864 100644
> --- a/usr/tgtd.h
> +++ b/usr/tgtd.h
> @@ -5,6 +5,7 @@
>  
>  #define SCSI_ID_LEN	24
>  #define SCSI_SN_LEN	8
> +#define VERSION_DESCRIPTOR_LEN 8
>  
>  #define VENDOR_ID	"IET"
>  
> @@ -29,13 +30,27 @@ struct tgt_cmd_queue {
>  	struct list_head queue;
>  };
>  
> +struct physicalAttributes {
> +	char	scsi_id[SCSI_ID_LEN];
> +	char	scsi_sn[SCSI_SN_LEN];
> +
> +	/* SCSI Inquiry Params */
> +	char	VendorIdent[9];
> +	char	ProductIdent[17];
> +	char	ProductRev[5];
> +	uint16_t	version_desc[VERSION_DESCRIPTOR_LEN];
> +
> +	char	isRemovable;	/* Removable media */
> +	char	onLine;
> +	char	reset;		/* Power-on or reset */
> +	char	sense_format;	/* sense data format */
> +};
> +
>  struct scsi_lu {
>  	int fd;
>  	uint64_t addr; /* persistent mapped address */
>  	uint64_t size;
>  	uint64_t lun;
> -	char scsi_id[SCSI_ID_LEN];
> -	char scsi_sn[SCSI_SN_LEN];
>  	char *path;
>  
>  	/* the list of devices belonging to a target */
> @@ -48,7 +63,7 @@ struct scsi_lu {
>  	uint64_t reserve_id;
>  
>  	/* TODO: needs a structure for lots of device parameters */
> -	uint8_t d_sense;
> +	struct physicalAttributes * attributes;
>  };
>  
>  struct scsi_cmd {
> @@ -121,7 +136,9 @@ struct device_type_template {
>  	char *name;
>  	char *pid;
>  
> -	void (*device_init)(struct scsi_lu *dev);
> +	int (*lu_init)(struct scsi_lu *lu);
> +	int (*lu_exit)(struct scsi_lu *lu);
> +	int (*lu_config)(struct scsi_lu *lu, char *arg);
>  
>  	struct device_type_operations ops[256];
>  };
> -- 
> 1.5.1.3
> 


From fujita.tomonori at lab.ntt.co.jp  Thu May 31 05:25:27 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 31 May 2007 12:25:27 +0900
Subject: [Stgt-devel] [Patch 0/2] Re-format / resubmit patch.
In-Reply-To: <f29db9a80705301927l7ef9bb82h96b0f5eb6329ceb8@mail.gmail.com>
References: <f29db9a80705301927l7ef9bb82h96b0f5eb6329ceb8@mail.gmail.com>
Message-ID: <20070531122527U.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 0/2] Re-format / resubmit patch.
Date: Thu, 31 May 2007 12:27:23 +1000

> Another attempt to submit part of the 8 part patch sent earlier.
> 
> This time, hopefully I have excluded the white space issues and
> brought coding standards to acceptable standards :)
> 
> Learning about git all the time. This time I've found the
> "git-format-patch -p " option and trying that.
> 
> Please let me know if I have the wrong options or if this is in fact
> the preferred method of generating patch sets.
> 
> Note: These two patches do not cover all code submitted in the
> previous 8 patch set.
> 
> I want to confirm I'm on the right track before re-working all previous patches.

Please a plain mail if possible. But your mailer converted tabs to
spaces so you need to change the configuration.


From markh794 at gmail.com  Thu May 31 05:29:59 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 31 May 2007 13:29:59 +1000
Subject: [Stgt-devel] [Patch 0/2] Re-format / resubmit patch.
In-Reply-To: <20070531122527U.fujita.tomonori@lab.ntt.co.jp>
References: <f29db9a80705301927l7ef9bb82h96b0f5eb6329ceb8@mail.gmail.com>
	<20070531122527U.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80705302029j640979abj3f6843a7841485e7@mail.gmail.com>

On 5/31/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: [Stgt-devel] [Patch 0/2] Re-format / resubmit patch.
> Date: Thu, 31 May 2007 12:27:23 +1000
>
> > Another attempt to submit part of the 8 part patch sent earlier.
> >
> > This time, hopefully I have excluded the white space issues and
> > brought coding standards to acceptable standards :)
> >
> > Learning about git all the time. This time I've found the
> > "git-format-patch -p " option and trying that.
> >
> > Please let me know if I have the wrong options or if this is in fact
> > the preferred method of generating patch sets.
> >
> > Note: These two patches do not cover all code submitted in the
> > previous 8 patch set.
> >
> > I want to confirm I'm on the right track before re-working all previous patches.
>
> Please a plain mail if possible. But your mailer converted tabs to
> spaces so you need to change the configuration.
>

Yeah, I've not figured out how to set up gmail to include patches
within the body.

Hence I've been sending attachments ([patch 0/2] had the attachments.
The other two mails I attempted to inline the contents - unsuccessfully.

I'll keep trying to find the right answer...

Thanks
Mark


From fujita.tomonori at lab.ntt.co.jp  Thu May 31 05:28:33 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 31 May 2007 12:28:33 +0900
Subject: [Stgt-devel] [patch 1/2] passthrough target notification
 function
In-Reply-To: <20070531023349.GC10833@austin.ibm.com>
References: <20070531012629.GA10833@austin.ibm.com>
	<20070531110734I.fujita.tomonori@lab.ntt.co.jp>
	<20070531023349.GC10833@austin.ibm.com>
Message-ID: <20070531122833I.fujita.tomonori@lab.ntt.co.jp>

From: Robert Jennings <rcj at linux.vnet.ibm.com>
Subject: Re: [Stgt-devel] [patch 1/2] passthrough target notification function
Date: Wed, 30 May 2007 21:33:49 -0500

> * FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> > From: Robert Jennings <rcj at linux.vnet.ibm.com>
> > Subject: Re: [Stgt-devel] [patch 1/2] passthrough target notification function
> > Date: Wed, 30 May 2007 20:26:29 -0500
> > 
> > > * FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> > > > From: Robert Jennings <rcj at linux.vnet.ibm.com>
> > > > Subject: [Stgt-devel] [patch 1/2] passthrough target notification function
> > > > Date: Fri, 18 May 2007 13:17:45 -0500
> > > > 
> > > > > We spoke about this last week on the mailing list in relation to 
> > > > > pass-through for kernel lld's.  This would notify scsi_tgt of any
> > > > > target logical units that should be handled in the kernel.  Here is a
> > > > > first pass, this is the user-space portion.
> > > > > 
> > > > > Send target state updates to the kernel (in-kernel pass-through enablement)
> > > > 
> > > > Thanks a lot.
> > > > 
> > > > From a quick look, you try to bind an lld to a scsi_host? If so, we
> > > > can't (yeah, user-space code does something like that, but it's
> > > > wrong. it needs be fixed). We need to bind a scsi_host to a tgt
> > > > scsi_host (please read the previous pass-through discussion).
> > > 
> > > If I'm understanding you correctly, the target software assigns one
> > > scsi_host to only one remote initiator.  This would mean that you want to
> > > assign an entire physical adapter on the target side to a tgt scsi_host
> > > that an initiator will see?  And then this would be a 1:1 relationship
> > > of initiator to target.  Is this all correct?
> > 
> > Yeah, that's all correct though an entire physical adapter would be an
> > entire virtual adapter with NPIV.
> 
> For ibmvstgt, NPIV wouldn't be involved so I would have to dedicate
> an entire scsi adapter and all storage attached to it for each
> initiator?

Yeah. Another option would be sending SCSI commands to user space
once. But I don't know it's worth implementing such feature.


From rcj at linux.vnet.ibm.com  Thu May 31 11:03:04 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Thu, 31 May 2007 04:03:04 -0500
Subject: [Stgt-devel] [patch 1/2] passthrough target notification
	function
In-Reply-To: <20070531122833I.fujita.tomonori@lab.ntt.co.jp>
References: <20070531012629.GA10833@austin.ibm.com>
	<20070531110734I.fujita.tomonori@lab.ntt.co.jp>
	<20070531023349.GC10833@austin.ibm.com>
	<20070531122833I.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070531090304.GE10833@austin.ibm.com>

* FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> From: Robert Jennings <rcj at linux.vnet.ibm.com>
> Subject: Re: [Stgt-devel] [patch 1/2] passthrough target notification function
> Date: Wed, 30 May 2007 21:33:49 -0500
> 
> > * FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> > > From: Robert Jennings <rcj at linux.vnet.ibm.com>
> > > Subject: Re: [Stgt-devel] [patch 1/2] passthrough target notification function
> > > Date: Wed, 30 May 2007 20:26:29 -0500
> > > 
> > > > * FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> > > > > From: Robert Jennings <rcj at linux.vnet.ibm.com>
> > > > > Subject: [Stgt-devel] [patch 1/2] passthrough target notification function
> > > > > Date: Fri, 18 May 2007 13:17:45 -0500
> > > > > 
> > > > > > We spoke about this last week on the mailing list in relation to 
> > > > > > pass-through for kernel lld's.  This would notify scsi_tgt of any
> > > > > > target logical units that should be handled in the kernel.  Here is a
> > > > > > first pass, this is the user-space portion.
> > > > > > 
> > > > > > Send target state updates to the kernel (in-kernel pass-through enablement)
> > > > > 
> > > > > Thanks a lot.
> > > > > 
> > > > > From a quick look, you try to bind an lld to a scsi_host? If so, we
> > > > > can't (yeah, user-space code does something like that, but it's
> > > > > wrong. it needs be fixed). We need to bind a scsi_host to a tgt
> > > > > scsi_host (please read the previous pass-through discussion).
> > > > 
> > > > If I'm understanding you correctly, the target software assigns one
> > > > scsi_host to only one remote initiator.  This would mean that you want to
> > > > assign an entire physical adapter on the target side to a tgt scsi_host
> > > > that an initiator will see?  And then this would be a 1:1 relationship
> > > > of initiator to target.  Is this all correct?
> > > 
> > > Yeah, that's all correct though an entire physical adapter would be an
> > > entire virtual adapter with NPIV.
> > 
> > For ibmvstgt, NPIV wouldn't be involved so I would have to dedicate
> > an entire scsi adapter and all storage attached to it for each
> > initiator?
> 
> Yeah. Another option would be sending SCSI commands to user space
> once. But I don't know it's worth implementing such feature.

I want to pursue a more fine-grained approach.  With the hardware that
supports the ibmvstgt driver the end-user can already assign an I/O
slot to a paritition; providing functionality that maps tgt scsi_host
to scsi_host would be unproductive.  I would like to find a way to
map scsi_device to tgt scsi_lu in a 1:1 relationship for pass-through,
along with the other target types, I think this would provide the most
value to the end-user.

I'm trying to understand the decision because I've missed something.
Were you wanting to bind the scsi_host to a tgt scsi_host and map
more than one initiator to a target?  If not, if we maintained a 1:1
relationship, then I haven't followed why we can't bind a scsi_device
to a tgt scsi_lu.  Wouldn't scsi reservations and event notification
work with that binding, with the caveat that there be no local access
because that breaks the 1:1 relationship?


From fujita.tomonori at lab.ntt.co.jp  Thu May 31 12:59:19 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 31 May 2007 19:59:19 +0900
Subject: [Stgt-devel] [patch 1/2] passthrough target
	notification	function
In-Reply-To: <20070531090304.GE10833@austin.ibm.com>
References: <20070531023349.GC10833@austin.ibm.com>
	<20070531122833I.fujita.tomonori@lab.ntt.co.jp>
	<20070531090304.GE10833@austin.ibm.com>
Message-ID: <20070531195919A.fujita.tomonori@lab.ntt.co.jp>

From: Robert Jennings <rcj at linux.vnet.ibm.com>
Subject: Re: [Stgt-devel] [patch 1/2] passthrough target notification	function
Date: Thu, 31 May 2007 04:03:04 -0500

> * FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> > From: Robert Jennings <rcj at linux.vnet.ibm.com>
> > Subject: Re: [Stgt-devel] [patch 1/2] passthrough target notification function
> > Date: Wed, 30 May 2007 21:33:49 -0500
> > 
> > > * FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> > > > From: Robert Jennings <rcj at linux.vnet.ibm.com>
> > > > Subject: Re: [Stgt-devel] [patch 1/2] passthrough target notification function
> > > > Date: Wed, 30 May 2007 20:26:29 -0500
> > > > 
> > > > > * FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> > > > > > From: Robert Jennings <rcj at linux.vnet.ibm.com>
> > > > > > Subject: [Stgt-devel] [patch 1/2] passthrough target notification function
> > > > > > Date: Fri, 18 May 2007 13:17:45 -0500
> > > > > > 
> > > > > > > We spoke about this last week on the mailing list in relation to 
> > > > > > > pass-through for kernel lld's.  This would notify scsi_tgt of any
> > > > > > > target logical units that should be handled in the kernel.  Here is a
> > > > > > > first pass, this is the user-space portion.
> > > > > > > 
> > > > > > > Send target state updates to the kernel (in-kernel pass-through enablement)
> > > > > > 
> > > > > > Thanks a lot.
> > > > > > 
> > > > > > From a quick look, you try to bind an lld to a scsi_host? If so, we
> > > > > > can't (yeah, user-space code does something like that, but it's
> > > > > > wrong. it needs be fixed). We need to bind a scsi_host to a tgt
> > > > > > scsi_host (please read the previous pass-through discussion).
> > > > > 
> > > > > If I'm understanding you correctly, the target software assigns one
> > > > > scsi_host to only one remote initiator.  This would mean that you want to
> > > > > assign an entire physical adapter on the target side to a tgt scsi_host
> > > > > that an initiator will see?  And then this would be a 1:1 relationship
> > > > > of initiator to target.  Is this all correct?
> > > > 
> > > > Yeah, that's all correct though an entire physical adapter would be an
> > > > entire virtual adapter with NPIV.
> > > 
> > > For ibmvstgt, NPIV wouldn't be involved so I would have to dedicate
> > > an entire scsi adapter and all storage attached to it for each
> > > initiator?
> > 
> > Yeah. Another option would be sending SCSI commands to user space
> > once. But I don't know it's worth implementing such feature.
> 
> I want to pursue a more fine-grained approach.  With the hardware that
> supports the ibmvstgt driver the end-user can already assign an I/O
> slot to a paritition; providing functionality that maps tgt scsi_host
> to scsi_host would be unproductive.  I would like to find a way to
> map scsi_device to tgt scsi_lu in a 1:1 relationship for pass-through,
> along with the other target types, I think this would provide the most
> value to the end-user.
> 
> I'm trying to understand the decision because I've missed something.
> Were you wanting to bind the scsi_host to a tgt scsi_host

Yes.

> and map more than one initiator to a target?

It doesn't matter.

> If not, if we maintained a 1:1 relationship, then I haven't followed
> why we can't bind a scsi_device to a tgt scsi_lu.

Because we need the scsi target state machine in kernel for that.


> Wouldn't scsi
> reservations and event notification work with that binding, with the
> caveat that there be no local access because that breaks the 1:1
> relationship?


From markh794 at gmail.com  Thu May 31 22:00:43 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 1 Jun 2007 06:00:43 +1000
Subject: [PATCH] Add new module entry points for configuration
Message-ID: <mailman.7.1331738471.12506.stgt-devel@lists.berlios.de>

Add new module entry points.
  <module>_lu_init(struct scsi_lu *lu) - called at setup time.
  <module>_lu_exit(struct scsi_lu *lu) - called at shutdown time.
  <module>_lu_config(struct scsi_lu *lu) - Any module unique configuration.

Moved logical unit configuration from target -> <module>
  Along with above entry point <module>_lu_config(), will allow module
  specific configuration.
  No new functionality added yet.

Add a dump_cdb(struct scsi_cmd *cmd) - Called from spc_illegal_op()

Update - All modules use common INQUIRY routine.

Signed-off-by: Mark Harvey <markh794 at gmail.com>

diff --git a/usr/mmc.c b/usr/mmc.c
index e9cc479..ae0a0ca 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -121,11 +121,32 @@ static int mmc_read_capacity(int host_no, struct
scsi_cmd *cmd)
        return SAM_STAT_GOOD;
 }

+static int mmc_lu_init(struct scsi_lu *lu)
+{
+       if (spc_lu_init(lu))
+               return -ENOMEM;
+
+       memcpy(lu->attributes->ProductIdent, "VIRTUAL-CDROM", 16);
+       lu->attributes->sense_format = 1;
+       lu->attributes->version_desc[0] = 0x02A0; /* MMC3, no version claimed */
+       lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
+       lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
+
+       return 0;
+}
+
+static int mmc_lu_exit(struct scsi_lu *lu)
+{
+       return 0;
+}
+
 struct device_type_template mmc_template = {
-       .type   = TYPE_ROM,
-       .name   = "cdrom/dvd",
-       .pid    = "VIRTUAL-CDROM",
-       .ops    = {
+       .type           = TYPE_ROM,
+       .name           = "cdrom/dvd",
+       .lu_init        = mmc_lu_init,
+       .lu_exit        = mmc_lu_exit,
+       .lu_config      = spc_lu_config,
+       .ops            = {
                {spc_test_unit,},
                {spc_illegal_op,},
                {spc_illegal_op,},
diff --git a/usr/osd.c b/usr/osd.c
index 46bf0a0..0ce8fde 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -20,6 +20,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
  */
+#include <errno.h>
 #include <inttypes.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -33,101 +34,6 @@
 #include "scsi.h"
 #include "spc.h"

-#define PRODUCT_ID     "OSD"
-#define PRODUCT_REV    "0"
-
-static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
-{
-       uint8_t *data, *scb = cmd->scb;
-       int len, ret = SAM_STAT_CHECK_CONDITION;
-       unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
-
-       /* EVPD means need a page code */
-       if ((scb[1] & 0x3) == 0 && scb[2] != 0)
-               goto sense;
-
-       data = valloc(pagesize);
-       if (!data) {
-               key = HARDWARE_ERROR;
-               asc = 0;
-               goto sense;
-       }
-       memset(data, 0, pagesize);
-
-       dprintf("%x %x\n", scb[1], scb[2]);
-
-       data[0] = TYPE_OSD;
-       if (!cmd->dev)
-               data[0] = TYPE_NO_LUN;
-
-       if ((scb[1] & 0x1) == 0) {
-               data[2] = 5;  /* modern version */
-               data[3] = 0x02;  /* modern response format */
-               data[7] = 0x02;  /* support command queueing */
-               memset(data + 8, 0x20, 28);
-               memcpy(data + 8,
-                      VENDOR_ID, min_t(size_t, strlen(VENDOR_ID), 8));
-               memcpy(data + 16,
-                      PRODUCT_ID, min_t(size_t, strlen(PRODUCT_ID), 16));
-               memcpy(data + 32,
-                      PRODUCT_REV, min_t(size_t, strlen(PRODUCT_REV), 4));
-               len = 36;
-               if (cmd->dev) {
-                       data[58] = 0x03;
-                       data[59] = 0x40;  /* osd */
-                       data[60] = 0x09;
-                       data[61] = 0x60;  /* iscsi */
-                       data[62] = 0x03;
-                       data[63] = 0x00;  /* spc3 */
-                       len = 64;
-               }
-               data[4] = len - 5;  /* additional length */
-               ret = SAM_STAT_GOOD;
-       } else {
-               if (!cmd->dev)
-                       goto sense;
-
-               data[1] = scb[2];
-               if (scb[2] == 0x0) {
-                       /* supported VPD pages */
-                       data[3] = 3;
-                       data[4] = 0x0;
-                       data[5] = 0x80;
-                       data[6] = 0x83;
-                       len = 7;
-                       ret = SAM_STAT_GOOD;
-               } else if (scb[2] == 0x80) {
-                       /* unit serial number "    " */
-                       data[3] = 4;
-                       memset(data + 4, 0x20, 4);
-                       len = 8;
-                       ret = SAM_STAT_GOOD;
-               } else if (scb[2] == 0x83) {
-                       /* device identification */
-                       data[3] = SCSI_ID_LEN + 4;
-                       data[4] = 0x1;
-                       data[5] = 0x1;
-                       data[7] = SCSI_ID_LEN;
-                       if (cmd->dev)
-                               memcpy(data + 8, cmd->dev->scsi_id,
SCSI_ID_LEN);
-                       len = SCSI_ID_LEN + 8;
-                       ret = SAM_STAT_GOOD;
-               }
-       }
-
-       if (ret != SAM_STAT_GOOD)
-               goto sense;
-
-       cmd->len = min_t(int, len, scb[4]);
-       cmd->uaddr = (unsigned long) data;
-
-       return SAM_STAT_GOOD;
-sense:
-       sense_data_build(cmd, key, asc, 0);
-       cmd->len = 0;
-       return SAM_STAT_CHECK_CONDITION;
-}
-
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 {
        unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
@@ -145,22 +51,37 @@ static int osd_varlen_cdb(int host_no, struct
scsi_cmd *cmd)
        return cmd->c_target->bst->bs_cmd_submit(cmd);
 }

-static void device_osd_init(struct scsi_lu *lu)
+static int osd_lu_init(struct scsi_lu *lu)
+{
+       if (spc_lu_init(lu))
+               return -ENOMEM;
+
+       memcpy(lu->attributes->ProductIdent, "OSD", 16);
+       lu->attributes->sense_format = 1;
+       lu->attributes->version_desc[0] = 0x0340; /* OSD */
+       lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
+       lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
+
+       return 0;
+}
+
+static int osd_lu_exit(struct scsi_lu *lu)
 {
-       lu->d_sense = 1;
+       return 0;
 }

 struct device_type_template osd_template = {
        .type           = TYPE_OSD,
        .name           = "osd",
-       .device_init    = device_osd_init,
+       .lu_init        = osd_lu_init,
+       .lu_exit        = osd_lu_exit,
        .ops            = {
                [0x00 ... 0x0f] = {spc_illegal_op},

                /* 0x10 */
                {spc_illegal_op,},
                {spc_illegal_op,},
-               {osd_inquiry,},
+               {spc_inquiry,},
                {spc_illegal_op,},
                {spc_illegal_op,},
                {spc_illegal_op,},
diff --git a/usr/parser.h b/usr/parser.h
index 1ff6016..bf210bf 100644
--- a/usr/parser.h
+++ b/usr/parser.h
@@ -17,7 +17,7 @@ struct match_token {
 typedef struct match_token match_table_t[];

 /* Maximum number of arguments that match_token will find in a pattern */
-enum {MAX_OPT_ARGS = 3};
+enum {MAX_OPT_ARGS = 17};

 /* Describe the location within a string of a substring */
 typedef struct {
diff --git a/usr/sbc.c b/usr/sbc.c
index a22d3b0..5357087 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -337,11 +337,31 @@ sense:
        return SAM_STAT_CHECK_CONDITION;
 }

+static int sbc_lu_init(struct scsi_lu *lu)
+{
+       if (spc_lu_init(lu))
+               return -ENOMEM;
+
+       memcpy(lu->attributes->ProductIdent, "VIRTUAL-DISK", 16);
+       lu->attributes->version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
+       lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
+       lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
+
+       return 0;
+}
+
+static int sbc_lu_exit(struct scsi_lu *lu)
+{
+       return 0;
+}
+
 struct device_type_template sbc_template = {
-       .type   = TYPE_DISK,
-       .name   = "disk",
-       .pid    = "VIRTUAL-DISK",
-       .ops    = {
+       .type           = TYPE_DISK,
+       .name           = "disk",
+       .lu_init        = sbc_lu_init,
+       .lu_exit        = sbc_lu_exit,
+       .lu_config      = spc_lu_config,
+       .ops            = {
                {spc_test_unit,},
                {spc_illegal_op,},
                {spc_illegal_op,},
diff --git a/usr/scsi.c b/usr/scsi.c
index 1a6929f..728dfe9 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -40,7 +40,7 @@

 void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc,
uint8_t asq)
 {
-       if (cmd->dev && cmd->dev->d_sense) {
+       if (cmd->dev && cmd->dev->attributes->sense_format) {
                /* descriptor format */

                cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
@@ -121,3 +121,4 @@ int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd)
        unsigned char op = cmd->scb[0];
        return cmd->c_target->dev_type_template.ops[op].cmd_perform(host_no,
cmd);
 }
+
diff --git a/usr/spc.c b/usr/spc.c
index b922a45..e9a74d9 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -19,6 +19,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
  */
+#include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -27,12 +28,15 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "parser.h"
 #include "target.h"
 #include "driver.h"
+#include "tgtadm_error.h"
 #include "scsi.h"
 #include "spc.h"

 #define PRODUCT_REV    "0"
+#define BLK_SHIFT      9

 int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
@@ -40,7 +44,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
        uint8_t *data;
        uint8_t *scb = cmd->scb;
        unsigned char device_type = cmd->c_target->dev_type_template.type;
-       char *product_id = cmd->c_target->dev_type_template.pid;
+       struct physicalAttributes * attributes = cmd->dev->attributes;
        unsigned char key = ILLEGAL_REQUEST, asc = 0x24;

        if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
@@ -57,22 +61,21 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
        dprintf("%x %x\n", scb[1], scb[2]);

        if (!(scb[1] & 0x3)) {
+               int i;
                data[0] = device_type;
-               data[2] = 4;
+               data[1] = (attributes->isRemovable) ? 0x80 : 0;
+               data[2] = 5;    /* SPC-3 */
                data[3] = 0x42;
-               data[4] = 59;
                data[7] = 0x02;
                memset(data + 8, 0x20, 28);
-               strncpy((char *)data + 8, VENDOR_ID, 8);
-               strncpy((char *)data + 16, product_id, 16);
-               strncpy((char *)data + 32, PRODUCT_REV, 4);
-               data[58] = 0x03;
-               data[59] = 0x20;
-               data[60] = 0x09;
-               data[61] = 0x60;
-               data[62] = 0x03;
-               data[63] = 0x00;
-               len = 64;
+               strncpy((char *)data + 8, attributes->VendorIdent, 8);
+               strncpy((char *)data + 16, attributes->ProductIdent, 16);
+               strncpy((char *)data + 32, attributes->ProductRev, 4);
+               for (i=0, len=58; i < VERSION_DESCRIPTOR_LEN; i++, len += 2) {
+                       data[len] = (attributes->version_desc[i] >> 8) & 0xff;
+                       data[len+1] = attributes->version_desc[i] & 0xff;
+               }
+               data[4] = len - 5;      /* Additional Length */
                ret = SAM_STAT_GOOD;
        } else if (scb[1] & 0x2) {
                /* CmdDt bit is set */
@@ -101,13 +104,13 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
                        len = 4 + SCSI_SN_LEN;
                        ret = SAM_STAT_GOOD;

-                       if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
+                       if (cmd->dev && strlen(cmd->dev->attributes->scsi_sn)) {
                                uint8_t *p;
                                char *q;

                                p = data + 4 + tmp - 1;
-                               q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
-
+                               q = cmd->dev->attributes->scsi_sn +
+                                                               SCSI_SN_LEN - 1;
                                for (; tmp > 0; tmp--, q)
                                        *(p--) = *(q--);
                        }
@@ -120,7 +123,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
                        data[5] = 0x1;
                        data[7] = tmp;
                        if (cmd->dev)
-                               strncpy((char *) data + 8, cmd->dev->scsi_id,
+                               strncpy((char *) data + 8,
+                                       cmd->dev->attributes->scsi_id,
                                        SCSI_ID_LEN);
                        len = tmp + 8;
                        ret = SAM_STAT_GOOD;
@@ -238,9 +242,98 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
        return SAM_STAT_GOOD;
 }

+void dump_cdb(struct scsi_cmd *cmd)
+{
+       uint8_t * cdb = cmd->scb;
+
+       switch(cmd->scb_len) {
+       case 6:
+               dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x",
+                       cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5]);
+               break;
+       case 10:
+               dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
+                               " %02x %02x %02x %02x",
+                       cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
+                       cdb[6], cdb[7], cdb[8], cdb[9]);
+               break;
+       case 12:
+               dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
+                               " %02x %02x %02x %02x %02x %02x",
+                       cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
+                       cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11]);
+               break;
+       case 16:
+               dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
+                               " %02x %02x %02x %02x %02x %02x"
+                               " %02x %02x %02x %02x",
+                       cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
+                       cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11],
+                       cdb[12], cdb[13], cdb[14], cdb[15]);
+               break;
+       }
+}
+
 int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 {
+       dump_cdb(cmd);
        cmd->len = 0;
        sense_data_build(cmd, ILLEGAL_REQUEST, 0x20, 0);
        return SAM_STAT_CHECK_CONDITION;
 }
+
+enum {
+       Opt_scsiid, Opt_scsisn, Opt_err,
+};
+
+static match_table_t tokens = {
+       {Opt_scsiid, "scsi_id=%s"},
+       {Opt_scsisn, "scsi_sn=%s"},
+       {Opt_err, NULL},
+};
+
+int spc_lu_config(struct scsi_lu *lu, char * params) {
+       int err = 0;
+       char *p;
+
+       if (!strncmp("targetOps", params, 9))
+               params = params + 10;
+
+       while ((p = strsep(&params, ",")) != NULL) {
+               substring_t args[MAX_OPT_ARGS];
+               int token;
+               if (!*p)
+                       continue;
+               dprintf("*p : %s\n", p);
+               token = match_token(p, tokens, args);
+               switch (token) {
+               case Opt_scsiid:
+                       match_strncpy(lu->attributes->scsi_id, &args[0],
+                                     sizeof(lu->attributes->scsi_id) - 1);
+                       break;
+               case Opt_scsisn:
+                       match_strncpy(lu->attributes->scsi_sn, &args[0],
+                                     sizeof(lu->attributes->scsi_sn) - 1);
+                       break;
+               default:
+                       err = TGTADM_INVALID_REQUEST;
+               }
+       }
+       return err;
+}
+
+int spc_lu_init(struct scsi_lu * lu)
+{
+       lu->attributes = zalloc(sizeof(struct physicalAttributes));
+       if(!lu->attributes)
+               return -ENOMEM;
+
+       memcpy(lu->attributes->VendorIdent, VENDOR_ID, 8);
+       memcpy(lu->attributes->ProductRev, "0001", 4);
+       lu->attributes->isRemovable = 0;
+       lu->attributes->sense_format = 0;
+       lu->attributes->onLine = 0;
+       lu->attributes->reset = 1;
+
+       return 0;
+}
diff --git a/usr/spc.h b/usr/spc.h
index f81e74c..1036b70 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -7,5 +7,8 @@ extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
 extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
 extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
+extern int spc_lu_init(struct scsi_lu *lu);
+extern int spc_lu_config(struct scsi_lu *lu, char * params);
+extern void dump_cdb(struct scsi_cmd *cmd);

 #endif
diff --git a/usr/target.c b/usr/target.c
index 23f450f..e3fa1e0 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -29,7 +29,6 @@
 #include <sys/socket.h>

 #include "list.h"
-#include "parser.h"
 #include "util.h"
 #include "tgtd.h"
 #include "driver.h"
@@ -247,13 +246,19 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
        lu->lun = lun;
        lu->lu_state = SCSI_LU_RUNNING;

-       snprintf(lu->scsi_id, sizeof(lu->scsi_id),
-                "deadbeaf%d:%" PRIu64, tid, lun);
-
        tgt_cmd_queue_init(&lu->cmd_queue);

-       if (target->dev_type_template.device_init)
-               target->dev_type_template.device_init(lu);
+       if (target->dev_type_template.lu_init)
+               err = target->dev_type_template.lu_init(lu);
+
+       if(!err) {
+               snprintf(lu->attributes->scsi_id,
+                       sizeof(lu->attributes->scsi_id),
+                       "deadbeaf%d:%" PRIu64, tid, lun);
+               snprintf(lu->attributes->scsi_sn,
+                       sizeof(lu->attributes->scsi_sn),
+                       "beaf%d%" PRIu64, tid, lun);
+       }

        list_for_each_entry(pos, &target->device_list, device_siblings) {
                if (lu->lun < pos->lun)
@@ -262,13 +267,14 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
        list_add_tail(&lu->device_siblings, &pos->device_siblings);

        dprintf("Add a logical unit %" PRIu64 " to the target %d\n", lun, tid);
-       return 0;
+       return err;
 }

 int tgt_device_destroy(int tid, uint64_t lun)
 {
        struct target *target;
        struct scsi_lu *lu;
+       int err;

        dprintf("%u %" PRIu64 "\n", tid, lun);

@@ -281,12 +287,14 @@ int tgt_device_destroy(int tid, uint64_t lun)
        if (!list_empty(&lu->cmd_queue.queue) || lu->cmd_queue.active_cmd)
                return TGTADM_LUN_ACTIVE;

+       err = target->dev_type_template.lu_exit(lu);
+
        free(lu->path);
        list_del(&lu->device_siblings);

        target->bst->bs_close(lu);
        free(lu);
-       return 0;
+       return err;
 }

 int device_reserve(struct scsi_cmd *cmd)
@@ -339,20 +347,9 @@ int device_reserved(struct scsi_cmd *cmd)
        return -EBUSY;
 }

-enum {
-       Opt_scsiid, Opt_scsisn, Opt_err,
-};
-
-static match_table_t tokens = {
-       {Opt_scsiid, "scsi_id=%s"},
-       {Opt_scsisn, "scsi_sn=%s"},
-       {Opt_err, NULL},
-};
-
 int tgt_device_update(int tid, uint64_t dev_id, char *params)
 {
-       int err = 0;
-       char *p;
+       int err = TGTADM_INVALID_REQUEST;
        struct target *target;
        struct scsi_lu *lu;

@@ -366,26 +363,8 @@ int tgt_device_update(int tid, uint64_t dev_id,
char *params)
                return TGTADM_NO_LUN;
        }

-       while ((p = strsep(&params, ",")) != NULL) {
-               substring_t args[MAX_OPT_ARGS];
-               int token;
-               if (!*p)
-                       continue;
-               token = match_token(p, tokens, args);
-
-               switch (token) {
-               case Opt_scsiid:
-                       match_strncpy(lu->scsi_id, &args[0],
-                                     sizeof(lu->scsi_id) - 1);
-                       break;
-               case Opt_scsisn:
-                       match_strncpy(lu->scsi_sn, &args[0],
-                                     sizeof(lu->scsi_sn) - 1);
-                       break;
-               default:
-                       err = TGTADM_INVALID_REQUEST;
-               }
-       }
+       if (target->dev_type_template.lu_config)
+               err = target->dev_type_template.lu_config(lu, params);

        return err;
 }
@@ -474,8 +453,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
                cmd_post_perform(q, cmd);

                dprintf("%" PRIx64 " %x %" PRIx64 " %" PRIu64 " %u %d %d\n",
-                       cmd->tag, cmd->scb[0], cmd->uaddr,
cmd->offset, cmd->len,
-                       result, cmd->async);
+                       cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset,
+                       cmd->len, result, cmd->async);

                set_cmd_processed(cmd);
                if (!cmd->async)
@@ -483,7 +462,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
        } else {
                set_cmd_queued(cmd);
                dprintf("blocked %" PRIx64 " %x %" PRIu64 " %d\n",
-                       cmd->tag, cmd->scb[0], cmd->dev ?
cmd->dev->lun : UINT64_MAX,
+                       cmd->tag, cmd->scb[0],
+                       cmd->dev ? cmd->dev->lun : UINT64_MAX,
                        q->active_cmd);

                list_add_tail(&cmd->qlist, &q->queue);
@@ -1148,8 +1128,8 @@ int tgt_target_show_all(char *buf, int rest)
                                 _TAB3 "Size: %s\n"
                                 _TAB3 "Backing store: %s\n",
                                 lu->lun,
-                                lu->scsi_id,
-                                lu->scsi_sn,
+                                lu->attributes->scsi_id,
+                                lu->attributes->scsi_sn,
                                 print_disksize(lu->size),
                                 lu->path);

diff --git a/usr/tgtadm.c b/usr/tgtadm.c
index e55a785..3d551cc 100644
--- a/usr/tgtadm.c
+++ b/usr/tgtadm.c
@@ -103,6 +103,7 @@ struct option const long_options[] = {
        {"initiator-address", required_argument, NULL, 'I'},
        {"user", required_argument, NULL, 'u'},
        {"password", required_argument, NULL, 'p'},
+       {"params", required_argument, NULL, 'P'},

        {"bus", required_argument, NULL, 'B'},
        {"target-type", required_argument, NULL, 'Y'},
@@ -110,7 +111,7 @@ struct option const long_options[] = {
        {NULL, 0, NULL, 0},
 };

-static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:B:Y:O";
+static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:P:B:Y:O";

 static void usage(int status)
 {
@@ -355,7 +356,7 @@ int main(int argc, char **argv)
        int op, total, tid, rest, mode, t_type, ac_dir;
        uint32_t cid, hostno;
        uint64_t sid, lun;
-       char *name, *value, *path, *targetname, *params, *address;
+       char *name, *value, *path, *targetname, *params, *address, *targetOps;
        char *user, *password;
        char buf[BUFSIZE + sizeof(struct tgtadm_req)];
        struct tgtadm_req *req;
@@ -365,7 +366,7 @@ int main(int argc, char **argv)
        t_type = TYPE_DISK;
        ac_dir = ACCOUNT_TYPE_INCOMING;
        rest = BUFSIZE;
-       name = value = path = targetname = address = NULL;
+       name = value = path = targetname = address = targetOps = NULL;
        user = password = NULL;

        memset(buf, 0, sizeof(buf));
@@ -396,6 +397,9 @@ int main(int argc, char **argv)
                case 'l':
                        lun = strtoull(optarg, NULL, 10);
                        break;
+               case 'P':
+                       targetOps = optarg;
+                       break;
                case 'n':
                        name = optarg;
                        break;
@@ -570,6 +574,10 @@ int main(int argc, char **argv)
        if (password)
                shprintf(total, params, rest, "%spassword=%s",
                         rest == BUFSIZE ? "" : ",", password);
+       // Trailing ',' makes parsing params in modules easier..
+       if (targetOps)
+               shprintf(total, params, rest, "%stargetOps %s,",
+                        rest == BUFSIZE ? "" : ",", targetOps);

        req->len = sizeof(*req) + total;

diff --git a/usr/tgtadm.h b/usr/tgtadm.h
index fb83753..d53cb40 100644
--- a/usr/tgtadm.h
+++ b/usr/tgtadm.h
@@ -4,31 +4,7 @@
 #define TGT_IPC_NAMESPACE      "TGT_IPC_ABSTRACT_NAMESPACE"
 #define TGT_LLD_NAME_LEN       64

-enum tgtadm_errno {
-       TGTADM_SUCCESS,
-       TGTADM_UNKNOWN_ERR,
-       TGTADM_NOMEM,
-       TGTADM_NO_DRIVER,
-       TGTADM_NO_TARGET,
-
-       TGTADM_NO_LUN,
-       TGTADM_NO_SESSION,
-       TGTADM_NO_CONNECTION,
-       TGTADM_TARGET_EXIST,
-       TGTADM_LUN_EXIST,
-
-       TGTADM_ACL_EXIST,
-       TGTADM_USER_EXIST,
-       TGTADM_NO_USER,
-       TGTADM_TOO_MANY_USER,
-       TGTADM_INVALID_REQUEST,
-
-       TGTADM_OUTACCOUNT_EXIST,
-       TGTADM_TARGET_ACTIVE,
-       TGTADM_LUN_ACTIVE,
-       TGTADM_UNSUPPORTED_OPERATION,
-       TGTADM_UNKNOWN_PARAM,
-};
+#include "tgtadm_error.h"

 enum tgtadm_op {
        OP_NEW,
diff --git a/usr/tgtadm_error.h b/usr/tgtadm_error.h
new file mode 100644
index 0000000..319a4ad
--- /dev/null
+++ b/usr/tgtadm_error.h
@@ -0,0 +1,30 @@
+#ifndef TGTADM_ERROR_H
+#define TGTADM_ERROR_H
+
+enum tgtadm_errno {
+       TGTADM_SUCCESS,
+       TGTADM_UNKNOWN_ERR,
+       TGTADM_NOMEM,
+       TGTADM_NO_DRIVER,
+       TGTADM_NO_TARGET,
+
+       TGTADM_NO_LUN,
+       TGTADM_NO_SESSION,
+       TGTADM_NO_CONNECTION,
+       TGTADM_TARGET_EXIST,
+       TGTADM_LUN_EXIST,
+
+       TGTADM_ACL_EXIST,
+       TGTADM_USER_EXIST,
+       TGTADM_NO_USER,
+       TGTADM_TOO_MANY_USER,
+       TGTADM_INVALID_REQUEST,
+
+       TGTADM_OUTACCOUNT_EXIST,
+       TGTADM_TARGET_ACTIVE,
+       TGTADM_LUN_ACTIVE,
+       TGTADM_UNSUPPORTED_OPERATION,
+       TGTADM_UNKNOWN_PARAM,
+};
+
+#endif
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 06e0dd9..8cda864 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -5,6 +5,7 @@

 #define SCSI_ID_LEN    24
 #define SCSI_SN_LEN    8
+#define VERSION_DESCRIPTOR_LEN 8

 #define VENDOR_ID      "IET"

@@ -29,13 +30,27 @@ struct tgt_cmd_queue {
        struct list_head queue;
 };

+struct physicalAttributes {
+       char    scsi_id[SCSI_ID_LEN];
+       char    scsi_sn[SCSI_SN_LEN];
+
+       /* SCSI Inquiry Params */
+       char    VendorIdent[9];
+       char    ProductIdent[17];
+       char    ProductRev[5];
+       uint16_t        version_desc[VERSION_DESCRIPTOR_LEN];
+
+       char    isRemovable;    /* Removable media */
+       char    onLine;
+       char    reset;          /* Power-on or reset */
+       char    sense_format;   /* sense data format */
+};
+
 struct scsi_lu {
        int fd;
        uint64_t addr; /* persistent mapped address */
        uint64_t size;
        uint64_t lun;
-       char scsi_id[SCSI_ID_LEN];
-       char scsi_sn[SCSI_SN_LEN];
        char *path;

        /* the list of devices belonging to a target */
@@ -48,7 +63,7 @@ struct scsi_lu {
        uint64_t reserve_id;

        /* TODO: needs a structure for lots of device parameters */
-       uint8_t d_sense;
+       struct physicalAttributes * attributes;
 };

 struct scsi_cmd {
@@ -121,7 +136,9 @@ struct device_type_template {
        char *name;
        char *pid;

-       void (*device_init)(struct scsi_lu *dev);
+       int (*lu_init)(struct scsi_lu *lu);
+       int (*lu_exit)(struct scsi_lu *lu);
+       int (*lu_config)(struct scsi_lu *lu, char *arg);

        struct device_type_operations ops[256];
 };
-- 
1.5.1.3


From markh794 at gmail.com  Thu May 31 22:07:33 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 1 Jun 2007 06:07:33 +1000
Subject: [PATCH] Add ability to dynamically set SCSI Inquiry params
Message-ID: <mailman.8.1331738471.12506.stgt-devel@lists.berlios.de>

Added support to configure:
  Vendor Identification
  Product Identification
  Product Revision
  Format of returned 'sense data'
  Define if the lu is capable of supporting removable media
  Define/set if the lu is online / offline.
  Params are passed using the 'tgtadm' utility:

  VendorIdent="string"
  ProductIdent="string"
  ProductRev="string"
  Removable=<0|1> - 0 == non-removable, 1 == removable media
  SenseFormat=<0|1> - 0 == Clasic sense format, 1 == New sense format
  Online=<0|1> - 0 == Unit offline, 1 == Unit Online

e.g.
tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
        --params VendorIdent=QUANTUM,ProductIdent=HD100,ProductRev=0010
tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
        --params Removable=1,SenseFormat=1,Online=1

Example script (scripts/tgt-core-test) to set up HDD & CD device.

Signed-off-by: Mark Harvey <markh794 at gmail.com>

diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
new file mode 100755
index 0000000..37a007c
--- /dev/null
+++ b/scripts/tgt-core-test
@@ -0,0 +1,74 @@
+#!/bin/bash
+
+P=`ps -ef|grep -v grep|grep tgtd|wc -l`
+if [ "X"$P == "X0" ]; then
+       tgtd -d 1
+fi
+
+if [ ! -d /d/01 ]; then
+       mkdir -p /d/01
+fi
+
+if [ ! -f /d/01/hd_block ]; then
+       dd if=/dev/zero of=/d/01/hd_block bs=1M count=8
+fi
+if [ ! -f /d/01/cd_block0 ]; then
+       dd if=/dev/zero of=/d/01/cd_block0 bs=1M count=8
+fi
+if [ ! -f /d/01/cd_block1 ]; then
+       dd if=/dev/zero of=/d/01/cd_block1 bs=1M count=8
+fi
+if [ ! -f /d/01/cd_block2 ]; then
+       dd if=/dev/zero of=/d/01/cd_block2 bs=1M count=8
+fi
+
+set -x
+
+sleep 1
+
+###################################################################################
+# Set up SBC HDD device
+###################################################################################
+TID=1
+
+tgtadm --lld iscsi --mode target --op new --tid $TID \
+               -T iqn.2007-03:marks-vtl_sbc:`hostname` --target-type disk
+
+sleep 1
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b
/d/01/hd_block
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0
--params scsi_sn=FRED00,scsi_id=Fred
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
+       --params
VendorIdent=QUANTUM,ProductIdent=HD100,ProductRev=0010,Removable=1,SenseFormat=1
+
+
+tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
+
+
+###################################################################################
+# Set up MMC CD/DVD device
+###################################################################################
+TID=2
+
+tgtadm --lld iscsi --mode target --op new --tid $TID \
+               -T iqn.2007-03:marks-vtl_mmc:`hostname` --target-type cd
+
+sleep 1
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b
/d/01/cd_block0
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
+       --params
VendorIdent=VirtualCD,ProductIdent=CD101,ProductRev=0010,scsi_sn=XYZZY10,Removable=1
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 1 -b
/d/01/cd_block1
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 1 \
+       --params
VendorIdent=VirtualCD,ProductIdent=CD101,ProductRev=0010,scsi_sn=XYZZY11,Removable=1
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 2 -b
/d/01/cd_block2
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 2 \
+       --params
VendorIdent=VirtualCD,ProductIdent=CD101,ProductRev=0010,scsi_sn=XYZZY12,Removable=1
+
+tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
+
+tgtadm --lld iscsi --mode target --op show
+
+
diff --git a/usr/spc.c b/usr/spc.c
index e9a74d9..d864443 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -283,18 +283,29 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 }

 enum {
-       Opt_scsiid, Opt_scsisn, Opt_err,
+       Opt_scsiid, Opt_scsisn,
+       Opt_VendorIdent, Opt_ProductIdent,
+       Opt_ProductRev, Opt_SenseFormat,
+       Opt_Removable, Opt_Online,
+       Opt_err,
 };

 static match_table_t tokens = {
        {Opt_scsiid, "scsi_id=%s"},
        {Opt_scsisn, "scsi_sn=%s"},
+       {Opt_VendorIdent, "VendorIdent=%s"},
+       {Opt_ProductIdent, "ProductIdent=%s"},
+       {Opt_ProductRev, "ProductRev=%s"},
+       {Opt_SenseFormat, "SenseFormat=%s"},
+       {Opt_Removable, "Removable=%s"},
+       {Opt_Online, "Online=%s"},
        {Opt_err, NULL},
 };

 int spc_lu_config(struct scsi_lu *lu, char * params) {
        int err = 0;
        char *p;
+       char buf[20];

        if (!strncmp("targetOps", params, 9))
                params = params + 10;
@@ -315,6 +326,30 @@ int spc_lu_config(struct scsi_lu *lu, char * params) {
                        match_strncpy(lu->attributes->scsi_sn, &args[0],
                                      sizeof(lu->attributes->scsi_sn) - 1);
                        break;
+               case Opt_VendorIdent:
+                       match_strncpy(lu->attributes->VendorIdent, &args[0],
+                                       sizeof(lu->attributes->VendorIdent));
+                       break;
+               case Opt_ProductIdent:
+                       match_strncpy(lu->attributes->ProductIdent, &args[0],
+                                       sizeof(lu->attributes->ProductIdent));
+                       break;
+               case Opt_ProductRev:
+                       match_strncpy(lu->attributes->ProductRev, &args[0],
+                                       sizeof(lu->attributes->ProductRev));
+                       break;
+               case Opt_SenseFormat:
+                       match_strncpy(buf, &args[0],  sizeof(buf));
+                       lu->attributes->sense_format = atoi(buf);
+                       break;
+               case Opt_Removable:
+                       match_strncpy(buf, &args[0],  sizeof(buf));
+                       lu->attributes->isRemovable = atoi(buf);
+                       break;
+               case Opt_Online:
+                       match_strncpy(buf, &args[0],  sizeof(buf));
+                       lu->attributes->onLine = atoi(buf);
+                       break;
                default:
                        err = TGTADM_INVALID_REQUEST;
                }
-- 
1.5.1.3


