From kensandars at hotmail.com  Thu May  1 10:24:15 2008
From: kensandars at hotmail.com (Ken Sandars)
Date: Thu, 1 May 2008 18:24:15 +1000
Subject: [Stgt-devel] [Ips] [ofa-general] Re: Calculating the
	VA	iniSER	header
In-Reply-To: <39C75744D164D948A170E9792AF8E7CAF60D50@exil.voltaire.com>
References: <4804B03C.6060507@voltaire.com><OFA528E763.71479425-ON8525742C.005B02F4-8825742C.005F18F1@us.ibm.com><694d48600804160122l1cc97b8aka8986ee6deb7dec8@mail.gmail.com><20080416144830.GC23861@osc.edu>
	<adaskxlls4u.fsf@cisco.com><694d48600804170413g4d54cd9g447abd345a1f6301@mail.gmail.com>
	<20080429170516.GA8857@osc.edu>
	<BLU117-W2898E0FCDF826F8FBFE13ED7D80@phx.gbl> 
	<39C75744D164D948A170E9792AF8E7CAF60D50@exil.voltaire.com>
Message-ID: <BLU117-W9F1A35C1D34824D30AA0DD7DB0@phx.gbl>

>> [Ken] It appears the current Linux iSER initiator does not send the HELLO message when
>> the connection transits to full feature phase. The stgt target also ignores this
>> message (if it were to appear). 
[Ken] The IBTA document does not mention the HELLO/HELLOREPLY messages.
Implementing this message exchange gives a distinction between the current implementations
and those that will correctly calculate the write_va (as per Pete Wyckoff's option 3).

>> [Ken] Both of these implementations use a non-conformant iSER header (they add
>> write_va and read_va fields, which incidentally do not appear to be used). Are
>> these changes documented anywhere in the IB domain, or are these variations
>> needed for another reason?
>
> [Erez] Take a look at the iSER for IB annex:
> http://www.infinibandta.org/members/spec/Annex_iSER.PDF

[Ken] Ouch. That link requires a username/password. Looks like it is only available to members
of the Infiniband Trade Association. Fortunately I gained access to it with username "open" and
password "standard". ;-)

[Ken] Neither of these implementations send or examine the iSER CM REQ/REP message private
data. The document doesn't define what action to take when this message is absent. Interestingly,
when the target reports that "ZBVA shall be used for this connection" and "the target shall issue
Send with Invalidate as needed" then it appears the iSER header specified in RFC5046 should be
used for control-type PDUs. Is there any plan to conform with the list of requirements for IBTA
compliance?


Cheers,
Ken

_________________________________________________________________
Never miss another e-mail with Hotmail on your mobile.
http://www.livelife.ninemsn.com.au/article.aspx?id=343869
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080501/260f357e/attachment.html>

From dorfman.eli at gmail.com  Thu May  1 15:50:55 2008
From: dorfman.eli at gmail.com (Eli Dorfman)
Date: Thu, 1 May 2008 16:50:55 +0300
Subject: [Stgt-devel] [ofa-general] Re: [Ips] Calculating the VA in iSER
	header
In-Reply-To: <20080429170516.GA8857@osc.edu>
References: <4804B03C.6060507@voltaire.com>
	<OFA528E763.71479425-ON8525742C.005B02F4-8825742C.005F18F1@us.ibm.com>
	<694d48600804160122l1cc97b8aka8986ee6deb7dec8@mail.gmail.com>
	<20080416144830.GC23861@osc.edu> <adaskxlls4u.fsf@cisco.com>
	<694d48600804170413g4d54cd9g447abd345a1f6301@mail.gmail.com>
	<20080429170516.GA8857@osc.edu>
Message-ID: <694d48600805010650l75c2f70bx662456ce85e7e9a5@mail.gmail.com>

On Tue, Apr 29, 2008 at 8:05 PM, Pete Wyckoff <pw at osc.edu> wrote:
> dorfman.eli at gmail.com wrote on Thu, 17 Apr 2008 14:13 +0300:
>
> > On Wed, Apr 16, 2008 at 6:46 PM, Roland Dreier <rdreier at cisco.com> wrote:
>  > >  > Agree with the interpretation of the spec, and it's probably a bit
>  > >   > clearer that way too.  But we have working initiators and targets
>  > >   > that do it the "wrong" way.
>  > >
>  > >  Yes... I guess the key question is whether there are any initiators that
>  > >  do things the "right" way.
>  > >
>  > >
>  > >   > 1. Flag day: all initiators and targets change at the same time.
>  > >   > Will see data corruption if someone unluckily runs one or the other
>  > >   > using old non-fixed code.
>  > >
>  > >  Seems unacceptable to me... it doesn't make sense at all to break every
>  > >  setup in the world just to be "right" according to the spec.
>  >
>  > This will break only when both initiator and target will use
>  > InitialR2T=No, which means allow unsolicited data.
>  > As far as I know, STGT is not very common (and its version in RHEL5.1
>  > is considered experimental). Its default is also InitialR2T=Yes.
>  > Voltaire's iSCSI over iSER target also uses default InitialR2T=Yes.
>  > So it seems that nothing will break.
>
>  I finally got a chance to look at this just now.  I think you mean
>  default is InitialR2T=No above, which means no unsolicited data.
>  That is the default case, and true, the two different meanings
>  of the initiator-supplied VA coincide.

InitialR2T=Yes means that R2T is required, hence no unsolicited data.
Only is both sides, initiator and target agree on InitialR2T=No then
first data burst is unsolicited.

>
>  But you missed the impact of immediate data.  We run with the
>  defaults (I think) that say the first write request packet should be
>  filled with a bit of the coming data stream.  From iscsid.conf:
>
>     # To enable immediate data (i.e., the initiator sends unsolicited data
>     # with the iSCSI command packet), uncomment the following line:
>     #
>     # The default is Yes
>     node.session.iscsi.ImmediateData = Yes
>
>  Looking at the offset printed out by your patch, it is indeed
>  non-zero for the first RDMA read.  Please correct me if I am
>  mistaken about this---you must have tested all four variations of
>  with and without the patches on initiator and target side, but I did
>  not.

You are right about the ImmediateData=Yes.
I really missed that, so after all this patch will break current
target implementation and
cause data corruption.
I suggest to postpone this patch till we implement the iSER HELLO
message and then add this patch with the corresponding target patch.
This will allow current initiator to work with current target and new
initiator work with new target.
I still think we should do that since future iser implementation will
probably rely on the spec.

>
>  Hence I am still a bit unhappy about having to deal with the
>  fallout, with no way to detect it.  For our local use, I'll keep an
>  older version of stgt in use until we switch to a new kernel, then
>  merge up the target side change.  It is a bother, but I can deal
>  with it.  For other institutions, this lockstep upgrade requirement
>  will not be obvious until they debug the resulting data corruption.
>
>  Still, I do understand why it would be nice to conform to the spec,
>  and it is maybe a bit cleaner that way too.  Maybe you can help with
>  the bug reports on stgt-devel during the transition, and maintain
>  and publish a patch to let it work with old kernels.
>
>                 -- Pete
>


From dorfman.eli at gmail.com  Thu May  1 16:18:45 2008
From: dorfman.eli at gmail.com (Eli Dorfman)
Date: Thu, 1 May 2008 17:18:45 +0300
Subject: [Stgt-devel] [Ips] [ofa-general] Re: Calculating the VA iniSER
	header
In-Reply-To: <BLU117-W9F1A35C1D34824D30AA0DD7DB0@phx.gbl>
References: <4804B03C.6060507@voltaire.com>
	<OFA528E763.71479425-ON8525742C.005B02F4-8825742C.005F18F1@us.ibm.com>
	<694d48600804160122l1cc97b8aka8986ee6deb7dec8@mail.gmail.com>
	<20080416144830.GC23861@osc.edu> <adaskxlls4u.fsf@cisco.com>
	<694d48600804170413g4d54cd9g447abd345a1f6301@mail.gmail.com>
	<20080429170516.GA8857@osc.edu>
	<BLU117-W2898E0FCDF826F8FBFE13ED7D80@phx.gbl>
	<39C75744D164D948A170E9792AF8E7CAF60D50@exil.voltaire.com>
	<BLU117-W9F1A35C1D34824D30AA0DD7DB0@phx.gbl>
Message-ID: <694d48600805010718n7f02a30ev38d35c50e926d02@mail.gmail.com>

On Thu, May 1, 2008 at 11:24 AM, Ken Sandars <kensandars at hotmail.com> wrote:
>
> >> [Ken] It appears the current Linux iSER initiator does not send the HELLO
> message when
>
> >> the connection transits to full feature phase. The stgt target also
> ignores this
> >> message (if it were to appear).
> [Ken] The IBTA document does not mention the HELLO/HELLOREPLY messages.
> Implementing this message exchange gives a distinction between the current
> implementations
> and those that will correctly calculate the write_va (as per Pete Wyckoff's
> option 3).

I agree.

>
> >> [Ken] Both of these implementations use a non-conformant iSER header
> (they add
>
> >> write_va and read_va fields, which incidentally do not appear to be
> used). Are
> >> these changes documented anywhere in the IB domain, or are these
> variations
> >> needed for another reason?
> >
> > [Erez] Take a look at the iSER for IB annex:
>
> > http://www.infinibandta.org/members/spec/Annex_iSER.PDF
>
> [Ken] Ouch. That link requires a username/password. Looks like it is only
> available to members
> of the Infiniband Trade Association. Fortunately I gained access to it with
> username "open" and
> password "standard". ;-)
>
> [Ken] Neither of these implementations send or examine the iSER CM REQ/REP
> message private data.
> The document doesn't define what action to take when this message is
> absent. Interestingly,
> when the target reports that "ZBVA shall be used for this connection" and
> "the target shall issue
> Send with Invalidate as needed" then it appears the iSER header specified in
> RFC5046 should be
> used for control-type PDUs. Is there any plan to conform with the list of
> requirements for IBTA
> compliance?

At the moment these capabilities (ZBVA, Send Invalidate) are not
supported in the driver,
though they seem to be supported by the ConnectX HCA.
Hence, iSER implementation do not send/examine them.
This may be added to the CM REQ/REP with the current defaults but in
order to use these capabilities a code
should be added to the HCA driver and iser.

>
> Cheers,
> Ken
>
> ________________________________
> Hotmail on your mobile. Never miss another e-mail with


From pw at osc.edu  Thu May  1 16:26:18 2008
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 1 May 2008 10:26:18 -0400
Subject: [Stgt-devel] [ofa-general] Re: [Ips] Calculating the VA in iSER
	header
In-Reply-To: <694d48600805010650l75c2f70bx662456ce85e7e9a5@mail.gmail.com>
References: <4804B03C.6060507@voltaire.com>
	<OFA528E763.71479425-ON8525742C.005B02F4-8825742C.005F18F1@us.ibm.com>
	<694d48600804160122l1cc97b8aka8986ee6deb7dec8@mail.gmail.com>
	<20080416144830.GC23861@osc.edu> <adaskxlls4u.fsf@cisco.com>
	<694d48600804170413g4d54cd9g447abd345a1f6301@mail.gmail.com>
	<20080429170516.GA8857@osc.edu>
	<694d48600805010650l75c2f70bx662456ce85e7e9a5@mail.gmail.com>
Message-ID: <20080501142618.GA19304@osc.edu>

dorfman.eli at gmail.com wrote on Thu, 01 May 2008 16:50 +0300:
> InitialR2T=Yes means that R2T is required, hence no unsolicited data.
> Only is both sides, initiator and target agree on InitialR2T=No then
> first data burst is unsolicited.

Thanks for the explanation.  I keep getting that backwards.

> On Tue, Apr 29, 2008 at 8:05 PM, Pete Wyckoff <pw at osc.edu> wrote:
> >  But you missed the impact of immediate data.  We run with the
> >  defaults (I think) that say the first write request packet should be
> >  filled with a bit of the coming data stream.  From iscsid.conf:
> >
> >     # To enable immediate data (i.e., the initiator sends unsolicited data
> >     # with the iSCSI command packet), uncomment the following line:
> >     #
> >     # The default is Yes
> >     node.session.iscsi.ImmediateData = Yes
> >
> >  Looking at the offset printed out by your patch, it is indeed
> >  non-zero for the first RDMA read.  Please correct me if I am
> >  mistaken about this---you must have tested all four variations of
> >  with and without the patches on initiator and target side, but I did
> >  not.
> 
> You are right about the ImmediateData=Yes.
> I really missed that, so after all this patch will break current
> target implementation and
> cause data corruption.
> I suggest to postpone this patch till we implement the iSER HELLO
> message and then add this patch with the corresponding target patch.
> This will allow current initiator to work with current target and new
> initiator work with new target.
> I still think we should do that since future iser implementation will
> probably rely on the spec.

We might as well do the Hello message exchange anyway.  As Ken
points out, the spec would approve.  We could even use this
opportunity to set the IRD and ORD too, but I'm not sure exactly how
that would work in IB once the connection is up.

Here we're not proposing a new bit in the Hello message to indicate
"VA starts before unsol data", but rather lack of Hello message
indicates old initiatior that gets the VA wrong.  That will be easy
to detect in targets.

I wonder if by supporting Hello, that we could remove the use of
private data as specified in the IBTA annex?  These negotiated
parameters (ZBVA and Send w/Inval) could be in the Hello exchange.

We still have the need to put VAs in the iSER header to support the
non-ZBVA case (pre-ConnectX IB), though.  Once we get the Hello
worked out, it might be time to update RFC 5046 to encompass this
hardware model too.

		-- Pete


From dorfman.eli at gmail.com  Thu May  1 16:32:13 2008
From: dorfman.eli at gmail.com (Eli Dorfman)
Date: Thu, 1 May 2008 17:32:13 +0300
Subject: [Stgt-devel] [PATCH 2/2] IB/iSER: Use offset from r2t header
	for rdma
In-Reply-To: <694d48600804270555i6ee55843x51c416294fec6397@mail.gmail.com>
References: <694d48600804270555i6ee55843x51c416294fec6397@mail.gmail.com>
Message-ID: <694d48600805010732p43bed1a7q75dd8d8512b275f2@mail.gmail.com>

On Sun, Apr 27, 2008 at 3:55 PM, Eli Dorfman <dorfman.eli at gmail.com> wrote:
> Use offset from r2t header for rdma instead of using
>  internal offset counter.
>
>  Signed-off-by: Eli Dorfman <elid at voltaire.com>
>  ---
>   usr/iscsi/iscsi_rdma.c |   16 +++++-----------
>   1 files changed, 5 insertions(+), 11 deletions(-)
>
>  diff --git a/usr/iscsi/iscsi_rdma.c b/usr/iscsi/iscsi_rdma.c
>  index d46ddff..84f5949 100644
>  --- a/usr/iscsi/iscsi_rdma.c
>  +++ b/usr/iscsi/iscsi_rdma.c
>  @@ -1447,28 +1447,22 @@ static int iscsi_rdma_rdma_read(struct
>  iscsi_connection *conn)
>         struct iscsi_r2t_rsp *r2t = (struct iscsi_r2t_rsp *) &conn->rsp.bhs;
>         uint8_t *buf;
>         uint32_t len;
>  +       uint32_t offset;
>         int ret;
>
>         buf = (uint8_t *) task->data + task->offset;
>         len = be32_to_cpu(r2t->data_length);
>  +       offset = be32_to_cpu(r2t->data_offset);
>
>  -       dprintf("len %u stag %x va %llx\n",
>  +       dprintf("len %u stag %x va %llx offset %x\n",
>                 len, itask->rem_write_stag,
>  -               (unsigned long long) itask->rem_write_va);
>  +               (unsigned long long) itask->rem_write_va, offset);
>
>         ret = iser_post_rdma_wr(ci, task, buf, len, IBV_WR_RDMA_READ,
>  -                               itask->rem_write_va, itask->rem_write_stag);
>  +                               itask->rem_write_va + offset, itask->rem_write_stag);
>         if (ret < 0)
>                 return ret;
>
>  -       /*
>  -        * Initiator registers the entire buffer, but gives us a VA that
>  -        * is advanced by immediate + unsolicited data amounts.  Advance
>  -        * rem_va as we read, knowing that the target always grabs segments
>  -        * in order.
>  -        */
>  -       itask->rem_write_va += len;
>  -
>         return 0;
>   }
>
>  --
>  1.5.5
>
Please do not apply this patch until we decide how to sync this with
the initiator side.
See the following discussion for details:
http://www.ietf.org/mail-archive/web/ips/current/msg02506.html

I tend to agree with Pete's option (3) implementing iSER HELLO message
in the initiator and target.
Then adding this patch and the corresponding initiator patch so that we have:
Old initiator working with old target, AND
New initiator working with new target.

Eli


From dorfman.eli at gmail.com  Thu May  1 16:35:48 2008
From: dorfman.eli at gmail.com (Eli Dorfman)
Date: Thu, 1 May 2008 17:35:48 +0300
Subject: [Stgt-devel] [PATCH 1/2] IB/iSER: Do not add unsolicited data
	offset to VA in iSER header
In-Reply-To: <694d48600804270553u36b776ame9695a8858dd278@mail.gmail.com>
References: <694d48600804270553u36b776ame9695a8858dd278@mail.gmail.com>
Message-ID: <694d48600805010735k4836e955jabde51ddaf85d645@mail.gmail.com>

On Sun, Apr 27, 2008 at 3:53 PM, Eli Dorfman <dorfman.eli at gmail.com> wrote:
> iSER initiator sends a VA (in the iSER header) which includes
>  an offset for the unsolicited data (which is wrong according to the spec).
>
>  Signed-off-by: Eli Dorfman <elid at voltaire.com>
>  Signed-off-by: Erez Zilber <erezz at voltaire.com>
>  ---
>   drivers/infiniband/ulp/iser/iser_initiator.c |    6 +++---
>   1 files changed, 3 insertions(+), 3 deletions(-)
>
>  diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c
>  b/drivers/infiniband/ulp/iser/iser_initiator.c
>  index 08dc81c..5c2bbc6 100644
>  --- a/drivers/infiniband/ulp/iser/iser_initiator.c
>  +++ b/drivers/infiniband/ulp/iser/iser_initiator.c
>  @@ -154,12 +154,12 @@ iser_prepare_write_cmd(struct iscsi_cmd_task *ctask,
>         if (unsol_sz < edtl) {
>                 hdr->flags     |= ISER_WSV;
>                 hdr->write_stag = cpu_to_be32(regd_buf->reg.rkey);
>  -               hdr->write_va   = cpu_to_be64(regd_buf->reg.va + unsol_sz);
>  +               hdr->write_va   = cpu_to_be64(regd_buf->reg.va);
>
>                 iser_dbg("Cmd itt:%d, WRITE tags, RKEY:%#.4X "
>  -                        "VA:%#llX + unsol:%d\n",
>  +                        "VA:%#llX\n",
>                          ctask->itt, regd_buf->reg.rkey,
>  -                        (unsigned long long)regd_buf->reg.va, unsol_sz);
>  +                        (unsigned long long)regd_buf->reg.va);
>         }
>
>         if (imm_sz > 0) {
>  --
>  1.5.5
>

Please do not apply this patch until we decide how to sync this with
the target side.

Thanks,
Eli


From fujita.tomonori at lab.ntt.co.jp  Thu May  1 16:54:48 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 1 May 2008 23:54:48 +0900
Subject: [Stgt-devel] Prototype MMC DVD-ROM and burnable DVD+R
 implementation
In-Reply-To: <c9a3e4540804282331w5530012bw8458dbc5b6032602@mail.gmail.com>
References: <c9a3e4540804281419r4b187385g8364bf65b29acd6e@mail.gmail.com>
	<20080429141513Y.tomof@acm.org>
	<c9a3e4540804282331w5530012bw8458dbc5b6032602@mail.gmail.com>
Message-ID: <20080501235442O.tomof@acm.org>

On Tue, 29 Apr 2008 16:31:19 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> Ok, thanks.
> 
> I redid the patches as you requested but I cant send SMTP mails from
> my home machines
> so hence git-send-email didnt work. :-(
> 
> I have attached a tgz that contains the patch series created by
> git-format-patch instead.
> Please apply.

Thanks a lot,

There are the style problems. I fixed them this time but please use
checkpatch.pl before submitting patches next time.

Here's a patch to fix the style problems (can be applied after
applying all your patches). If nothing is wrong, I'll push your
patchset. Please check the attached patch.


diff --git a/usr/mmc.c b/usr/mmc.c
index 37c51cf..6c0dcac 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -56,7 +56,6 @@ struct mmc_info {
 	int current_profile;
 };
 
-
 static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
@@ -71,24 +70,26 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 
 	switch (mmc->current_profile) {
 	case PROFILE_DVD_ROM:
-		switch(cmd->scb[0]) {
+		switch (cmd->scb[0]) {
 		case WRITE_6:
 		case WRITE_10:
 		case WRITE_12:
 		case WRITE_16:
 			scsi_set_in_resid_by_actual(cmd, 0);
-			sense_data_build(cmd, ILLEGAL_REQUEST, ASC_INCOMPATIBLE_FORMAT);
+			sense_data_build(cmd, ILLEGAL_REQUEST,
+					 ASC_INCOMPATIBLE_FORMAT);
 			return SAM_STAT_CHECK_CONDITION;
 		}
 		break;
 	case PROFILE_DVD_PLUS_R:
-		switch(cmd->scb[0]) {
+		switch (cmd->scb[0]) {
 		case READ_6:
 		case READ_10:
 		case READ_12:
 		case READ_16:
 			scsi_set_in_resid_by_actual(cmd, 0);
-			sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LBA_OUT_OF_RANGE);
+			sense_data_build(cmd, ILLEGAL_REQUEST,
+					 ASC_LBA_OUT_OF_RANGE);
 			return SAM_STAT_CHECK_CONDITION;
 		}
 		break;
@@ -99,10 +100,10 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 	cmd->offset = (scsi_rw_offset(cmd->scb) << MMC_BLK_SHIFT);
 
 	/* update the size of the device */
-	end_offset = cmd->offset + (((uint64_t)scsi_rw_count(cmd->scb)) << MMC_BLK_SHIFT);
-	if (end_offset > cmd->dev->size) {
+	end_offset = cmd->offset +
+		(((uint64_t)scsi_rw_count(cmd->scb)) << MMC_BLK_SHIFT);
+	if (end_offset > cmd->dev->size)
 		cmd->dev->size = end_offset;
-	}
 
 	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	if (ret) {
@@ -139,14 +140,13 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	data = scsi_get_in_buffer(cmd);
 	size = cmd->dev->size >> MMC_BLK_SHIFT;
 
-	if (size == 0) {
-		data[0] = 0; /* A blank DVD */
-	} else {
+	if (size)
 		data[0] = (size >> 32) ?
 			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
-	}
-	data[1] = __cpu_to_be32(1U << MMC_BLK_SHIFT);
+	else
+		data[0] = 0; /* A blank DVD */
 
+	data[1] = __cpu_to_be32(1U << MMC_BLK_SHIFT);
 overflow:
 	scsi_set_in_resid_by_actual(cmd, 8);
 	return SAM_STAT_GOOD;
@@ -173,28 +173,28 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 		return SAM_STAT_CHECK_CONDITION;
 	}
 
-	toc_time   = cmd->scb[1] & 0x02;
+	toc_time = cmd->scb[1] & 0x02;
 	toc_format = cmd->scb[2] & 0x0f;
-	toc_track  = cmd->scb[6];
+	toc_track = cmd->scb[6];
 
 	memset(buf, 0, sizeof(buf));
 	data = buf;
-		
+
 	switch (toc_format) {
 	case 0:	/* formatted toc */
-		if (toc_track != 0) {
+		if (toc_track) {
 			/* we only do single session data disks so only
 			   track 0 is valid */
 			scsi_set_in_resid_by_actual(cmd, 0);
-			sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
+			sense_data_build(cmd, NOT_READY,
+					 ASC_INVALID_FIELD_IN_CDB);
 			return SAM_STAT_CHECK_CONDITION;
 		}
 
-		if (toc_time) {
+		if (toc_time)
 			tsa = 0x00ff3b4a;
-		} else {
+		else
 			tsa = cmd->dev->size >> MMC_BLK_SHIFT; /* lba */
-		}
 
 		/* size of return data */
 		data[0] = 0;
@@ -204,28 +204,27 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 		data[3] = 1;	/* last track */
 
 		/* data track */
-		data[ 4] = 0;		/* reserved */	
-		data[ 5] = 0x14;
-		data[ 6] = 1;		/* track number */
-		data[ 7] = 0;		/* reserved */
-		data[ 8] = 0;		/* track start address : 0 */
-		data[ 9] = 0;
-		if (toc_time) {
+		data[4] = 0;		/* reserved */
+		data[5] = 0x14;
+		data[6] = 1;		/* track number */
+		data[7] = 0;		/* reserved */
+		data[8] = 0;		/* track start address : 0 */
+		data[9] = 0;
+		if (toc_time)
 			data[10] = 2;	/* time 00:00:02:00 */
-		} else {
+		else
 			data[10] = 0;
-		}
 		data[11] = 0;
 
 		/* leadout track */
-		data[12] = 0;		/* reserved */	
+		data[12] = 0;		/* reserved */
 		data[13] = 0x14;
 		data[14] = 0xaa;	/* track number */
 		data[15] = 0;		/* reserved */
-		data[16] = (tsa>>24)&0xff;/* track start address */
-		data[17] = (tsa>>16)&0xff;
-		data[18] = (tsa>> 8)&0xff;
-		data[19] = (tsa    )&0xff;
+		data[16] = (tsa >> 24) & 0xff;/* track start address */
+		data[17] = (tsa >> 16) & 0xff;
+		data[18] = (tsa >> 8) & 0xff;
+		data[19] = tsa & 0xff;
 
 		break;
 	case 1:	/* multi session info */
@@ -237,17 +236,16 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 		data[3] = 1;	/* last session */
 
 		/* data track */
-		data[ 4] = 0;		/* reserved */	
-		data[ 5] = 0x14;
-		data[ 6] = 1;		/* track number */
-		data[ 7] = 0;		/* reserved */
-		data[ 8] = 0;		/* track start address : 0 */
-		data[ 9] = 0;
-		if (toc_time) {
+		data[4] = 0;		/* reserved */
+		data[5] = 0x14;
+		data[6] = 1;		/* track number */
+		data[7] = 0;		/* reserved */
+		data[8] = 0;		/* track start address : 0 */
+		data[9] = 0;
+		if (toc_time)
 			data[10] = 2;	/* time 00:00:02:00 */
-		} else {
+		else
 			data[10] = 0;
-		}
 		data[11] = 0;
 
 		break;
@@ -295,15 +293,18 @@ static int mmc_read_disc_information(int host_no, struct scsi_cmd *cmd)
 
 	memset(buf, 0, sizeof(buf));
 
-	switch(mmc->current_profile){
+	switch (mmc->current_profile) {
 	case PROFILE_DVD_ROM:
 		/* disk information length */
 		buf[0] = 0x00;
 		buf[1] = 0x20;
 
-		/* erasable:0 state of last session:complete disc status:finalized */
+		/*
+		 * erasable:0 state of last session:complete disc
+		 * status:finalized
+		 */
 		buf[2] = 0x0e;
-	
+
 		/* number of first track on disk */
 		buf[3] = 1;
 
@@ -373,7 +374,7 @@ static int mmc_read_disc_information(int host_no, struct scsi_cmd *cmd)
 
 		/* erasable:0 state of last session:empty disc status:empty */
 		buf[2] = 0;
-	
+
 		/* number of first track on disk */
 		buf[3] = 1;
 
@@ -434,7 +435,6 @@ static int mmc_read_disc_information(int host_no, struct scsi_cmd *cmd)
 
 		/* number of opc tables */
 		buf[33] = 0;
-
 		break;
 	default:
 		/* we do not understand/support this command for this profile */
@@ -444,12 +444,11 @@ static int mmc_read_disc_information(int host_no, struct scsi_cmd *cmd)
 	}
 
 	memcpy(scsi_get_in_buffer(cmd), buf,
-		min(scsi_get_in_length(cmd),
-			(uint32_t) sizeof(buf)));
+	       min_t(uint32_t, scsi_get_in_length(cmd), sizeof(buf)));
 	return SAM_STAT_GOOD;
 }
 
-void profile_dvd_rom(struct scsi_cmd *cmd, char *data)
+static void profile_dvd_rom(struct scsi_cmd *cmd, char *data)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 
@@ -458,17 +457,16 @@ void profile_dvd_rom(struct scsi_cmd *cmd, char *data)
 	*data++ = 0x10;
 
 	/* current ? */
-	if (mmc->current_profile == PROFILE_DVD_ROM) {
+	if (mmc->current_profile == PROFILE_DVD_ROM)
 		*data++ = 0x01;
-	} else {
+	else
 		*data++ = 0;
-	}
 
 	/* reserved */
 	*data++ = 0;
 }
 
-void profile_dvd_plus_r(struct scsi_cmd *cmd, char *data)
+static void profile_dvd_plus_r(struct scsi_cmd *cmd, char *data)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 
@@ -477,11 +475,10 @@ void profile_dvd_plus_r(struct scsi_cmd *cmd, char *data)
 	*data++ = 0x1b;
 
 	/* current ? */
-	if (mmc->current_profile == PROFILE_DVD_PLUS_R) {
+	if (mmc->current_profile == PROFILE_DVD_PLUS_R)
 		*data++ = 0x01;
-	} else {
+	else
 		*data++ = 0;
-	}
 
 	/* reserved */
 	*data++ = 0;
@@ -497,34 +494,37 @@ struct profile_descriptor profiles[] = {
 	{0, NULL}
 };
 
-/* these features are mandatory for profile DVD_ROM
-	FEATURE_PROFILE_LIST
-	FEATURE_CORE
-	FEATURE_MORHPING
-	FEATURE_REMOVABLE_MEDIUM
-	FEATURE_RANDOM_READABLE
-	FEATURE_DVD_READ
-	FEATURE_POWER_MANAGEMENT
-	FEATURE_TIMEOUT
-	FEATURE_REAL_TIME_STREAMING
-   these features are mandatory for profile DVD+R
-	FEATURE_PROFILE_LIST
-	FEATURE_CORE
-	FEATURE_MORHPING
-	FEATURE_REMOVABLE_MEDIUM
-	FEATURE_RANDOM_READABLE
-	FEATURE_DVD_READ
-	FEATURE_DVD_PLUS_R
-	FEATURE_POWER_MANAGEMENT
-	FEATURE_TIMEOUT
-	FEATURE_REAL_TIME_STREAMING
-	FEATURE_DCBS
-   additional features
-	FEATURE_MULIT_READ
-	FEATURE_LUN_SERIAL_NO
-*/
-
-char *feature_profile_list(struct scsi_cmd *cmd, char *data, int only_current)
+/*
+ * these features are mandatory for profile DVD_ROM
+ * FEATURE_PROFILE_LIST
+ * FEATURE_CORE
+ * FEATURE_MORHPING
+ * FEATURE_REMOVABLE_MEDIUM
+ * FEATURE_RANDOM_READABLE
+ * FEATURE_DVD_READ
+ * FEATURE_POWER_MANAGEMENT
+ * FEATURE_TIMEOUT
+ * FEATURE_REAL_TIME_STREAMING
+ *
+ * these features are mandatory for profile DVD+R
+ * FEATURE_PROFILE_LIST
+ * FEATURE_CORE
+ * FEATURE_MORHPING
+ * FEATURE_REMOVABLE_MEDIUM
+ * FEATURE_RANDOM_READABLE
+ * FEATURE_DVD_READ
+ * FEATURE_DVD_PLUS_R
+ * FEATURE_POWER_MANAGEMENT
+ * FEATURE_TIMEOUT
+ * FEATURE_REAL_TIME_STREAMING
+ * FEATURE_DCBS
+ *
+ * additional features
+ * FEATURE_MULIT_READ
+ * FEATURE_LUN_SERIAL_NO
+ */
+static char *feature_profile_list(struct scsi_cmd *cmd, char *data,
+				  int only_current)
 {
 	struct profile_descriptor *p;
 	char *additional;
@@ -535,22 +535,22 @@ char *feature_profile_list(struct scsi_cmd *cmd, char *data, int only_current)
 
 	/* version 0  always persistent, always current */
 	*data++ = 0x03;
-	
+
 	/* additional length start at 0*/
 	additional = data++;
 	*additional = 0;
 
 	/* all all profiles we support */
-	for (p=profiles;p->func;p++) {
+	for (p = profiles; p->func; p++) {
 		p->func(cmd, data);
 		*additional = (*additional) + 4;
-		data+=4;
+		data += 4;
 	}
 
 	return data;
 }
 
-char *feature_core(struct scsi_cmd *cmd, char *data, int only_current)
+static char *feature_core(struct scsi_cmd *cmd, char *data, int only_current)
 {
 	/* feature code */
 	*data++ = 0;
@@ -558,7 +558,7 @@ char *feature_core(struct scsi_cmd *cmd, char *data, int only_current)
 
 	/* version 0  always persistent, always current */
 	*data++ = 0x03;
-	
+
 	/* additional length */
 	*data++ = 4;
 
@@ -571,7 +571,8 @@ char *feature_core(struct scsi_cmd *cmd, char *data, int only_current)
 	return data;
 }
 
-char *feature_morphing(struct scsi_cmd *cmd, char *data, int only_current)
+static char *feature_morphing(struct scsi_cmd *cmd, char *data,
+			      int only_current)
 {
 	/* feature code */
 	*data++ = 0;
@@ -583,16 +584,17 @@ char *feature_morphing(struct scsi_cmd *cmd, char *data, int only_current)
 	/* additional length */
 	*data++ = 4;
 
-	/* dont support ocevent or async */ 
+	/* dont support ocevent or async */
 	*data++ = 0;
 	*data++ = 0;
 	*data++ = 0;
 	*data++ = 0;
 
 	return data;
-}	
+}
 
-char *feature_removable_medium(struct scsi_cmd *cmd, char *data, int only_current)
+static char *feature_removable_medium(struct scsi_cmd *cmd, char *data,
+				      int only_current)
 {
 	/* feature code */
 	*data++ = 0;
@@ -605,9 +607,9 @@ char *feature_removable_medium(struct scsi_cmd *cmd, char *data, int only_curren
 	*data++ = 4;
 
 	/* loading mechanism:tray
-	   ejectable through STARTSTOPUNIT loej
-	   pvnt : PREVENTALLOWMEDIUMREMOVAL supported
-	   lock : medium can be locked
+	 * ejectable through STARTSTOPUNIT loej
+	 * vnt : PREVENTALLOWMEDIUMREMOVAL supported
+	 * lock : medium can be locked
 	*/
 	*data++ = 0x29;
 
@@ -619,13 +621,14 @@ char *feature_removable_medium(struct scsi_cmd *cmd, char *data, int only_curren
 	return data;
 }
 
-char *feature_random_readable(struct scsi_cmd *cmd, char *data, int only_current)
+static char *feature_random_readable(struct scsi_cmd *cmd, char *data,
+				     int only_current)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 	int is_current;
 
 	/* this feature is only current in DVD_ROM */
-	switch(mmc->current_profile){
+	switch (mmc->current_profile) {
 	case PROFILE_DVD_ROM:
 		is_current = 1;
 		break;
@@ -633,9 +636,8 @@ char *feature_random_readable(struct scsi_cmd *cmd, char *data, int only_current
 		is_current = 0;
 	}
 
-	if (only_current) 
-		if (!is_current)
-			return data;
+	if (only_current && !is_current)
+		return data;
 
 	/* feature code */
 	*data++ = 0;
@@ -655,11 +657,11 @@ char *feature_random_readable(struct scsi_cmd *cmd, char *data, int only_current
 	*data++ = 0;
 	*data++ = 8;
 	*data++ = 0;
-	
+
 	/* blocking is always 0x10 for dvd devices */
 	*data++ = 0;
 	*data++ = 0x10;
-	
+
 	/* pp is supported */
 	*data++ = 0x01;
 
@@ -669,13 +671,14 @@ char *feature_random_readable(struct scsi_cmd *cmd, char *data, int only_current
 	return data;
 }
 
-char *feature_dvd_read(struct scsi_cmd *cmd, char *data, int only_current)
+static char *feature_dvd_read(struct scsi_cmd *cmd, char *data,
+			      int only_current)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 	int is_current;
 
 	/* this feature is only current in DVD_ROM */
-	switch(mmc->current_profile){
+	switch (mmc->current_profile) {
 	case PROFILE_DVD_ROM:
 		is_current = 1;
 		break;
@@ -683,9 +686,8 @@ char *feature_dvd_read(struct scsi_cmd *cmd, char *data, int only_current)
 		is_current = 0;
 	}
 
-	if (only_current) 
-		if (!is_current)
-			return data;
+	if (only_current && !is_current)
+		return data;
 
 	/* feature code */
 	*data++ = 0;
@@ -703,7 +705,8 @@ char *feature_dvd_read(struct scsi_cmd *cmd, char *data, int only_current)
 	return data;
 }
 
-char *feature_power_management(struct scsi_cmd *cmd, char *data, int only_current)
+static char *feature_power_management(struct scsi_cmd *cmd, char *data,
+				      int only_current)
 {
 	/* feature code */
 	*data++ = 0x01;
@@ -718,7 +721,7 @@ char *feature_power_management(struct scsi_cmd *cmd, char *data, int only_curren
 	return data;
 }
 
-char *feature_timeout(struct scsi_cmd *cmd, char *data, int only_current)
+static char *feature_timeout(struct scsi_cmd *cmd, char *data, int only_current)
 {
 	/* feature code */
 	*data++ = 0x01;
@@ -733,13 +736,14 @@ char *feature_timeout(struct scsi_cmd *cmd, char *data, int only_current)
 	return data;
 }
 
-char *feature_real_time_streaming(struct scsi_cmd *cmd, char *data, int only_current)
+static char *feature_real_time_streaming(struct scsi_cmd *cmd, char *data,
+					 int only_current)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 	int is_current;
 
 	/* this feature is only current in DVD_ROM */
-	switch(mmc->current_profile){
+	switch (mmc->current_profile) {
 	case PROFILE_DVD_ROM:
 		is_current = 1;
 		break;
@@ -747,9 +751,8 @@ char *feature_real_time_streaming(struct scsi_cmd *cmd, char *data, int only_cur
 		is_current = 0;
 	}
 
-	if (only_current) 
-		if (!is_current)
-			return data;
+	if (only_current && !is_current)
+		return data;
 
 	/* feature code */
 	*data++ = 0x01;
@@ -767,7 +770,7 @@ char *feature_real_time_streaming(struct scsi_cmd *cmd, char *data, int only_cur
 	/* flags */
 	*data++ = 0x1f;
 
-	/* reserved */	
+	/* reserved */
 	*data++ = 0;
 	*data++ = 0;
 	*data++ = 0;
@@ -775,13 +778,14 @@ char *feature_real_time_streaming(struct scsi_cmd *cmd, char *data, int only_cur
 	return data;
 }
 
-char *feature_dvd_plus_r(struct scsi_cmd *cmd, char *data, int only_current)
+static char *feature_dvd_plus_r(struct scsi_cmd *cmd, char *data,
+				int only_current)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 	int is_current;
 
 	/* this feature is only current in DVD+R */
-	switch(mmc->current_profile){
+	switch (mmc->current_profile) {
 	case PROFILE_DVD_PLUS_R:
 		is_current = 1;
 		break;
@@ -789,9 +793,8 @@ char *feature_dvd_plus_r(struct scsi_cmd *cmd, char *data, int only_current)
 		is_current = 0;
 	}
 
-	if (only_current) 
-		if (!is_current)
-			return data;
+	if (only_current && !is_current)
+		return data;
 
 	/* feature code */
 	*data++ = 0;
@@ -817,7 +820,8 @@ char *feature_dvd_plus_r(struct scsi_cmd *cmd, char *data, int only_current)
 	return data;
 }
 
-char *feature_lun_serial_no(struct scsi_cmd *cmd, char *data, int only_current)
+static char *feature_lun_serial_no(struct scsi_cmd *cmd, char *data,
+				   int only_current)
 {
 	/* feature code */
 	*data++ = 0x01;
@@ -842,7 +846,8 @@ char *feature_lun_serial_no(struct scsi_cmd *cmd, char *data, int only_current)
 	return data;
 }
 
-char *feature_multi_read(struct scsi_cmd *cmd, char *data, int only_current)
+static char *feature_multi_read(struct scsi_cmd *cmd, char *data,
+				int only_current)
 {
 	/* feature code */
 	*data++ = 0;
@@ -857,13 +862,13 @@ char *feature_multi_read(struct scsi_cmd *cmd, char *data, int only_current)
 	return data;
 }
 
-char *feature_dcbs(struct scsi_cmd *cmd, char *data, int only_current)
+static char *feature_dcbs(struct scsi_cmd *cmd, char *data, int only_current)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 	int is_current;
 
 	/* this feature is only current in DVD+R */
-	switch(mmc->current_profile){
+	switch (mmc->current_profile) {
 	case PROFILE_DVD_PLUS_R:
 		is_current = 1;
 		break;
@@ -871,9 +876,8 @@ char *feature_dcbs(struct scsi_cmd *cmd, char *data, int only_current)
 		is_current = 0;
 	}
 
-	if (only_current) 
-		if (!is_current)
-			return data;
+	if (only_current && !is_current)
+		return data;
 
 	/* feature code */
 	*data++ = 0x01;
@@ -956,7 +960,7 @@ static int mmc_get_configuration(int host_no, struct scsi_cmd *cmd)
 	rt = cmd->scb[1] & 0x03;
 
 	start = cmd->scb[2];
-	start = (start<<8) | cmd->scb[3];
+	start = (start << 8) | cmd->scb[3];
 
 	memset(buf, 0, sizeof(buf));
 	data = buf;
@@ -964,46 +968,48 @@ static int mmc_get_configuration(int host_no, struct scsi_cmd *cmd)
 	data += 4;
 
 	/* reserved */
-	*data++ = 0; 
-	*data++ = 0; 
+	*data++ = 0;
+	*data++ = 0;
 	/* current profile */
-	*data++ = (mmc->current_profile>>8)&0xff;
-	*data++ = (mmc->current_profile   )&0xff;
+	*data++ = (mmc->current_profile >> 8) & 0xff;
+	*data++ = mmc->current_profile & 0xff;
 
 	/* add the features */
-	for (f=features;f->func;f++) {
+	for (f = features; f->func; f++) {
 		/* only return features >= the start feature */
 		if (f->feature < start)
 			continue;
 		/* if rt==2 we skip all other features except start */
-		if ( (rt==2) && (f->feature!=start) )
+		if (rt == 2 && f->feature != start)
 			continue;
 
-		data = f->func(cmd, data, (rt==1)?1:0 );
+		data = f->func(cmd, data, rt == 1);
 	}
 
 	tmp = data-buf;
 	tmp -= 4;
 
-	buf[0] = (tmp>>24)&0xff;
-	buf[1] = (tmp>>16)&0xff;
-	buf[2] = (tmp>> 8)&0xff;
-	buf[3] = (tmp    )&0xff;
+	buf[0] = (tmp >> 24) & 0xff;
+	buf[1] = (tmp >> 16) & 0xff;
+	buf[2] = (tmp >> 8) & 0xff;
+	buf[3] = tmp & 0xff;
 
 	tmp = data-buf;
 
 	memcpy(scsi_get_in_buffer(cmd), buf,
-	       min(scsi_get_in_length(cmd), (uint32_t) sizeof(buf)));
+	       min_t(uint32_t, scsi_get_in_length(cmd), sizeof(buf)));
 
 	/* dont report overflow/underflow for GET CONFIGURATION */
 	return SAM_STAT_GOOD;
 }
 
-unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data, unsigned int lba)
+static unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data,
+				     unsigned int lba)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 	unsigned long tmp;
-	switch(mmc->current_profile){
+
+	switch (mmc->current_profile) {
 	case PROFILE_DVD_PLUS_R:
 		/* track number LSB */
 		*data++ = 1;
@@ -1014,7 +1020,7 @@ unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data, unsigne
 		/* reserved */
 		*data++ = 0;
 
-		/* damage:0 copy:0 track_mode:DVD+R */ 
+		/* damage:0 copy:0 track_mode:DVD+R */
 		*data++ = 0x07;
 
 		/* rt:0 blank:1 packet/inc:0 fp:0 data mode:1 */
@@ -1066,7 +1072,7 @@ unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data, unsigne
 		*data++ = 0;
 
 		/* reserved */
-		data+=2;
+		data += 2;
 
 		/* read compat lba */
 		*data++ = 0x00;
@@ -1085,7 +1091,7 @@ unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data, unsigne
 		/* reserved */
 		*data++ = 0;
 
-		/* damage:0 copy:0 track_mode:other media */ 
+		/* damage:0 copy:0 track_mode:other media */
 		*data++ = 0x04;
 
 		/* rt:0 blank:0 packet/inc:0 fp:0 data mode:1 */
@@ -1120,17 +1126,17 @@ unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data, unsigne
 
 		/* track size */
 		tmp = cmd->dev->size >> MMC_BLK_SHIFT;
-		*data++ = (tmp>>24)&0xff;
-		*data++ = (tmp>>16)&0xff;
-		*data++ = (tmp>> 8)&0xff;
-		*data++ = (tmp    )&0xff;
+		*data++ = (tmp >> 24) & 0xff;
+		*data++ = (tmp >> 16) & 0xff;
+		*data++ = (tmp >> 8) & 0xff;
+		*data++ = tmp & 0xff;
 
 		/* last recorded address */
 		tmp--;  /* one less */
-		*data++ = (tmp>>24)&0xff;
-		*data++ = (tmp>>16)&0xff;
-		*data++ = (tmp>> 8)&0xff;
-		*data++ = (tmp    )&0xff;
+		*data++ = (tmp >> 24) & 0xff;
+		*data++ = (tmp >> 16) & 0xff;
+		*data++ = (tmp >> 8) & 0xff;
+		*data++ = tmp & 0xff;
 
 		/* track number MSB */
 		*data++ = 0;
@@ -1139,27 +1145,29 @@ unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data, unsigne
 		*data++ = 0;
 
 		/* reserved */
-		data+=2;
+		data += 2;
 
 		return data;
 	}
-	
+
 	/* we do not understand/support this profile */
 	scsi_set_in_resid_by_actual(cmd, 0);
 	sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
 	return NULL;
 }
 
-unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsigned int lba)
+static unsigned char *track_type_track(struct scsi_cmd *cmd,
+				       unsigned char *data, unsigned int lba)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 	unsigned long tmp;
 
-	switch(mmc->current_profile){
+	switch (mmc->current_profile) {
 	case PROFILE_DVD_PLUS_R:
-		if (lba == 0) {
+		if (!lba) {
 			scsi_set_in_resid_by_actual(cmd, 0);
-			sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
+			sense_data_build(cmd, NOT_READY,
+					 ASC_INVALID_FIELD_IN_CDB);
 			return NULL;
 		}
 
@@ -1172,7 +1180,7 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
 		/* reserved */
 		*data++ = 0;
 
-		/* damage:0 copy:0 track_mode:DVD+R */ 
+		/* damage:0 copy:0 track_mode:DVD+R */
 		*data++ = 0x07;
 
 		/* rt:0 blank:1 packet/inc:0 fp:0 data mode:1 */
@@ -1224,7 +1232,7 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
 		*data++ = 0;
 
 		/* reserved */
-		data+=2;
+		data += 2;
 
 		/* read compat lba */
 		*data++ = 0x00;
@@ -1237,7 +1245,8 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
 		/* we only have one track */
 		if (lba != 1) {
 			scsi_set_in_resid_by_actual(cmd, 0);
-			sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
+			sense_data_build(cmd, NOT_READY,
+					 ASC_INVALID_FIELD_IN_CDB);
 			return NULL;
 		}
 
@@ -1250,7 +1259,7 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
 		/* reserved */
 		*data++ = 0;
 
-		/* damage:0 copy:0 track_mode:other media */ 
+		/* damage:0 copy:0 track_mode:other media */
 		*data++ = 0x04;
 
 		/* rt:0 blank:0 packet/inc:0 fp:0 data mode:1 */
@@ -1285,17 +1294,17 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
 
 		/* track size */
 		tmp = cmd->dev->size >> MMC_BLK_SHIFT;
-		*data++ = (tmp>>24)&0xff;
-		*data++ = (tmp>>16)&0xff;
-		*data++ = (tmp>> 8)&0xff;
-		*data++ = (tmp    )&0xff;
+		*data++ = (tmp >> 24) & 0xff;
+		*data++ = (tmp >> 16) & 0xff;
+		*data++ = (tmp >> 8) & 0xff;
+		*data++ = tmp & 0xff;
 
 		/* last recorded address */
 		tmp--;  /* one less */
-		*data++ = (tmp>>24)&0xff;
-		*data++ = (tmp>>16)&0xff;
-		*data++ = (tmp>> 8)&0xff;
-		*data++ = (tmp    )&0xff;
+		*data++ = (tmp >> 24) & 0xff;
+		*data++ = (tmp >> 16) & 0xff;
+		*data++ = (tmp >> 8) & 0xff;
+		*data++ = tmp & 0xff;
 
 		/* track number MSB */
 		*data++ = 0;
@@ -1304,11 +1313,11 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
 		*data++ = 0;
 
 		/* reserved */
-		data+=2;
+		data += 2;
 
 		return data;
 	}
-	
+
 	/* we do not understand/support this profile */
 	scsi_set_in_resid_by_actual(cmd, 0);
 	sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
@@ -1321,7 +1330,8 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
 
 struct track_type {
 	int type;
-	unsigned char *(*func)(struct scsi_cmd *cmd, unsigned char *data, unsigned int lba);
+	unsigned char *(*func)(struct scsi_cmd *cmd, unsigned char *data,
+			       unsigned int lba);
 };
 struct track_type track_types[] = {
 	{TRACK_INFO_LBA,     track_type_lba},
@@ -1354,23 +1364,22 @@ static int mmc_read_track_information(int host_no, struct scsi_cmd *cmd)
 	memset(buf, 0, sizeof(buf));
 	data = &buf[2];
 
-	for(t=track_types;t->func;t++){
+	for (t = track_types; t->func; t++) {
 		int tmp;
 
-		if (t->type != type) {
+		if (t->type != type)
 			continue;
-		}
+
 		data = t->func(cmd, data, lba);
-		if (data == NULL) {
+
+		if (!data)
 			return SAM_STAT_CHECK_CONDITION;
-		}
 
 		tmp = data-&buf[2];
-		buf[0] = (tmp>>8)&0xff;
-		buf[1] = (tmp   )&0xff;
+		buf[0] = (tmp >> 8) & 0xff;
+		buf[1] = tmp & 0xff;
 		memcpy(scsi_get_in_buffer(cmd), buf,
-			min(scsi_get_in_length(cmd),
-				(uint32_t) sizeof(buf)));
+		       min_t(uint32_t, scsi_get_in_length(cmd), sizeof(buf)));
 		return SAM_STAT_GOOD;
 	}
 
@@ -1379,7 +1388,7 @@ static int mmc_read_track_information(int host_no, struct scsi_cmd *cmd)
 	sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
 	return SAM_STAT_CHECK_CONDITION;
 }
-	
+
 static int mmc_read_buffer_capacity(int host_no, struct scsi_cmd *cmd)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
@@ -1403,7 +1412,7 @@ static int mmc_read_buffer_capacity(int host_no, struct scsi_cmd *cmd)
 		/* data length */
 		buf[0] = 0x00;
 		buf[1] = 0x0a;
-		
+
 		/* 4096 blocks */
 		tmp = 0x1000;
 		if (!blocks) {
@@ -1412,21 +1421,21 @@ static int mmc_read_buffer_capacity(int host_no, struct scsi_cmd *cmd)
 		}
 
 		/* length of buffer */
-		buf[4]  = (tmp>>24)&0xff;
-		buf[5]  = (tmp>>16)&0xff;
-		buf[6] = (tmp>> 8)&0xff;
-		buf[7] = (tmp    )&0xff;
+		buf[4] = (tmp >> 24) & 0xff;
+		buf[5] = (tmp >> 16) & 0xff;
+		buf[6] = (tmp >> 8) & 0xff;
+		buf[7] = tmp & 0xff;
 
 		/* available length of buffer (always half) */
 		tmp = tmp >> 1;
-		buf[8]  = (tmp>>24)&0xff;
-		buf[9]  = (tmp>>16)&0xff;
-		buf[10] = (tmp>> 8)&0xff;
-		buf[11] = (tmp    )&0xff;
+		buf[8]  = (tmp >> 24) & 0xff;
+		buf[9]  = (tmp >> 16) & 0xff;
+		buf[10] = (tmp >> 8) & 0xff;
+		buf[11] = tmp & 0xff;
 
-		memcpy(scsi_get_in_buffer(cmd), &buf[0],
+		memcpy(scsi_get_in_buffer(cmd), buf,
 		       min(scsi_get_in_length(cmd), (uint32_t) sizeof(buf)));
-		scsi_set_in_resid_by_actual(cmd, buf[1]+2);
+		scsi_set_in_resid_by_actual(cmd, buf[1] + 2);
 		return SAM_STAT_GOOD;
 	}
 
@@ -1438,7 +1447,7 @@ static int mmc_read_buffer_capacity(int host_no, struct scsi_cmd *cmd)
 static int mmc_synchronize_cache(int host_no, struct scsi_cmd *cmd)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
-	
+
 	if (mmc->current_profile == PROFILE_NO_PROFILE) {
 		scsi_set_in_resid_by_actual(cmd, 0);
 		sense_data_build(cmd, NOT_READY, ASC_MEDIUM_NOT_PRESENT);
@@ -1448,14 +1457,17 @@ static int mmc_synchronize_cache(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 }
 
-unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data, unsigned int type, unsigned int data_type)
+static unsigned char *perf_type_write_speed(struct scsi_cmd *cmd,
+					    unsigned char *data,
+					    unsigned int type,
+					    unsigned int data_type)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 
 	/* write/except */
 	*data++ = 0x00;
 
-	data+=3;
+	data += 3;
 
 	switch (mmc->current_profile) {
 	case PROFILE_NO_PROFILE:
@@ -1464,7 +1476,7 @@ unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data,
 		*data++ = 0x00;
 
 		/* reserved */
-		data+=3;
+		data += 3;
 
 		/* end lba */
 		*data++ = 0x00;
@@ -1489,7 +1501,7 @@ unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data,
 		*data++ = 0x00;
 
 		/* reserved */
-		data+=3;
+		data += 3;
 
 		/* end lba */
 		*data++ = 0x00;
@@ -1517,7 +1529,7 @@ unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data,
 		*data++ = 0x01;
 
 		/* reserved */
-		data+=3;
+		data += 3;
 
 		/* end lba */
 		*data++ = 0x00;
@@ -1545,7 +1557,7 @@ unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data,
 		*data++ = 0x00;
 
 		/* reserved */
-		data+=3;
+		data += 3;
 
 		/* end lba */
 		*data++ = 0x00;
@@ -1570,7 +1582,7 @@ unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data,
 		*data++ = 0x00;
 
 		/* reserved */
-		data+=3;
+		data += 3;
 
 		/* end lba */
 		*data++ = 0x00;
@@ -1600,7 +1612,10 @@ unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data,
 	return NULL;
 }
 
-unsigned char *perf_type_perf_data(struct scsi_cmd *cmd, unsigned char *data, unsigned int type, unsigned int data_type)
+static unsigned char *perf_type_perf_data(struct scsi_cmd *cmd,
+					  unsigned char *data,
+					  unsigned int type,
+					  unsigned int data_type)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 	int tolerance;
@@ -1608,9 +1623,9 @@ unsigned char *perf_type_perf_data(struct scsi_cmd *cmd, unsigned char *data, un
 	int except;
 	long tmp;
 
-	tolerance  = (data_type>>3)&0x03;
-	write_flag = (data_type>>2)&0x01;
-	except     = data_type&0x03;
+	tolerance  = (data_type >> 3) & 0x03;
+	write_flag = (data_type >> 2) & 0x01;
+	except = data_type & 0x03;
 
 	/* all other values for tolerance are reserved */
 	if (tolerance != 0x02) {
@@ -1619,14 +1634,14 @@ unsigned char *perf_type_perf_data(struct scsi_cmd *cmd, unsigned char *data, un
 		return NULL;
 	}
 
-	switch(except){
+	switch (except) {
 	case 1:
 	case 2:
 		/* write/except */
 		*data++ = 0x01;
 
 		/* reserved */
-		data+=3;
+		data += 3;
 
 		/* no actual descriptor returned here */
 		return data;
@@ -1638,14 +1653,13 @@ unsigned char *perf_type_perf_data(struct scsi_cmd *cmd, unsigned char *data, un
 	}
 
 	/* write/except */
-	if (write_flag) {
+	if (write_flag)
 		*data++ = 0x02;
-	} else {
+	else
 		*data++ = 0x00;
-	}
 
 	/* reserved */
-	data+=3;
+	data += 3;
 
 	/* start lba */
 	*data++ = 0;
@@ -1666,11 +1680,12 @@ unsigned char *perf_type_perf_data(struct scsi_cmd *cmd, unsigned char *data, un
 		break;
 	default:
 		tmp = 0x23053f;
-	}			
-	*data++ = (tmp>>24)&0xff;
-	*data++ = (tmp>>16)&0xff;
-	*data++ = (tmp>> 8)&0xff;
-	*data++ = (tmp    )&0xff;
+	}
+
+	*data++ = (tmp >> 24) & 0xff;
+	*data++ = (tmp >> 16) & 0xff;
+	*data++ = (tmp >> 8) & 0xff;
+	*data++ = tmp & 0xff;
 
 	/* end performance */
 	*data++ = 0x00;
@@ -1685,7 +1700,8 @@ unsigned char *perf_type_perf_data(struct scsi_cmd *cmd, unsigned char *data, un
 #define PERF_TYPE_WRITE_SPEED		0x03
 struct perf_type {
 	int type;
-	unsigned char *(*func)(struct scsi_cmd *cmd, unsigned char *data, unsigned int type, unsigned int data_type);
+	unsigned char *(*func)(struct scsi_cmd *cmd, unsigned char *data,
+			       unsigned int type, unsigned int data_type);
 };
 struct perf_type perf_types[] = {
 	{PERF_TYPE_PERF_DATA, perf_type_perf_data},
@@ -1718,25 +1734,23 @@ static int mmc_get_performance(int host_no, struct scsi_cmd *cmd)
 
 	type = cmd->scb[10];
 
-	for (p=perf_types;p->func;p++) {
+	for (p = perf_types; p->func; p++) {
 		int tmp;
 
-		if (p->type != type) {
+		if (p->type != type)
 			continue;
-		}
+
 		data = p->func(cmd, data, type, data_type);
-		if (data == NULL) {
+		if (!data)
 			return SAM_STAT_CHECK_CONDITION;
-		}
 
 		tmp = data-&buf[4];
-		buf[0] = (tmp>>24)&0xff;
-		buf[1] = (tmp>>16)&0xff;
-		buf[2] = (tmp>> 8)&0xff;
-		buf[3] = (tmp    )&0xff;
+		buf[0] = (tmp >> 24) & 0xff;
+		buf[1] = (tmp >> 16) & 0xff;
+		buf[2] = (tmp >> 8) & 0xff;
+		buf[3] = tmp & 0xff;
 		memcpy(scsi_get_in_buffer(cmd), buf,
-			min(scsi_get_in_length(cmd),
-				(uint32_t) sizeof(buf)));
+		       min_t(uint32_t, scsi_get_in_length(cmd), sizeof(buf)));
 		return SAM_STAT_GOOD;
 
 	}
@@ -1752,14 +1766,14 @@ static int mmc_set_streaming(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 }
 
-
 #define DVD_FORMAT_PHYS_INFO		0x00
 #define DVD_FORMAT_DVD_COPYRIGHT_INFO	0x01
 #define DVD_FORMAT_ADIP_INFO		0x11
 #define DVD_FORMAT_DVD_STRUCTURE_LIST	0xff
 
-
-unsigned char *dvd_format_phys_info(struct scsi_cmd *cmd, unsigned char *data, int format, int layer, int write_header)
+static unsigned char *dvd_format_phys_info(struct scsi_cmd *cmd,
+					   unsigned char *data, int format,
+					   int layer, int write_header)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 	unsigned char *old_data;
@@ -1772,7 +1786,7 @@ unsigned char *dvd_format_phys_info(struct scsi_cmd *cmd, unsigned char *data, i
 		return data;
 	}
 
-	if (layer != 0) {
+	if (layer) {
 		/* we only support single layer disks */
 		scsi_set_in_resid_by_actual(cmd, 0);
 		sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
@@ -1816,8 +1830,7 @@ unsigned char *dvd_format_phys_info(struct scsi_cmd *cmd, unsigned char *data, i
 		*data++ = 0;
 
 		/* just leave the media specific area as 0 */
-		data+=2031;
-
+		data += 2031;
 		break;
 	case PROFILE_DVD_PLUS_R:
 		/* book type DVD+R, part version */
@@ -1897,7 +1910,7 @@ unsigned char *dvd_format_phys_info(struct scsi_cmd *cmd, unsigned char *data, i
 		*data++ = 0x00; *data++ = 0x00; *data++ = 0x00; *data++ = 0x00;
 		*data++ = 0x00; *data++ = 0x00; *data++ = 0x00;
 
-		data=old_data+2031;
+		data = old_data + 2031;
 
 		break;
 	default:
@@ -1909,13 +1922,15 @@ unsigned char *dvd_format_phys_info(struct scsi_cmd *cmd, unsigned char *data, i
 	return data;
 }
 
-unsigned char *dvd_format_adip_info(struct scsi_cmd *cmd, unsigned char *data, int format, int layer, int write_header)
+static unsigned char *dvd_format_adip_info(struct scsi_cmd *cmd,
+					   unsigned char *data, int format,
+					   int layer, int write_header)
 {
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 
 	if (write_header) {
 		*data++ = DVD_FORMAT_ADIP_INFO;
-		switch(mmc->current_profile){
+		switch (mmc->current_profile) {
 		case PROFILE_DVD_PLUS_R:
 			*data++ = 0x40;	/* readable */
 			break;
@@ -2006,7 +2021,10 @@ unsigned char *dvd_format_adip_info(struct scsi_cmd *cmd, unsigned char *data, i
 	return data;
 }
 
-unsigned char *dvd_format_copyright_info(struct scsi_cmd *cmd, unsigned char *data, int format, int layer, int write_header)
+static unsigned char *dvd_format_copyright_info(struct scsi_cmd *cmd,
+						unsigned char *data,
+						int format, int layer,
+						int write_header)
 {
 	if (write_header) {
 		*data++ = DVD_FORMAT_DVD_COPYRIGHT_INFO;
@@ -2016,7 +2034,7 @@ unsigned char *dvd_format_copyright_info(struct scsi_cmd *cmd, unsigned char *da
 		return data;
 	}
 
-	if (layer != 0) {
+	if (layer) {
 		/* we only support single layer disks */
 		scsi_set_in_resid_by_actual(cmd, 0);
 		sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
@@ -2032,16 +2050,21 @@ unsigned char *dvd_format_copyright_info(struct scsi_cmd *cmd, unsigned char *da
 	/* reserved */
 	*data++ = 0;
 	*data++ = 0;
-	
+
 	return data;
 }
 
-unsigned char *dvd_format_dvd_structure_list(struct scsi_cmd *cmd, unsigned char *data, int format, int layer, int write_header);
-
+static unsigned char *dvd_format_dvd_structure_list(struct scsi_cmd *cmd,
+						    unsigned char *data,
+						    int format,
+						    int layer,
+						    int write_header);
 struct dvd_format {
 	int format;
-	unsigned char *(*func)(struct scsi_cmd *cmd, unsigned char *data, int format, int layer, int write_header);
+	unsigned char *(*func)(struct scsi_cmd *cmd, unsigned char *data,
+			       int format, int layer, int write_header);
 };
+
 struct dvd_format dvd_formats[] = {
 	{DVD_FORMAT_PHYS_INFO,		dvd_format_phys_info},
 	{DVD_FORMAT_DVD_COPYRIGHT_INFO,	dvd_format_copyright_info},
@@ -2050,20 +2073,22 @@ struct dvd_format dvd_formats[] = {
 	{0, NULL}
 };
 
-unsigned char *dvd_format_dvd_structure_list(struct scsi_cmd *cmd, unsigned char *data, int format, int layer, int write_header)
+static unsigned char *dvd_format_dvd_structure_list(struct scsi_cmd *cmd,
+						    unsigned char *data,
+						    int format,
+						    int layer, int write_header)
 {
 	struct dvd_format *f;
 
 	/* list all format headers */
-	for (f=dvd_formats;f->func;f++) {
+	for (f = dvd_formats; f->func; f++) {
 		/* we dont report ourself back in the format list */
 		if (f->format == 0xff)
 			continue;
-		
+
 		data = f->func(cmd, data, format, layer, 1);
-		if (data == NULL) {
+		if (!data)
 			return NULL;
-		}
 	}
 
 	return data;
@@ -2094,24 +2119,23 @@ static int mmc_read_dvd_structure(int host_no, struct scsi_cmd *cmd)
 	memset(buf, 0, sizeof(buf));
 	data = &buf[4];
 
-	for (f=dvd_formats;f->func;f++) {
+	for (f = dvd_formats; f->func; f++) {
 		if (f->format == format) {
 			int tmp;
 
 			data = f->func(cmd, data, format, layer, 0);
-			if (data == NULL) {
+			if (!data)
 				return SAM_STAT_CHECK_CONDITION;
-			}
 
-			tmp = data-buf;
+			tmp = data - buf;
 			tmp -= 2;
-			buf[0] = (tmp>>8)&0xff;
-			buf[1] = (tmp   )&0xff;
+			buf[0] = (tmp >> 8) & 0xff;
+			buf[1] = tmp & 0xff;
 			buf[2] = 0;
 			buf[3] = 0;
 			memcpy(scsi_get_in_buffer(cmd), buf,
-		       		min(scsi_get_in_length(cmd),
-					(uint32_t) sizeof(buf)));
+			       min_t(uint32_t,
+				     scsi_get_in_length(cmd), sizeof(buf)));
 			return SAM_STAT_GOOD;
 		}
 	}
@@ -2137,7 +2161,7 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	struct mmc_info *mmc;
 
 	mmc = zalloc(sizeof(struct mmc_info));
-	if (mmc == NULL)
+	if (!mmc)
 		return -ENOMEM;
 
 	lu->mmc_p = mmc;
@@ -2153,7 +2177,8 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	}
 	lu->bst = bst;
 
-	strncpy(lu->attrs.product_id, "VIRTUAL-CDROM", sizeof(lu->attrs.product_id));
+	strncpy(lu->attrs.product_id, "VIRTUAL-CDROM",
+		sizeof(lu->attrs.product_id));
 	lu->attrs.sense_format = 0;
 	lu->attrs.version_desc[0] = 0x02A0; /* MMC3, no version claimed */
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
@@ -2198,23 +2223,21 @@ static int mmc_lu_online(struct scsi_lu *lu)
 
 	mmc->current_profile = PROFILE_NO_PROFILE;
 
-	if (lu->fd == -1) {
+	if (lu->fd == -1)
 		return TGTADM_INVALID_REQUEST;
-	}
 
 	lu->attrs.online = 1;
 
-	if (stat(lu->path, &st) != 0) {	
+	if (stat(lu->path, &st)) {
 		mmc->current_profile = PROFILE_NO_PROFILE;
 		lu->attrs.online = 0;
 	} else {
-		if (st.st_size == 0) {
+		if (!st.st_size)
 			mmc->current_profile = PROFILE_DVD_PLUS_R;
-		} else {
+		else
 			mmc->current_profile = PROFILE_DVD_ROM;
-		}
 	}
-	
+
 	return 0;
 }
 


From ronniesahlberg at gmail.com  Thu May  1 22:24:44 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Fri, 2 May 2008 06:24:44 +1000
Subject: [Stgt-devel] Prototype MMC DVD-ROM and burnable DVD+R
	implementation
In-Reply-To: <20080501235442O.tomof@acm.org>
References: <c9a3e4540804281419r4b187385g8364bf65b29acd6e@mail.gmail.com>
	<20080429141513Y.tomof@acm.org>
	<c9a3e4540804282331w5530012bw8458dbc5b6032602@mail.gmail.com>
	<20080501235442O.tomof@acm.org>
Message-ID: <c9a3e4540805011324r25536056v5c4496e3717584aa@mail.gmail.com>

Hi,

That looks good to me.   please push that patchset and I will re-sync
and start adding RESERVE/RELEASE to all commands.



On Fri, May 2, 2008 at 12:54 AM, FUJITA Tomonori
<fujita.tomonori at lab.ntt.co.jp> wrote:
> On Tue, 29 Apr 2008 16:31:19 +1000
>
> "ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:
>
>
> > Ok, thanks.
>  >
>  > I redid the patches as you requested but I cant send SMTP mails from
>  > my home machines
>  > so hence git-send-email didnt work. :-(
>  >
>  > I have attached a tgz that contains the patch series created by
>  > git-format-patch instead.
>  > Please apply.
>
>  Thanks a lot,
>
>  There are the style problems. I fixed them this time but please use
>  checkpatch.pl before submitting patches next time.
>
>  Here's a patch to fix the style problems (can be applied after
>  applying all your patches). If nothing is wrong, I'll push your
>  patchset. Please check the attached patch.
>
>
>  diff --git a/usr/mmc.c b/usr/mmc.c
>  index 37c51cf..6c0dcac 100644
>  --- a/usr/mmc.c
>  +++ b/usr/mmc.c
>  @@ -56,7 +56,6 @@ struct mmc_info {
>         int current_profile;
>   };
>
>  -
>   static int mmc_rw(int host_no, struct scsi_cmd *cmd)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>  @@ -71,24 +70,26 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
>
>         switch (mmc->current_profile) {
>         case PROFILE_DVD_ROM:
>  -               switch(cmd->scb[0]) {
>  +               switch (cmd->scb[0]) {
>                 case WRITE_6:
>                 case WRITE_10:
>                 case WRITE_12:
>                 case WRITE_16:
>                         scsi_set_in_resid_by_actual(cmd, 0);
>  -                       sense_data_build(cmd, ILLEGAL_REQUEST, ASC_INCOMPATIBLE_FORMAT);
>  +                       sense_data_build(cmd, ILLEGAL_REQUEST,
>  +                                        ASC_INCOMPATIBLE_FORMAT);
>                         return SAM_STAT_CHECK_CONDITION;
>                 }
>                 break;
>         case PROFILE_DVD_PLUS_R:
>  -               switch(cmd->scb[0]) {
>  +               switch (cmd->scb[0]) {
>                 case READ_6:
>                 case READ_10:
>                 case READ_12:
>                 case READ_16:
>                         scsi_set_in_resid_by_actual(cmd, 0);
>  -                       sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LBA_OUT_OF_RANGE);
>  +                       sense_data_build(cmd, ILLEGAL_REQUEST,
>  +                                        ASC_LBA_OUT_OF_RANGE);
>                         return SAM_STAT_CHECK_CONDITION;
>                 }
>                 break;
>  @@ -99,10 +100,10 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
>         cmd->offset = (scsi_rw_offset(cmd->scb) << MMC_BLK_SHIFT);
>
>         /* update the size of the device */
>  -       end_offset = cmd->offset + (((uint64_t)scsi_rw_count(cmd->scb)) << MMC_BLK_SHIFT);
>  -       if (end_offset > cmd->dev->size) {
>  +       end_offset = cmd->offset +
>  +               (((uint64_t)scsi_rw_count(cmd->scb)) << MMC_BLK_SHIFT);
>  +       if (end_offset > cmd->dev->size)
>                 cmd->dev->size = end_offset;
>  -       }
>
>         ret = cmd->dev->bst->bs_cmd_submit(cmd);
>         if (ret) {
>  @@ -139,14 +140,13 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
>         data = scsi_get_in_buffer(cmd);
>         size = cmd->dev->size >> MMC_BLK_SHIFT;
>
>  -       if (size == 0) {
>  -               data[0] = 0; /* A blank DVD */
>  -       } else {
>  +       if (size)
>                 data[0] = (size >> 32) ?
>                         __cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
>  -       }
>  -       data[1] = __cpu_to_be32(1U << MMC_BLK_SHIFT);
>  +       else
>  +               data[0] = 0; /* A blank DVD */
>
>  +       data[1] = __cpu_to_be32(1U << MMC_BLK_SHIFT);
>   overflow:
>         scsi_set_in_resid_by_actual(cmd, 8);
>         return SAM_STAT_GOOD;
>  @@ -173,28 +173,28 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
>                 return SAM_STAT_CHECK_CONDITION;
>         }
>
>  -       toc_time   = cmd->scb[1] & 0x02;
>  +       toc_time = cmd->scb[1] & 0x02;
>         toc_format = cmd->scb[2] & 0x0f;
>  -       toc_track  = cmd->scb[6];
>  +       toc_track = cmd->scb[6];
>
>         memset(buf, 0, sizeof(buf));
>         data = buf;
>  -
>  +
>         switch (toc_format) {
>         case 0: /* formatted toc */
>  -               if (toc_track != 0) {
>  +               if (toc_track) {
>                         /* we only do single session data disks so only
>                            track 0 is valid */
>                         scsi_set_in_resid_by_actual(cmd, 0);
>  -                       sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
>  +                       sense_data_build(cmd, NOT_READY,
>  +                                        ASC_INVALID_FIELD_IN_CDB);
>                         return SAM_STAT_CHECK_CONDITION;
>                 }
>
>  -               if (toc_time) {
>  +               if (toc_time)
>                         tsa = 0x00ff3b4a;
>  -               } else {
>  +               else
>                         tsa = cmd->dev->size >> MMC_BLK_SHIFT; /* lba */
>  -               }
>
>                 /* size of return data */
>                 data[0] = 0;
>  @@ -204,28 +204,27 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
>                 data[3] = 1;    /* last track */
>
>                 /* data track */
>  -               data[ 4] = 0;           /* reserved */
>  -               data[ 5] = 0x14;
>  -               data[ 6] = 1;           /* track number */
>  -               data[ 7] = 0;           /* reserved */
>  -               data[ 8] = 0;           /* track start address : 0 */
>  -               data[ 9] = 0;
>  -               if (toc_time) {
>  +               data[4] = 0;            /* reserved */
>  +               data[5] = 0x14;
>  +               data[6] = 1;            /* track number */
>  +               data[7] = 0;            /* reserved */
>  +               data[8] = 0;            /* track start address : 0 */
>  +               data[9] = 0;
>  +               if (toc_time)
>                         data[10] = 2;   /* time 00:00:02:00 */
>  -               } else {
>  +               else
>                         data[10] = 0;
>  -               }
>                 data[11] = 0;
>
>                 /* leadout track */
>  -               data[12] = 0;           /* reserved */
>  +               data[12] = 0;           /* reserved */
>                 data[13] = 0x14;
>                 data[14] = 0xaa;        /* track number */
>                 data[15] = 0;           /* reserved */
>  -               data[16] = (tsa>>24)&0xff;/* track start address */
>  -               data[17] = (tsa>>16)&0xff;
>  -               data[18] = (tsa>> 8)&0xff;
>  -               data[19] = (tsa    )&0xff;
>  +               data[16] = (tsa >> 24) & 0xff;/* track start address */
>  +               data[17] = (tsa >> 16) & 0xff;
>  +               data[18] = (tsa >> 8) & 0xff;
>  +               data[19] = tsa & 0xff;
>
>                 break;
>         case 1: /* multi session info */
>  @@ -237,17 +236,16 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
>                 data[3] = 1;    /* last session */
>
>                 /* data track */
>  -               data[ 4] = 0;           /* reserved */
>  -               data[ 5] = 0x14;
>  -               data[ 6] = 1;           /* track number */
>  -               data[ 7] = 0;           /* reserved */
>  -               data[ 8] = 0;           /* track start address : 0 */
>  -               data[ 9] = 0;
>  -               if (toc_time) {
>  +               data[4] = 0;            /* reserved */
>  +               data[5] = 0x14;
>  +               data[6] = 1;            /* track number */
>  +               data[7] = 0;            /* reserved */
>  +               data[8] = 0;            /* track start address : 0 */
>  +               data[9] = 0;
>  +               if (toc_time)
>                         data[10] = 2;   /* time 00:00:02:00 */
>  -               } else {
>  +               else
>                         data[10] = 0;
>  -               }
>                 data[11] = 0;
>
>                 break;
>  @@ -295,15 +293,18 @@ static int mmc_read_disc_information(int host_no, struct scsi_cmd *cmd)
>
>         memset(buf, 0, sizeof(buf));
>
>  -       switch(mmc->current_profile){
>  +       switch (mmc->current_profile) {
>         case PROFILE_DVD_ROM:
>                 /* disk information length */
>                 buf[0] = 0x00;
>                 buf[1] = 0x20;
>
>  -               /* erasable:0 state of last session:complete disc status:finalized */
>  +               /*
>  +                * erasable:0 state of last session:complete disc
>  +                * status:finalized
>  +                */
>                 buf[2] = 0x0e;
>  -
>  +
>                 /* number of first track on disk */
>                 buf[3] = 1;
>
>  @@ -373,7 +374,7 @@ static int mmc_read_disc_information(int host_no, struct scsi_cmd *cmd)
>
>                 /* erasable:0 state of last session:empty disc status:empty */
>                 buf[2] = 0;
>  -
>  +
>                 /* number of first track on disk */
>                 buf[3] = 1;
>
>  @@ -434,7 +435,6 @@ static int mmc_read_disc_information(int host_no, struct scsi_cmd *cmd)
>
>                 /* number of opc tables */
>                 buf[33] = 0;
>  -
>                 break;
>         default:
>                 /* we do not understand/support this command for this profile */
>  @@ -444,12 +444,11 @@ static int mmc_read_disc_information(int host_no, struct scsi_cmd *cmd)
>         }
>
>         memcpy(scsi_get_in_buffer(cmd), buf,
>  -               min(scsi_get_in_length(cmd),
>  -                       (uint32_t) sizeof(buf)));
>  +              min_t(uint32_t, scsi_get_in_length(cmd), sizeof(buf)));
>         return SAM_STAT_GOOD;
>   }
>
>  -void profile_dvd_rom(struct scsi_cmd *cmd, char *data)
>  +static void profile_dvd_rom(struct scsi_cmd *cmd, char *data)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>
>  @@ -458,17 +457,16 @@ void profile_dvd_rom(struct scsi_cmd *cmd, char *data)
>         *data++ = 0x10;
>
>         /* current ? */
>  -       if (mmc->current_profile == PROFILE_DVD_ROM) {
>  +       if (mmc->current_profile == PROFILE_DVD_ROM)
>                 *data++ = 0x01;
>  -       } else {
>  +       else
>                 *data++ = 0;
>  -       }
>
>         /* reserved */
>         *data++ = 0;
>   }
>
>  -void profile_dvd_plus_r(struct scsi_cmd *cmd, char *data)
>  +static void profile_dvd_plus_r(struct scsi_cmd *cmd, char *data)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>
>  @@ -477,11 +475,10 @@ void profile_dvd_plus_r(struct scsi_cmd *cmd, char *data)
>         *data++ = 0x1b;
>
>         /* current ? */
>  -       if (mmc->current_profile == PROFILE_DVD_PLUS_R) {
>  +       if (mmc->current_profile == PROFILE_DVD_PLUS_R)
>                 *data++ = 0x01;
>  -       } else {
>  +       else
>                 *data++ = 0;
>  -       }
>
>         /* reserved */
>         *data++ = 0;
>  @@ -497,34 +494,37 @@ struct profile_descriptor profiles[] = {
>         {0, NULL}
>   };
>
>  -/* these features are mandatory for profile DVD_ROM
>  -       FEATURE_PROFILE_LIST
>  -       FEATURE_CORE
>  -       FEATURE_MORHPING
>  -       FEATURE_REMOVABLE_MEDIUM
>  -       FEATURE_RANDOM_READABLE
>  -       FEATURE_DVD_READ
>  -       FEATURE_POWER_MANAGEMENT
>  -       FEATURE_TIMEOUT
>  -       FEATURE_REAL_TIME_STREAMING
>  -   these features are mandatory for profile DVD+R
>  -       FEATURE_PROFILE_LIST
>  -       FEATURE_CORE
>  -       FEATURE_MORHPING
>  -       FEATURE_REMOVABLE_MEDIUM
>  -       FEATURE_RANDOM_READABLE
>  -       FEATURE_DVD_READ
>  -       FEATURE_DVD_PLUS_R
>  -       FEATURE_POWER_MANAGEMENT
>  -       FEATURE_TIMEOUT
>  -       FEATURE_REAL_TIME_STREAMING
>  -       FEATURE_DCBS
>  -   additional features
>  -       FEATURE_MULIT_READ
>  -       FEATURE_LUN_SERIAL_NO
>  -*/
>  -
>  -char *feature_profile_list(struct scsi_cmd *cmd, char *data, int only_current)
>  +/*
>  + * these features are mandatory for profile DVD_ROM
>  + * FEATURE_PROFILE_LIST
>  + * FEATURE_CORE
>  + * FEATURE_MORHPING
>  + * FEATURE_REMOVABLE_MEDIUM
>  + * FEATURE_RANDOM_READABLE
>  + * FEATURE_DVD_READ
>  + * FEATURE_POWER_MANAGEMENT
>  + * FEATURE_TIMEOUT
>  + * FEATURE_REAL_TIME_STREAMING
>  + *
>  + * these features are mandatory for profile DVD+R
>  + * FEATURE_PROFILE_LIST
>  + * FEATURE_CORE
>  + * FEATURE_MORHPING
>  + * FEATURE_REMOVABLE_MEDIUM
>  + * FEATURE_RANDOM_READABLE
>  + * FEATURE_DVD_READ
>  + * FEATURE_DVD_PLUS_R
>  + * FEATURE_POWER_MANAGEMENT
>  + * FEATURE_TIMEOUT
>  + * FEATURE_REAL_TIME_STREAMING
>  + * FEATURE_DCBS
>  + *
>  + * additional features
>  + * FEATURE_MULIT_READ
>  + * FEATURE_LUN_SERIAL_NO
>  + */
>  +static char *feature_profile_list(struct scsi_cmd *cmd, char *data,
>  +                                 int only_current)
>   {
>         struct profile_descriptor *p;
>         char *additional;
>  @@ -535,22 +535,22 @@ char *feature_profile_list(struct scsi_cmd *cmd, char *data, int only_current)
>
>         /* version 0  always persistent, always current */
>         *data++ = 0x03;
>  -
>  +
>         /* additional length start at 0*/
>         additional = data++;
>         *additional = 0;
>
>         /* all all profiles we support */
>  -       for (p=profiles;p->func;p++) {
>  +       for (p = profiles; p->func; p++) {
>                 p->func(cmd, data);
>                 *additional = (*additional) + 4;
>  -               data+=4;
>  +               data += 4;
>         }
>
>         return data;
>   }
>
>  -char *feature_core(struct scsi_cmd *cmd, char *data, int only_current)
>  +static char *feature_core(struct scsi_cmd *cmd, char *data, int only_current)
>   {
>         /* feature code */
>         *data++ = 0;
>  @@ -558,7 +558,7 @@ char *feature_core(struct scsi_cmd *cmd, char *data, int only_current)
>
>         /* version 0  always persistent, always current */
>         *data++ = 0x03;
>  -
>  +
>         /* additional length */
>         *data++ = 4;
>
>  @@ -571,7 +571,8 @@ char *feature_core(struct scsi_cmd *cmd, char *data, int only_current)
>         return data;
>   }
>
>  -char *feature_morphing(struct scsi_cmd *cmd, char *data, int only_current)
>  +static char *feature_morphing(struct scsi_cmd *cmd, char *data,
>  +                             int only_current)
>   {
>         /* feature code */
>         *data++ = 0;
>  @@ -583,16 +584,17 @@ char *feature_morphing(struct scsi_cmd *cmd, char *data, int only_current)
>         /* additional length */
>         *data++ = 4;
>
>  -       /* dont support ocevent or async */
>  +       /* dont support ocevent or async */
>         *data++ = 0;
>         *data++ = 0;
>         *data++ = 0;
>         *data++ = 0;
>
>         return data;
>  -}
>  +}
>
>  -char *feature_removable_medium(struct scsi_cmd *cmd, char *data, int only_current)
>  +static char *feature_removable_medium(struct scsi_cmd *cmd, char *data,
>  +                                     int only_current)
>   {
>         /* feature code */
>         *data++ = 0;
>  @@ -605,9 +607,9 @@ char *feature_removable_medium(struct scsi_cmd *cmd, char *data, int only_curren
>         *data++ = 4;
>
>         /* loading mechanism:tray
>  -          ejectable through STARTSTOPUNIT loej
>  -          pvnt : PREVENTALLOWMEDIUMREMOVAL supported
>  -          lock : medium can be locked
>  +        * ejectable through STARTSTOPUNIT loej
>  +        * vnt : PREVENTALLOWMEDIUMREMOVAL supported
>  +        * lock : medium can be locked
>         */
>         *data++ = 0x29;
>
>  @@ -619,13 +621,14 @@ char *feature_removable_medium(struct scsi_cmd *cmd, char *data, int only_curren
>         return data;
>   }
>
>  -char *feature_random_readable(struct scsi_cmd *cmd, char *data, int only_current)
>  +static char *feature_random_readable(struct scsi_cmd *cmd, char *data,
>  +                                    int only_current)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>         int is_current;
>
>         /* this feature is only current in DVD_ROM */
>  -       switch(mmc->current_profile){
>  +       switch (mmc->current_profile) {
>         case PROFILE_DVD_ROM:
>                 is_current = 1;
>                 break;
>  @@ -633,9 +636,8 @@ char *feature_random_readable(struct scsi_cmd *cmd, char *data, int only_current
>                 is_current = 0;
>         }
>
>  -       if (only_current)
>  -               if (!is_current)
>  -                       return data;
>  +       if (only_current && !is_current)
>  +               return data;
>
>         /* feature code */
>         *data++ = 0;
>  @@ -655,11 +657,11 @@ char *feature_random_readable(struct scsi_cmd *cmd, char *data, int only_current
>         *data++ = 0;
>         *data++ = 8;
>         *data++ = 0;
>  -
>  +
>         /* blocking is always 0x10 for dvd devices */
>         *data++ = 0;
>         *data++ = 0x10;
>  -
>  +
>         /* pp is supported */
>         *data++ = 0x01;
>
>  @@ -669,13 +671,14 @@ char *feature_random_readable(struct scsi_cmd *cmd, char *data, int only_current
>         return data;
>   }
>
>  -char *feature_dvd_read(struct scsi_cmd *cmd, char *data, int only_current)
>  +static char *feature_dvd_read(struct scsi_cmd *cmd, char *data,
>  +                             int only_current)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>         int is_current;
>
>         /* this feature is only current in DVD_ROM */
>  -       switch(mmc->current_profile){
>  +       switch (mmc->current_profile) {
>         case PROFILE_DVD_ROM:
>                 is_current = 1;
>                 break;
>  @@ -683,9 +686,8 @@ char *feature_dvd_read(struct scsi_cmd *cmd, char *data, int only_current)
>                 is_current = 0;
>         }
>
>  -       if (only_current)
>  -               if (!is_current)
>  -                       return data;
>  +       if (only_current && !is_current)
>  +               return data;
>
>         /* feature code */
>         *data++ = 0;
>  @@ -703,7 +705,8 @@ char *feature_dvd_read(struct scsi_cmd *cmd, char *data, int only_current)
>         return data;
>   }
>
>  -char *feature_power_management(struct scsi_cmd *cmd, char *data, int only_current)
>  +static char *feature_power_management(struct scsi_cmd *cmd, char *data,
>  +                                     int only_current)
>   {
>         /* feature code */
>         *data++ = 0x01;
>  @@ -718,7 +721,7 @@ char *feature_power_management(struct scsi_cmd *cmd, char *data, int only_curren
>         return data;
>   }
>
>  -char *feature_timeout(struct scsi_cmd *cmd, char *data, int only_current)
>  +static char *feature_timeout(struct scsi_cmd *cmd, char *data, int only_current)
>   {
>         /* feature code */
>         *data++ = 0x01;
>  @@ -733,13 +736,14 @@ char *feature_timeout(struct scsi_cmd *cmd, char *data, int only_current)
>         return data;
>   }
>
>  -char *feature_real_time_streaming(struct scsi_cmd *cmd, char *data, int only_current)
>  +static char *feature_real_time_streaming(struct scsi_cmd *cmd, char *data,
>  +                                        int only_current)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>         int is_current;
>
>         /* this feature is only current in DVD_ROM */
>  -       switch(mmc->current_profile){
>  +       switch (mmc->current_profile) {
>         case PROFILE_DVD_ROM:
>                 is_current = 1;
>                 break;
>  @@ -747,9 +751,8 @@ char *feature_real_time_streaming(struct scsi_cmd *cmd, char *data, int only_cur
>                 is_current = 0;
>         }
>
>  -       if (only_current)
>  -               if (!is_current)
>  -                       return data;
>  +       if (only_current && !is_current)
>  +               return data;
>
>         /* feature code */
>         *data++ = 0x01;
>  @@ -767,7 +770,7 @@ char *feature_real_time_streaming(struct scsi_cmd *cmd, char *data, int only_cur
>         /* flags */
>         *data++ = 0x1f;
>
>  -       /* reserved */
>  +       /* reserved */
>         *data++ = 0;
>         *data++ = 0;
>         *data++ = 0;
>  @@ -775,13 +778,14 @@ char *feature_real_time_streaming(struct scsi_cmd *cmd, char *data, int only_cur
>         return data;
>   }
>
>  -char *feature_dvd_plus_r(struct scsi_cmd *cmd, char *data, int only_current)
>  +static char *feature_dvd_plus_r(struct scsi_cmd *cmd, char *data,
>  +                               int only_current)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>         int is_current;
>
>         /* this feature is only current in DVD+R */
>  -       switch(mmc->current_profile){
>  +       switch (mmc->current_profile) {
>         case PROFILE_DVD_PLUS_R:
>                 is_current = 1;
>                 break;
>  @@ -789,9 +793,8 @@ char *feature_dvd_plus_r(struct scsi_cmd *cmd, char *data, int only_current)
>                 is_current = 0;
>         }
>
>  -       if (only_current)
>  -               if (!is_current)
>  -                       return data;
>  +       if (only_current && !is_current)
>  +               return data;
>
>         /* feature code */
>         *data++ = 0;
>  @@ -817,7 +820,8 @@ char *feature_dvd_plus_r(struct scsi_cmd *cmd, char *data, int only_current)
>         return data;
>   }
>
>  -char *feature_lun_serial_no(struct scsi_cmd *cmd, char *data, int only_current)
>  +static char *feature_lun_serial_no(struct scsi_cmd *cmd, char *data,
>  +                                  int only_current)
>   {
>         /* feature code */
>         *data++ = 0x01;
>  @@ -842,7 +846,8 @@ char *feature_lun_serial_no(struct scsi_cmd *cmd, char *data, int only_current)
>         return data;
>   }
>
>  -char *feature_multi_read(struct scsi_cmd *cmd, char *data, int only_current)
>  +static char *feature_multi_read(struct scsi_cmd *cmd, char *data,
>  +                               int only_current)
>   {
>         /* feature code */
>         *data++ = 0;
>  @@ -857,13 +862,13 @@ char *feature_multi_read(struct scsi_cmd *cmd, char *data, int only_current)
>         return data;
>   }
>
>  -char *feature_dcbs(struct scsi_cmd *cmd, char *data, int only_current)
>  +static char *feature_dcbs(struct scsi_cmd *cmd, char *data, int only_current)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>         int is_current;
>
>         /* this feature is only current in DVD+R */
>  -       switch(mmc->current_profile){
>  +       switch (mmc->current_profile) {
>         case PROFILE_DVD_PLUS_R:
>                 is_current = 1;
>                 break;
>  @@ -871,9 +876,8 @@ char *feature_dcbs(struct scsi_cmd *cmd, char *data, int only_current)
>                 is_current = 0;
>         }
>
>  -       if (only_current)
>  -               if (!is_current)
>  -                       return data;
>  +       if (only_current && !is_current)
>  +               return data;
>
>         /* feature code */
>         *data++ = 0x01;
>  @@ -956,7 +960,7 @@ static int mmc_get_configuration(int host_no, struct scsi_cmd *cmd)
>         rt = cmd->scb[1] & 0x03;
>
>         start = cmd->scb[2];
>  -       start = (start<<8) | cmd->scb[3];
>  +       start = (start << 8) | cmd->scb[3];
>
>         memset(buf, 0, sizeof(buf));
>         data = buf;
>  @@ -964,46 +968,48 @@ static int mmc_get_configuration(int host_no, struct scsi_cmd *cmd)
>         data += 4;
>
>         /* reserved */
>  -       *data++ = 0;
>  -       *data++ = 0;
>  +       *data++ = 0;
>  +       *data++ = 0;
>         /* current profile */
>  -       *data++ = (mmc->current_profile>>8)&0xff;
>  -       *data++ = (mmc->current_profile   )&0xff;
>  +       *data++ = (mmc->current_profile >> 8) & 0xff;
>  +       *data++ = mmc->current_profile & 0xff;
>
>         /* add the features */
>  -       for (f=features;f->func;f++) {
>  +       for (f = features; f->func; f++) {
>                 /* only return features >= the start feature */
>                 if (f->feature < start)
>                         continue;
>                 /* if rt==2 we skip all other features except start */
>  -               if ( (rt==2) && (f->feature!=start) )
>  +               if (rt == 2 && f->feature != start)
>                         continue;
>
>  -               data = f->func(cmd, data, (rt==1)?1:0 );
>  +               data = f->func(cmd, data, rt == 1);
>         }
>
>         tmp = data-buf;
>         tmp -= 4;
>
>  -       buf[0] = (tmp>>24)&0xff;
>  -       buf[1] = (tmp>>16)&0xff;
>  -       buf[2] = (tmp>> 8)&0xff;
>  -       buf[3] = (tmp    )&0xff;
>  +       buf[0] = (tmp >> 24) & 0xff;
>  +       buf[1] = (tmp >> 16) & 0xff;
>  +       buf[2] = (tmp >> 8) & 0xff;
>  +       buf[3] = tmp & 0xff;
>
>         tmp = data-buf;
>
>         memcpy(scsi_get_in_buffer(cmd), buf,
>  -              min(scsi_get_in_length(cmd), (uint32_t) sizeof(buf)));
>  +              min_t(uint32_t, scsi_get_in_length(cmd), sizeof(buf)));
>
>         /* dont report overflow/underflow for GET CONFIGURATION */
>         return SAM_STAT_GOOD;
>   }
>
>  -unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data, unsigned int lba)
>  +static unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data,
>  +                                    unsigned int lba)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>         unsigned long tmp;
>  -       switch(mmc->current_profile){
>  +
>  +       switch (mmc->current_profile) {
>         case PROFILE_DVD_PLUS_R:
>                 /* track number LSB */
>                 *data++ = 1;
>  @@ -1014,7 +1020,7 @@ unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data, unsigne
>                 /* reserved */
>                 *data++ = 0;
>
>  -               /* damage:0 copy:0 track_mode:DVD+R */
>  +               /* damage:0 copy:0 track_mode:DVD+R */
>                 *data++ = 0x07;
>
>                 /* rt:0 blank:1 packet/inc:0 fp:0 data mode:1 */
>  @@ -1066,7 +1072,7 @@ unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data, unsigne
>                 *data++ = 0;
>
>                 /* reserved */
>  -               data+=2;
>  +               data += 2;
>
>                 /* read compat lba */
>                 *data++ = 0x00;
>  @@ -1085,7 +1091,7 @@ unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data, unsigne
>                 /* reserved */
>                 *data++ = 0;
>
>  -               /* damage:0 copy:0 track_mode:other media */
>  +               /* damage:0 copy:0 track_mode:other media */
>                 *data++ = 0x04;
>
>                 /* rt:0 blank:0 packet/inc:0 fp:0 data mode:1 */
>  @@ -1120,17 +1126,17 @@ unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data, unsigne
>
>                 /* track size */
>                 tmp = cmd->dev->size >> MMC_BLK_SHIFT;
>  -               *data++ = (tmp>>24)&0xff;
>  -               *data++ = (tmp>>16)&0xff;
>  -               *data++ = (tmp>> 8)&0xff;
>  -               *data++ = (tmp    )&0xff;
>  +               *data++ = (tmp >> 24) & 0xff;
>  +               *data++ = (tmp >> 16) & 0xff;
>  +               *data++ = (tmp >> 8) & 0xff;
>  +               *data++ = tmp & 0xff;
>
>                 /* last recorded address */
>                 tmp--;  /* one less */
>  -               *data++ = (tmp>>24)&0xff;
>  -               *data++ = (tmp>>16)&0xff;
>  -               *data++ = (tmp>> 8)&0xff;
>  -               *data++ = (tmp    )&0xff;
>  +               *data++ = (tmp >> 24) & 0xff;
>  +               *data++ = (tmp >> 16) & 0xff;
>  +               *data++ = (tmp >> 8) & 0xff;
>  +               *data++ = tmp & 0xff;
>
>                 /* track number MSB */
>                 *data++ = 0;
>  @@ -1139,27 +1145,29 @@ unsigned char *track_type_lba(struct scsi_cmd *cmd, unsigned char *data, unsigne
>                 *data++ = 0;
>
>                 /* reserved */
>  -               data+=2;
>  +               data += 2;
>
>                 return data;
>         }
>  -
>  +
>         /* we do not understand/support this profile */
>         scsi_set_in_resid_by_actual(cmd, 0);
>         sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
>         return NULL;
>   }
>
>  -unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsigned int lba)
>  +static unsigned char *track_type_track(struct scsi_cmd *cmd,
>  +                                      unsigned char *data, unsigned int lba)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>         unsigned long tmp;
>
>  -       switch(mmc->current_profile){
>  +       switch (mmc->current_profile) {
>         case PROFILE_DVD_PLUS_R:
>  -               if (lba == 0) {
>  +               if (!lba) {
>                         scsi_set_in_resid_by_actual(cmd, 0);
>  -                       sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
>  +                       sense_data_build(cmd, NOT_READY,
>  +                                        ASC_INVALID_FIELD_IN_CDB);
>                         return NULL;
>                 }
>
>  @@ -1172,7 +1180,7 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
>                 /* reserved */
>                 *data++ = 0;
>
>  -               /* damage:0 copy:0 track_mode:DVD+R */
>  +               /* damage:0 copy:0 track_mode:DVD+R */
>                 *data++ = 0x07;
>
>                 /* rt:0 blank:1 packet/inc:0 fp:0 data mode:1 */
>  @@ -1224,7 +1232,7 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
>                 *data++ = 0;
>
>                 /* reserved */
>  -               data+=2;
>  +               data += 2;
>
>                 /* read compat lba */
>                 *data++ = 0x00;
>  @@ -1237,7 +1245,8 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
>                 /* we only have one track */
>                 if (lba != 1) {
>                         scsi_set_in_resid_by_actual(cmd, 0);
>  -                       sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
>  +                       sense_data_build(cmd, NOT_READY,
>  +                                        ASC_INVALID_FIELD_IN_CDB);
>                         return NULL;
>                 }
>
>  @@ -1250,7 +1259,7 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
>                 /* reserved */
>                 *data++ = 0;
>
>  -               /* damage:0 copy:0 track_mode:other media */
>  +               /* damage:0 copy:0 track_mode:other media */
>                 *data++ = 0x04;
>
>                 /* rt:0 blank:0 packet/inc:0 fp:0 data mode:1 */
>  @@ -1285,17 +1294,17 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
>
>                 /* track size */
>                 tmp = cmd->dev->size >> MMC_BLK_SHIFT;
>  -               *data++ = (tmp>>24)&0xff;
>  -               *data++ = (tmp>>16)&0xff;
>  -               *data++ = (tmp>> 8)&0xff;
>  -               *data++ = (tmp    )&0xff;
>  +               *data++ = (tmp >> 24) & 0xff;
>  +               *data++ = (tmp >> 16) & 0xff;
>  +               *data++ = (tmp >> 8) & 0xff;
>  +               *data++ = tmp & 0xff;
>
>                 /* last recorded address */
>                 tmp--;  /* one less */
>  -               *data++ = (tmp>>24)&0xff;
>  -               *data++ = (tmp>>16)&0xff;
>  -               *data++ = (tmp>> 8)&0xff;
>  -               *data++ = (tmp    )&0xff;
>  +               *data++ = (tmp >> 24) & 0xff;
>  +               *data++ = (tmp >> 16) & 0xff;
>  +               *data++ = (tmp >> 8) & 0xff;
>  +               *data++ = tmp & 0xff;
>
>                 /* track number MSB */
>                 *data++ = 0;
>  @@ -1304,11 +1313,11 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
>                 *data++ = 0;
>
>                 /* reserved */
>  -               data+=2;
>  +               data += 2;
>
>                 return data;
>         }
>  -
>  +
>         /* we do not understand/support this profile */
>         scsi_set_in_resid_by_actual(cmd, 0);
>         sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
>  @@ -1321,7 +1330,8 @@ unsigned char *track_type_track(struct scsi_cmd *cmd, unsigned char *data, unsig
>
>   struct track_type {
>         int type;
>  -       unsigned char *(*func)(struct scsi_cmd *cmd, unsigned char *data, unsigned int lba);
>  +       unsigned char *(*func)(struct scsi_cmd *cmd, unsigned char *data,
>  +                              unsigned int lba);
>   };
>   struct track_type track_types[] = {
>         {TRACK_INFO_LBA,     track_type_lba},
>  @@ -1354,23 +1364,22 @@ static int mmc_read_track_information(int host_no, struct scsi_cmd *cmd)
>         memset(buf, 0, sizeof(buf));
>         data = &buf[2];
>
>  -       for(t=track_types;t->func;t++){
>  +       for (t = track_types; t->func; t++) {
>                 int tmp;
>
>  -               if (t->type != type) {
>  +               if (t->type != type)
>                         continue;
>  -               }
>  +
>                 data = t->func(cmd, data, lba);
>  -               if (data == NULL) {
>  +
>  +               if (!data)
>                         return SAM_STAT_CHECK_CONDITION;
>  -               }
>
>                 tmp = data-&buf[2];
>  -               buf[0] = (tmp>>8)&0xff;
>  -               buf[1] = (tmp   )&0xff;
>  +               buf[0] = (tmp >> 8) & 0xff;
>  +               buf[1] = tmp & 0xff;
>                 memcpy(scsi_get_in_buffer(cmd), buf,
>  -                       min(scsi_get_in_length(cmd),
>  -                               (uint32_t) sizeof(buf)));
>  +                      min_t(uint32_t, scsi_get_in_length(cmd), sizeof(buf)));
>                 return SAM_STAT_GOOD;
>         }
>
>  @@ -1379,7 +1388,7 @@ static int mmc_read_track_information(int host_no, struct scsi_cmd *cmd)
>         sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
>         return SAM_STAT_CHECK_CONDITION;
>   }
>  -
>  +
>   static int mmc_read_buffer_capacity(int host_no, struct scsi_cmd *cmd)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>  @@ -1403,7 +1412,7 @@ static int mmc_read_buffer_capacity(int host_no, struct scsi_cmd *cmd)
>                 /* data length */
>                 buf[0] = 0x00;
>                 buf[1] = 0x0a;
>  -
>  +
>                 /* 4096 blocks */
>                 tmp = 0x1000;
>                 if (!blocks) {
>  @@ -1412,21 +1421,21 @@ static int mmc_read_buffer_capacity(int host_no, struct scsi_cmd *cmd)
>                 }
>
>                 /* length of buffer */
>  -               buf[4]  = (tmp>>24)&0xff;
>  -               buf[5]  = (tmp>>16)&0xff;
>  -               buf[6] = (tmp>> 8)&0xff;
>  -               buf[7] = (tmp    )&0xff;
>  +               buf[4] = (tmp >> 24) & 0xff;
>  +               buf[5] = (tmp >> 16) & 0xff;
>  +               buf[6] = (tmp >> 8) & 0xff;
>  +               buf[7] = tmp & 0xff;
>
>                 /* available length of buffer (always half) */
>                 tmp = tmp >> 1;
>  -               buf[8]  = (tmp>>24)&0xff;
>  -               buf[9]  = (tmp>>16)&0xff;
>  -               buf[10] = (tmp>> 8)&0xff;
>  -               buf[11] = (tmp    )&0xff;
>  +               buf[8]  = (tmp >> 24) & 0xff;
>  +               buf[9]  = (tmp >> 16) & 0xff;
>  +               buf[10] = (tmp >> 8) & 0xff;
>  +               buf[11] = tmp & 0xff;
>
>  -               memcpy(scsi_get_in_buffer(cmd), &buf[0],
>  +               memcpy(scsi_get_in_buffer(cmd), buf,
>                        min(scsi_get_in_length(cmd), (uint32_t) sizeof(buf)));
>  -               scsi_set_in_resid_by_actual(cmd, buf[1]+2);
>  +               scsi_set_in_resid_by_actual(cmd, buf[1] + 2);
>                 return SAM_STAT_GOOD;
>         }
>
>  @@ -1438,7 +1447,7 @@ static int mmc_read_buffer_capacity(int host_no, struct scsi_cmd *cmd)
>   static int mmc_synchronize_cache(int host_no, struct scsi_cmd *cmd)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>  -
>  +
>         if (mmc->current_profile == PROFILE_NO_PROFILE) {
>                 scsi_set_in_resid_by_actual(cmd, 0);
>                 sense_data_build(cmd, NOT_READY, ASC_MEDIUM_NOT_PRESENT);
>  @@ -1448,14 +1457,17 @@ static int mmc_synchronize_cache(int host_no, struct scsi_cmd *cmd)
>         return SAM_STAT_GOOD;
>   }
>
>  -unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data, unsigned int type, unsigned int data_type)
>  +static unsigned char *perf_type_write_speed(struct scsi_cmd *cmd,
>  +                                           unsigned char *data,
>  +                                           unsigned int type,
>  +                                           unsigned int data_type)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>
>         /* write/except */
>         *data++ = 0x00;
>
>  -       data+=3;
>  +       data += 3;
>
>         switch (mmc->current_profile) {
>         case PROFILE_NO_PROFILE:
>  @@ -1464,7 +1476,7 @@ unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data,
>                 *data++ = 0x00;
>
>                 /* reserved */
>  -               data+=3;
>  +               data += 3;
>
>                 /* end lba */
>                 *data++ = 0x00;
>  @@ -1489,7 +1501,7 @@ unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data,
>                 *data++ = 0x00;
>
>                 /* reserved */
>  -               data+=3;
>  +               data += 3;
>
>                 /* end lba */
>                 *data++ = 0x00;
>  @@ -1517,7 +1529,7 @@ unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data,
>                 *data++ = 0x01;
>
>                 /* reserved */
>  -               data+=3;
>  +               data += 3;
>
>                 /* end lba */
>                 *data++ = 0x00;
>  @@ -1545,7 +1557,7 @@ unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data,
>                 *data++ = 0x00;
>
>                 /* reserved */
>  -               data+=3;
>  +               data += 3;
>
>                 /* end lba */
>                 *data++ = 0x00;
>  @@ -1570,7 +1582,7 @@ unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data,
>                 *data++ = 0x00;
>
>                 /* reserved */
>  -               data+=3;
>  +               data += 3;
>
>                 /* end lba */
>                 *data++ = 0x00;
>  @@ -1600,7 +1612,10 @@ unsigned char *perf_type_write_speed(struct scsi_cmd *cmd, unsigned char *data,
>         return NULL;
>   }
>
>  -unsigned char *perf_type_perf_data(struct scsi_cmd *cmd, unsigned char *data, unsigned int type, unsigned int data_type)
>  +static unsigned char *perf_type_perf_data(struct scsi_cmd *cmd,
>  +                                         unsigned char *data,
>  +                                         unsigned int type,
>  +                                         unsigned int data_type)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>         int tolerance;
>  @@ -1608,9 +1623,9 @@ unsigned char *perf_type_perf_data(struct scsi_cmd *cmd, unsigned char *data, un
>         int except;
>         long tmp;
>
>  -       tolerance  = (data_type>>3)&0x03;
>  -       write_flag = (data_type>>2)&0x01;
>  -       except     = data_type&0x03;
>  +       tolerance  = (data_type >> 3) & 0x03;
>  +       write_flag = (data_type >> 2) & 0x01;
>  +       except = data_type & 0x03;
>
>         /* all other values for tolerance are reserved */
>         if (tolerance != 0x02) {
>  @@ -1619,14 +1634,14 @@ unsigned char *perf_type_perf_data(struct scsi_cmd *cmd, unsigned char *data, un
>                 return NULL;
>         }
>
>  -       switch(except){
>  +       switch (except) {
>         case 1:
>         case 2:
>                 /* write/except */
>                 *data++ = 0x01;
>
>                 /* reserved */
>  -               data+=3;
>  +               data += 3;
>
>                 /* no actual descriptor returned here */
>                 return data;
>  @@ -1638,14 +1653,13 @@ unsigned char *perf_type_perf_data(struct scsi_cmd *cmd, unsigned char *data, un
>         }
>
>         /* write/except */
>  -       if (write_flag) {
>  +       if (write_flag)
>                 *data++ = 0x02;
>  -       } else {
>  +       else
>                 *data++ = 0x00;
>  -       }
>
>         /* reserved */
>  -       data+=3;
>  +       data += 3;
>
>         /* start lba */
>         *data++ = 0;
>  @@ -1666,11 +1680,12 @@ unsigned char *perf_type_perf_data(struct scsi_cmd *cmd, unsigned char *data, un
>                 break;
>         default:
>                 tmp = 0x23053f;
>  -       }
>  -       *data++ = (tmp>>24)&0xff;
>  -       *data++ = (tmp>>16)&0xff;
>  -       *data++ = (tmp>> 8)&0xff;
>  -       *data++ = (tmp    )&0xff;
>  +       }
>  +
>  +       *data++ = (tmp >> 24) & 0xff;
>  +       *data++ = (tmp >> 16) & 0xff;
>  +       *data++ = (tmp >> 8) & 0xff;
>  +       *data++ = tmp & 0xff;
>
>         /* end performance */
>         *data++ = 0x00;
>  @@ -1685,7 +1700,8 @@ unsigned char *perf_type_perf_data(struct scsi_cmd *cmd, unsigned char *data, un
>   #define PERF_TYPE_WRITE_SPEED          0x03
>   struct perf_type {
>         int type;
>  -       unsigned char *(*func)(struct scsi_cmd *cmd, unsigned char *data, unsigned int type, unsigned int data_type);
>  +       unsigned char *(*func)(struct scsi_cmd *cmd, unsigned char *data,
>  +                              unsigned int type, unsigned int data_type);
>   };
>   struct perf_type perf_types[] = {
>         {PERF_TYPE_PERF_DATA, perf_type_perf_data},
>  @@ -1718,25 +1734,23 @@ static int mmc_get_performance(int host_no, struct scsi_cmd *cmd)
>
>         type = cmd->scb[10];
>
>  -       for (p=perf_types;p->func;p++) {
>  +       for (p = perf_types; p->func; p++) {
>                 int tmp;
>
>  -               if (p->type != type) {
>  +               if (p->type != type)
>                         continue;
>  -               }
>  +
>                 data = p->func(cmd, data, type, data_type);
>  -               if (data == NULL) {
>  +               if (!data)
>                         return SAM_STAT_CHECK_CONDITION;
>  -               }
>
>                 tmp = data-&buf[4];
>  -               buf[0] = (tmp>>24)&0xff;
>  -               buf[1] = (tmp>>16)&0xff;
>  -               buf[2] = (tmp>> 8)&0xff;
>  -               buf[3] = (tmp    )&0xff;
>  +               buf[0] = (tmp >> 24) & 0xff;
>  +               buf[1] = (tmp >> 16) & 0xff;
>  +               buf[2] = (tmp >> 8) & 0xff;
>  +               buf[3] = tmp & 0xff;
>                 memcpy(scsi_get_in_buffer(cmd), buf,
>  -                       min(scsi_get_in_length(cmd),
>  -                               (uint32_t) sizeof(buf)));
>  +                      min_t(uint32_t, scsi_get_in_length(cmd), sizeof(buf)));
>                 return SAM_STAT_GOOD;
>
>         }
>  @@ -1752,14 +1766,14 @@ static int mmc_set_streaming(int host_no, struct scsi_cmd *cmd)
>         return SAM_STAT_GOOD;
>   }
>
>  -
>   #define DVD_FORMAT_PHYS_INFO           0x00
>   #define DVD_FORMAT_DVD_COPYRIGHT_INFO  0x01
>   #define DVD_FORMAT_ADIP_INFO           0x11
>   #define DVD_FORMAT_DVD_STRUCTURE_LIST  0xff
>
>  -
>  -unsigned char *dvd_format_phys_info(struct scsi_cmd *cmd, unsigned char *data, int format, int layer, int write_header)
>  +static unsigned char *dvd_format_phys_info(struct scsi_cmd *cmd,
>  +                                          unsigned char *data, int format,
>  +                                          int layer, int write_header)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>         unsigned char *old_data;
>  @@ -1772,7 +1786,7 @@ unsigned char *dvd_format_phys_info(struct scsi_cmd *cmd, unsigned char *data, i
>                 return data;
>         }
>
>  -       if (layer != 0) {
>  +       if (layer) {
>                 /* we only support single layer disks */
>                 scsi_set_in_resid_by_actual(cmd, 0);
>                 sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
>  @@ -1816,8 +1830,7 @@ unsigned char *dvd_format_phys_info(struct scsi_cmd *cmd, unsigned char *data, i
>                 *data++ = 0;
>
>                 /* just leave the media specific area as 0 */
>  -               data+=2031;
>  -
>  +               data += 2031;
>                 break;
>         case PROFILE_DVD_PLUS_R:
>                 /* book type DVD+R, part version */
>  @@ -1897,7 +1910,7 @@ unsigned char *dvd_format_phys_info(struct scsi_cmd *cmd, unsigned char *data, i
>                 *data++ = 0x00; *data++ = 0x00; *data++ = 0x00; *data++ = 0x00;
>                 *data++ = 0x00; *data++ = 0x00; *data++ = 0x00;
>
>  -               data=old_data+2031;
>  +               data = old_data + 2031;
>
>                 break;
>         default:
>  @@ -1909,13 +1922,15 @@ unsigned char *dvd_format_phys_info(struct scsi_cmd *cmd, unsigned char *data, i
>         return data;
>   }
>
>  -unsigned char *dvd_format_adip_info(struct scsi_cmd *cmd, unsigned char *data, int format, int layer, int write_header)
>  +static unsigned char *dvd_format_adip_info(struct scsi_cmd *cmd,
>  +                                          unsigned char *data, int format,
>  +                                          int layer, int write_header)
>   {
>         struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
>
>         if (write_header) {
>                 *data++ = DVD_FORMAT_ADIP_INFO;
>  -               switch(mmc->current_profile){
>  +               switch (mmc->current_profile) {
>                 case PROFILE_DVD_PLUS_R:
>                         *data++ = 0x40; /* readable */
>                         break;
>  @@ -2006,7 +2021,10 @@ unsigned char *dvd_format_adip_info(struct scsi_cmd *cmd, unsigned char *data, i
>         return data;
>   }
>
>  -unsigned char *dvd_format_copyright_info(struct scsi_cmd *cmd, unsigned char *data, int format, int layer, int write_header)
>  +static unsigned char *dvd_format_copyright_info(struct scsi_cmd *cmd,
>  +                                               unsigned char *data,
>  +                                               int format, int layer,
>  +                                               int write_header)
>   {
>         if (write_header) {
>                 *data++ = DVD_FORMAT_DVD_COPYRIGHT_INFO;
>  @@ -2016,7 +2034,7 @@ unsigned char *dvd_format_copyright_info(struct scsi_cmd *cmd, unsigned char *da
>                 return data;
>         }
>
>  -       if (layer != 0) {
>  +       if (layer) {
>                 /* we only support single layer disks */
>                 scsi_set_in_resid_by_actual(cmd, 0);
>                 sense_data_build(cmd, NOT_READY, ASC_INVALID_FIELD_IN_CDB);
>  @@ -2032,16 +2050,21 @@ unsigned char *dvd_format_copyright_info(struct scsi_cmd *cmd, unsigned char *da
>         /* reserved */
>         *data++ = 0;
>         *data++ = 0;
>  -
>  +
>         return data;
>   }
>
>  -unsigned char *dvd_format_dvd_structure_list(struct scsi_cmd *cmd, unsigned char *data, int format, int layer, int write_header);
>  -
>  +static unsigned char *dvd_format_dvd_structure_list(struct scsi_cmd *cmd,
>  +                                                   unsigned char *data,
>  +                                                   int format,
>  +                                                   int layer,
>  +                                                   int write_header);
>   struct dvd_format {
>         int format;
>  -       unsigned char *(*func)(struct scsi_cmd *cmd, unsigned char *data, int format, int layer, int write_header);
>  +       unsigned char *(*func)(struct scsi_cmd *cmd, unsigned char *data,
>  +                              int format, int layer, int write_header);
>   };
>  +
>   struct dvd_format dvd_formats[] = {
>         {DVD_FORMAT_PHYS_INFO,          dvd_format_phys_info},
>         {DVD_FORMAT_DVD_COPYRIGHT_INFO, dvd_format_copyright_info},
>  @@ -2050,20 +2073,22 @@ struct dvd_format dvd_formats[] = {
>         {0, NULL}
>   };
>
>  -unsigned char *dvd_format_dvd_structure_list(struct scsi_cmd *cmd, unsigned char *data, int format, int layer, int write_header)
>  +static unsigned char *dvd_format_dvd_structure_list(struct scsi_cmd *cmd,
>  +                                                   unsigned char *data,
>  +                                                   int format,
>  +                                                   int layer, int write_header)
>   {
>         struct dvd_format *f;
>
>         /* list all format headers */
>  -       for (f=dvd_formats;f->func;f++) {
>  +       for (f = dvd_formats; f->func; f++) {
>                 /* we dont report ourself back in the format list */
>                 if (f->format == 0xff)
>                         continue;
>  -
>  +
>                 data = f->func(cmd, data, format, layer, 1);
>  -               if (data == NULL) {
>  +               if (!data)
>                         return NULL;
>  -               }
>         }
>
>         return data;
>  @@ -2094,24 +2119,23 @@ static int mmc_read_dvd_structure(int host_no, struct scsi_cmd *cmd)
>         memset(buf, 0, sizeof(buf));
>         data = &buf[4];
>
>  -       for (f=dvd_formats;f->func;f++) {
>  +       for (f = dvd_formats; f->func; f++) {
>                 if (f->format == format) {
>                         int tmp;
>
>                         data = f->func(cmd, data, format, layer, 0);
>  -                       if (data == NULL) {
>  +                       if (!data)
>                                 return SAM_STAT_CHECK_CONDITION;
>  -                       }
>
>  -                       tmp = data-buf;
>  +                       tmp = data - buf;
>                         tmp -= 2;
>  -                       buf[0] = (tmp>>8)&0xff;
>  -                       buf[1] = (tmp   )&0xff;
>  +                       buf[0] = (tmp >> 8) & 0xff;
>  +                       buf[1] = tmp & 0xff;
>                         buf[2] = 0;
>                         buf[3] = 0;
>                         memcpy(scsi_get_in_buffer(cmd), buf,
>  -                               min(scsi_get_in_length(cmd),
>  -                                       (uint32_t) sizeof(buf)));
>  +                              min_t(uint32_t,
>  +                                    scsi_get_in_length(cmd), sizeof(buf)));
>                         return SAM_STAT_GOOD;
>                 }
>         }
>  @@ -2137,7 +2161,7 @@ static int mmc_lu_init(struct scsi_lu *lu)
>         struct mmc_info *mmc;
>
>         mmc = zalloc(sizeof(struct mmc_info));
>  -       if (mmc == NULL)
>  +       if (!mmc)
>                 return -ENOMEM;
>
>         lu->mmc_p = mmc;
>  @@ -2153,7 +2177,8 @@ static int mmc_lu_init(struct scsi_lu *lu)
>         }
>         lu->bst = bst;
>
>  -       strncpy(lu->attrs.product_id, "VIRTUAL-CDROM", sizeof(lu->attrs.product_id));
>  +       strncpy(lu->attrs.product_id, "VIRTUAL-CDROM",
>  +               sizeof(lu->attrs.product_id));
>         lu->attrs.sense_format = 0;
>         lu->attrs.version_desc[0] = 0x02A0; /* MMC3, no version claimed */
>         lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
>  @@ -2198,23 +2223,21 @@ static int mmc_lu_online(struct scsi_lu *lu)
>
>         mmc->current_profile = PROFILE_NO_PROFILE;
>
>  -       if (lu->fd == -1) {
>  +       if (lu->fd == -1)
>                 return TGTADM_INVALID_REQUEST;
>  -       }
>
>         lu->attrs.online = 1;
>
>  -       if (stat(lu->path, &st) != 0) {
>  +       if (stat(lu->path, &st)) {
>                 mmc->current_profile = PROFILE_NO_PROFILE;
>                 lu->attrs.online = 0;
>         } else {
>  -               if (st.st_size == 0) {
>  +               if (!st.st_size)
>                         mmc->current_profile = PROFILE_DVD_PLUS_R;
>  -               } else {
>  +               else
>                         mmc->current_profile = PROFILE_DVD_ROM;
>  -               }
>         }
>  -
>  +
>         return 0;
>   }
>
>


From fujita.tomonori at lab.ntt.co.jp  Fri May  2 01:17:11 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 02 May 2008 08:17:11 +0900
Subject: [Stgt-devel] Prototype MMC DVD-ROM and burnable
	DVD+R	implementation
In-Reply-To: <c9a3e4540805011324r25536056v5c4496e3717584aa@mail.gmail.com>
References: <c9a3e4540804282331w5530012bw8458dbc5b6032602@mail.gmail.com>
	<20080501235442O.tomof@acm.org>
	<c9a3e4540805011324r25536056v5c4496e3717584aa@mail.gmail.com>
Message-ID: <20080502081711W.fujita.tomonori@lab.ntt.co.jp>

On Fri, 2 May 2008 06:24:44 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> Hi,
> 
> That looks good to me.

Thanks!


> please push that patchset and I will re-sync and start adding
> RESERVE/RELEASE to all commands.

I've pushed all the changes.


From ronniesahlberg at gmail.com  Fri May  2 01:31:46 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Fri, 2 May 2008 09:31:46 +1000
Subject: [Stgt-devel] MMC emulation documentation update
Message-ID: <c9a3e4540805011631w3f1bbb7eyc9f84abbda61dd93@mail.gmail.com>

Please find attached a patch that adds a file README.mmc that
documents the current capabilities of the MMC emulation and also
provides examples on

1, how to create a LUN emulating a DVD device containing a blank
writeable DVD+R disk
2, how to make the device offline and swap the "disk" in the tray to a
different disk.

regards
ronnie sahlberg
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0001-Add-documentation-about-the-MMC-emulation.patch.gz
Type: application/x-gzip
Size: 2100 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080502/74da6aae/attachment.bin>

From fujita.tomonori at lab.ntt.co.jp  Fri May  2 02:48:37 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 02 May 2008 09:48:37 +0900
Subject: [Stgt-devel] MMC emulation documentation update
In-Reply-To: <c9a3e4540805011631w3f1bbb7eyc9f84abbda61dd93@mail.gmail.com>
References: <c9a3e4540805011631w3f1bbb7eyc9f84abbda61dd93@mail.gmail.com>
Message-ID: <20080502094837W.fujita.tomonori@lab.ntt.co.jp>

On Fri, 2 May 2008 09:31:46 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> Please find attached a patch that adds a file README.mmc that
> documents the current capabilities of the MMC emulation and also
> provides examples on
> 
> 1, how to create a LUN emulating a DVD device containing a blank
> writeable DVD+R disk
> 2, how to make the device offline and swap the "disk" in the tray to a
> different disk.

Applied, thanks a lot!


From ronniesahlberg at gmail.com  Fri May  2 06:06:04 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Fri, 2 May 2008 14:06:04 +1000
Subject: [Stgt-devel] Patches for MMC and fix for serious crash bug in
	spc_mode_sense()
Message-ID: <c9a3e4540805012106p7821a705lc9f90e18babd9eae@mail.gmail.com>

Please find attached a few smallish patches,

0001: Fix a "length too small by one" bug in mode sense 10.

0002 : we dont need to specify these mode pages in the mmc example
since they are set by default when the lun is initialized

0003 : add the modepage for MM capabilities (this mode page was what
discovered the bug below)

0004: this fixes a serious crash bug in spc_mode_sense. the bug is
triggered when an initiator is specifying a small alloc_len but the
modepage is big.
This causes the memcpy() in build_mode_page() overwrite other vital
memory and tgtd crashes.
I tried to address it for modesense10 only.   The same bug still
exists for the modesense6 path.
Please   if someone more comfortable than I can look at the issue and
do a better/more correct patch for this.
This is a pretty important bug to fix.


regards
ronnie sahlberg
-------------- next part --------------
A non-text attachment was scrubbed...
Name: mmc.diff.gz
Type: application/x-gzip
Size: 2688 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080502/3f0fc741/attachment.bin>

From ronniesahlberg at gmail.com  Fri May  2 08:47:16 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Fri, 2 May 2008 16:47:16 +1000
Subject: [Stgt-devel] Patches for MMC and fix for serious crash bug in
	spc_mode_sense()
In-Reply-To: <c9a3e4540805012106p7821a705lc9f90e18babd9eae@mail.gmail.com>
References: <c9a3e4540805012106p7821a705lc9f90e18babd9eae@mail.gmail.com>
Message-ID: <c9a3e4540805012347n63c33e4avc704353c64d29009@mail.gmail.com>

Please note that patch 0004 is completely bogus and broken.
The patch only serves to illustrate where the crash bug in TGTD is for
spc_mode_sense()   and should not be applied.
(the bug still needs to be addressed though)

Please apply patches 0001 - 0003 though.


On Fri, May 2, 2008 at 2:06 PM, ronnie sahlberg
<ronniesahlberg at gmail.com> wrote:
> Please find attached a few smallish patches,
>
> 0001: Fix a "length too small by one" bug in mode sense 10.
>
> 0002 : we dont need to specify these mode pages in the mmc example
> since they are set by default when the lun is initialized
>
> 0003 : add the modepage for MM capabilities (this mode page was what
> discovered the bug below)
>
> 0004: this fixes a serious crash bug in spc_mode_sense. the bug is
> triggered when an initiator is specifying a small alloc_len but the
> modepage is big.
> This causes the memcpy() in build_mode_page() overwrite other vital
> memory and tgtd crashes.
> I tried to address it for modesense10 only.   The same bug still
> exists for the modesense6 path.
> Please   if someone more comfortable than I can look at the issue and
> do a better/more correct patch for this.
> This is a pretty important bug to fix.
>
>
> regards
> ronnie sahlberg
>


From ronniesahlberg at gmail.com  Fri May  2 14:55:22 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Fri, 2 May 2008 22:55:22 +1000
Subject: [Stgt-devel] Patches for MMC and fix for serious crash bug in
	spc_mode_sense()
In-Reply-To: <c9a3e4540805012106p7821a705lc9f90e18babd9eae@mail.gmail.com>
References: <c9a3e4540805012106p7821a705lc9f90e18babd9eae@mail.gmail.com>
Message-ID: <c9a3e4540805020555m1ace28a7w6ce0f69e323b4d88@mail.gmail.com>

Please disregard the previous pathset

Please find attached a patchset that contains

0001 fix a bug in mode sense 10  where the data length is 1 too little
0002 dont set modepages in the example, these pages are created by
default when the lun is created anyway
0003 add modepage for mm capabilities
0004 fix crashbug in spc_mode_sense()    if an application is asking
for mode sense and specifies a small allocation length,
spc_mode_sense() and build_mode_page() would write beyond the end of
the data array and overwrite other things causing tgtd to crash
has probably not been seen before since prior to 0003 above, there
hasnt been any very large mode pages   and tgtd just must have been
lucky.
0005 mode page for write parameters
0006 example on how to use dvdrecorder under linux with the emulation
0007 final fix so that both windows dvddecrypter and also linux
dvdrecorder can write to the emulated lun


please apply


regards
ronnie sahlberg




On Fri, May 2, 2008 at 2:06 PM, ronnie sahlberg
<ronniesahlberg at gmail.com> wrote:
> Please find attached a few smallish patches,
>
> 0001: Fix a "length too small by one" bug in mode sense 10.
>
> 0002 : we dont need to specify these mode pages in the mmc example
> since they are set by default when the lun is initialized
>
> 0003 : add the modepage for MM capabilities (this mode page was what
> discovered the bug below)
>
> 0004: this fixes a serious crash bug in spc_mode_sense. the bug is
> triggered when an initiator is specifying a small alloc_len but the
> modepage is big.
> This causes the memcpy() in build_mode_page() overwrite other vital
> memory and tgtd crashes.
> I tried to address it for modesense10 only.   The same bug still
> exists for the modesense6 path.
> Please   if someone more comfortable than I can look at the issue and
> do a better/more correct patch for this.
> This is a pretty important bug to fix.
>
>
> regards
> ronnie sahlberg
>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: mmc.diff.tgz
Type: application/x-gzip
Size: 4537 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080502/18939e9c/attachment.bin>

From fujita.tomonori at lab.ntt.co.jp  Sat May  3 03:32:11 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 3 May 2008 10:32:11 +0900
Subject: [Stgt-devel] Patches for MMC and fix for serious crash bug
	in	spc_mode_sense()
In-Reply-To: <c9a3e4540805020555m1ace28a7w6ce0f69e323b4d88@mail.gmail.com>
References: <c9a3e4540805012106p7821a705lc9f90e18babd9eae@mail.gmail.com>
	<c9a3e4540805020555m1ace28a7w6ce0f69e323b4d88@mail.gmail.com>
Message-ID: <20080503103208X.tomof@acm.org>

On Fri, 2 May 2008 22:55:22 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> Please disregard the previous pathset
> 
> Please find attached a patchset that contains
> 
> 0001 fix a bug in mode sense 10  where the data length is 1 too little
> 0002 dont set modepages in the example, these pages are created by
> default when the lun is created anyway
> 0003 add modepage for mm capabilities
> 0004 fix crashbug in spc_mode_sense()    if an application is asking
> for mode sense and specifies a small allocation length,
> spc_mode_sense() and build_mode_page() would write beyond the end of
> the data array and overwrite other things causing tgtd to crash
> has probably not been seen before since prior to 0003 above, there
> hasnt been any very large mode pages   and tgtd just must have been
> lucky.
> 0005 mode page for write parameters
> 0006 example on how to use dvdrecorder under linux with the emulation
> 0007 final fix so that both windows dvddecrypter and also linux
> dvdrecorder can write to the emulated lun

Thanks,

Can you send patches as just plain text (one patch per email)? Then
wee can read and comment on your patches.

If you are not familiar with the way to send patches in Linux kernel
way, the followings would help:

http://linux.yyz.us/patch-format.html
http://lxr.linux.no/linux/Documentation/SubmittingPatches


From ronniesahlberg at gmail.com  Sat May  3 04:00:58 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sat, 3 May 2008 12:00:58 +1000
Subject: [Stgt-devel] Patches for MMC and fix for serious crash bug in
	spc_mode_sense()
In-Reply-To: <20080503103208X.tomof@acm.org>
References: <c9a3e4540805012106p7821a705lc9f90e18babd9eae@mail.gmail.com>
	<c9a3e4540805020555m1ace28a7w6ce0f69e323b4d88@mail.gmail.com>
	<20080503103208X.tomof@acm.org>
Message-ID: <c9a3e4540805021900u7448c129h34e207f7955aca3f@mail.gmail.com>

do you want me to resend these 7 patches in that way as separate mails?


On Sat, May 3, 2008 at 11:32 AM, FUJITA Tomonori
<fujita.tomonori at lab.ntt.co.jp> wrote:
> On Fri, 2 May 2008 22:55:22 +1000
> "ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:
>
>> Please disregard the previous pathset
>>
>> Please find attached a patchset that contains
>>
>> 0001 fix a bug in mode sense 10  where the data length is 1 too little
>> 0002 dont set modepages in the example, these pages are created by
>> default when the lun is created anyway
>> 0003 add modepage for mm capabilities
>> 0004 fix crashbug in spc_mode_sense()    if an application is asking
>> for mode sense and specifies a small allocation length,
>> spc_mode_sense() and build_mode_page() would write beyond the end of
>> the data array and overwrite other things causing tgtd to crash
>> has probably not been seen before since prior to 0003 above, there
>> hasnt been any very large mode pages   and tgtd just must have been
>> lucky.
>> 0005 mode page for write parameters
>> 0006 example on how to use dvdrecorder under linux with the emulation
>> 0007 final fix so that both windows dvddecrypter and also linux
>> dvdrecorder can write to the emulated lun
>
> Thanks,
>
> Can you send patches as just plain text (one patch per email)? Then
> wee can read and comment on your patches.
>
> If you are not familiar with the way to send patches in Linux kernel
> way, the followings would help:
>
> http://linux.yyz.us/patch-format.html
> http://lxr.linux.no/linux/Documentation/SubmittingPatches
>


From fujita.tomonori at lab.ntt.co.jp  Sat May  3 04:32:46 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 3 May 2008 11:32:46 +0900
Subject: [Stgt-devel] Patches for MMC and fix for serious crash bug
	in	spc_mode_sense()
In-Reply-To: <c9a3e4540805021900u7448c129h34e207f7955aca3f@mail.gmail.com>
References: <c9a3e4540805020555m1ace28a7w6ce0f69e323b4d88@mail.gmail.com>
	<20080503103208X.tomof@acm.org>
	<c9a3e4540805021900u7448c129h34e207f7955aca3f@mail.gmail.com>
Message-ID: <20080503113241E.tomof@acm.org>

On Sat, 3 May 2008 12:00:58 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> do you want me to resend these 7 patches in that way as separate mails?

Yes, please.


From ronniesahlberg at gmail.com  Sat May  3 04:42:29 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sat, 3 May 2008 12:42:29 +1000
Subject: [Stgt-devel] [PATCH 1/7] spc/mmc: modesense10 returns data length 1
	byte too small
Message-ID: <c9a3e4540805021942u4cc0c7f7na8ccd1e75ffce612@mail.gmail.com>


From ronniesahlberg at gmail.com  Fri May  2 14:31:07 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Fri, 2 May 2008 22:31:07 +1000
Subject: [PATCH 1/7] modesense10 length too small by one byte
Message-ID: <mailman.19.1331738481.12506.stgt-devel@lists.berlios.de>

fix a bug in the mode sense 10 data  where the length is one byte too small

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 usr/spc.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/usr/spc.c b/usr/spc.c
index cf2e504..e3e4d98 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -419,7 +419,7 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 		data[0] = len - 1;
 		data[3] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
 	} else {
-		*(uint16_t *)(data) = __cpu_to_be16(len - 3);
+		*(uint16_t *)(data) = __cpu_to_be16(len - 2);
 		data[7] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
 	}

-- 
1.5.5


From ronniesahlberg at gmail.com  Sat May  3 04:43:46 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sat, 3 May 2008 12:43:46 +1000
Subject: [Stgt-devel] [PATCH 2/7] spc/mmc: dont set modepages in the example
	text
Message-ID: <c9a3e4540805021943x63b90dfdu343d0fb94fe1955f@mail.gmail.com>


From ronniesahlberg at gmail.com  Fri May  2 14:32:13 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Fri, 2 May 2008 22:32:13 +1000
Subject: [PATCH 2/7] dont set modepages in the example
Message-ID: <mailman.20.1331738481.12506.stgt-devel@lists.berlios.de>

Done tset the modepages in the example, these pages are added by
default for the device anyway during initialization

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 doc/README.mmc |    7 -------
 1 files changed, 0 insertions(+), 7 deletions(-)

diff --git a/doc/README.mmc b/doc/README.mmc
index 514e15a..265b95a 100644
--- a/doc/README.mmc
+++ b/doc/README.mmc
@@ -65,13 +65,6 @@ tgtadm --lld iscsi --mode logicalunit --op new
--tid 1 --lun 1 -b /tmp/empty-dis
 SN=XYZ123
 tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1
--params vendor_id=STGT_DVD,product_id=DVD101,product_rev=0010,scsi_sn=$SN,removable=1

-# Vendor Uniq - Mode page 0..
-tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1
--params mode_page=0:0:0
-# ctrl mode page
-tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1
--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
-# Informational Exceptions Control Mode Page
-tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1
--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
-

 # Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid 1 -I ALL
-- 
1.5.5


From ronniesahlberg at gmail.com  Sat May  3 04:45:25 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sat, 3 May 2008 12:45:25 +1000
Subject: [Stgt-devel] [PATCH 3/7] spc/mmc: add modepage for MM capabilities
Message-ID: <c9a3e4540805021945s2a9a1208vd7ff8ce08387255a@mail.gmail.com>


From ronniesahlberg at gmail.com  Fri May  2 14:33:02 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Fri, 2 May 2008 22:33:02 +1000
Subject: [PATCH 3/7] modepage for mm capabilities
Message-ID: <mailman.21.1331738481.12506.stgt-devel@lists.berlios.de>

add a modepage for mm capabilities

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 usr/mmc.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index 6c0dcac..ce66c7c 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -2212,6 +2212,8 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
 	/* Timeout & Protect */
 	add_mode_page(lu, "0x1d:0:10:0:0:7:0:0:2:0:2:0:20");
+	/* MM capabilities */
+	add_mode_page(lu,
"0x2a:0:0x3e:0x3f:0x37:0xf3:0xf3:0x29:0x23:0x10:0x8a:0x01:0x00:0x08:0x00:0x10:0x8a:0x00:0x00:0x10:0x8a:0x10:0x8a:0x00:0x01:0x00:0x00:0x00:0x00:0x10:0x8a:0x00:0x05:0x00:0x00:0x10:0x8a:0x00:0x00:0x0b:0x06:0x00:0x00:0x08:0x45:0x00:0x00:0x05:0x83:0x00:0x00:0x02:0xc2:0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00");

 	return 0;
 }
-- 
1.5.5


From ronniesahlberg at gmail.com  Sat May  3 04:46:54 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sat, 3 May 2008 12:46:54 +1000
Subject: [Stgt-devel] [PATCH 4/7] spc/mmc: dont write outside the buffer in
	spc_mode_sense()
Message-ID: <c9a3e4540805021946s39f4e83es8cbc20dfa8434aa0@mail.gmail.com>


From ronniesahlberg at gmail.com  Fri May  2 14:36:54 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Fri, 2 May 2008 22:36:54 +1000
Subject: [PATCH 4/7] crash bug in spc_mode_sense
Message-ID: <mailman.22.1331738481.12506.stgt-devel@lists.berlios.de>

If an initiator/application is requesting mode_sense and specifying a very
small allocation_length (2,8 or so bytes) but the mode page itself
is big,  then the memcpy() in build_mode_page() will overwrite other memory
and cause tgtd to crash.

be more careful when writing to the data buffer.

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 usr/spc.c |   63 ++++++++++++++++++++++++++++++++++--------------------------
 1 files changed, 36 insertions(+), 27 deletions(-)

diff --git a/usr/spc.c b/usr/spc.c
index e3e4d98..6707778 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -335,22 +335,28 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
  *
  * Returns number of bytes copied.
  */
-static int build_mode_page(uint8_t *data, struct mode_pg *pg, int update)
+static uint8_t *build_mode_page(uint8_t *data, uint8_t *p, int alloc_len,
+				struct mode_pg *pg)
 {
-	uint8_t *p;
-	int len;
+	int i;
+
+	if (alloc_len > (p-data))
+		*p = pg->pcode;
+	p++;
+
+
+	if (alloc_len > (p-data))
+		*p = pg->pcode_size;
+	p++;
+

-	len = pg->pcode_size;
-	if (update) {
-		data[0] = pg->pcode;
-		data[1] = len;
+	for (i = 0; i < pg->pcode_size; i++) {
+		if (alloc_len > (p-data))
+			*p = pg->mode_data[i];
+		p++;
 	}
-	p = &data[2];
-	len += 2;
-	if (update)
-		memcpy(p, pg->mode_data, pg->pcode_size);

-	return len;
+	return p;
 }

 /**
@@ -362,12 +368,13 @@ static int build_mode_page(uint8_t *data, struct
mode_pg *pg, int update)
  */
 int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 {
-	int len = 0;
 	uint8_t *data = NULL, *scb, mode6, dbd, pcode, subpcode;
+	uint8_t *p;
 	uint16_t alloc_len;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 	struct mode_pg *pg;
+	int i;

 	scb = cmd->scb;
 	mode6 = (scb[0] == 0x1a);
@@ -383,10 +390,10 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)

 	if (mode6) {
 		alloc_len = scb[4];
-		len = 4;
+		p = &data[4];
 	} else {
 		alloc_len = (scb[7] << 8) + scb[8];
-		len = 8;
+		p = &data[8];
 	}

 	if (scsi_get_in_length(cmd) < alloc_len)
@@ -394,10 +401,11 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	memset(data, 0, alloc_len);

 	if (!dbd) {
-		if (alloc_len >= len)
-			memcpy(data + len, cmd->dev->mode_block_descriptor,
-			       BLOCK_DESCRIPTOR_LEN);
-		len += BLOCK_DESCRIPTOR_LEN;
+		for (i = 0; i < BLOCK_DESCRIPTOR_LEN; i++) {
+			if (alloc_len > (p-data))
+				*p = cmd->dev->mode_block_descriptor[i];
+			p++;
+		}
 	}

 	if (pcode == 0x3f) {
@@ -405,25 +413,26 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 		for (i = 0; i < ARRAY_SIZE(cmd->dev->mode_pgs); i++) {
 			pg = cmd->dev->mode_pgs[i];
 			if (pg)
-				len += build_mode_page(data + len, pg,
-						       alloc_len >= len);
+				p = build_mode_page(data, p, alloc_len, pg);
 		}
 	} else {
 		pg = cmd->dev->mode_pgs[pcode];
 		if (!pg)
 			goto sense;
-		len += build_mode_page(data + len, pg, alloc_len >= len);
+		p = build_mode_page(data, p, alloc_len, pg);
 	}

 	if (mode6) {
-		data[0] = len - 1;
-		data[3] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
+		data[0] = (p - data) - 1;
+		if (alloc_len > 3)
+			data[3] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
 	} else {
-		*(uint16_t *)(data) = __cpu_to_be16(len - 2);
-		data[7] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
+		*(uint16_t *)(data) = __cpu_to_be16((p - data)-2);
+		if (alloc_len > 7)
+			data[7] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
 	}

-	scsi_set_in_resid_by_actual(cmd, len);
+	scsi_set_in_resid_by_actual(cmd, p - data);
 	return SAM_STAT_GOOD;
 sense:
 	scsi_set_in_resid_by_actual(cmd, 0);
-- 
1.5.5


From ronniesahlberg at gmail.com  Sat May  3 04:48:27 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sat, 3 May 2008 12:48:27 +1000
Subject: [Stgt-devel] [PATCH 5/7] spc/mmc: three more commands for mmc and
	write parameters modepage
Message-ID: <c9a3e4540805021948t42638c5aq6bb19f444ca1a410@mail.gmail.com>


From ronniesahlberg at gmail.com  Fri May  2 14:38:54 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Fri, 2 May 2008 22:38:54 +1000
Subject: [PATCH 5/7] modepage for write parameters
Message-ID: <mailman.23.1331738481.12506.stgt-devel@lists.berlios.de>

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 usr/mmc.c |   29 ++++++++++++++++++++++++++---
 1 files changed, 26 insertions(+), 3 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index ce66c7c..d075b23 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -119,6 +119,7 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 		set_cmd_mmapio(cmd);
 		return SAM_STAT_GOOD;
 	}
+
 	return 0;
 }

@@ -1454,6 +1455,11 @@ static int mmc_synchronize_cache(int host_no,
struct scsi_cmd *cmd)
 		return SAM_STAT_CHECK_CONDITION;
 	}

+	if (mmc->current_profile == PROFILE_DVD_PLUS_R) {
+		/* once we close the track it becomes a DVD_ROM */
+		mmc->current_profile = PROFILE_DVD_ROM;
+	}
+
 	return SAM_STAT_GOOD;
 }

@@ -2146,6 +2152,21 @@ static int mmc_read_dvd_structure(int host_no,
struct scsi_cmd *cmd)
 	return SAM_STAT_CHECK_CONDITION;
 }

+static int mmc_reserve_track(int host_no, struct scsi_cmd *cmd)
+{
+	return SAM_STAT_GOOD;
+}
+
+static int mmc_mode_select(int host_no, struct scsi_cmd *cmd)
+{
+	return SAM_STAT_GOOD;
+}
+
+static int mmc_set_cd_speed(int host_no, struct scsi_cmd *cmd)
+{
+	return SAM_STAT_GOOD;
+}
+
 static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)
 {
 	uint8_t *scb = cmd->scb;
@@ -2214,6 +2235,8 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	add_mode_page(lu, "0x1d:0:10:0:0:7:0:0:2:0:2:0:20");
 	/* MM capabilities */
 	add_mode_page(lu,
"0x2a:0:0x3e:0x3f:0x37:0xf3:0xf3:0x29:0x23:0x10:0x8a:0x01:0x00:0x08:0x00:0x10:0x8a:0x00:0x00:0x10:0x8a:0x10:0x8a:0x00:0x01:0x00:0x00:0x00:0x00:0x10:0x8a:0x00:0x05:0x00:0x00:0x10:0x8a:0x00:0x00:0x0b:0x06:0x00:0x00:0x08:0x45:0x00:0x00:0x05:0x83:0x00:0x00:0x02:0xc2:0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00");
+	/* Write parameters */
+	add_mode_page(lu,
"0x05:0:0x32:0x62:5:8:0x10:0:0:0:0:0:0:0:0x10:0:0x96:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0");

 	return 0;
 }
@@ -2355,9 +2378,9 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{mmc_read_disc_information,},
 		{mmc_read_track_information,},
+		{mmc_reserve_track,},
 		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
+		{mmc_mode_select,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

@@ -2404,7 +2427,7 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_illegal_op,},
+		{mmc_set_cd_speed,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-- 
1.5.5


From ronniesahlberg at gmail.com  Sat May  3 04:49:31 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sat, 3 May 2008 12:49:31 +1000
Subject: [Stgt-devel] [PATCH 6/7] spc/mmc: show example on how to burn dvd
	from linux to mmc emulation
Message-ID: <c9a3e4540805021949w418cf51bn12319b52a7e0afcd@mail.gmail.com>


From ronniesahlberg at gmail.com  Fri May  2 14:39:39 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Fri, 2 May 2008 22:39:39 +1000
Subject: [PATCH 6/7] example on how to use dvdrecorder to write to the
Message-ID: <mailman.24.1331738481.12506.stgt-devel@lists.berlios.de>

emulated disk

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 doc/README.mmc |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/doc/README.mmc b/doc/README.mmc
index 265b95a..6f7074d 100644
--- a/doc/README.mmc
+++ b/doc/README.mmc
@@ -37,6 +37,13 @@ operations in which case it may or may not work.
 It is the intent that the emulation will be enhanced to provide compatibility
 with all DVD burning applications on all important platforms.

+The emulation is also compatible with Linux:dvdrecorder but you must
+specify the command arguments -dao -ignsize -overburn
+
+Example:
+dvdrecord -dao -ignsize -overburn dev=/dev/sg3 ./IMAGE.iso
+
+
 Please report incompatibilities with other burning applications other than
 Windows/DVD-Decrypter to ronniesahlberg at gmail.com and I will try to
 enhance the emulation to also support your application of choice.
-- 
1.5.5


From ronniesahlberg at gmail.com  Sat May  3 04:51:43 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sat, 3 May 2008 12:51:43 +1000
Subject: [Stgt-devel] [PATCH 7/7] spc/mmc: change how to detect
	end-of-burning for linux/dvdrecord and unbreak DVDDecrypter
	that broke in patch 5/7
Message-ID: <c9a3e4540805021951k46800d6dy155846edc39272e0@mail.gmail.com>


From ronniesahlberg at gmail.com  Fri May  2 14:41:50 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Fri, 2 May 2008 22:41:50 +1000
Subject: [PATCH 7/7] change how we handle dvdrecorder close track
Message-ID: <mailman.25.1331738481.12506.stgt-devel@lists.berlios.de>

dvdrecorder uses the reserve_track command before starting to write data.
pull the size of the full track from the cdb and store it in the mmc
structure.
once we see a write command where offset+length is equal to this track size
we consider the burning complete and morph the device into DVD-ROM

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 usr/mmc.c |   33 +++++++++++++++++++++++++--------
 1 files changed, 25 insertions(+), 8 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index d075b23..9e52845 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -54,6 +54,7 @@

 struct mmc_info {
 	int current_profile;
+	uint64_t reserve_track_len;
 };

 static int mmc_rw(int host_no, struct scsi_cmd *cmd)
@@ -61,6 +62,7 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 	int ret;
 	uint64_t end_offset;
+	uint64_t offset, length;

 	if (mmc->current_profile == PROFILE_NO_PROFILE) {
 		scsi_set_in_resid_by_actual(cmd, 0);
@@ -97,11 +99,13 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)

 	cmd->scsi_cmd_done = target_cmd_io_done;

-	cmd->offset = (scsi_rw_offset(cmd->scb) << MMC_BLK_SHIFT);
+	offset = scsi_rw_offset(cmd->scb);
+	cmd->offset = (offset << MMC_BLK_SHIFT);

 	/* update the size of the device */
-	end_offset = cmd->offset +
-		(((uint64_t)scsi_rw_count(cmd->scb)) << MMC_BLK_SHIFT);
+	length = scsi_rw_count(cmd->scb);
+	end_offset = cmd->offset + (length << MMC_BLK_SHIFT);
+
 	if (end_offset > cmd->dev->size)
 		cmd->dev->size = end_offset;

@@ -116,10 +120,17 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 		sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LUN_NOT_SUPPORTED);
 		return SAM_STAT_CHECK_CONDITION;
 	} else {
+		if ((mmc->current_profile == PROFILE_DVD_PLUS_R) &&
+			(mmc->reserve_track_len == (offset + length))) {
+			/* once we close the track it becomes a DVD_ROM */
+			mmc->current_profile = PROFILE_DVD_ROM;
+		}
+
 		set_cmd_mmapio(cmd);
 		return SAM_STAT_GOOD;
 	}

+
 	return 0;
 }

@@ -1455,11 +1466,6 @@ static int mmc_synchronize_cache(int host_no,
struct scsi_cmd *cmd)
 		return SAM_STAT_CHECK_CONDITION;
 	}

-	if (mmc->current_profile == PROFILE_DVD_PLUS_R) {
-		/* once we close the track it becomes a DVD_ROM */
-		mmc->current_profile = PROFILE_DVD_ROM;
-	}
-
 	return SAM_STAT_GOOD;
 }

@@ -2154,6 +2160,16 @@ static int mmc_read_dvd_structure(int host_no,
struct scsi_cmd *cmd)

 static int mmc_reserve_track(int host_no, struct scsi_cmd *cmd)
 {
+	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
+	uint64_t tmp;
+
+	tmp = cmd->scb[5];
+	tmp = (tmp << 8) | cmd->scb[6];
+	tmp = (tmp << 8) | cmd->scb[7];
+	tmp = (tmp << 8) | cmd->scb[8];
+
+	mmc->reserve_track_len = tmp;
+
 	return SAM_STAT_GOOD;
 }

@@ -2247,6 +2263,7 @@ static int mmc_lu_online(struct scsi_lu *lu)
 	struct stat st;

 	mmc->current_profile = PROFILE_NO_PROFILE;
+	mmc->reserve_track_len = 0;

 	if (lu->fd == -1)
 		return TGTADM_INVALID_REQUEST;
-- 
1.5.5


From ronniesahlberg at gmail.com  Sat May  3 07:25:31 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sat, 3 May 2008 15:25:31 +1000
Subject: [Stgt-devel] Store persistent media data in extended attributes?
Message-ID: <c9a3e4540805022225mc53dbc2pee59f43921cd9684@mail.gmail.com>

List,

Please comment.

A lot of SCSI device types contain a lot of persistent metadata.

Some of these would be the medium auxiliary memory that is accessed by
SPC : READ/WRITE ATTRIBUTE which is available for many device types.

SMC contains things such as SEND VOLUME TAG.

Many device types contain mode page settings, settable from the
initiator and which are supposed to be "persistent" across power and
unload/load cycles.
For example SSC : WORM settings.

UnitSerialNumber which all medias provide is similar, once I have
specified the USN to a device, to me it would make sense if this USN
would be persistent so next time I
export that file as a SCSI device, it should automatically use the
same USN that was previously attached to the device.
Example:
tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun
$LUN  --params scsi_sn=FRED00,scsi_id=Fred
Wouldnt it make sense that once this command is issued, the sn and the
id is stored persistently with that backing store file   so that they
apply automagically
next time this volume is exported?
I.e.   you specify/set the serial number once, and it remains
persistent for the remainder of the lifetime of the backing store file
itself. Not having to reapply the setting every single time
you startup tgtd again.

For MMC and SSC devices, this could include things like the barcode
for the media.

For SSC it could also include the metadata such as where the filemark
markers are. (there is a lot of metadata required in ssc).


Would it make sense to implement some smallish API to attach these
kinds of metadata to extended attributes attached to the backing store
file?


regards
ronnie sahlberg


From ronniesahlberg at gmail.com  Sat May  3 08:23:56 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sat, 3 May 2008 16:23:56 +1000
Subject: [Stgt-devel] Store persistent media data in extended attributes?
In-Reply-To: <B3E98EAC5926D5498DDD341AE4B7D21C03BCC0C1@TUS1XCHCLUPIN06.enterprise.veritas.com>
References: <c9a3e4540805022225mc53dbc2pee59f43921cd9684@mail.gmail.com>
	<B3E98EAC5926D5498DDD341AE4B7D21C03BCC0C1@TUS1XCHCLUPIN06.enterprise.veritas.com>
Message-ID: <c9a3e4540805022323hf95ff30k82ebf818858c7fff@mail.gmail.com>

Cool.

How far is you ssc?  can one do basic i/o with say mt with it?

While SSC is very different,
in MMC I would like to be able to store things like a barcode,
serialnumber, and other MAM and MAM-like data  attached to the backing
store file.
I want it to be stored in a was so that this data is "attached" to the
file that contains the actual image of the media.
I dont want to use separate files to store the metadata, so extended
attributes would be a nice way to associate the metadata with the
actual data.

In MMC I think it would also have value if the actual file itself,
reading all data from position 0 to the end of file would be an
identical image of the data
of the disk itself.  I.e. the file content IS the actual .ISO of the
disk.  Which would allow such files holding a STGT MMC backingstore
to be mountable as
a ISO9660 filesystem through loopback   and also be immediately
compatible and work with the myriad of "Virtual/Phantom DVD Drive"
applications
and drivers on other systems.
This compatibility would fail for me if I store metadata at the
beginning of the file.
(Yeah, you can mount the file as an .ISO   but you have to strip off
the first xMByte of the file first :-(   compared to "the file is just
a normal .ISO image so its compatible with anything under the sun (but
it also has some invisible extra metadata stored at the side)". )


This, desire to be compatible with other apps that expect a file to be
a raw .ISO image  would of course not exist for SSC.  So my desire in
how to implement
this metadata store is different from yours.


While SSC constraints probably forces you to embedd at least some
metadata intermixed with the actual data (by the way is there even
such a thing that could conceptually be described as a "raw" tape
image anyway? :-) )
Some of the SSC metadata wouldnt make sense to split out from the file
data, other metadata is probably impossible to split out from the file
data.

But,  some metadata, such as serial number and barcode's could be.
It would be great if we could store some of this metadata in a way
that is consistent across all device types SSC MMC and others   so we
can share code and implementation.



got to run ...

regards
ronnie sahlberg

On Sat, May 3, 2008 at 3:56 PM, Mark Harvey <mark_harvey at symantec.com> wrote:
> Hello Ronnie,
>
> A few months ago, I started on an SSC module. However I have failed to
> find the spare time to get a working proof of concept to post.... I
> still hope to finish this.
>
>
> I was embedding this information within the backing store of the virtual
> media disk file...
> e.g.
> struct MAM {
>        uint32_t tape_fmt_version;
>
>        uint64_t remaining_capacity;
>        uint64_t max_capacity;
>        uint64_t TapeAlert;
>        uint64_t load_count;
> [snip]
> };
>
> #define BLK_NOOP                0x00000000
> #define BLK_UNCOMPRESS_DATA     0x00000001
> #define BLK_COMPRESSED_DATA     0x00000002
> #define BLK_ENCRYPTED_DATA      0x00000004
> #define BLK_BOT                 0x00000010
> #define BLK_EOD                 0x00000020
> #define BLK_FILEMARK            0x00000040
> #define BLK_FILEMARK_DATA       0x00001000
>
> struct blk_header {
>        uint32_t blk_type;
>        uint32_t blk_size;
>        uint32_t disk_blk_size;
>        loff_t blk_number;
>        loff_t prev_blk;
>        loff_t curr_blk;
>        loff_t next_blk;
> };
>
> The virtual media disk layout of :
>
> struct blk_header (BLK_BOT)
> struct MAM
> struct blk_header (block 0)
> <disk_blk_size> block of data
> struct blk_header (block 1)
> <disk_blk_size> block of data
> (repeat for n blocks)
> struct blk_header (block n+1)
> <disk_blk_size> block of data
> struct blk_header (BLK_EOD)
>
> The prev_blk, curr_blk & next_blk form pointers to previous, current &
> next block of data (poor man's double linked list - if you like).
>
>
> The 'blk_size' & disk_blk_size relates to uncompressed data block size &
> size of data block within the virtual media.
>
> Initially I tried keeping this 'metadata' separate from the disk blocks
> of data. However this did not work with variable block reads & writes,
> as I could not easily determine when a short (or long) block read was
> attempted.
>
> The Extended attributes information is kept within the MAM data
> structure (total bytes read / written during media life time, total
> mounts, media type, mdia serial number etc)
>
> Cheers
> Mark Harvey
>
>
> -----Original Message-----
> From: stgt-devel-bounces at lists.berlios.de
> [mailto:stgt-devel-bounces at lists.berlios.de] On Behalf Of ronnie
> sahlberg
> Sent: Saturday, May 03, 2008 3:26 PM
> To: stgt-devel at lists.berlios.de
> Subject: [Stgt-devel] Store persistent media data in extended
> attributes?
>
> List,
>
> Please comment.
>
> A lot of SCSI device types contain a lot of persistent metadata.
>
> Some of these would be the medium auxiliary memory that is accessed by
> SPC : READ/WRITE ATTRIBUTE which is available for many device types.
>
> SMC contains things such as SEND VOLUME TAG.
>
> Many device types contain mode page settings, settable from the
> initiator and which are supposed to be "persistent" across power and
> unload/load cycles.
> For example SSC : WORM settings.
>
> UnitSerialNumber which all medias provide is similar, once I have
> specified the USN to a device, to me it would make sense if this USN
> would be persistent so next time I
> export that file as a SCSI device, it should automatically use the
> same USN that was previously attached to the device.
> Example:
> tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun
> $LUN  --params scsi_sn=FRED00,scsi_id=Fred
> Wouldnt it make sense that once this command is issued, the sn and the
> id is stored persistently with that backing store file   so that they
> apply automagically
> next time this volume is exported?
> I.e.   you specify/set the serial number once, and it remains
> persistent for the remainder of the lifetime of the backing store file
> itself. Not having to reapply the setting every single time
> you startup tgtd again.
>
> For MMC and SSC devices, this could include things like the barcode
> for the media.
>
> For SSC it could also include the metadata such as where the filemark
> markers are. (there is a lot of metadata required in ssc).
>
>
> Would it make sense to implement some smallish API to attach these
> kinds of metadata to extended attributes attached to the backing store
> file?
>
>
> regards
> ronnie sahlberg
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>


From mark_harvey at symantec.com  Sat May  3 07:56:33 2008
From: mark_harvey at symantec.com (Mark Harvey)
Date: Fri, 2 May 2008 22:56:33 -0700
Subject: [Stgt-devel] Store persistent media data in extended attributes?
In-Reply-To: <c9a3e4540805022225mc53dbc2pee59f43921cd9684@mail.gmail.com>
References: <c9a3e4540805022225mc53dbc2pee59f43921cd9684@mail.gmail.com>
Message-ID: <B3E98EAC5926D5498DDD341AE4B7D21C03BCC0C1@TUS1XCHCLUPIN06.enterprise.veritas.com>

Hello Ronnie,

A few months ago, I started on an SSC module. However I have failed to
find the spare time to get a working proof of concept to post.... I
still hope to finish this.


I was embedding this information within the backing store of the virtual
media disk file...
e.g.
struct MAM {
        uint32_t tape_fmt_version;

        uint64_t remaining_capacity;
        uint64_t max_capacity;
        uint64_t TapeAlert;
        uint64_t load_count;
[snip]
};

#define BLK_NOOP                0x00000000
#define BLK_UNCOMPRESS_DATA     0x00000001
#define BLK_COMPRESSED_DATA     0x00000002
#define BLK_ENCRYPTED_DATA      0x00000004
#define BLK_BOT                 0x00000010
#define BLK_EOD                 0x00000020
#define BLK_FILEMARK            0x00000040
#define BLK_FILEMARK_DATA       0x00001000

struct blk_header {
        uint32_t blk_type;
        uint32_t blk_size;
        uint32_t disk_blk_size;
        loff_t blk_number;
        loff_t prev_blk;
        loff_t curr_blk;
        loff_t next_blk;
};

The virtual media disk layout of :

struct blk_header (BLK_BOT)
struct MAM
struct blk_header (block 0)
<disk_blk_size> block of data
struct blk_header (block 1)
<disk_blk_size> block of data
(repeat for n blocks)
struct blk_header (block n+1)
<disk_blk_size> block of data
struct blk_header (BLK_EOD)

The prev_blk, curr_blk & next_blk form pointers to previous, current &
next block of data (poor man's double linked list - if you like).


The 'blk_size' & disk_blk_size relates to uncompressed data block size &
size of data block within the virtual media.

Initially I tried keeping this 'metadata' separate from the disk blocks
of data. However this did not work with variable block reads & writes,
as I could not easily determine when a short (or long) block read was
attempted.

The Extended attributes information is kept within the MAM data
structure (total bytes read / written during media life time, total
mounts, media type, mdia serial number etc)

Cheers
Mark Harvey


-----Original Message-----
From: stgt-devel-bounces at lists.berlios.de
[mailto:stgt-devel-bounces at lists.berlios.de] On Behalf Of ronnie
sahlberg
Sent: Saturday, May 03, 2008 3:26 PM
To: stgt-devel at lists.berlios.de
Subject: [Stgt-devel] Store persistent media data in extended
attributes?

List,

Please comment.

A lot of SCSI device types contain a lot of persistent metadata.

Some of these would be the medium auxiliary memory that is accessed by
SPC : READ/WRITE ATTRIBUTE which is available for many device types.

SMC contains things such as SEND VOLUME TAG.

Many device types contain mode page settings, settable from the
initiator and which are supposed to be "persistent" across power and
unload/load cycles.
For example SSC : WORM settings.

UnitSerialNumber which all medias provide is similar, once I have
specified the USN to a device, to me it would make sense if this USN
would be persistent so next time I
export that file as a SCSI device, it should automatically use the
same USN that was previously attached to the device.
Example:
tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun
$LUN  --params scsi_sn=FRED00,scsi_id=Fred
Wouldnt it make sense that once this command is issued, the sn and the
id is stored persistently with that backing store file   so that they
apply automagically
next time this volume is exported?
I.e.   you specify/set the serial number once, and it remains
persistent for the remainder of the lifetime of the backing store file
itself. Not having to reapply the setting every single time
you startup tgtd again.

For MMC and SSC devices, this could include things like the barcode
for the media.

For SSC it could also include the metadata such as where the filemark
markers are. (there is a lot of metadata required in ssc).


Would it make sense to implement some smallish API to attach these
kinds of metadata to extended attributes attached to the backing store
file?


regards
ronnie sahlberg
_______________________________________________
Stgt-devel mailing list
Stgt-devel at lists.berlios.de
https://lists.berlios.de/mailman/listinfo/stgt-devel


From ronniesahlberg at gmail.com  Sun May  4 08:09:49 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sun, 4 May 2008 16:09:49 +1000
Subject: [Stgt-devel] [PATCH mmc serial number fix 1/1] MMC: Use the
	Inquiry:0x80 serial number in mmc getconfiguration
Message-ID: <c9a3e4540805032309n3bef00fepaad104a985b1bf25@mail.gmail.com>


From ronniesahlberg at gmail.com  Sun May  4 07:59:07 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Sun, 4 May 2008 15:59:07 +1000
Subject: [PATCH] Use the same serial number in mmc GetConfiguration as
Message-ID: <mailman.26.1331738481.12506.stgt-devel@lists.berlios.de>

Inquiry 0x80 uses

When sending back the Logical Unit Serial Number of the device as part of
GetConfiguration: feature 0x0108    use the same data/string as is used
when reporting the serial number through inquiry 0x80

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 usr/mmc.c |   19 ++++++++++---------
 1 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index 9e52845..6f3be08 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -835,6 +835,9 @@ static char *feature_dvd_plus_r(struct scsi_cmd
*cmd, char *data,
 static char *feature_lun_serial_no(struct scsi_cmd *cmd, char *data,
 				   int only_current)
 {
+	struct lu_phy_attr *attrs;
+	struct vpd *vpd_pg;
+
 	/* feature code */
 	*data++ = 0x01;
 	*data++ = 0x08;
@@ -845,15 +848,13 @@ static char *feature_lun_serial_no(struct
scsi_cmd *cmd, char *data,
 	/* additional length */
 	*data++ = 8;

-	/* XXX */
-	*data++ = 'D';
-	*data++ = 'V';
-	*data++ = 'D';
-	*data++ = '#';
-	*data++ = '1';
-	*data++ = '2';
-	*data++ = '3';
-	*data++ = '4';
+	/* serial number */
+	attrs = &cmd->dev->attrs;
+	vpd_pg = attrs->lu_vpd[PCODE_OFFSET(0x80)];
+	if (vpd_pg->size == 8) {
+		memcpy(data, vpd_pg->data, 8);
+	}
+	data += 8;

 	return data;
 }
-- 
1.5.5


From tgt.user at gmail.com  Mon May  5 13:17:27 2008
From: tgt.user at gmail.com (tgt user)
Date: Mon, 5 May 2008 14:17:27 +0300
Subject: [Stgt-devel] tgt target drivers?
Message-ID: <515601290805050417m291cb022qc0cccb4230079762@mail.gmail.com>

Hello,

I was wondering - what is the status of the target drivers in tgt? I know
that iSCSI is available. What about the rest? What is their status?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080505/94c18816/attachment.html>

From fujita.tomonori at lab.ntt.co.jp  Tue May  6 06:59:53 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 6 May 2008 13:59:53 +0900
Subject: [Stgt-devel] [PATCH 2/7] spc/mmc: dont set modepages in the
 example	text
In-Reply-To: <c9a3e4540805021943x63b90dfdu343d0fb94fe1955f@mail.gmail.com>
References: <c9a3e4540805021943x63b90dfdu343d0fb94fe1955f@mail.gmail.com>
Message-ID: <20080506134135K.tomof@acm.org>

On Sat, 3 May 2008 12:43:46 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> >From ddc93dcca2e5310e5f469814dab060cffbd58097 Mon Sep 17 00:00:00 2001
> From: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> Date: Fri, 2 May 2008 22:32:13 +1000
> Subject: [PATCH 2/7] dont set modepages in the example
> 
> Done tset the modepages in the example, these pages are added by
> default for the device anyway during initialization
> 
> Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> ---
>  doc/README.mmc |    7 -------
>  1 files changed, 0 insertions(+), 7 deletions(-)

Seems that the patch is corrupted:

fujita at arbre:~/git/tgt$ git-am ~/Mail/iscsi/stgt/2593 
Applying dont set modepages in the example
fatal: corrupt patch at line 29
Patch failed at 0001.
When you have resolved this problem run "git-am --resolved".
If you would prefer to skip this patch, instead run "git-am --skip".
fujita at arbre:~/git/tgt$ patch -p1 < ~/Mail/iscsi/stgt/2593 
patching file doc/README.mmc
patch: **** malformed patch at line 93: --params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0


#2-7 patches seems to be corrupted too.

Can you send a patch to youself and make sure that you can apply it
cleanly, then resend #2-7 patches?


Thanks,


From fujita.tomonori at lab.ntt.co.jp  Tue May  6 06:59:52 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 6 May 2008 13:59:52 +0900
Subject: [Stgt-devel] [PATCH 1/7] spc/mmc: modesense10 returns data
 length 1	byte too small
In-Reply-To: <c9a3e4540805021942u4cc0c7f7na8ccd1e75ffce612@mail.gmail.com>
References: <c9a3e4540805021942u4cc0c7f7na8ccd1e75ffce612@mail.gmail.com>
Message-ID: <20080506133438E.tomof@acm.org>

On Sat, 3 May 2008 12:42:29 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> >From 1cf2289d1b38d1edddd9fe8f3e242f5b912d9d7a Mon Sep 17 00:00:00 2001
> From: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> Date: Fri, 2 May 2008 22:31:07 +1000
> Subject: [PATCH 1/7] modesense10 length too small by one byte
> 
> fix a bug in the mode sense 10 data  where the length is one byte too small
> 
> Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> ---
>  usr/spc.c |    2 +-
>  1 files changed, 1 insertions(+), 1 deletions(-)

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Tue May  6 06:59:54 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 6 May 2008 13:59:54 +0900
Subject: [Stgt-devel] Store persistent media data in extended attributes?
In-Reply-To: <c9a3e4540805022323hf95ff30k82ebf818858c7fff@mail.gmail.com>
References: <c9a3e4540805022225mc53dbc2pee59f43921cd9684@mail.gmail.com>
	<B3E98EAC5926D5498DDD341AE4B7D21C03BCC0C1@TUS1XCHCLUPIN06.enterprise.veritas.com>
	<c9a3e4540805022323hf95ff30k82ebf818858c7fff@mail.gmail.com>
Message-ID: <20080506135937D.tomof@acm.org>

On Sat, 3 May 2008 16:23:56 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> Cool.
> 
> How far is you ssc?  can one do basic i/o with say mt with it?
> 
> While SSC is very different,
> in MMC I would like to be able to store things like a barcode,
> serialnumber, and other MAM and MAM-like data  attached to the backing
> store file.
> I want it to be stored in a was so that this data is "attached" to the
> file that contains the actual image of the media.
> I dont want to use separate files to store the metadata, so extended
> attributes would be a nice way to associate the metadata with the
> actual data.
> 
> In MMC I think it would also have value if the actual file itself,
> reading all data from position 0 to the end of file would be an
> identical image of the data
> of the disk itself.  I.e. the file content IS the actual .ISO of the
> disk.  Which would allow such files holding a STGT MMC backingstore
> to be mountable as
> a ISO9660 filesystem through loopback   and also be immediately
> compatible and work with the myriad of "Virtual/Phantom DVD Drive"
> applications
> and drivers on other systems.
> This compatibility would fail for me if I store metadata at the
> beginning of the file.
> (Yeah, you can mount the file as an .ISO   but you have to strip off
> the first xMByte of the file first :-(   compared to "the file is just
> a normal .ISO image so its compatible with anything under the sun (but
> it also has some invisible extra metadata stored at the side)". )

As you said, we need to consider both the pros and cons of using
metadata. People are happy to give up the compatibily and use virtual
disk images (like QCOW, VMDK, and VHD) for snapshot. I think that just
for something trivial like serial number is not a good idea. Does the
metadata give something huge for mmc and ssc (like snapshot for sbc)?


From fujita.tomonori at lab.ntt.co.jp  Tue May  6 07:37:27 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 6 May 2008 14:37:27 +0900
Subject: [Stgt-devel] tgt target drivers?
In-Reply-To: <515601290805050417m291cb022qc0cccb4230079762@mail.gmail.com>
References: <515601290805050417m291cb022qc0cccb4230079762@mail.gmail.com>
Message-ID: <20080506143733R.tomof@acm.org>

On Mon, 5 May 2008 14:17:27 +0300
"tgt user" <tgt.user at gmail.com> wrote:

> Hello,
> 
> I was wondering - what is the status of the target drivers in tgt? I know
> that iSCSI is available. What about the rest? What is their status?

First, use the plain text format. I often ignore html mails.

- iSCSI and iSER drivers should work.

- IBM pSeries virtual scsi target driver should work

- FCoE driver is available but not tested well.

- I submitted qlogic 2x00 fc driver several monthes ago but I guess
that Qlogic is not eager to support it.


From ronniesahlberg at gmail.com  Tue May  6 08:06:43 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Tue, 6 May 2008 16:06:43 +1000
Subject: [Stgt-devel] Store persistent media data in extended attributes?
In-Reply-To: <20080506135937D.tomof@acm.org>
References: <c9a3e4540805022225mc53dbc2pee59f43921cd9684@mail.gmail.com>
	<B3E98EAC5926D5498DDD341AE4B7D21C03BCC0C1@TUS1XCHCLUPIN06.enterprise.veritas.com>
	<c9a3e4540805022323hf95ff30k82ebf818858c7fff@mail.gmail.com>
	<20080506135937D.tomof@acm.org>
Message-ID: <c9a3e4540805052306o1342ed27tf6417c4080677bc6@mail.gmail.com>

I think that for MMC there is very little metadata that would be nice to have.
I think MMC could benefit from storing (feature 0x0109) MediaSerialNumber
maybe also barcode (if used with SMC as a dvd jukebox) and possibly other
MAM attributes as well.

I think none of these are that important really (a lot of DVD players
can not return feature 0x0109 anyway :-) )

It would be nice to store MediaSerialNumber and also a Barcode
together with the "image" file for MMC.
I dont know how much other MAM data that applications using a MMC
jukebox expects/require for the jukebox functionality to work.

Since "iso image" is a "standard/common" fileformat for storing
"images of CD/DVD disks" and a lot of tools exist for using
such iso images,   I think it would be attractive if our "images" were
compatible, which kind of requires that we do not store this metadata
in the filedata itself.
Extended attributes would be one possible avenue to store this
metadata without "polluting" hte data and make us incompatible.


SSC is different.
First it likely requires a LOT of metadata. Second, I dont think there
is a de-facto standard   or tools   to operate on a "raw-tape-image"
anyway
so there shouldnt be anything that the images have to be compatible
with in the first place.


The biggest question for "how much metadata does MMC need" would
probably be when combined with SMC into a jukebox.
I have no idea how much/what metadata that a jukebox controller
program wants/needs to be happy.


On Tue, May 6, 2008 at 2:59 PM, FUJITA Tomonori
<fujita.tomonori at lab.ntt.co.jp> wrote:
> On Sat, 3 May 2008 16:23:56 +1000
> "ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:
>
>> Cool.
>>
>> How far is you ssc?  can one do basic i/o with say mt with it?
>>
>> While SSC is very different,
>> in MMC I would like to be able to store things like a barcode,
>> serialnumber, and other MAM and MAM-like data  attached to the backing
>> store file.
>> I want it to be stored in a was so that this data is "attached" to the
>> file that contains the actual image of the media.
>> I dont want to use separate files to store the metadata, so extended
>> attributes would be a nice way to associate the metadata with the
>> actual data.
>>
>> In MMC I think it would also have value if the actual file itself,
>> reading all data from position 0 to the end of file would be an
>> identical image of the data
>> of the disk itself.  I.e. the file content IS the actual .ISO of the
>> disk.  Which would allow such files holding a STGT MMC backingstore
>> to be mountable as
>> a ISO9660 filesystem through loopback   and also be immediately
>> compatible and work with the myriad of "Virtual/Phantom DVD Drive"
>> applications
>> and drivers on other systems.
>> This compatibility would fail for me if I store metadata at the
>> beginning of the file.
>> (Yeah, you can mount the file as an .ISO   but you have to strip off
>> the first xMByte of the file first :-(   compared to "the file is just
>> a normal .ISO image so its compatible with anything under the sun (but
>> it also has some invisible extra metadata stored at the side)". )
>
> As you said, we need to consider both the pros and cons of using
> metadata. People are happy to give up the compatibily and use virtual
> disk images (like QCOW, VMDK, and VHD) for snapshot. I think that just
> for something trivial like serial number is not a good idea. Does the
> metadata give something huge for mmc and ssc (like snapshot for sbc)?
>


From ronniesahlberg at gmail.com  Tue May  6 08:45:47 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Tue, 6 May 2008 16:45:47 +1000
Subject: [Stgt-devel] [PATCH spc/mmc 1/4] RESEND Dont set modepages in the
	example.
Message-ID: <c9a3e4540805052345m53f3563fr42a79871dbe998df@mail.gmail.com>


From ronniesahlberg at gmail.com  Tue May  6 08:13:29 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Tue, 6 May 2008 16:13:29 +1000
Subject: [PATCH] Dont set the modepages in the example
Message-ID: <mailman.27.1331738481.12506.stgt-devel@lists.berlios.de>

No need to specify the modepages in the example since they
are set automatically when the device is initialized anyway.
No need to make the example more complicated than it has to be.

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 doc/README.mmc |    7 -------
 1 files changed, 0 insertions(+), 7 deletions(-)

diff --git a/doc/README.mmc b/doc/README.mmc
index 514e15a..265b95a 100644
--- a/doc/README.mmc
+++ b/doc/README.mmc
@@ -65,13 +65,6 @@ tgtadm --lld iscsi --mode logicalunit --op new
--tid 1 --lun 1 -b /tmp/empty-dis
 SN=XYZ123
 tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1
--params vendor_id=STGT_DVD,product_id=DVD101,product_rev=0010,scsi_sn=$SN,removable=1

-# Vendor Uniq - Mode page 0..
-tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1
--params mode_page=0:0:0
-# ctrl mode page
-tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1
--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
-# Informational Exceptions Control Mode Page
-tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1
--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
-

 # Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid 1 -I ALL
-- 
1.5.5

------=_Part_11110_32233178.1210056347050
Content-Type: application/x-gzip;
 name=0001-Dont-set-the-modepages-in-the-example.patch.gz
Content-Transfer-Encoding: base64
X-Attachment-Id: f_ffw44tqa0
Content-Disposition: attachment;
 filename=0001-Dont-set-the-modepages-in-the-example.patch.gz

H4sICCD9H0gAAzAwMDEtRG9udC1zZXQtdGhlLW1vZGVwYWdlcy1pbi10aGUtZXhhbXBsZS5wYXRj
aAC1VG1v0zAQ/u5fcRJ8YGqT2W2TrhVFm9YBk7ZpWgfiRWhy7GtqcOyQuNuK+PGc0wnYJiEhQRLF
9unueR77fPey8RUUuc45lyMlx5NC5UOuCjURfDQocDzGbJkX46zIhhM49Q4WWIMYA+fT7oMB54K9
JJgpXHjnDMJCrmyBTQnPm87Q3q33y0oamypfvWBzGXAKl2vsQw6nchNh9kDkUzGcDibQE5xztlgX
n1GFKXw8P7g8fP0J5t4FaDFAWCFUXmMtS2zBuM6At7KqLTJ25sEhagge2hqVWW7+GACtcQqjZcNk
gx2BXAdfyWCUtHYDNyvcRmi8NuRqIoQJRlrzjXik29zITfo7byW/4D2OyhMybb22hBmi00o6MAFW
so0BBaaMLUzpUCd+uUyKzV+dZ5IkDLRXuxdHB/PTo7SqFHwHesaQbB8GApbG0u4VMZeo+8BpFy02
wXjXPuvt9MlZo8XtOtlhTJvlkuJLkil3H6AXDwzMOI23kIkRikym6SDPikkmgTKZj0ZR4CMM1uv1
HuPs70OSZ30xhB4NOdA6lEHqipRYq+nwVWtoHtMJ1pcxR2vKBpl8TQm4oUkwmrZL/msXxwJ2Q1Xv
YlWHTaJNy2BxNnv3/oMYDNnfgK9rTbl7jJ/UspFVC9fotG+ujJ4tLl9dXs3fzvt14/VahWijpeDi
p6XB6xnVDu9HyqvWzZ4uzvoNVv5aFhZnggFLnsDbDhLeOPMVEipAkhXvMPA0Zck/lB6jriLyjKp6
yiO1Co3t7B3jf2ITkY5+gym/9w62Go7d0jexEL2TFo5uFdbd9YRDagWNt9sTOf9/+vitUFuFew8U
dqdESYIncGCtv4GDk5O7thB80xW1onqlBhanYUVNI8imxPCnK7f12IosqKJ+STyO+FRGwESapRlj
PwB+M0RTuwUAAA==
------=_Part_11110_32233178.1210056347050--


From ronniesahlberg at gmail.com  Tue May  6 08:47:03 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Tue, 6 May 2008 16:47:03 +1000
Subject: [Stgt-devel] [PATCH spc/mmc 2/4] RESEND Add modepage for MM
	Capabilities
Message-ID: <c9a3e4540805052347k3ded3dc0r2245bc3eea7b5c22@mail.gmail.com>


From ronniesahlberg at gmail.com  Tue May  6 08:18:57 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Tue, 6 May 2008 16:18:57 +1000
Subject: [PATCH] Add modepage for MM Capabilities
Message-ID: <mailman.28.1331738481.12506.stgt-devel@lists.berlios.de>

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 usr/mmc.c |   10 ++++++++++
 1 files changed, 10 insertions(+), 0 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index 6c0dcac..1ab31c3 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -2212,6 +2212,16 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
 	/* Timeout & Protect */
 	add_mode_page(lu, "0x1d:0:10:0:0:7:0:0:2:0:2:0:20");
+	/* MM capabilities */
+	add_mode_page(lu, "0x2a:0x00:0x3e:0x3f:0x37:0xf3:0xf3:0x29:"
+			  "0x23:0x10:0x8a:0x01:0x00:0x08:0x00:0x10:"
+			  "0x8a:0x00:0x00:0x10:0x8a:0x10:0x8a:0x00:"
+			  "0x01:0x00:0x00:0x00:0x00:0x10:0x8a:0x00:"
+			  "0x05:0x00:0x00:0x10:0x8a:0x00:0x00:0x0b:"
+			  "0x06:0x00:0x00:0x08:0x45:0x00:0x00:0x05:"
+			  "0x83:0x00:0x00:0x02:0xc2:0x00:0x00:0x00:"
+			  "0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00:"
+			  "0x00");

 	return 0;
 }
-- 
1.5.5

------=_Part_11113_31165383.1210056423820
Content-Type: application/x-gzip;
 name=0002-Add-modepage-for-MM-Capabilities.patch.gz
Content-Transfer-Encoding: base64
X-Attachment-Id: f_ffw472ux0
Content-Disposition: attachment;
 filename=0002-Add-modepage-for-MM-Capabilities.patch.gz

H4sICCD9H0gAAzAwMDItQWRkLW1vZGVwYWdlLWZvci1NTS1DYXBhYmlsaXRpZXMucGF0Y2gAlZJd
T9swFIav8a94xcVEP9LaSZuGbJpATGg3ldDK3TRVjj+Kp3ygxJGCNP777EAhYXCxODm2z/H7+MTH
13VVQDEWylWi6EZs2HlCtdRan4t4EyZKRrFiWkUiExzbqsRO3YNtQGnavwgpZeTaYVL8qMrSKOz4
XZ6p+oAvde9onucXh4KbfCGq4iv5xq1KcduqOWJs+YPHJGBxypJ0vcGMUUrJrs1+K2FT/Ly5vL36
/guXUqKopLrnBwVd1dhuccXveWZyY91GhOzMoVQyqLQOsof/yigIAoK2qZdFIRYCfwAwitnLQ8Cg
Ta4aiDteHpSc+7gpG1VbU5XN2WwyB4VUuXqaBxNCpNEaQXAwFnz5Cs9ex8SUUnWIBZWCi8WC8Sxi
InJsGq9WPquhkrhERuqLCwRhyMJ5jFnfsxjO11hujXDZWbh1+7zdm9LYs8bWrbBoRGOcD9O8nRCc
cCn3/lT3/ljP8naOU9oxkdKU0TRx3Zt2OvnsVMspbk2hqtbiE27qyrpKYbr8kCefeL5tehsevx44
80BXTjEop8fN3seFPKWdv4BdpLzR3jhup6OjCc/TUyc/OUEv8C6/f5f0UnbU0+Q4ctGBIHnZ4Rh8
9g0gI8EAST+QvhGsP152NNlIEI+DPvPVGOKYw3+IxkF33J0I32Y43OGd9P81I0F/G1zVa2XbugR1
s0d3bUHYYr1YE/IX+9HkO2IEAAA=
------=_Part_11113_31165383.1210056423820--


From ronniesahlberg at gmail.com  Tue May  6 08:48:14 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Tue, 6 May 2008 16:48:14 +1000
Subject: [Stgt-devel] [PATCH spc/mmc 3/4] RESEND tweaks to get dvdrecord
	happy
Message-ID: <c9a3e4540805052348r2aa58dc5mceaca21dab9fe927@mail.gmail.com>


From ronniesahlberg at gmail.com  Tue May  6 08:32:05 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Tue, 6 May 2008 16:32:05 +1000
Subject: [PATCH] Add tweaks to get linux dvdrecord happy
Message-ID: <mailman.29.1331738481.12506.stgt-devel@lists.berlios.de>

Add a new modepage (write performance) and a few commands to keep
linux dvdrecord happy.
Document an example on how to use MMC emulation with linux dvdrecord

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 doc/README.mmc |    7 +++++++
 usr/mmc.c      |   54 +++++++++++++++++++++++++++++++++++++++++++++++-------
 2 files changed, 54 insertions(+), 7 deletions(-)

diff --git a/doc/README.mmc b/doc/README.mmc
index 265b95a..6f7074d 100644
--- a/doc/README.mmc
+++ b/doc/README.mmc
@@ -37,6 +37,13 @@ operations in which case it may or may not work.
 It is the intent that the emulation will be enhanced to provide compatibility
 with all DVD burning applications on all important platforms.

+The emulation is also compatible with Linux:dvdrecorder but you must
+specify the command arguments -dao -ignsize -overburn
+
+Example:
+dvdrecord -dao -ignsize -overburn dev=/dev/sg3 ./IMAGE.iso
+
+
 Please report incompatibilities with other burning applications other than
 Windows/DVD-Decrypter to ronniesahlberg at gmail.com and I will try to
 enhance the emulation to also support your application of choice.
diff --git a/usr/mmc.c b/usr/mmc.c
index 1ab31c3..074b9be 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -54,6 +54,7 @@

 struct mmc_info {
 	int current_profile;
+	uint64_t reserve_track_len;
 };

 static int mmc_rw(int host_no, struct scsi_cmd *cmd)
@@ -61,6 +62,7 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
 	int ret;
 	uint64_t end_offset;
+	uint64_t offset, length;

 	if (mmc->current_profile == PROFILE_NO_PROFILE) {
 		scsi_set_in_resid_by_actual(cmd, 0);
@@ -97,11 +99,13 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)

 	cmd->scsi_cmd_done = target_cmd_io_done;

-	cmd->offset = (scsi_rw_offset(cmd->scb) << MMC_BLK_SHIFT);
+	offset = scsi_rw_offset(cmd->scb);
+	cmd->offset = (offset << MMC_BLK_SHIFT);

 	/* update the size of the device */
-	end_offset = cmd->offset +
-		(((uint64_t)scsi_rw_count(cmd->scb)) << MMC_BLK_SHIFT);
+	length = scsi_rw_count(cmd->scb);
+	end_offset = cmd->offset + (length << MMC_BLK_SHIFT);
+
 	if (end_offset > cmd->dev->size)
 		cmd->dev->size = end_offset;

@@ -116,6 +120,12 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 		sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LUN_NOT_SUPPORTED);
 		return SAM_STAT_CHECK_CONDITION;
 	} else {
+		if ((mmc->current_profile == PROFILE_DVD_PLUS_R) &&
+			(mmc->reserve_track_len == (offset + length))) {
+			/* once we close the track it becomes a DVD_ROM */
+			mmc->current_profile = PROFILE_DVD_ROM;
+		}
+
 		set_cmd_mmapio(cmd);
 		return SAM_STAT_GOOD;
 	}
@@ -2146,6 +2156,31 @@ static int mmc_read_dvd_structure(int host_no,
struct scsi_cmd *cmd)
 	return SAM_STAT_CHECK_CONDITION;
 }

+static int mmc_reserve_track(int host_no, struct scsi_cmd *cmd)
+{
+	struct mmc_info *mmc = (struct mmc_info *)cmd->dev->mmc_p;
+	uint64_t tmp;
+
+	tmp = cmd->scb[5];
+	tmp = (tmp << 8) | cmd->scb[6];
+	tmp = (tmp << 8) | cmd->scb[7];
+	tmp = (tmp << 8) | cmd->scb[8];
+
+	mmc->reserve_track_len = tmp;
+
+	return SAM_STAT_GOOD;
+}
+
+static int mmc_mode_select(int host_no, struct scsi_cmd *cmd)
+{
+	return SAM_STAT_GOOD;
+}
+
+static int mmc_set_cd_speed(int host_no, struct scsi_cmd *cmd)
+{
+	return SAM_STAT_GOOD;
+}
+
 static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)
 {
 	uint8_t *scb = cmd->scb;
@@ -2222,7 +2257,11 @@ static int mmc_lu_init(struct scsi_lu *lu)
 			  "0x83:0x00:0x00:0x02:0xc2:0x00:0x00:0x00:"
 			  "0x00:0x00:0x00:0x00:0x00:0x00:0x00:0x00:"
 			  "0x00");
-
+	/* Write parameters */
+	add_mode_page(lu, "0x05:0:0x32:0x62:5:8:0x10:0:0:0:0:0:0:0:"
+			  "0x10:0:0x96:0:0:0:0:0:0:0:0:0:0:0:0:0:0:"
+			  "0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:"
+			  "0:0");
 	return 0;
 }

@@ -2232,6 +2271,7 @@ static int mmc_lu_online(struct scsi_lu *lu)
 	struct stat st;

 	mmc->current_profile = PROFILE_NO_PROFILE;
+	mmc->reserve_track_len = 0;

 	if (lu->fd == -1)
 		return TGTADM_INVALID_REQUEST;
@@ -2363,9 +2403,9 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{mmc_read_disc_information,},
 		{mmc_read_track_information,},
+		{mmc_reserve_track,},
 		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
+		{mmc_mode_select,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

@@ -2412,7 +2452,7 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_illegal_op,},
+		{mmc_set_cd_speed,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-- 
1.5.5

------=_Part_11120_29418391.1210056494449
Content-Type: application/x-gzip;
 name=0003-Add-tweaks-to-get-linux-dvdrecord-happy.patch.gz
Content-Transfer-Encoding: base64
X-Attachment-Id: f_ffw48c7q0
Content-Disposition: attachment;
 filename=0003-Add-tweaks-to-get-linux-dvdrecord-happy.patch.gz

H4sICCD9H0gAAzAwMDMtQWRkLXR3ZWFrcy10by1nZXQtbGludXgtZHZkcmVjb3JkLWhhcHB5LnBh
dGNoAK1XW3PaVhB+Rr9ixw8dMAgkQDLGsSfUkIQpvtSQ9qGT0ehyBGokHY0uxjT1f+/ukQCBIXba
yh4hrfa+3+4550PMA3BdzbJdhXXNjmvbPcZ0zdU7Vs/qWq5ruVrPPbf0jubADQ9hyiJQz0BR+uIf
2oqiSh9QTR8eeBh6DKbmwrdYPId3sSAkxfv7eWB6ftPmwZU0NFPWh1nGGqDDjbkiNT1Q9X6n3Vc0
qKuKokjTzPqT2Wkf/rgfzK4/fYGB40C6ZObXBFIOc5aC74XZEziPTsxsHjuwMKNoJUnEaELIlhBw
h0XmnEF1GXspg4jFLo8DM7RZDcyQ2FxkQ6eQ5gi9XxmLpIOKm9KQ21nAwhRFgT2ZQeQzwKQs+JIk
s4TBzc01sCDzzdTDD0svXew7KUlTbx4yR+auK1urH8qbLMsSONxuPYwGw5tRMwhs+BvwOoN6fkno
RdxCetMGcdFnrbv+/NZLzi8J2uB6PkvAXpjhnDkN0uWFCYspvqRarzXQtsN8lr/LNUlyPNcFWZ57
mKbWnrPWHkHyQoc9QVvXrHPNbDZ190w56zqAANC7XYr3hQ4J3Xup5/17kDtnDR3qeFc7gO8ciy3K
kKDHsFx49gJsE2uEjgWIOR6Ln5CnsOTx16YE4xQ8xMACWcKUypwuzFS8l0vq+2AhJVwQihwqfBTz
R89hBKMIuSzP99KVlFffRPbhb0Owsjj0wjkgkHzPLvxCffTdCyIepyYajNAKATRBb6T6bMcyumb6
Cd9YQewJCxPCV3+DLxajrRRWPIMgS1KpnkTM9tyViKMAOpjxXAA5AdkxOciIyMT7i4HMH1lMrkp1
qT7KEd6X6ttGOMKOEHi8bOGtlcw70GyNbwYfR00v4aRHgnufUeJjRnFicsuJQqTncXB0MD6SJ/EJ
qxFK8DtChi+TFiZVHjI7XkUpfeNwrG1En4/zwqUx5oFL6+rt1RaViAwnWSQcxRzGZUeAu9gI3LNZ
cxfl256zts8FtlXT6qh2p9lEYFvniJwdbG+5c1hv3wnRWpcQjfczBDQiApI0zmyEb2AbXuhy+CZB
BbEKdhbHWE4DkUj9eiHVKxnS9a6RYtaxXR+Zkcam/dXwWXghwfNFrg3DsgnsQmO8rNLjgiepEfLG
2lhiJ55hBw6c4q0m/NJV8ktvC7/+nRqo7MdySgPiEqov6DUUkK8QXPIVEaOLIuiYpfS4CZSFjoFD
NSFyKf6c1ACMfJ4uROAVz4Uq6pKv9hIHl5dw/3D3YTwZGbd3RvFYE3muiAhQFbplYFI9x7BWhmmn
melX0cUGKLULkZ5zHEEq1M/Pi0n07xKEJkXga7rh8BAdhBSbF50giscFkWKSc+Y8WJFGEouXRUaq
hSqrBu/e0Spl/Dz5xZh+Gn+Y1ShbG7ljYsS0Z6F4OqCPfG+dQhY5uNCLJhPjAtuHnrGS2EJw2kKn
tzVDjWX9dfxYqVar6zLW1o7ZPAtLfh2JJy92KZ49MeI5bhuqhfwh3QV8StJXsEUoBUroruyS0EIZ
niBwoqo69ZHaVhpq+z90UiVhuCQbmGzTsDLPd3I4jieT0cfBxHgY/fp5NJ01YDC9NiafbxHZM2P6
+f7+7mE2GlK5KhXsJRrj08GNMZ0NZsb1p9H1L8b13e1wPBvf3RLPMzAfh/g3zJxIwKsNhBPauJ98
nhoPNfjpJxKr5DIvJhJJVTfJz3Nfq9VyW4QkTsN6ieuXz5McUEKWlnILF6YA1xCTllnj4e6GgEVi
h93b8Q65CQiVZ1HVSlK0Fa6RkccpiYeT8/HubigyIqrYVruijG1V0xsd9VAdmYnd++gYeQGzmL2t
rq8X5Zm2CS+slbL7FkN1SvN/mMalWZsG9I4UfFg3FbbbH9qXiw2xSj/YWL0abk43HPqrHGevcvS+
5MaPgWzr3uGK1gkH++mkIwROfR+PIm9O5g+oF5hDZESMOf+H/n3sFe7jfHgT5r4VC2oPi3mKOS0V
MV/b2njhsl9vtzWxyr1Eu58hUry0WrbgZ3DqZ2JWVQBOlKdep6880RGyuOG578lu79KU/slWYId+
9LYjcILdK2O2cH78np/+zNgMGG4Xk3xGmI6T54eOiFU/awg5rU/K6CT6pLf7Wr+HD6rS3/07ESNG
GMq/PZ3r/X2mwwLfZTsscCLmUFF1pej7vBqdtpg97TP14GYMi8FDPIGyI+VYU1EKb/nK/crg3O6L
Lr7Xa8p2p+Vn8pXr0JCX1VppoM4+zvAAZ4xvfxtMxsP1OlXgrKN3GucYWVeh321khcf5JsJIVxHe
WEAHJyYi3rxc5ru2b0mEo8v32dz0DR41nhuCup3LXpKPtjgQm/wXDHlQexz1DUcp8rXoS4vyD1DX
qkuD57jiI9Q8hV01b9WutrtT/59S+Fbq98MsD8AfjvOwPRkktak1NUn6Bwyua4zhEgAA
------=_Part_11120_29418391.1210056494449--


From ronniesahlberg at gmail.com  Tue May  6 08:50:40 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Tue, 6 May 2008 16:50:40 +1000
Subject: [Stgt-devel] [PATCH spc/mmc 4/4] RESEND modesense memory corruption
	bug
Message-ID: <c9a3e4540805052350u26f83577y428170b2b0ee2fc3@mail.gmail.com>


From ronniesahlberg at gmail.com  Tue May  6 08:37:07 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Tue, 6 May 2008 16:37:07 +1000
Subject: [PATCH] Fix a memory corruption bug in build_mode_page
Message-ID: <mailman.30.1331738481.12506.stgt-devel@lists.berlios.de>

If an application is providing a small allocation size when asking for a large
mode page hte memcpy() in build_mode_page can cause memory to be overwritten
and cause a crash.

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 usr/spc.c |   63 ++++++++++++++++++++++++++++++++++--------------------------
 1 files changed, 36 insertions(+), 27 deletions(-)

diff --git a/usr/spc.c b/usr/spc.c
index e3e4d98..35de2e1 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -335,22 +335,28 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
  *
  * Returns number of bytes copied.
  */
-static int build_mode_page(uint8_t *data, struct mode_pg *pg, int update)
+static uint8_t *build_mode_page(uint8_t *data, uint8_t *p, int alloc_len,
+struct mode_pg *pg)
 {
-	uint8_t *p;
-	int len;
+	int i;
+
+	if (alloc_len > (p-data))
+		*p = pg->pcode;
+	p++;
+
+
+	if (alloc_len > (p-data))
+		*p = pg->pcode_size;
+	p++;
+

-	len = pg->pcode_size;
-	if (update) {
-		data[0] = pg->pcode;
-		data[1] = len;
+	for (i = 0; i < pg->pcode_size; i++) {
+		if (alloc_len > (p-data))
+			*p = pg->mode_data[i];
+		p++;
 	}
-	p = &data[2];
-	len += 2;
-	if (update)
-		memcpy(p, pg->mode_data, pg->pcode_size);

-	return len;
+	return p;
 }

 /**
@@ -362,12 +368,13 @@ static int build_mode_page(uint8_t *data, struct
mode_pg *pg, int update)
  */
 int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 {
-	int len = 0;
 	uint8_t *data = NULL, *scb, mode6, dbd, pcode, subpcode;
+	uint8_t *p;
 	uint16_t alloc_len;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 	struct mode_pg *pg;
+	int i;

 	scb = cmd->scb;
 	mode6 = (scb[0] == 0x1a);
@@ -383,10 +390,10 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)

 	if (mode6) {
 		alloc_len = scb[4];
-		len = 4;
+		p = &data[4];
 	} else {
 		alloc_len = (scb[7] << 8) + scb[8];
-		len = 8;
+		p = &data[8];
 	}

 	if (scsi_get_in_length(cmd) < alloc_len)
@@ -394,10 +401,11 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	memset(data, 0, alloc_len);

 	if (!dbd) {
-		if (alloc_len >= len)
-			memcpy(data + len, cmd->dev->mode_block_descriptor,
-			       BLOCK_DESCRIPTOR_LEN);
-		len += BLOCK_DESCRIPTOR_LEN;
+		for (i = 0; i < BLOCK_DESCRIPTOR_LEN; i++) {
+			if (alloc_len > (p-data))
+				*p = cmd->dev->mode_block_descriptor[i];
+			p++;
+		}
 	}

 	if (pcode == 0x3f) {
@@ -405,25 +413,26 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 		for (i = 0; i < ARRAY_SIZE(cmd->dev->mode_pgs); i++) {
 			pg = cmd->dev->mode_pgs[i];
 			if (pg)
-				len += build_mode_page(data + len, pg,
-						       alloc_len >= len);
+				p = build_mode_page(data, p, alloc_len, pg);
 		}
 	} else {
 		pg = cmd->dev->mode_pgs[pcode];
 		if (!pg)
 			goto sense;
-		len += build_mode_page(data + len, pg, alloc_len >= len);
+		p = build_mode_page(data, p, alloc_len, pg);
 	}

 	if (mode6) {
-		data[0] = len - 1;
-		data[3] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
+		data[0] = (p - data) - 1;
+		if (alloc_len > 3)
+			data[3] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
 	} else {
-		*(uint16_t *)(data) = __cpu_to_be16(len - 2);
-		data[7] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
+		*(uint16_t *)(data) = __cpu_to_be16((p - data)-2);
+		if (alloc_len > 7)
+			data[7] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
 	}

-	scsi_set_in_resid_by_actual(cmd, len);
+	scsi_set_in_resid_by_actual(cmd, p - data);
 	return SAM_STAT_GOOD;
 sense:
 	scsi_set_in_resid_by_actual(cmd, 0);
-- 
1.5.5

------=_Part_11131_11363071.1210056640593
Content-Type: application/x-gzip;
 name=0004-Fix-a-memory-corruption-bug-in-build_mode_page.patch.gz
Content-Transfer-Encoding: base64
X-Attachment-Id: f_ffw4bnfw0
Content-Disposition: attachment;
 filename=0004-Fix-a-memory-corruption-bug-in-build_mode_page.patch.gz

H4sICCD9H0gAAzAwMDQtRml4LWEtbWVtb3J5LWNvcnJ1cHRpb24tYnVnLWluLWJ1aWxkX21vZGVf
cGFnZS5wYXRjaACtVutz2kYQ/4z+iu2XjoQkrAcgjB8NsXHKlMQpOJ1pM54bPQ5xCUgaPZLQ1P97
906ykMEu9qQaY3R3u799/XaPqzReg+1YTi/o+Qt34Q8c1+z3BlbX9xbHjmVR1+laruMYXcOGt3EE
c5qA6YBhDMUfWIZhSlcIM4RZHEWMwtxdrjyahnCaio2sWr8K1y5bdfx4fS5dujkdwk1BNejDW3fD
YQZg9oe2MzQcUE3DMKR54X2ifj6Ej+9HNxe/3sIV+wYurOk6Tjfgx2laJDlDn7wiBMa/2Cog6zig
JHFDKkmTBbgRuEmyYr4rJFkGSRp/YQGLQoTK1u5qBfiJq/OM/U3h65KiVvaZyyziFOVWbop4HBk4
Mixzyt3wk42sPGIZfDTru0VG753NY/AoxF9o+jVleU4jyY2CSsQFP3WzZUeS5iyMaKDHi4XubV6U
T13XJSiy9ChL/I4P/wBA3wb14KM/+UhgwoKtaAb+0o1CGmhg9zHWjKY8U5msKhpYDgR0RcsNXZGk
gC0WoOshy8E92vrjbd8lFgX0G1CbdoPjQadj9wJqUROw4v1ulwfS1JTQxwfar16Bbts9zbJAFd8D
wC0W5YDnJKdZToqI5TLfWca4imINsjwtfJTwM0b8dQBt/KdIAG3+gRnNizTKICrWmFaIF+Btch53
nDAadLjMkaRnOTLEF5Z2qi0XuDkgObQDN3dra+V5CO0k1IRakeA5VSS1gqrVDuDVy6TEEXQlKxpp
HGrXFsb1XdJbW6UTXHE1VDiRVPHK8IW/LkCuweAc5ETnFhV0sdVqJ3AGSaifJz6Cc81EVYXeyzQJ
b6mGOqA7XGlfRBewVZZEEC0O+tG4fejJ/b7J96uoeJvKDNfGCTA43cUGpqocEr37T9e3vouMCjPs
lhso3YfWHZrnMj+LM+v2pApHPQNrJwTuaDUksHIPQLUdB5UTkZdUMPE+pmqFBYQ7PIajdrukf9/S
TE7//kAzbU7//4+bgut1OwmxjGLPP6ufvm+ZJiqB6XpgHjfffZhONWhnvqcJJ/oaBB6OFpEKBC68
mm5NBpdAZp802C92o0yMTD6jUvhMN2hiMp2O34ymZDb+/cN4fvNQOfNRYjS/IJN3f4ymk0tyNRlP
L3FFLi5fc9H9BDWaBriA7yEEBqyf4ytXEXHgnoxrQVaM/ZvpYk1FtQa2ZhpYrWODfzeG1Quzi5Y4
uYQ1zmVotbY8PgNuvCvoWLVXt6RtzVV+iPwFusI7Z09dOO/cwukpDBRQBdygCTfYgRuUcLVfwt2Q
5oRFHDLMlzL3G3uxNqOUCTnuioR0DVMzzR9ICG+ujOZyyWxDaxg6qd36CelVDZOdzhezQzTpfZcK
jqp8WysLHNAvVdN6qPaZBDTzU5bkcaoJPSif19Pri9/I5Xh+MZu8v7meken4nVKnDifDYwIinbtj
61HBxvA6ML3K8XXA9fuBVg3kFq9ho46i/0oO2wtultesa+BN28OambZm9X+kZnshj2az0Z9kPvlr
LO84noSZUgcP3OFwPzoUEgFBlRx+AfLS3Kd+dx42a4zDr5StK7lHjzJTgvaPISFGg3YcURGu3O10
2lOei2SX3guyiusb7YUx/mAUWW3S6EAsT3j/Qt/v9ifNg4uYw+tgbq9hm+9il8EvYMDwaa5vIeQE
EQRtS6RHbmW7JPTzDTTyjY615XrktxW5NHUGhPhJQfKYeNTsy2UglrKNxHlmJM9B38aoW8qjITqN
EJ9luayN3hI9lZWTNqUZC4i3Ia6fF+6Kt5BWl/6gYO0jB69+bsxHb8n8ZnRD3lxfX+K+YOFQXHwH
0AyeSh0ks9Pr9CTpX8t1fahbDgAA
------=_Part_11131_11363071.1210056640593--


From max_aftab at yahoo.com  Tue May  6 09:24:00 2008
From: max_aftab at yahoo.com (aftab azmi)
Date: Tue, 6 May 2008 12:54:00 +0530 (IST)
Subject: [Stgt-devel] Implementation of vtl
Message-ID: <78490.54378.qm@web94812.mail.in2.yahoo.com>

Hiii everyone... 
    Attached herewith  is our implementation  of  Virtual  Tape Library....I have implemented all the mandatory commands mentioned in ssc-r42  except  erase command..... 
For this to run u have  to change the default-bst in iscsid.c  to "ssc"..  
We can use tar command to read/write  backup..  
Please do send in your comments and suggestions for further devlopment.
 





      Bollywood, fun, friendship, sports and more. You name it, we have it on http://in.promos.yahoo.com/groups/bestofyahoo/
-------------- next part --------------
A non-text attachment was scrubbed...
Name: bs_ssc.c
Type: application/octet-stream
Size: 6083 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080506/b6ba91c8/attachment.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ssc.c
Type: application/octet-stream
Size: 6581 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080506/b6ba91c8/attachment-0001.obj>

From tgt.user at gmail.com  Tue May  6 13:57:15 2008
From: tgt.user at gmail.com (tgt user)
Date: Tue, 6 May 2008 13:57:15 +0200
Subject: [Stgt-devel] tgt target drivers?
In-Reply-To: <20080506143733R.tomof@acm.org>
References: <515601290805050417m291cb022qc0cccb4230079762@mail.gmail.com>
	<20080506143733R.tomof@acm.org>
Message-ID: <515601290805060457m575afe83x3c24debbc59899b6@mail.gmail.com>

On Tue, May 6, 2008 at 7:37 AM, FUJITA Tomonori
<fujita.tomonori at lab.ntt.co.jp> wrote:
>
> On Mon, 5 May 2008 14:17:27 +0300
> "tgt user" <tgt.user at gmail.com> wrote:
>
> > Hello,
> >
> > I was wondering - what is the status of the target drivers in tgt? I know
> > that iSCSI is available. What about the rest? What is their status?
>
> First, use the plain text format. I often ignore html mails.
Sure. I hope it is ok now. If not, I'll try to re-config my Gmail account.
>
> - iSCSI and iSER drivers should work.
>
> - IBM pSeries virtual scsi target driver should work
>
> - FCoE driver is available but not tested well.
>
> - I submitted qlogic 2x00 fc driver several monthes ago but I guess
> that Qlogic is not eager to support it.
Thank you.

The FC driver is kernel code, right? Was it accepted? Which support
does it need from Qlogic?

Can you direct me to the stgt FC code in the kernel tree?

Another question - I think that I understand more or less the
userspace code. Can you say a few words about scsi_tgt_lib.c &
scsi_tgt_if.c and how it interacts with userland?


From erezz at voltaire.com  Tue May  6 15:51:36 2008
From: erezz at voltaire.com (Erez Zilber)
Date: Tue, 06 May 2008 16:51:36 +0300
Subject: [Stgt-devel] Calling iser_rx_progress
Message-ID: <48206268.1010001@voltaire.com>

Pete,


I'm going over some of the iSER code and I have a question: I saw that
iser_rx_progress is called from iser_cqe_handler and from the event loop
(added by tgt_counter_event_add). I understand the purpose of calling it
from iser_cqe_handler - it is called to handle new completions. Can you
explain the usage in tgt_counter_event_add?


Thanks,
Erez



From fujita.tomonori at lab.ntt.co.jp  Tue May  6 16:43:48 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 6 May 2008 23:43:48 +0900
Subject: [Stgt-devel] [PATCH spc/mmc 4/4] RESEND modesense memory
 corruption	bug
In-Reply-To: <c9a3e4540805052350u26f83577y428170b2b0ee2fc3@mail.gmail.com>
References: <c9a3e4540805052350u26f83577y428170b2b0ee2fc3@mail.gmail.com>
Message-ID: <20080506233010N.tomof@acm.org>

On Tue, 6 May 2008 16:50:40 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> >From 37275d5cfafc87a165824cbf9722ea742a770403 Mon Sep 17 00:00:00 2001
> From: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> Date: Tue, 6 May 2008 16:37:07 +1000
> Subject: [PATCH] Fix a memory corruption bug in build_mode_page
> 
> If an application is providing a small allocation size when asking for a large
> mode page hte memcpy() in build_mode_page can cause memory to be overwritten
> and cause a crash.
> 
> Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> ---
>  usr/spc.c |   63 ++++++++++++++++++++++++++++++++++--------------------------
>  1 files changed, 36 insertions(+), 27 deletions(-)

Thanks a lot,


> diff --git a/usr/spc.c b/usr/spc.c
> index e3e4d98..35de2e1 100644
> --- a/usr/spc.c
> +++ b/usr/spc.c
> @@ -335,22 +335,28 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
>   *
>   * Returns number of bytes copied.
>   */
> -static int build_mode_page(uint8_t *data, struct mode_pg *pg, int update)
> +static uint8_t *build_mode_page(uint8_t *data, uint8_t *p, int alloc_len,
> +struct mode_pg *pg)
>  {
> -	uint8_t *p;
> -	int len;
> +	int i;
> +
> +	if (alloc_len > (p-data))
> +		*p = pg->pcode;
> +	p++;
> +
> +
> +	if (alloc_len > (p-data))
> +		*p = pg->pcode_size;
> +	p++;
> +
> 
> -	len = pg->pcode_size;
> -	if (update) {
> -		data[0] = pg->pcode;
> -		data[1] = len;
> +	for (i = 0; i < pg->pcode_size; i++) {
> +		if (alloc_len > (p-data))
> +			*p = pg->mode_data[i];
> +		p++;
>  	}
> -	p = &data[2];
> -	len += 2;
> -	if (update)
> -		memcpy(p, pg->mode_data, pg->pcode_size);
> 
> -	return len;
> +	return p;
>  }
> 
>  /**
> @@ -362,12 +368,13 @@ static int build_mode_page(uint8_t *data, struct
> mode_pg *pg, int update)
>   */
>  int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
>  {
> -	int len = 0;
>  	uint8_t *data = NULL, *scb, mode6, dbd, pcode, subpcode;
> +	uint8_t *p;
>  	uint16_t alloc_len;
>  	unsigned char key = ILLEGAL_REQUEST;
>  	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
>  	struct mode_pg *pg;
> +	int i;
> 
>  	scb = cmd->scb;
>  	mode6 = (scb[0] == 0x1a);
> @@ -383,10 +390,10 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
> 
>  	if (mode6) {
>  		alloc_len = scb[4];
> -		len = 4;
> +		p = &data[4];
>  	} else {
>  		alloc_len = (scb[7] << 8) + scb[8];
> -		len = 8;
> +		p = &data[8];
>  	}
>  	if (scsi_get_in_length(cmd) < alloc_len)

We still have the same problem here? If a buggy (or malicious)
initiator sends a bogus cdb, alloc_len can be larger than what we
actually allocated.

I'll fix this bug later.


From fujita.tomonori at lab.ntt.co.jp  Tue May  6 16:43:47 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 6 May 2008 23:43:47 +0900
Subject: [Stgt-devel] [PATCH spc/mmc 1/4] RESEND Dont set modepages in
 the	example.
In-Reply-To: <c9a3e4540805052345m53f3563fr42a79871dbe998df@mail.gmail.com>
References: <c9a3e4540805052345m53f3563fr42a79871dbe998df@mail.gmail.com>
Message-ID: <20080506232611X.tomof@acm.org>

On Tue, 6 May 2008 16:45:47 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> >From b6d600a4ca79bc630cbc91042be77e5f6b75b539 Mon Sep 17 00:00:00 2001
> From: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> Date: Tue, 6 May 2008 16:13:29 +1000
> Subject: [PATCH] Dont set the modepages in the example
> 
> No need to specify the modepages in the example since they
> are set automatically when the device is initialized anyway.
> No need to make the example more complicated than it has to be.
> 
> Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> ---
>  doc/README.mmc |    7 -------
>  1 files changed, 0 insertions(+), 7 deletions(-)

#1-3 applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Tue May  6 16:43:48 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 6 May 2008 23:43:48 +0900
Subject: [Stgt-devel] tgt target drivers?
In-Reply-To: <515601290805060457m575afe83x3c24debbc59899b6@mail.gmail.com>
References: <515601290805050417m291cb022qc0cccb4230079762@mail.gmail.com>
	<20080506143733R.tomof@acm.org>
	<515601290805060457m575afe83x3c24debbc59899b6@mail.gmail.com>
Message-ID: <20080506234343J.tomof@acm.org>

On Tue, 6 May 2008 13:57:15 +0200
"tgt user" <tgt.user at gmail.com> wrote:

> On Tue, May 6, 2008 at 7:37 AM, FUJITA Tomonori
> <fujita.tomonori at lab.ntt.co.jp> wrote:
> >
> > On Mon, 5 May 2008 14:17:27 +0300
> > "tgt user" <tgt.user at gmail.com> wrote:
> >
> > > Hello,
> > >
> > > I was wondering - what is the status of the target drivers in tgt? I know
> > > that iSCSI is available. What about the rest? What is their status?
> >
> > First, use the plain text format. I often ignore html mails.
> Sure. I hope it is ok now. If not, I'll try to re-config my Gmail account.

ok.


> > - iSCSI and iSER drivers should work.
> >
> > - IBM pSeries virtual scsi target driver should work
> >
> > - FCoE driver is available but not tested well.
> >
> > - I submitted qlogic 2x00 fc driver several monthes ago but I guess
> > that Qlogic is not eager to support it.
> Thank you.
> 
> The FC driver is kernel code, right?

Yes, IBM pSeries driver and qla2xxx drivers run in user space.


> Was it accepted?

The qla2xxx driver isn't.


> Which support does it need from Qlogic?

We need ACK from Qlogic to push it to mainline because the target
driver works with the mainline qla2xxx initiator driver.

We also need thier technical help like the details of the hardware and
firmware. Without such help, it's impossible to implement and keep the
driver reliable.


> Can you direct me to the stgt FC code in the kernel tree?

Here's a patch:

http://marc.info/?l=linux-scsi&m=118857984513557&w=2

However, it doesn't work anymore since the qla2xxx initiator driver
has changed lot.


> Another question - I think that I understand more or less the
> userspace code. Can you say a few words about scsi_tgt_lib.c &
> scsi_tgt_if.c and how it interacts with userland?

In short, they share a ring buffer for bi-directional communiction.

A similar and simpler exmaple is net/packet/af_packet.c
(CONFIG_PACKET_MMAP) though it's not bi-directional communiction
(only kernel -> user space).

Another similar example is Xen's blktap, storage virtualization
mechanism. It works like tgt.


From ronniesahlberg at gmail.com  Tue May  6 22:17:49 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Wed, 7 May 2008 06:17:49 +1000
Subject: [Stgt-devel] [PATCH spc/mmc 4/4] RESEND modesense memory
	corruption bug
In-Reply-To: <20080506233010N.tomof@acm.org>
References: <c9a3e4540805052350u26f83577y428170b2b0ee2fc3@mail.gmail.com>
	<20080506233010N.tomof@acm.org>
Message-ID: <c9a3e4540805061317w2a54e711g5a455b2614871f48@mail.gmail.com>

On Wed, May 7, 2008 at 12:43 AM, FUJITA Tomonori
<fujita.tomonori at lab.ntt.co.jp> wrote:
...
>
> We still have the same problem here? If a buggy (or malicious)
> initiator sends a bogus cdb, alloc_len can be larger than what we
> actually allocated.

Yes.

For example if an application tries to "probe" the size of a modepage
by doing a mode sense and specifying alloc_len == 20 for example when
requesting the
modepage for MM Capabilities (which is >60 bytes in size)
then the memcpy() will corrupt data and tgtd will crash.


>
> I'll fix this bug later.
>

ok. thanks.


From ronniesahlberg at gmail.com  Tue May  6 22:27:25 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Wed, 7 May 2008 06:27:25 +1000
Subject: [Stgt-devel] [PATCH 1/1] mmc: unit serial number fix
Message-ID: <c9a3e4540805061327w2bbdf811qdc321fbe7e13413c@mail.gmail.com>


From ronniesahlberg at gmail.com  Tue May  6 22:18:55 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Wed, 7 May 2008 06:18:55 +1000
Subject: [PATCH] Use same serial num in getconfig:unitserialnum as inquiry does
Message-ID: <mailman.31.1331738481.12506.stgt-devel@lists.berlios.de>

The feature GetConfiguration/Lun_Serial_Number is used to pull
the unit serial number from a device.
Use the same data that inq 0x80 uses to report the serial number
so that both methods (getconf and inq) report the same serial number
for the device.

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 usr/mmc.c |   19 ++++++++++---------
 1 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index 074b9be..aaf26e9 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -833,6 +833,9 @@ static char *feature_dvd_plus_r(struct scsi_cmd
*cmd, char *data,
 static char *feature_lun_serial_no(struct scsi_cmd *cmd, char *data,
 				   int only_current)
 {
+	struct lu_phy_attr *attrs;
+	struct vpd *vpd_pg;
+
 	/* feature code */
 	*data++ = 0x01;
 	*data++ = 0x08;
@@ -843,15 +846,13 @@ static char *feature_lun_serial_no(struct
scsi_cmd *cmd, char *data,
 	/* additional length */
 	*data++ = 8;

-	/* XXX */
-	*data++ = 'D';
-	*data++ = 'V';
-	*data++ = 'D';
-	*data++ = '#';
-	*data++ = '1';
-	*data++ = '2';
-	*data++ = '3';
-	*data++ = '4';
+	/* serial number */
+	attrs = &cmd->dev->attrs;
+	vpd_pg = attrs->lu_vpd[PCODE_OFFSET(0x80)];
+	if (vpd_pg->size == 8) {
+		memcpy(data, vpd_pg->data, 8);
+	}
+	data += 8;

 	return data;
 }
-- 
1.5.5


From fujita.tomonori at lab.ntt.co.jp  Wed May  7 01:32:01 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 7 May 2008 08:32:01 +0900
Subject: [Stgt-devel] [PATCH 1/1] mmc: unit serial number fix
In-Reply-To: <c9a3e4540805061327w2bbdf811qdc321fbe7e13413c@mail.gmail.com>
References: <c9a3e4540805061327w2bbdf811qdc321fbe7e13413c@mail.gmail.com>
Message-ID: <20080507083146Q.tomof@acm.org>

On Wed, 7 May 2008 06:27:25 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> >From 4f5391a1c67e69d913163c9dcf168cdf39229ad9 Mon Sep 17 00:00:00 2001
> From: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> Date: Wed, 7 May 2008 06:18:55 +1000
> Subject: [PATCH] Use same serial num in getconfig:unitserialnum as inquiry does
> 
> The feature GetConfiguration/Lun_Serial_Number is used to pull
> the unit serial number from a device.
> Use the same data that inq 0x80 uses to report the serial number
> so that both methods (getconf and inq) report the same serial number
> for the device.
> 
> Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> ---
>  usr/mmc.c |   19 ++++++++++---------
>  1 files changed, 10 insertions(+), 9 deletions(-)

The patch is corrupt. If you use gmail via the web interface, you
can't post patches properly, I guess (if you use gmail via pop/smtp,
it would be fine).

There is one style problem too.

I fixed them and merged the patch.

Thanks,

fujita at arbre:~/git/tgt$ ./scripts/checkpatch.pl ~/Mail/iscsi/stgt/2621
ERROR: patch seems to be corrupt (line wrapped?)
#82: FILE: usr/mmc.c:832:
*cmd, char *data,

ERROR: patch seems to be corrupt (line wrapped?)
#93: FILE: usr/mmc.c:845:
scsi_cmd *cmd, char *data,

WARNING: braces {} are not necessary for single statement blocks
#109: FILE: usr/mmc.c:852:
+       if (vpd_pg->size == 8) {
+               memcpy(data, vpd_pg->data, 8);
+       }

Your patch has style problems, please review.  If any of these errors
are false positives report them to the maintainer, see
CHECKPATCH in MAINTAINERS.


From ronniesahlberg at gmail.com  Wed May  7 09:56:08 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Wed, 7 May 2008 17:56:08 +1000
Subject: [Stgt-devel] [PATCH docs 1/1] Provide example for creating DVD
	jukebox (gzip patch is also attached)
Message-ID: <c9a3e4540805070056i368da513yc9d9f9c65aab1b39@mail.gmail.com>


From ronniesahlberg at gmail.com  Wed May  7 09:49:12 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Wed, 7 May 2008 17:49:12 +1000
Subject: [PATCH] Provide example on how to build DVD jukebox
Message-ID: <mailman.32.1331738481.12506.stgt-devel@lists.berlios.de>

Add an example on how to configure STGT to act as a DVD jukebox

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 doc/README.mmc |  175 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 175 insertions(+), 0 deletions(-)

diff --git a/doc/README.mmc b/doc/README.mmc
index 6f7074d..021e4f5 100644
--- a/doc/README.mmc
+++ b/doc/README.mmc
@@ -98,3 +98,178 @@ tgtadm --tid 1 --lun 1 --op update --mode
logicalunit --name path --value /tmp/e

 # note: when we updated the device to a new bakend storage file the device
 # automatically goes online again with the new media present.
+
+
+
+
+
+
+
+
+#
+# Example 4: How to create a DVD jukebox with 8 disk trays
+#
+
+# Create a target
+tgtadm --lld iscsi --mode target --op new --tid 1 -T
iqn.2007-03:virtual-dvd:`hostname`
+
+# Create a DVD drive and give it a nice name
+# The dvd starts out without a backing store file, i.e. no disk loaded
+tgtadm --op new --mode logicalunit --tid 1 --lun 1 -Y cd
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1
--params vendor_id=STGT_DVD,product_id=DVD101,product_rev=0010,scsi_sn=STGTDVD01,removable=1
+
+
+# We need a backend store file for the media changer
+if [ ! -f $HOME/smc ]; then
+	dd if=/dev/zero of=$HOME/smc bs=1k count=1
+fi
+
+# Create the SMC device and give it a nice name
+tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 2 -b
$HOME/smc --device-type=changer
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2
--params vendor_id=STK,product_id=L700,product_rev=0010,scsi_sn=XYZZY_0,removable=1
+
+
+# Add a Data Transfer devices (1 drive)
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2
--params element_type=4,start_address=1,quantity=1
+
+# Specify that the DVD above (LUN 1) is the data transfer device we created
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2
--params element_type=4,address=1,tid=1,lun=1
+
+# Medium Transport Elements (robot arm / picker)
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2
--params element_type=1,start_address=16,quantity=1
+
+# define path to virtual media
+VTL=${HOME}/vtl
+mkdir -p ${VTL} 2>/dev/null
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2
--params media_home=${VTL}
+
+# Storage Elements - 8 starting at addr 1024
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2
--params element_type=2,start_address=1024,quantity=8
+
+# Add 'media' to slots 1 and 2 and leave the other 6 slots empty
+# slot 1
+touch ${VTL}/DISK_001
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2
--params element_type=2,address=1024,barcode=DISK_001,sides=1
+
+# slot 2
+touch ${VTL}/DISK_002
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2
--params element_type=2,address=1025,barcode=DISK_002,sides=1
+
+# Allow ALL initiators to connect to this target
+tgtadm --lld iscsi --mode target --op bind --tid 1 -I ALL
+
+# Show all our good work.
+tgtadm --lld iscsi --mode target --op show
+
+
+
+
+Now you should be able to access the devices and try it out :
+tgtadm --lld iscsi --mode target --op show
+
+Target 1: iqn.2007-03:virtual-dvd:ronnie
+    System information:
+        Driver: iscsi
+        State: ready
+    I_T nexus information:
+    LUN information:
+        LUN: 0
+            Type: controller
+            SCSI ID: deadbeaf1:0
+            SCSI SN: beaf10
+            Size: 0 MB
+            Online: Yes
+            Removable media: No
+            Backing store: No backing store
+        LUN: 1
+            Type: cd/dvd
+            SCSI ID: deadbeaf1:1
+            SCSI SN: STGTDVD0
+            Size: 0 MB
+            Online: No
+            Removable media: Yes
+            Backing store: No backing store
+        LUN: 2
+            Type: changer
+            SCSI ID: deadbeaf1:2
+            SCSI SN: XYZZY_0
+            Size: 0 MB
+            Online: Yes
+            Removable media: Yes
+            Backing store: /root/smc
+    Account information:
+    ACL information:
+        ALL
+
+
+You can use the 'mtx' command under linux to manage the jukebox (man mtx)
+mtx -f /dev/sg4 status
+
+  Storage Changer /dev/sg4:1 Drives, 8 Slots ( 0 Import/Export )
+Data Transfer Element 0:Empty
+      Storage Element 1:Full :VolumeTag=DISK_001
+      Storage Element 2:Full :VolumeTag=DISK_002
+      Storage Element 3:Empty:VolumeTag=
+      Storage Element 4:Empty:VolumeTag=
+      Storage Element 5:Empty:VolumeTag=
+      Storage Element 6:Empty:VolumeTag=
+      Storage Element 7:Empty:VolumeTag=
+      Storage Element 8:Empty:VolumeTag=
+
+Now load the disk in slot 1 :
+mtx -f /dev/sg4 load 1
+mtx -f /dev/sg4 status
+
+  Storage Changer /dev/sg4:1 Drives, 8 Slots ( 0 Import/Export )
+Data Transfer Element 0:Full (Storage Element 1 Loaded):VolumeTag =
DISK_001
+      Storage Element 1:Empty:VolumeTag=
+      Storage Element 2:Full :VolumeTag=DISK_002
+      Storage Element 3:Empty:VolumeTag=
+      Storage Element 4:Empty:VolumeTag=
+      Storage Element 5:Empty:VolumeTag=
+      Storage Element 6:Empty:VolumeTag=
+      Storage Element 7:Empty:VolumeTag=
+      Storage Element 8:Empty:VolumeTag=
+
+And if we look at the devices again we see the DVD drive is now online and has
+a disk loaded :
+tgtadm --lld iscsi --mode target --op show
+
+Target 1: iqn.2007-03:virtual-dvd:ronnie    System information:
+        Driver: iscsi
+        State: ready
+    I_T nexus information:
+        I_T nexus: 1
+            Initiator: iqn.1993-08.org.debian:ronnie
+            Connection: 0
+                IP Address: 127.0.0.1
+    LUN information:
+        LUN: 0
+            Type: controller
+            SCSI ID: deadbeaf1:0
+            SCSI SN: beaf10
+            Size: 0 MB
+            Online: Yes
+            Removable media: No
+            Backing store: No backing store
+        LUN: 1
+            Type: cd/dvd
+            SCSI ID: deadbeaf1:1
+            SCSI SN: STGTDVD0
+            Size: 0 MB
+            Online: Yes
+            Removable media: Yes
+            Backing store: /root/vtl/DISK_001
+        LUN: 2
+            Type: changer
+            SCSI ID: deadbeaf1:2
+            SCSI SN: XYZZY_0
+            Size: 0 MB
+            Online: Yes
+            Removable media: Yes
+            Backing store: /root/smc
+    Account information:
+    ACL information:
+        ALL
+
+Have fun building big DVD jukeboxes !!!
-- 
1.5.5

------=_Part_16778_27264919.1210146968097
Content-Type: application/x-gzip;
 name=0001-Provide-example-on-how-to-build-DVD-jukebox.patch.gz
Content-Transfer-Encoding: base64
X-Attachment-Id: f_ffxm3k3n0
Content-Disposition: attachment;
 filename=0001-Provide-example-on-how-to-build-DVD-jukebox.patch.gz

H4sICChfIUgAAzAwMDEtUHJvdmlkZS1leGFtcGxlLW9uLWhvdy10by1idWlsZC1EVkQtanVrZWJv
eC5wYXRjaADtWW1z28YR/lz8ivXYM5aGBAlAlCihZcaKJNeaSI7HZN0qmYxyAA7kRQCOORwoMWn+
e3fvwFeRdZVSbWdqSAMB97K3++ze7nPQWyVzCKKT4NALuOdHAefR8Ul6mPCkG50cdLiXeN2IpSfp
QcrgWhbQ52Pwu+B5ofmFwPN85y2KCeGjLArBoc9GWcTVEP6kTENZv78Z5kxkrVjmXznnTPMQ/sqT
JnThmk1JzDHKDTsnoR9Aw/c8z+lX0U881iF8/+F0cPbuB/ig5EQkHPgDy8cZB1RnJO9BS4gqkSVw
/ukcfqrueCQfHOc0SYAVG8bGskjFsFKo6eDPA2phsQZWAlsV0BfDgieuTFM3mj7JOtd1HUhk3P54
cXp+fdHK8xj+DmjeITR+5+WAD6nIeAnxiBVDAo7EiaLkSgtZlHuN/SZ4kPCM23d333ESkabgukOB
9rXXFIrWGhxRJPwBjtKu1+0krZYX+LyTHgK64qjTIZseyXBQscdy3rwB9+S4eQANvPvdY8AGPdQs
yVEVLRK0xHWzqjB/5RiqcYLRgM+5RN9mcihiht2os+sWLOcwZnqEzxNs5dDW+bjNHXDgJRSSouh+
xAu457WcBPSIIwwTEXPjWyj4PUTsjhcJlFoqNuQGyaVxJItVWuZM09rZFIYSkZZFJgoObMgELiBQ
CZpC4nKeCAZjxUte6JbTWP95ib9wUUdeJ4R3deQpTpauxJkVfAyJKO9AKzYtzXQScDYbrpkacu00
5ihmGOyijEsxQ82OsHiSgnOgByB+Llq4u7qudxBOhNIVy9xkkoQ/jmSpCd8f11Yj5RIlJviMkA3p
geIHCkKUJtDoAYE3IUSZ0ghVpY0h9Jch2vGdKIYGbgt2E0SLt9Bh1s5MMswwSwbN1d4QA2shcwNx
8s+gWJ28HF/rsTdmiuUlTDAypLoVSY/ywS2a3xwrmVSxpjZ89T1/3qL4pIcZz2vSkrdlYebgGByi
eC4nLMp4z6+jABMcmoUhaSGZRWAdf6lUJqBsMNltrZyGSOF7eAFuCq/efXt90S5xr/7wRxpZOI0/
YFITaa+Ncdv+hSsJMu0thkVlz7/D/FYVmnRIxYpnaa3+9dlsb2x17hOgXQk1g2sAbrSkuOva1Vw9
HfPe3MZ/13vBZu99s+y4q67nbXfb326+++7m1tvkNFM4ACsUg4FiRZlyVWNWwp5vt8b+Tm3AnJ1j
Irk1IHWaZk/dsiTB/IIebf5csUILPbUqvoT+mMcinaJDmTZepR3LIom+3Lv6y3vw91Efm97ICL1q
BKVKm4h2sI22G7FQH8fjHUfP9L/GgK9yC+5YKg0XdirCq2QkMRxVDm0YC9wy6hmR9teRPnoEdcJT
KgGmAmECr/On3bJO49PgqvfqVwr239oTnTmN/C4RCtwxvPoV+36D4CuzU4sqy3Zqhln/diRz3rMr
1YFRl7c5ni4WFmMjZWMMFrIUC3rQeT5Qg3VQcbUFrMeLLfbaGPGaYC0zicr6JiUF5p5xNrEZS+JN
wVE9hudjPSUJ9AroJC2reFTD3T6/7H9zS3z0Ga1bsStiKkahvdnCzRLpaTkLHqNjsFnH4D+k4+G6
jsGqjqdZhtzk9OoKqaTQgmEElTVJLpB706MeUTZ5EgWJkEsutL0k+XWEEgdHhoWEQSHJkgncS3XX
+lflljh9wbLeo6yprKi1wlkR1rQos6QvxmRdLjG80kSVVlOqdkRSwqcuObBtfriVUNnzgNMAvPrT
UvMcMcUiT6xSFqHtoOucKogK7ZqL5r42hyJMzcnUtl7eDrDEPlTlBkGU6DeLx54QvMU7XQMMjJCc
qpXMMirBy739s/4lXJ6HCBZLIs5SP/Q2jOijXNO73il+QeEeXH+92v6t4c8h3PBytePjrOjaRBbC
e7k64OtlAkndq5RyzVZ/o61JG53yWTv9LXbOaN3TLF2345Ghj6B4mqXBRktnrOozpgZbTK2p0K59
+jlT20pKTSTRjjqNDW/dENOnZ1dbIr1OK07jBrNAjIf9qrRF43WuH15juOc5bfsKD7YKUO/qgZID
tlGRpHGzM9getgHOQbKBd+Lepm6Xww6VT12VtAjM6+uZRXw+KPTtni6bWG/7plDtIXaXObGb9sWD
ITkoe5VT1lUavPDCVrUa+dUijhnnLdIHCD/JrMr5gA3n1QY2X9sEBdsEBU8UdGAVXhK0RcDnBHV2
JehwV4KOdiWouytBxxsFzcofHaRtmaNjtShqXkTlbT2QzVD/vxPgJvD2HkU2XJnvAPsL46AHvzO6
/acC/mWf/B/sE7tTTgv6akIH30zKO6hPzXNmaL/vcSg5nx+n7QcwJL4F7rLZh0AUM2K4VdjyV6zn
o5LGzGcnkiv9j8jU5exUYJX1T04OXO+4JdWwlfBIsGKF9s6uM3t6oEXWmagR+oFOgHREwfWCbsvD
H/8Lrf2fpbW7InsTnS2d0VeM/cJsNzHbd/QVJMWzvvn/Fi0RieHyfw8wfb148cJxXXD81mHr0HH+
AXq8Rb/SGwAA
------=_Part_16778_27264919.1210146968097--


From markh794 at gmail.com  Wed May  7 10:22:45 2008
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 7 May 2008 18:22:45 +1000
Subject: [Stgt-devel] Implementation of vtl
In-Reply-To: <78490.54378.qm@web94812.mail.in2.yahoo.com>
References: <78490.54378.qm@web94812.mail.in2.yahoo.com>
Message-ID: <f29db9a80805070122x7b6fd3a3hfa33cfba731f5417@mail.gmail.com>

Hello aftab azmi,

First off, thanks... You beat me to the punch :) It might save me some work....

While I can't speak authoritatively, I'm sure this will be rejected
first off due the the code base not following the Linux kernel coding
style... You can find the coding style document in the Linux kernel
source under the Documentation dir.

I've passed it thru the scripts/checkpatch.pl script and attached are
the coding style errors: (Lots of tab/space issues)

2nd. The 'detection' of a filemark appears a little week. i.e. first
byte at a 512 byte boundary to contain '28'. This could produce many
false positives.

3rd. I see no way to detect variable block underrun/overrun detection
(the main sticking point with my code base)..

4th. You assume variable block writes. This code would fail if the
user set the tape block size to 'fixed block'.

Point 1 is easily resolved with a little effort.
Do you have any ideas on the solution to points 2 & 3 (just not coded yet) ?
Point 4 is an easy code fix.

Keep up the good work.

p.s. To make it much easier for people on this list to review the
code, please refer to the Linux kernel 'submitting patches' document.
You will receive much faster code reviews...

Regards
Mark Harvey

On Tue, May 6, 2008 at 5:24 PM, aftab azmi <max_aftab at yahoo.com> wrote:
> Hiii everyone...
>     Attached herewith  is our implementation  of  Virtual  Tape Library....I have implemented all the mandatory commands mentioned in ssc-r42  except  erase command.....
>  For this to run u have  to change the default-bst in iscsid.c  to "ssc"..
>  We can use tar command to read/write  backup..
>  Please do send in your comments and suggestions for further devlopment.
>
>
>
>
>
>
>       Bollywood, fun, friendship, sports and more. You name it, we have it on http://in.promos.yahoo.com/groups/bestofyahoo/
> _______________________________________________
>  Stgt-devel mailing list
>  Stgt-devel at lists.berlios.de
>  https://lists.berlios.de/mailman/listinfo/stgt-devel
>
>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: bs_ssc-check_patch
Type: application/octet-stream
Size: 16346 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080507/856ef0a4/attachment.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ssc-check_patch
Type: application/octet-stream
Size: 2017 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080507/856ef0a4/attachment-0001.obj>

From max_aftab at yahoo.com  Wed May  7 17:27:25 2008
From: max_aftab at yahoo.com (aftab azmi)
Date: Wed, 7 May 2008 20:57:25 +0530 (IST)
Subject: [Stgt-devel] Fw:  Implementation of vtl
Message-ID: <257229.68956.qm@web94812.mail.in2.yahoo.com>



----- Forwarded Message ----
From: aftab azmi <max_aftab at yahoo.com>
To: Mark Harvey <markh794 at gmail.com>
Sent: Wednesday, 7 May, 2008 8:56:36 PM
Subject: Re: [Stgt-devel] Implementation of vtl

Actually i couldnt find any value for file mark so i choose ascii code 28(file separator) as filemark.i guess it will not be present in any user file so will not produce false positive...

I have assummed fixed block write..i forgot to include check for the FIXED bit in read and write command.. 

For variable block write i think we have to use your structure...for underrun we can compare the blk_size in blk_header against the MINIMUM BLOCK LENGTH LIMIT field in READ BLOCK LIMITS data and for overrun we can compare blk_size and MAXIMUM BLOCK LENGTH LIMIT.

----- Original Message ----
From: Mark Harvey <markh794 at gmail.com>
To: aftab azmi <max_aftab at yahoo.com>
Cc: stgt-devel at lists.berlios.de; fujita.tomonori at lab.ntt.co.jp
Sent: Wednesday, 7 May, 2008 1:52:45 PM
Subject: Re: [Stgt-devel] Implementation of vtl

Hello aftab azmi,

First off, thanks... You beat me to the punch :) It might save me some work....

While I can't speak authoritatively, I'm sure this will be rejected
first off due the the code base not following the Linux kernel coding
style... You can find the coding style document in the Linux kernel
source under the Documentation dir.

I've passed it thru the scripts/checkpatch.pl script and attached are
the coding style errors: (Lots of tab/space issues)

2nd. The 'detection' of a filemark appears a little week. i.e. first
byte at a 512 byte boundary to contain '28'. This could produce many
false positives.

3rd. I see no way to detect variable block underrun/overrun detection
(the main sticking point with my code base)..

4th. You assume variable block writes. This code would fail if the
user set the tape block size to 'fixed block'.

Point 1 is easily resolved with a little effort.
Do you have any ideas on the solution to points 2 & 3 (just not coded yet) ?
Point 4 is an easy code fix.

Keep up the good work.

p.s. To make it much easier for people on this list to review the
code, please refer to the Linux kernel 'submitting patches' document.
You will receive much faster code reviews...

Regards
Mark Harvey

On Tue, May 6, 2008 at 5:24 PM, aftab azmi <max_aftab at yahoo.com> wrote:
> Hiii everyone...
>     Attached herewith  is our implementation  of  Virtual  Tape Library....I have implemented all the mandatory commands mentioned in ssc-r42  except  erase command.....
>  For this to run u have  to change the default-bst in iscsid.c  to "ssc"..
>  We can use tar command to read/write  backup..
>  Please do send in your comments and suggestions for further devlopment.
>
>
>
>
>
>
>       Bollywood, fun, friendship, sports and more. You name it, we have it on http://in.promos.yahoo.com/groups/bestofyahoo/
> _______________________________________________
>  Stgt-devel mailing list
>  Stgt-devel at lists.berlios.de
>  https://lists.berlios.de/mailman/listinfo/stgt-devel
>
>



      Check out the all-new face of Yahoo! India. Go to http://in.yahoo.com/



      Bring your gang together. Do your thing. Find your favourite Yahoo! group at http://in.promos.yahoo.com/groups/



From fujita.tomonori at lab.ntt.co.jp  Wed May  7 17:50:17 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 08 May 2008 00:50:17 +0900
Subject: [Stgt-devel] Implementation of vtl
In-Reply-To: <f29db9a80805070122x7b6fd3a3hfa33cfba731f5417@mail.gmail.com>
References: <78490.54378.qm@web94812.mail.in2.yahoo.com>
	<f29db9a80805070122x7b6fd3a3hfa33cfba731f5417@mail.gmail.com>
Message-ID: <20080508005017L.fujita.tomonori@lab.ntt.co.jp>

On Wed, 7 May 2008 18:22:45 +1000
"Mark Harvey" <markh794 at gmail.com> wrote:

> Hello aftab azmi,
> 
> First off, thanks... You beat me to the punch :) It might save me some work....
> 
> While I can't speak authoritatively, I'm sure this will be rejected
> first off due the the code base not following the Linux kernel coding
> style... You can find the coding style document in the Linux kernel
> source under the Documentation dir.
> 
> I've passed it thru the scripts/checkpatch.pl script and attached are
> the coding style errors: (Lots of tab/space issues)

Yes, please please fix the coding style problems first.

Thank for the code, Aftab and Thanks for the reviewing, Mark!


From fujita.tomonori at lab.ntt.co.jp  Wed May  7 18:50:01 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 8 May 2008 01:50:01 +0900
Subject: [Stgt-devel] [PATCH docs 1/1] Provide example for creating
	DVD	jukebox (gzip patch is also attached)
In-Reply-To: <c9a3e4540805070056i368da513yc9d9f9c65aab1b39@mail.gmail.com>
References: <c9a3e4540805070056i368da513yc9d9f9c65aab1b39@mail.gmail.com>
Message-ID: <20080508015000M.tomof@acm.org>

On Wed, 7 May 2008 17:56:08 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> >From 2b92502e01b2eeb89f5ded7b934e0d07baf9f3fa Mon Sep 17 00:00:00 2001
> From: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> Date: Wed, 7 May 2008 17:49:12 +1000
> Subject: [PATCH] Provide example on how to build DVD jukebox
> 
> Add an example on how to configure STGT to act as a DVD jukebox
> 
> Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> ---
>  doc/README.mmc |  175 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
>  1 files changed, 175 insertions(+), 0 deletions(-)

Thanks a lot. I got the following error. I fixed and applied it. I
really appreciate if you would run ./scripts/checkpatch.pl and fix the
style error before submitting a patch.

Thanks,


Applying add an example on how to build DVD jukebox
.dotest/patch:122: trailing whitespace.
      Storage Element 1:Full :VolumeTag=DISK_001
.dotest/patch:123: trailing whitespace.
      Storage Element 2:Full :VolumeTag=DISK_002
.dotest/patch:124: trailing whitespace.
      Storage Element 3:Empty:VolumeTag=
.dotest/patch:125: trailing whitespace.
      Storage Element 4:Empty:VolumeTag=
.dotest/patch:126: trailing whitespace.
      Storage Element 5:Empty:VolumeTag=
.dotest/patch:127: trailing whitespace.
      Storage Element 6:Empty:VolumeTag=
.dotest/patch:128: trailing whitespace.
      Storage Element 7:Empty:VolumeTag=
.dotest/patch:129: trailing whitespace.
      Storage Element 8:Empty:VolumeTag=
.dotest/patch:136: trailing whitespace.
Data Transfer Element 0:Full (Storage Element 1 Loaded):VolumeTag = DISK_001    
.dotest/patch:137: trailing whitespace.
      Storage Element 1:Empty:VolumeTag=
.dotest/patch:138: trailing whitespace.
      Storage Element 2:Full :VolumeTag=DISK_002
.dotest/patch:139: trailing whitespace.
      Storage Element 3:Empty:VolumeTag=
.dotest/patch:140: trailing whitespace.
      Storage Element 4:Empty:VolumeTag=
.dotest/patch:141: trailing whitespace.
      Storage Element 5:Empty:VolumeTag=
.dotest/patch:142: trailing whitespace.
      Storage Element 6:Empty:VolumeTag=
.dotest/patch:143: trailing whitespace.
      Storage Element 7:Empty:VolumeTag=
.dotest/patch:144: trailing whitespace.
      Storage Element 8:Empty:VolumeTag=
fatal: 17 lines add whitespace errors.
Patch failed at 0001.


From markh794 at gmail.com  Thu May  8 01:28:51 2008
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 8 May 2008 09:28:51 +1000
Subject: [Stgt-devel] Fwd:  Implementation of vtl
In-Reply-To: <f29db9a80805071432m7137769el39f80a4393ae48f7@mail.gmail.com>
References: <386901.45677.qm@web94813.mail.in2.yahoo.com>
	<f29db9a80805071432m7137769el39f80a4393ae48f7@mail.gmail.com>
Message-ID: <f29db9a80805071628s20f1037ds577ef64b54b5dcbd@mail.gmail.com>

Oops. Forgot to 'reply all'...

Forwarding to stgt mailing list - just in case I've got my facts wrong.

Cheers
Mark

---------- Forwarded message ----------
From: Mark Harvey <markh794 at gmail.com>
Date: Thu, May 8, 2008 at 7:32 AM
Subject: Re: [Stgt-devel] Implementation of vtl
To: aftab azmi <max_aftab at yahoo.com>


I'm not quite sure of your meaning of "couldn't find any value for
 filemark" so please excuse me, if I'm talking to the converted...

 A 'filemark' is a special bit pattern written to tape which is not
 actually data. Just a 'mark' so the tape drive firmware can find
 (position to) it. Many backup programs (VERITAS NetBackup, Legato
 NetWorker as larger examples) use filemarks as delimiters between
 segments of data. Especially in the older days when tape drives did
 not support the FAST BLOCK LOCATE cmd.

 The ability to be able to detect multiple filemarks will be critical
 for correct tape drive emulation.

 Re: Fixed block:
 How do you compute the block size ?

 From my quick review of the code, I did not see any reference to the
 MODE SELECT/MODE SENSE commands and the BLOCK LENGTH field. i.e. No
 way for a backup program to set / query the block size. (except the
 READ BLOCK LIMITS).

 Re: Block under/over run detection.
 This is only a requirement for variable block READ - so fixed block
we are safe.

 Cheers
 Mark





 On Thu, May 8, 2008 at 1:26 AM, aftab azmi <max_aftab at yahoo.com> wrote:
 > Actually i couldnt find any value for file mark so i choose ascii
code 28(file separator) as filemark.i guess it will not be present in
any user file so will not produce false positive...
 >
 >  I have assummed fixed block write..i forgot to include check for
the FIXED bit in read and write command..
 >
 >  For variable block write i think we have to use your
structure...for underrun we can compare the blk_size in blk_header
against the MINIMUM BLOCK LENGTH LIMIT field in READ BLOCK LIMITS data
and for overrun we can compare blk_size and MAXIMUM BLOCK LENGTH
LIMIT.
 >
 >
 >
 >  ----- Original Message ----
 >  From: Mark Harvey <markh794 at gmail.com>
 >  To: aftab azmi <max_aftab at yahoo.com>
 >  Cc: stgt-devel at lists.berlios.de; fujita.tomonori at lab.ntt.co.jp
 >  Sent: Wednesday, 7 May, 2008 1:52:45 PM
 >  Subject: Re: [Stgt-devel] Implementation of vtl
 >
 >  Hello aftab azmi,
 >
 >  First off, thanks... You beat me to the punch :) It might save me
some work....
 >
 >  While I can't speak authoritatively, I'm sure this will be rejected
 >  first off due the the code base not following the Linux kernel coding
 >  style... You can find the coding style document in the Linux kernel
 >  source under the Documentation dir.
 >
 >  I've passed it thru the scripts/checkpatch.pl script and attached are
 >  the coding style errors: (Lots of tab/space issues)
 >
 >  2nd. The 'detection' of a filemark appears a little week. i.e. first
 >  byte at a 512 byte boundary to contain '28'. This could produce many
 >  false positives.
 >
 >  3rd. I see no way to detect variable block underrun/overrun detection
 >  (the main sticking point with my code base)..
 >
 >  4th. You assume variable block writes. This code would fail if the
 >  user set the tape block size to 'fixed block'.
 >
 >  Point 1 is easily resolved with a little effort.
 >  Do you have any ideas on the solution to points 2 & 3 (just not coded yet) ?
 >  Point 4 is an easy code fix.
 >
 >  Keep up the good work.
 >
 >  p.s. To make it much easier for people on this list to review the
 >  code, please refer to the Linux kernel 'submitting patches' document.
 >  You will receive much faster code reviews...
 >
 >  Regards
 >  Mark Harvey
 >
 >  On Tue, May 6, 2008 at 5:24 PM, aftab azmi <max_aftab at yahoo.com> wrote:
 >  > Hiii everyone...
 >  >     Attached herewith  is our implementation  of  Virtual  Tape
Library....I have implemented all the mandatory commands mentioned in
ssc-r42  except  erase command.....
 >  >  For this to run u have  to change the default-bst in iscsid.c  to "ssc"..
 >  >  We can use tar command to read/write  backup..
 >  >  Please do send in your comments and suggestions for further devlopment.
 >  >
 >  >
 >  >
 >  >
 >  >
 >  >
 >  >       Bollywood, fun, friendship, sports and more. You name it,
we have it on http://in.promos.yahoo.com/groups/bestofyahoo/
 >  > _______________________________________________
 >  >  Stgt-devel mailing list
 >  >  Stgt-devel at lists.berlios.de
 >  >  https://lists.berlios.de/mailman/listinfo/stgt-devel
 >  >
 >  >
 >
 >
 >
 >       Check out the all-new face of Yahoo! India. Go to http://in.yahoo.com/
 >
 >


From pw at osc.edu  Thu May  8 01:40:49 2008
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 7 May 2008 19:40:49 -0400
Subject: [Stgt-devel] Calling iser_rx_progress
In-Reply-To: <48206268.1010001@voltaire.com>
References: <48206268.1010001@voltaire.com>
Message-ID: <20080507234049.GA7407@osc.edu>

erezz at voltaire.com wrote on Tue, 06 May 2008 16:51 +0300:
> I'm going over some of the iSER code and I have a question: I saw that
> iser_rx_progress is called from iser_cqe_handler and from the event loop
> (added by tgt_counter_event_add). I understand the purpose of calling it
> from iser_cqe_handler - it is called to handle new completions. Can you
> explain the usage in tgt_counter_event_add?

Unlike with transmit, rx progress can only occur when events
happen on the network:  a new request coming in, or completing
RDMA reads.  So why would we ever bother calling the rx progress
function from a generic event handler?

Initially we used to pull as many events off the completion queue as
possible, but it turns out that was starving the transmits.  The
machine was so busy handling new incoming requests, and queueing
them up, that transmits were not promptly going out.  So now there's
a limit of 8 rx CQ events, somewhat arbitrarily, to make sure the
tx engine gets a chance to run every so often.

But if you don't read all the completion queue events, there's no
way to have the device signal again that there are still some left.
Unlike with sockets and poll, where this is a very natural to do
things.  Thus we increase the "counter event" for the rx side if
there are more than 8 completion queue events, and later, after the
transmit side has run, the main event loop will see num_rx_ready and
go deal with another batch of 8.

Event notification is very weak aspect of unix/posix, even
considering some of the interesting linux-specific innovations.
Tossing yet another event mechanism into the mix (IB verbs CQEs)
doesn't make writing event-driven applications any easier.

		-- Pete


From ronniesahlberg at gmail.com  Sat May 10 09:50:01 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sat, 10 May 2008 17:50:01 +1000
Subject: [Stgt-devel] [PATCH service_actions 1/1] Add infrastructure to
	handle cdb lengths and service_actions
Message-ID: <c9a3e4540805100050y675415cdq6c5b830e4baa4abb@mail.gmail.com>

List

This patch is also attached in gzip format, if gmail once again
decides to mangle it.

It adds infrastructure to handle commands that take service actions.
It also adds the cdb length to all commands we have implemented and
list in the .ops structure.
(at least when I try the ioctl() to do scsi passthrough,   the devices
I have gets really "unhappy" if i dont provide the correct/expected
cdb length   so this sould also benefit when passthrough is added)

As an example of a "service action" command being implemented
I implemented 0xa3/0x0c which is ReportSupportedOperationCodes
other MaintenanceIn commands should be easy to add.

please review/apply/discuss

ronnie sahlberg


From ronniesahlberg at gmail.com  Sat May 10 09:29:51 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Sat, 10 May 2008 17:29:51 +1000
Subject: [PATCH] Add infrastructure to handle cdb lengths, service actions lists
Message-ID: <mailman.33.1331738481.12506.stgt-devel@lists.berlios.de>

Expand device_type_operations to also include the cdb length and an
array of possible service actions for this command.
We need both the list of service actions and also the cdb length in
order to implement
ReportSupportedOpcodes : ManagementIn:service action 0x0c

Augment the .ops structure and provide the expected cdb length for all
command implemented for all device types.  This is required to support
ReportSupportedOperationCodes as well as might be useful if/when we add
a passthrough backend   since at least the current backend becomes unhappy
if the cdb length provided to the ioctl() is different from what the
real device expects.

Augment the .ops structure with a null terminated list of service action for
the (now only 0xa3) opcodes that take service actions and which needs to
be reported in ReportSupportedOpcodes.

Implement MaintenanceIn and implement service action 0x0c for this command.
the provided infrastructure should make it easier to add other MaintIn
service actions, of which there are quite a few.

there are many other opcodes that also take service actions and which
could build on this framework:
0xa4 MaintOut
0x7f: variable length cdb
0x5e/0x5f persistent reservarion in/out
0xab
0x9e
0x9f

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 usr/mmc.c  |   54 ++++++++++----------
 usr/osd.c  |   12 ++--
 usr/sbc.c  |   44 ++++++++--------
 usr/scc.c  |   16 +++---
 usr/smc.c  |   20 ++++----
 usr/spc.c  |  171 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 usr/spc.h  |    4 ++
 usr/tgtd.h |    7 +++
 8 files changed, 255 insertions(+), 73 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index aaf26e9..9dd2523 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -2306,10 +2306,10 @@ static struct device_type_template mmc_template = {
 	.lu_offline	= mmc_lu_offline,
 	.lu_exit	= spc_lu_exit,
 	.ops		= {
-		{spc_test_unit,},
+		{spc_test_unit, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_request_sense,},
+		{spc_request_sense, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -2327,7 +2327,7 @@ static struct device_type_template mmc_template = {
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_inquiry,},
+		{spc_inquiry, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -2337,10 +2337,10 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_start_stop,},
+		{spc_start_stop, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_start_stop,}, /* allow medium removal */
+		{spc_start_stop, 6,}, /* allow medium removal */
 		{spc_illegal_op,},

 		/* 0x20 */
@@ -2349,18 +2349,18 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_read_capacity,},
+		{mmc_read_capacity, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{mmc_rw},
+		{mmc_rw, 10,}, /* read10*/
 		{spc_illegal_op,},
-		{mmc_rw},
+		{mmc_rw, 10,}, /* write10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_test_unit},
+		{spc_test_unit, 10,}, /* verify10 */

 		/* 0x30 */
 		{spc_illegal_op,},
@@ -2368,7 +2368,7 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_synchronize_cache,},
+		{mmc_synchronize_cache, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

@@ -2385,10 +2385,10 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_read_toc,},
+		{mmc_read_toc, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_get_configuration,},
+		{mmc_get_configuration, 10,},
 		{spc_illegal_op,},

 		{spc_illegal_op,},
@@ -2402,19 +2402,19 @@ static struct device_type_template mmc_template = {

 		/* 0x50 */
 		{spc_illegal_op,},
-		{mmc_read_disc_information,},
-		{mmc_read_track_information,},
-		{mmc_reserve_track,},
+		{mmc_read_disc_information, 10,},
+		{mmc_read_track_information, 10,},
+		{mmc_reserve_track, 10,},
 		{spc_illegal_op,},
-		{mmc_mode_select,},
+		{mmc_mode_select, 10,}, /* modeselect10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},

 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_mode_sense,},
-		{mmc_close_track,},
-		{mmc_read_buffer_capacity,},
+		{mmc_mode_sense, 10,}, /* modesense10 */
+		{mmc_close_track, 10,},
+		{mmc_read_buffer_capacity, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -2422,21 +2422,21 @@ static struct device_type_template mmc_template = {
 		[0x60 ... 0x9f] = {spc_illegal_op,},

 		/* 0xA0 */
-		{spc_report_luns,},
-		{spc_illegal_op,},
+		{spc_report_luns, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
+		{spc_maint_in, 12, maint_in_service_actions,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{mmc_rw},
+		{mmc_rw, 12,}, /* read12 */
 		{spc_illegal_op,},
-		{mmc_rw},
+		{mmc_rw, 12, }, /* write12 */
 		{spc_illegal_op,},
-		{mmc_get_performance,},
-		{mmc_read_dvd_structure,},
+		{mmc_get_performance, 12,},
+		{mmc_read_dvd_structure, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

@@ -2447,13 +2447,13 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_set_streaming,},
+		{mmc_set_streaming, 12,},
 		{spc_illegal_op,},

 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_set_cd_speed,},
+		{mmc_set_cd_speed, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/osd.c b/usr/osd.c
index 593cea8..ec3f117 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -80,10 +80,10 @@ static struct device_type_template osd_template = {
 	.lu_exit	= spc_lu_exit,
 	.ops		= {
 		/* 0x00 */
-		{spc_test_unit,},
+		{spc_test_unit, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_request_sense,},
+		{spc_request_sense, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -101,7 +101,7 @@ static struct device_type_template osd_template = {
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_inquiry,},
+		{spc_inquiry, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -136,15 +136,15 @@ static struct device_type_template osd_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{osd_varlen_cdb,},
+		{osd_varlen_cdb, 224,},

 		[0x80 ... 0x9f] = {spc_illegal_op},

 		/* 0xA0 */
-		{spc_report_luns,},
-		{spc_illegal_op,},
+		{spc_report_luns, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
+		{spc_maint_in, 12, maint_in_service_actions,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/sbc.c b/usr/sbc.c
index 09e3002..33f4b82 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -239,18 +239,18 @@ static struct device_type_template sbc_template = {
 	.lu_offline	= spc_lu_offline,
 	.lu_exit	= spc_lu_exit,
 	.ops		= {
-		{spc_test_unit,},
+		{spc_test_unit, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_request_sense,},
+		{spc_request_sense, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{sbc_rw,},
+		{sbc_rw, 6,}, /* read6 */
 		{spc_illegal_op,},
-		{sbc_rw,},
+		{sbc_rw, 6,}, /* write6 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -260,17 +260,17 @@ static struct device_type_template sbc_template = {
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_inquiry,},
+		{spc_inquiry, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_reserve,},
-		{sbc_release,},
+		{sbc_reserve, 6,}, /* reserve6 */
+		{sbc_release, 6,}, /* release6 */

 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_mode_sense,},
-		{spc_start_stop,},
+		{spc_mode_sense, 6,},
+		{spc_start_stop, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -282,13 +282,13 @@ static struct device_type_template sbc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_read_capacity,},
+		{sbc_read_capacity, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{sbc_rw},
+		{sbc_rw, 10,}, /* read10 */
 		{spc_illegal_op,},
-		{sbc_rw},
+		{sbc_rw, 10,}, /* write10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -301,7 +301,7 @@ static struct device_type_template sbc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_sync_cache,},
+		{sbc_sync_cache, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

@@ -328,7 +328,7 @@ static struct device_type_template sbc_template = {

 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_mode_sense,},
+		{spc_mode_sense, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -347,9 +347,9 @@ static struct device_type_template sbc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{sbc_rw,},
+		{sbc_rw, 16,}, /* read16 */
 		{spc_illegal_op,},
-		{sbc_rw,},
+		{sbc_rw, 16,}, /* write16 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -358,7 +358,7 @@ static struct device_type_template sbc_template = {

 		/* 0x90 */
 		{spc_illegal_op,},
-		{sbc_sync_cache,},
+		{sbc_sync_cache, 16,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -372,22 +372,22 @@ static struct device_type_template sbc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_service_action,},
+		{sbc_service_action, 16},
 		{spc_illegal_op,},

 		/* 0xA0 */
-		{spc_report_luns,},
-		{spc_illegal_op,},
+		{spc_report_luns, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
+		{spc_maint_in, 12, maint_in_service_actions,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{sbc_rw,},
+		{sbc_rw, 12,}, /* read12 */
 		{spc_illegal_op,},
-		{sbc_rw,},
+		{sbc_rw, 12,}, /* write12 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/scc.c b/usr/scc.c
index 7a6a66e..bec9bf3 100644
--- a/usr/scc.c
+++ b/usr/scc.c
@@ -60,10 +60,10 @@ static struct device_type_template scc_template = {
 	.lu_offline	= spc_lu_offline,
 	.lu_exit	= spc_lu_exit,
 	.ops		= {
-		{spc_test_unit,},
+		{spc_test_unit, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_request_sense,},
+		{spc_request_sense, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -81,7 +81,7 @@ static struct device_type_template scc_template = {
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_inquiry,},
+		{spc_inquiry, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -114,7 +114,7 @@ static struct device_type_template scc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_test_unit},
+		{spc_test_unit, 10,}, /* verify10 */

 		[0x30 ... 0x7f] = {spc_illegal_op,},

@@ -135,15 +135,15 @@ static struct device_type_template scc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_test_unit},
+		{spc_test_unit, 16,}, /* verify16 */

 		[0x90 ... 0x9f] = {spc_illegal_op,},

 		/* 0xA0 */
-		{spc_report_luns,},
-		{spc_illegal_op,},
+		{spc_report_luns, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
+		{spc_maint_in, 12, maint_in_service_actions,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -156,7 +156,7 @@ static struct device_type_template scc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_test_unit,},
+		{spc_test_unit, 12,}, /* verify12 */

 		[0xb0 ... 0xff] = {spc_illegal_op},
 	}
diff --git a/usr/smc.c b/usr/smc.c
index ef5f1b0..7125a3d 100644
--- a/usr/smc.c
+++ b/usr/smc.c
@@ -741,10 +741,10 @@ struct device_type_template smc_template = {
 	.lu_offline	= spc_lu_offline,
 	.lu_config	= smc_lu_config,
 	.ops	= {
-		{spc_test_unit,},
+		{spc_test_unit, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_request_sense,},
+		{spc_request_sense, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -762,7 +762,7 @@ struct device_type_template smc_template = {
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_inquiry,},
+		{spc_inquiry, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -771,7 +771,7 @@ struct device_type_template smc_template = {

 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_mode_sense,},
+		{spc_mode_sense, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -792,7 +792,7 @@ struct device_type_template smc_template = {

 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_mode_sense,},
+		{spc_mode_sense, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -802,12 +802,12 @@ struct device_type_template smc_template = {
 		[0x60 ... 0x9f] = {spc_illegal_op,},

 		/* 0xA0 */
-		{spc_report_luns,},
+		{spc_report_luns, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
+		{spc_maint_in, 12, maint_in_service_actions,},
 		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{smc_move_medium,},
+		{smc_move_medium, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

@@ -818,7 +818,7 @@ struct device_type_template smc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_test_unit,},
+		{spc_test_unit, 12,}, /* verify12 */

 		/* 0xB0 */
 		{spc_illegal_op,},
@@ -830,7 +830,7 @@ struct device_type_template smc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{smc_read_element_status,},	// Mandatory
+		{smc_read_element_status, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/spc.c b/usr/spc.c
index 35de2e1..a7a6570 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -440,6 +440,177 @@ sense:
 	return SAM_STAT_CHECK_CONDITION;
 }

+
+static int report_opcodes_all(struct scsi_cmd *cmd, int rctd,
+uint32_t alloc_len)
+{
+	uint8_t buf[2048], *data;
+	struct device_type_operations *ops;
+	struct service_action *service_action;
+	int i;
+	uint32_t len;
+
+	/* cant request RCTD for all descriptors */
+	if (rctd) {
+		scsi_set_in_resid_by_actual(cmd, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST,
+			ASC_INVALID_FIELD_IN_CDB);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
+	memset(buf, 0, sizeof(buf));
+	data = &buf[4];
+
+	ops = cmd->dev->dev_type_template.ops;
+	for (i = 0; i < 256; i++) {
+		if (ops[i].cdb_length == 0)
+			continue;
+
+		/* this command does not take a service action, so just
+		   report the opcode
+		*/
+		if (ops[i].service_actions == NULL) {
+			*data++ = i;
+
+			/* reserved */
+			data++;
+
+			/* service action */
+			data += 2;
+
+			/* reserved */
+			data++;
+
+			/* flags : no service action, no command descriptor */
+			data++;
+
+			/* cdb length */
+			*data++ = (ops[i].cdb_length>>8) & 0xff;
+			*data++ = ops[i].cdb_length & 0xff;
+
+			continue;
+		}
+
+		for (service_action = ops[i].service_actions;
+			service_action->cmd_perform;
+			service_action++) {
+			/* opcode */
+			*data++ = i;
+
+			/* reserved */
+			data++;
+
+			/* service action */
+			*data++ = (service_action->service_action>>8) & 0xff;
+			*data++ = service_action->service_action & 0xff;
+
+			/* reserved */
+			data++;
+
+			/* flags : service action */
+			*data++ = 0x01;
+
+			/* cdb length */
+			*data++ = (ops[i].cdb_length>>8) & 0xff;
+			*data++ = ops[i].cdb_length & 0xff;
+		}
+	}
+
+	len = data - &buf[0];
+	len -= 4;
+	buf[0] = (len>>24) & 0xff;
+	buf[1] = (len>>16) & 0xff;
+	buf[2] = (len>>8)  & 0xff;
+	buf[3] = len & 0xff;
+
+	memcpy(scsi_get_in_buffer(cmd), buf,
+	       min(scsi_get_in_length(cmd), len+4));
+
+	scsi_set_in_resid_by_actual(cmd, len+4);
+
+	return SAM_STAT_GOOD;
+}
+
+int spc_report_supported_opcodes(int host_no, struct scsi_cmd *cmd)
+{
+	uint8_t reporting_options;
+	uint8_t requested_opcode;
+	uint16_t requested_service_action;
+	uint32_t alloc_len;
+	int rctd;
+	int ret = SAM_STAT_GOOD;
+
+	reporting_options = cmd->scb[2] & 0x07;
+
+	requested_opcode = cmd->scb[3];
+
+	requested_service_action = cmd->scb[4];
+	requested_service_action <<= 8;
+	requested_service_action |= cmd->scb[5];
+
+	alloc_len = cmd->scb[6];
+	alloc_len <<= 8;
+	alloc_len |= cmd->scb[7];
+	alloc_len <<= 8;
+	alloc_len |= cmd->scb[8];
+	alloc_len <<= 8;
+	alloc_len |= cmd->scb[9];
+
+	rctd = cmd->scb[2] & 0x80;
+
+	switch (reporting_options) {
+	case 0x00: /* report all */
+		ret = report_opcodes_all(cmd, rctd, alloc_len);
+		break;
+	case 0x01: /* report one no service action*/
+	case 0x02: /* report one service action */
+	default:
+		scsi_set_in_resid_by_actual(cmd, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST,
+			ASC_INVALID_FIELD_IN_CDB);
+		ret = SAM_STAT_CHECK_CONDITION;
+	}
+
+	return ret;
+}
+
+struct service_action maint_in_service_actions[] = {
+	{0x0c, spc_report_supported_opcodes},
+	{0, NULL}
+};
+
+struct service_action *
+find_service_action(struct service_action *service_action, uint32_t action)
+{
+	while (service_action->cmd_perform) {
+		if (service_action->service_action == action)
+			return service_action;
+		service_action++;
+	}
+	return NULL;
+}
+
+/**
+ * This functions emulates the various commands using the 0xa3 cdb opcode
+ */
+int spc_maint_in(int host_no, struct scsi_cmd *cmd)
+{
+	uint8_t action;
+	struct service_action *service_action;
+
+	action = cmd->scb[1] & 0x1f;
+	service_action = find_service_action(maint_in_service_actions, action);
+
+	if (service_action == NULL) {
+		scsi_set_in_resid_by_actual(cmd, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST,
+				ASC_INVALID_FIELD_IN_CDB);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
+	return service_action->cmd_perform(host_no, cmd);
+}
+
 int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
 	scsi_set_in_resid_by_actual(cmd, 0);
diff --git a/usr/spc.h b/usr/spc.h
index a63436a..9147d4c 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -1,6 +1,9 @@
 #ifndef __SPC_H
 #define __SPC_H

+extern struct service_action maint_in_service_actions[];
+extern int spc_maint_in(int host_no, struct scsi_cmd *cmd);
+
 extern int spc_inquiry(int host_no, struct scsi_cmd *cmd);
 extern int spc_report_luns(int host_no, struct scsi_cmd *cmd);
 extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
@@ -9,6 +12,7 @@ extern int spc_request_sense(int host_no, struct
scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
 extern int spc_lu_init(struct scsi_lu *lu);

+
 typedef int (match_fn_t)(struct scsi_lu *lu, char *params);
 extern int lu_config(struct scsi_lu *lu, char *params, match_fn_t *);
 extern int spc_lu_config(struct scsi_lu *lu, char *params);
diff --git a/usr/tgtd.h b/usr/tgtd.h
index e516b0a..caff8d0 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -80,8 +80,15 @@ struct it_nexus_lu_info {
 	struct list_head pending_ua_sense_list;
 };

+struct service_action {
+	uint32_t service_action;
+	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
+};
+
 struct device_type_operations {
 	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
+	int cdb_length;
+	struct service_action *service_actions;
 };

 struct device_type_template {
-- 
1.5.5

------=_Part_10488_11687118.1210405801433
Content-Type: application/x-gzip;
 name=0001-Add-infrastructure-to-handle-cdb-lengths-service-ac.patch.gz
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fg1w2knk0
Content-Disposition: attachment;
 filename=0001-Add-infrastructure-to-handle-cdb-lengths-service-ac.patch.gz

H4sIAGZRJUgAA+0ca3PbNvKz+CswczMd23qYpERKsuNMfXbaei5NenF69yGT4fABSmwoUseHH03z
328XAN+ULDFO3bT1JCYJLBb7wu5iSfi7KFwR2Z3pjmbSqTqWp1NZG1tUdXTNnGkKNdWZNlEn89lY
tcmPYUCu6ZooUyLLJ+wfUWVZkb4DNCfkTRgEHiXX5tK3aLQgzyLWEIvnbxcr0/NHdrh6Ll2aCT0B
yGRAFJn8aN4jnhkgPlHnJ5pC+oosy9J1av1C7eSEvPvp/O3FD+/JueMQL3AjM06i1E7SiJIkJEsz
cHxKbMciPg0WyTIekJhGN55NiWknXhjExPfiJJakF3drACYOxU4juV9TI1zTyORAgMv04xCmsP3U
AdzLMlaCI82AmFEE9IYuWYdx7Fkwc30yN4xgrBcT4HUFo0bSfykJKHWIFQIeRIv0II76UDYH0lCb
2wtIGDk0Qhq91dqnKxok0hu6DqPkOl3jhTqv13bo0JicgEQDc8FgroKT6hxEvpNtSTpPF9jN5hmF
65gUIkUa1lF44wkR0Ls1aAGoL9GDLJq+LwkOC5oATPQJKROUcjwi5C1KBP5F9H+pFwEcsBJz0puM
CJ1cMH7MmNxSQAjXlbdYJsSiJI2pm/rEc49vlzSAfmI6jmSStRnHyTIK08WSWKb9gQJxhMSgUoBI
gHywHS7cNIpQABmQRYEXmCwNluZ6fS95bl0HQiaMcOzyQjvxDw6RJ8dzXcrQubiibpcmnySiZi4H
LsZ4tFX2tx4aGglSYDeh0coLTBRpu7mgpCVEchCEtyQM/HtQrjk+JKEwhITRYX5omijq7Hbp2Utm
l2j6koXkcvmjubXbFlB/lakarMwDhQcmyPYqIBUzqFOKRteyLpD4XKy1lR0vw9R3yArJ9xICivO4
/YOiCawjeGAEXAVSjbsBiopzh2DQDv/B6BK4Iy69BSaKdiDkXqCriI2vwq2yA+tHCq3Ug9/AJOMN
eFjR2zD6cCKBMiacxtdpAk9T94TcmJFnotMQRgX2BT0aPYZf4FJoFIOqUYARxXkBGhB7wXHIMJgI
PKf4y5Wka28RUGcYuu7Qut/L/w6HQwmWUHS8Wtkjm5DfYI1oE9LPf4b5D4cLYyeDU1SC/bw9tvLx
k2J8dWxs5zCKTni36ClmV2WSjRR966xPmSolyvb/KfAt+VwEKeWtySJxoJm1TgkDnhHX88EKbIgr
C+oMiKppoAHQBlP/Qf9wQKZjWNU+5Q3DQ0lCB0CGwwUYqnlcCNYq7iUvcOgdMU1X1el8NJo7jqqp
Y4h/sj6ZoEbKIyUgpTL622/JEOKzPoB42c9uoDFOwFHawoNUAltCYTGC9yCAoHg4Ix8l0hv5qQFm
43sB7Z0xgKJhIPrpnZdAJ8jNEE+sB/xVr4dYhr3eR+xMaJwYaQDdnwZSv9FIdGwnot3zfbowfYi6
m1szxBgoEE1MQfhl5NWO/Sdob+USVqeDKQqYXTvLt3d8BC4PNHR03Il1L8AYeV9mOmt6XHbHU2FQ
/KY7w59JTcY4zB6BYhPe2m+2djenCmoCCoIcBcLmijpeugJ3uwpvIFiDwjbNum3MBoJyU1CZKXCZ
T+YDZYYy5zdPKnNEC0mKY9jm2rS9JDe5Zgd4qr0tr5jjtoz3ViBDieIkirxRhA8juI0gsO+/1LqY
UO7V2j1dTtINjTz3XtCU28B4C43cMvQZdz7s+uR2Ed8HNmTSgfcrBSuwl7RsG83OTvbB+Z5pwgvx
myfnnBl+EtqNxYBtHfjM8C5oYthh4HqLlO9vyhM0O7fPtM2SJrI6UOYgUXHTVaK57WpbbLciNceL
MVZBqr/KOayKNYIN12YITHopB2pIv4FbCKi/HX8DqjzHVhlnZK1gWwDZhg/7tzKmcnOx+LGVN3Zw
Sp3MStAhsqSs1fbDuCTJihKsFPerrU6/hKzOE7RxlvotU7Tpoj5NFxexxchVdaAqaOT8prvbeCff
6TIZjUYEN1bvsXlbMD9nQijSVNwhQ44MG89yClcZ3G8Bhp3UvnxnaFa4qQQjZzhI9mSInaqR7YMf
Rdb7h3a1HNrVHRxHCwZSDu474EDvCbtntuoDmzYs3rlxjLy2UHe75YFCK/3NgzvoTQS6yQSy7DFa
LL958kAXU0xwgceVFywq4b3SsZ3jR6bHBlmvKWy8a+Tk7V3k39ra2LTzKodV3ItNuzYf29ScjUbU
HruKMm1u2jl0sWnnz6j0mcxyG37ZTeEwuG3D/tCGPHNPcsU9/Zm254qsYILML51l+ZVszpWxPlA0
4JZfu7P7CGsT0d6YkU8DWIZWxnmtlajqJHcIEFJnW0PqXziiNvwOr6Jaxb3wO/KcjmVZHY3GY3di
zdSm3+HQhd/hz3xXlZUZ9qgywPDtpULhfP7ipcJtKRGKEHKYjAb+lNePMJ3Qt2cz2xGwhGgLhr2z
aB0CExYd+LWzmXwFTjUXLt8AVpvwxSCtCF1AlVTHGvS8RFgaVwJiDXpe+dlbEM3N3Oa6aHmvppc7
PqtgusVYZirPX/m1u7E8miZbKpfNjs6VS774aiuxVrncZTFvwvCopUtU0JgnSOM9EqQvqB6sEVYr
h7XWziXDscoqpfzSlc9HWJ5tC/Exaxxj2CfOgU92+T30uSUCKeUYpnQKYkolim3DsbegNG4Q2uca
BAtj8x1W9Q7G/YiedzxVB6oKDPLr0y/tSl5ckUC1B6SwvXLwF8z/O6y9fUpqD6B4sKT2eVsZu7SV
sYutzNTUTV2no5FF7bnltnz3wKFLWxk728rovISi71FCgcF/b2R2cy0zljLM9sgYmrL9CrJ/VlJR
Jqx+xC7dmX0MH7r+jLfJ79i7ZF5bmW5+XcGLSJooImm7F5GekGe9yrNe5nn+9yuabbat6cy22eWP
o+cNDjKPRkLRalnRVqZod1PhsPepJfKUvriLS1/cUVdzFUsejaaKqpljpyXy1L64i/Mv7qYThYUe
cWVi3SLPhz60aw86/KU/dvPv8PhzHnj+rHFnqqtosPyyv2S/kpAznbLwyi97c/mFtqiPyd+ca3He
SYtfwRZ8hl/QqPgCj107GOpjfl3wBwtS7ZGUtbJPSW6owb+VzCetNXd+lz5TZjxtnXXzHk8e55iu
//nAJ4Gzscy4ZJcvymWuNFY6pfwUB9aRkxT13zs+xkNFjpmE0X2uyTbYL/d2Pl6XAvy6CPBjzaEq
VUYjEzaZ2lRuCfDrWoBfZwF+MpEHOunjRZlyEaMLOQGaIpqkUUCuz380rt+evzUufnhx8S/j4vWr
y6u3V69fnUrkE4itL/VFpuWxQxtsWYqDJIbp+wdCZbEde4a9csgR/BpwYDtxwGhSuB+rRsK+LYYE
gAaHUv8jyBg7ZtBupe47VZ7M3g/IESjAPIW+FkMoHWQ7gryhBFVdzuSo+oyASI53KuZkxAAZp8gc
2qltMtZYIkDeXLy9LB3xiu3IW4NRxPy1iOeSA+TrkCAHPcY1frwBTiWisecY1j1Om5r+AZODfHjK
4FDoBjJnsNM0vPPq5csX35+/NN68+PfPL67fsgXWO7++MK5e/ef85dWl8d3Vi5eX8GRcXP6TI3pQ
aX1IHZGtFV0BXQcgWyBiQGLvVxq6+HjIECEpsIi+QdlP3nNJ4EmtMwKUDZ+D3Nmv6hIcCbGjdA48
gJVPiUeeEVXT4abfF0JBGQHkO+/9yHYsQxwEOgPwQ8Yh5H+JF6SUz4oKKB+aIk5IYxKE4mCXWTue
BKyE5Jc0TnAoIcIi2VEzbpXYzt9gleioOXwk5tXPL18KgnvM7GD1nDEjYU3FCzFHvBDrcaASQO0M
WAmM9M+Iug8q1zcXeLAxCBv8QlMumtwcNyIqnecTIAVzTa08fz47JN+wnchpDbipwRyursWesDlu
GLXVmGOq6YDPV20cPgfry75WawPIbQxZ5fpusvkIOizJrE5h9XmLALcPrElzHxt5iGT5TlZ+Z4tg
FiCsAPoAmK2CIXcwMjoY1j48IxO8561IALQ+f65OynNip1J0Knq9Uy06gdha5xg7ca6ygMEb2uv7
A+auF9xd82930REfDjAEofcl/GflBRVQzq0AhYf+hDlRDEAP+X8OzYHrvvv7168voYdJDQNUKe+N
s2OpWag9QIBlCHlXEA5IW8ytBVWOyAsWgCFfb0Uni3U5+qxP0SudzTjajOVZdMWgmN/TBHRQ55NJ
oEZUFm9i20KtosrkaQZbpbEMOn5fh2k4nRyWRbfNkM+enZHZVojfSsg0MXHOfnkmnc1UdOWoi6Yy
rul+4LP9wOeZiEAvLVKeycKAb73EXkJOU9cM97O2GVP2xeUJfznDYi0mRtyTcEW3JIXM9ln+V8r6
mJ+wIKf+cFpCrZRRhwFthkA2Vwau1sHbvKFDXTP1k5OnStHK1r8xQxPuAC6ZE2hPZzftWt+xnTYg
+oiHzwdb3QfbvH2EPBCzHpjr0+nm+Y6kvgsbj9p0Bzvl2gNSeAjWILzS7dLzaTOWlqJ9KXd8IHBC
7pbj7uUZcdNXNVIHIfpsBIoik/zxEXBNjvjfcHDTQKSJdJVi3huz9JKdVU/zPDUmaQzrhXXhXyVg
cTZLQZkZZj49U+DePrzgZdeNDrqDhgdU+JJXWIhsOMo2XW8slGSS51M1lVVLrL/A2nus/VGr2VQs
8iBXFWpGWAopAnWpbryLZlnBYieBtBYGlqWt/TI7a6+PJ2PdHI3mymTqTOz2wsCyVhhY8tcpWBZQ
2Fc3EvmH5wJClxjG9U8Xxg/QAE8eONe8QerTu4SiwPb0Uaf5yA7LAc2M1IaLIvZOo+tjS1XFTuOL
zw53Go5ynjM5i+Jxg5z9bKhJUFFR6jTcT0GcXlKp4fgpOfJTBEbh4/4fLQNHgFuAXMFwAyM5bBky
wL8oARvTtRmZq7g2W/7a58GBWKbNpiFH7UTviKptLYk/iGGVHrL3aJqiWzKsJtt03ZnTUmYT4MVy
Eg3iGMyMn4LRSoVMD9RB79KYS9oNuRPgffg3b4wlNR2ypoGDqVdqclMwsAvrb0wJ7SsuixMs1rYX
vA6OyvF1t+XGEoO2Mmyp+oY8dMXPBhY7yJ1jW5yJY2uJ+CMoi0jKSBtpkvR/yWF7vPxLAAA=
------=_Part_10488_11687118.1210405801433--


From ronniesahlberg at gmail.com  Sun May 11 09:00:29 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sun, 11 May 2008 17:00:29 +1000
Subject: [Stgt-devel] [PATCH service_actions 1/1] RESEND Add infrastructure
	to handle cdb lengths and service_actions
Message-ID: <c9a3e4540805110000x137823bet10037ca0a1a123e3@mail.gmail.com>

Resend the patch.
MMC and OSD does not implement MaintenanceIn  so dont define them for
those two emulation targets.

List

This patch is also attached in gzip format, if gmail once again
decides to mangle it.

It adds infrastructure to handle commands that take service actions.
It also adds the cdb length to all commands we have implemented and
list in the .ops structure.
(at least when I try the ioctl() to do scsi passthrough,   the devices
I have gets really "unhappy" if i dont provide the correct/expected
cdb length   so this sould also benefit when passthrough is added)

As an example of a "service action" command being implemented
I implemented 0xa3/0x0c which is ReportSupportedOperationCodes
other MaintenanceIn commands should be easy to add.

please review/apply/discuss

ronnie sahlberg



From ronniesahlberg at gmail.com  Sun May 11 08:25:57 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Sun, 11 May 2008 16:25:57 +1000
Subject: [PATCH] Add infrastructure for MaintenanceIn and other
Message-ID: <mailman.34.1331738481.12506.stgt-devel@lists.berlios.de>

commands taking service actions.

Expand device_type_operations to also include the cdb length and an
array of possible service actions for this command.
We need both the list of service actions and also the cdb length in
order to implement
ReportSupportedOpcodes : ManagementIn:service action 0x0c

Augment the .ops structure and provide the expected cdb length for all
command implemented for all device types.  This is required to support
ReportSupportedOperationCodes as well as might be useful if/when we add
a passthrough backend   since at least the current backend becomes unhappy
if the cdb length provided to the ioctl() is different from what the
real device expects.

Augment the .ops structure with a null terminated list of service action for
the (now only 0xa3) opcodes that take service actions and which needs to
be reported in ReportSupportedOpcodes.

Implement MaintenanceIn and implement service action 0x0c for this command.
the provided infrastructure should make it easier to add other MaintIn
service actions, of which there are quite a few.

there are many other opcodes that also take service actions and which
could build on this framework:
0xa4 MaintOut
0x7f: variable length cdb
0x5e/0x5f persistent reservarion in/out
0xab
0x9e
0x9f

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 usr/mmc.c  |   52 +++++++++---------
 usr/osd.c  |   10 ++--
 usr/sbc.c  |   44 ++++++++--------
 usr/scc.c  |   16 +++---
 usr/smc.c  |   20 ++++----
 usr/spc.c  |  171 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 usr/spc.h  |    4 ++
 usr/tgtd.h |    7 +++
 8 files changed, 253 insertions(+), 71 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index f988f5a..25268bc 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -2306,10 +2306,10 @@ static struct device_type_template mmc_template = {
 	.lu_offline	= mmc_lu_offline,
 	.lu_exit	= spc_lu_exit,
 	.ops		= {
-		{spc_test_unit,},
+		{spc_test_unit, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_request_sense,},
+		{spc_request_sense, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -2327,7 +2327,7 @@ static struct device_type_template mmc_template = {
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_inquiry,},
+		{spc_inquiry, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -2337,10 +2337,10 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_start_stop,},
+		{spc_start_stop, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_start_stop,}, /* allow medium removal */
+		{spc_start_stop, 6,}, /* allow medium removal */
 		{spc_illegal_op,},

 		/* 0x20 */
@@ -2349,18 +2349,18 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_read_capacity,},
+		{mmc_read_capacity, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{mmc_rw},
+		{mmc_rw, 10,}, /* read10*/
 		{spc_illegal_op,},
-		{mmc_rw},
+		{mmc_rw, 10,}, /* write10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_test_unit},
+		{spc_test_unit, 10,}, /* verify10 */

 		/* 0x30 */
 		{spc_illegal_op,},
@@ -2368,7 +2368,7 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_synchronize_cache,},
+		{mmc_synchronize_cache, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

@@ -2385,10 +2385,10 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_read_toc,},
+		{mmc_read_toc, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_get_configuration,},
+		{mmc_get_configuration, 10,},
 		{spc_illegal_op,},

 		{spc_illegal_op,},
@@ -2402,19 +2402,19 @@ static struct device_type_template mmc_template = {

 		/* 0x50 */
 		{spc_illegal_op,},
-		{mmc_read_disc_information,},
-		{mmc_read_track_information,},
-		{mmc_reserve_track,},
+		{mmc_read_disc_information, 10,},
+		{mmc_read_track_information, 10,},
+		{mmc_reserve_track, 10,},
 		{spc_illegal_op,},
-		{mmc_mode_select,},
+		{mmc_mode_select, 10,}, /* modeselect10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},

 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_mode_sense,},
-		{mmc_close_track,},
-		{mmc_read_buffer_capacity,},
+		{mmc_mode_sense, 10,}, /* modesense10 */
+		{mmc_close_track, 10,},
+		{mmc_read_buffer_capacity, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -2422,7 +2422,7 @@ static struct device_type_template mmc_template = {
 		[0x60 ... 0x9f] = {spc_illegal_op,},

 		/* 0xA0 */
-		{spc_report_luns,},
+		{spc_report_luns, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -2431,12 +2431,12 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{mmc_rw},
+		{mmc_rw, 12,}, /* read12 */
 		{spc_illegal_op,},
-		{mmc_rw},
+		{mmc_rw, 12, }, /* write12 */
 		{spc_illegal_op,},
-		{mmc_get_performance,},
-		{mmc_read_dvd_structure,},
+		{mmc_get_performance, 12,},
+		{mmc_read_dvd_structure, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

@@ -2447,13 +2447,13 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_set_streaming,},
+		{mmc_set_streaming, 12,},
 		{spc_illegal_op,},

 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{mmc_set_cd_speed,},
+		{mmc_set_cd_speed, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/osd.c b/usr/osd.c
index 593cea8..e56b8ea 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -80,10 +80,10 @@ static struct device_type_template osd_template = {
 	.lu_exit	= spc_lu_exit,
 	.ops		= {
 		/* 0x00 */
-		{spc_test_unit,},
+		{spc_test_unit, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_request_sense,},
+		{spc_request_sense, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -101,7 +101,7 @@ static struct device_type_template osd_template = {
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_inquiry,},
+		{spc_inquiry, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -136,12 +136,12 @@ static struct device_type_template osd_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{osd_varlen_cdb,},
+		{osd_varlen_cdb, 224,},

 		[0x80 ... 0x9f] = {spc_illegal_op},

 		/* 0xA0 */
-		{spc_report_luns,},
+		{spc_report_luns, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/sbc.c b/usr/sbc.c
index 09e3002..33f4b82 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -239,18 +239,18 @@ static struct device_type_template sbc_template = {
 	.lu_offline	= spc_lu_offline,
 	.lu_exit	= spc_lu_exit,
 	.ops		= {
-		{spc_test_unit,},
+		{spc_test_unit, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_request_sense,},
+		{spc_request_sense, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{sbc_rw,},
+		{sbc_rw, 6,}, /* read6 */
 		{spc_illegal_op,},
-		{sbc_rw,},
+		{sbc_rw, 6,}, /* write6 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -260,17 +260,17 @@ static struct device_type_template sbc_template = {
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_inquiry,},
+		{spc_inquiry, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_reserve,},
-		{sbc_release,},
+		{sbc_reserve, 6,}, /* reserve6 */
+		{sbc_release, 6,}, /* release6 */

 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_mode_sense,},
-		{spc_start_stop,},
+		{spc_mode_sense, 6,},
+		{spc_start_stop, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -282,13 +282,13 @@ static struct device_type_template sbc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_read_capacity,},
+		{sbc_read_capacity, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{sbc_rw},
+		{sbc_rw, 10,}, /* read10 */
 		{spc_illegal_op,},
-		{sbc_rw},
+		{sbc_rw, 10,}, /* write10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -301,7 +301,7 @@ static struct device_type_template sbc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_sync_cache,},
+		{sbc_sync_cache, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

@@ -328,7 +328,7 @@ static struct device_type_template sbc_template = {

 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_mode_sense,},
+		{spc_mode_sense, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -347,9 +347,9 @@ static struct device_type_template sbc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{sbc_rw,},
+		{sbc_rw, 16,}, /* read16 */
 		{spc_illegal_op,},
-		{sbc_rw,},
+		{sbc_rw, 16,}, /* write16 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -358,7 +358,7 @@ static struct device_type_template sbc_template = {

 		/* 0x90 */
 		{spc_illegal_op,},
-		{sbc_sync_cache,},
+		{sbc_sync_cache, 16,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -372,22 +372,22 @@ static struct device_type_template sbc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_service_action,},
+		{sbc_service_action, 16},
 		{spc_illegal_op,},

 		/* 0xA0 */
-		{spc_report_luns,},
-		{spc_illegal_op,},
+		{spc_report_luns, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
+		{spc_maint_in, 12, maint_in_service_actions,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{sbc_rw,},
+		{sbc_rw, 12,}, /* read12 */
 		{spc_illegal_op,},
-		{sbc_rw,},
+		{sbc_rw, 12,}, /* write12 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/scc.c b/usr/scc.c
index 7a6a66e..bec9bf3 100644
--- a/usr/scc.c
+++ b/usr/scc.c
@@ -60,10 +60,10 @@ static struct device_type_template scc_template = {
 	.lu_offline	= spc_lu_offline,
 	.lu_exit	= spc_lu_exit,
 	.ops		= {
-		{spc_test_unit,},
+		{spc_test_unit, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_request_sense,},
+		{spc_request_sense, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -81,7 +81,7 @@ static struct device_type_template scc_template = {
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_inquiry,},
+		{spc_inquiry, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -114,7 +114,7 @@ static struct device_type_template scc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_test_unit},
+		{spc_test_unit, 10,}, /* verify10 */

 		[0x30 ... 0x7f] = {spc_illegal_op,},

@@ -135,15 +135,15 @@ static struct device_type_template scc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_test_unit},
+		{spc_test_unit, 16,}, /* verify16 */

 		[0x90 ... 0x9f] = {spc_illegal_op,},

 		/* 0xA0 */
-		{spc_report_luns,},
-		{spc_illegal_op,},
+		{spc_report_luns, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
+		{spc_maint_in, 12, maint_in_service_actions,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -156,7 +156,7 @@ static struct device_type_template scc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_test_unit,},
+		{spc_test_unit, 12,}, /* verify12 */

 		[0xb0 ... 0xff] = {spc_illegal_op},
 	}
diff --git a/usr/smc.c b/usr/smc.c
index ef5f1b0..7125a3d 100644
--- a/usr/smc.c
+++ b/usr/smc.c
@@ -741,10 +741,10 @@ struct device_type_template smc_template = {
 	.lu_offline	= spc_lu_offline,
 	.lu_config	= smc_lu_config,
 	.ops	= {
-		{spc_test_unit,},
+		{spc_test_unit, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_request_sense,},
+		{spc_request_sense, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -762,7 +762,7 @@ struct device_type_template smc_template = {
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_inquiry,},
+		{spc_inquiry, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -771,7 +771,7 @@ struct device_type_template smc_template = {

 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_mode_sense,},
+		{spc_mode_sense, 6,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -792,7 +792,7 @@ struct device_type_template smc_template = {

 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_mode_sense,},
+		{spc_mode_sense, 10,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -802,12 +802,12 @@ struct device_type_template smc_template = {
 		[0x60 ... 0x9f] = {spc_illegal_op,},

 		/* 0xA0 */
-		{spc_report_luns,},
+		{spc_report_luns, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
+		{spc_maint_in, 12, maint_in_service_actions,},
 		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{smc_move_medium,},
+		{smc_move_medium, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},

@@ -818,7 +818,7 @@ struct device_type_template smc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_test_unit,},
+		{spc_test_unit, 12,}, /* verify12 */

 		/* 0xB0 */
 		{spc_illegal_op,},
@@ -830,7 +830,7 @@ struct device_type_template smc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},

-		{smc_read_element_status,},	// Mandatory
+		{smc_read_element_status, 12,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/spc.c b/usr/spc.c
index e3e4d98..ea99a9b 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -431,6 +431,177 @@ sense:
 	return SAM_STAT_CHECK_CONDITION;
 }

+
+static int report_opcodes_all(struct scsi_cmd *cmd, int rctd,
+uint32_t alloc_len)
+{
+	uint8_t buf[2048], *data;
+	struct device_type_operations *ops;
+	struct service_action *service_action;
+	int i;
+	uint32_t len;
+
+	/* cant request RCTD for all descriptors */
+	if (rctd) {
+		scsi_set_in_resid_by_actual(cmd, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST,
+			ASC_INVALID_FIELD_IN_CDB);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
+	memset(buf, 0, sizeof(buf));
+	data = &buf[4];
+
+	ops = cmd->dev->dev_type_template.ops;
+	for (i = 0; i < 256; i++) {
+		if (ops[i].cdb_length == 0)
+			continue;
+
+		/* this command does not take a service action, so just
+		   report the opcode
+		*/
+		if (ops[i].service_actions == NULL) {
+			*data++ = i;
+
+			/* reserved */
+			data++;
+
+			/* service action */
+			data += 2;
+
+			/* reserved */
+			data++;
+
+			/* flags : no service action, no command descriptor */
+			data++;
+
+			/* cdb length */
+			*data++ = (ops[i].cdb_length>>8) & 0xff;
+			*data++ = ops[i].cdb_length & 0xff;
+
+			continue;
+		}
+
+		for (service_action = ops[i].service_actions;
+			service_action->cmd_perform;
+			service_action++) {
+			/* opcode */
+			*data++ = i;
+
+			/* reserved */
+			data++;
+
+			/* service action */
+			*data++ = (service_action->service_action>>8) & 0xff;
+			*data++ = service_action->service_action & 0xff;
+
+			/* reserved */
+			data++;
+
+			/* flags : service action */
+			*data++ = 0x01;
+
+			/* cdb length */
+			*data++ = (ops[i].cdb_length>>8) & 0xff;
+			*data++ = ops[i].cdb_length & 0xff;
+		}
+	}
+
+	len = data - &buf[0];
+	len -= 4;
+	buf[0] = (len>>24) & 0xff;
+	buf[1] = (len>>16) & 0xff;
+	buf[2] = (len>>8)  & 0xff;
+	buf[3] = len & 0xff;
+
+	memcpy(scsi_get_in_buffer(cmd), buf,
+	       min(scsi_get_in_length(cmd), len+4));
+
+	scsi_set_in_resid_by_actual(cmd, len+4);
+
+	return SAM_STAT_GOOD;
+}
+
+int spc_report_supported_opcodes(int host_no, struct scsi_cmd *cmd)
+{
+	uint8_t reporting_options;
+	uint8_t requested_opcode;
+	uint16_t requested_service_action;
+	uint32_t alloc_len;
+	int rctd;
+	int ret = SAM_STAT_GOOD;
+
+	reporting_options = cmd->scb[2] & 0x07;
+
+	requested_opcode = cmd->scb[3];
+
+	requested_service_action = cmd->scb[4];
+	requested_service_action <<= 8;
+	requested_service_action |= cmd->scb[5];
+
+	alloc_len = cmd->scb[6];
+	alloc_len <<= 8;
+	alloc_len |= cmd->scb[7];
+	alloc_len <<= 8;
+	alloc_len |= cmd->scb[8];
+	alloc_len <<= 8;
+	alloc_len |= cmd->scb[9];
+
+	rctd = cmd->scb[2] & 0x80;
+
+	switch (reporting_options) {
+	case 0x00: /* report all */
+		ret = report_opcodes_all(cmd, rctd, alloc_len);
+		break;
+	case 0x01: /* report one no service action*/
+	case 0x02: /* report one service action */
+	default:
+		scsi_set_in_resid_by_actual(cmd, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST,
+			ASC_INVALID_FIELD_IN_CDB);
+		ret = SAM_STAT_CHECK_CONDITION;
+	}
+
+	return ret;
+}
+
+struct service_action maint_in_service_actions[] = {
+	{0x0c, spc_report_supported_opcodes},
+	{0, NULL}
+};
+
+struct service_action *
+find_service_action(struct service_action *service_action, uint32_t action)
+{
+	while (service_action->cmd_perform) {
+		if (service_action->service_action == action)
+			return service_action;
+		service_action++;
+	}
+	return NULL;
+}
+
+/**
+ * This functions emulates the various commands using the 0xa3 cdb opcode
+ */
+int spc_maint_in(int host_no, struct scsi_cmd *cmd)
+{
+	uint8_t action;
+	struct service_action *service_action;
+
+	action = cmd->scb[1] & 0x1f;
+	service_action = find_service_action(maint_in_service_actions, action);
+
+	if (service_action == NULL) {
+		scsi_set_in_resid_by_actual(cmd, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST,
+				ASC_INVALID_FIELD_IN_CDB);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
+	return service_action->cmd_perform(host_no, cmd);
+}
+
 int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
 	scsi_set_in_resid_by_actual(cmd, 0);
diff --git a/usr/spc.h b/usr/spc.h
index a63436a..9147d4c 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -1,6 +1,9 @@
 #ifndef __SPC_H
 #define __SPC_H

+extern struct service_action maint_in_service_actions[];
+extern int spc_maint_in(int host_no, struct scsi_cmd *cmd);
+
 extern int spc_inquiry(int host_no, struct scsi_cmd *cmd);
 extern int spc_report_luns(int host_no, struct scsi_cmd *cmd);
 extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
@@ -9,6 +12,7 @@ extern int spc_request_sense(int host_no, struct
scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
 extern int spc_lu_init(struct scsi_lu *lu);

+
 typedef int (match_fn_t)(struct scsi_lu *lu, char *params);
 extern int lu_config(struct scsi_lu *lu, char *params, match_fn_t *);
 extern int spc_lu_config(struct scsi_lu *lu, char *params);
diff --git a/usr/tgtd.h b/usr/tgtd.h
index e516b0a..caff8d0 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -80,8 +80,15 @@ struct it_nexus_lu_info {
 	struct list_head pending_ua_sense_list;
 };

+struct service_action {
+	uint32_t service_action;
+	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
+};
+
 struct device_type_operations {
 	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
+	int cdb_length;
+	struct service_action *service_actions;
 };

 struct device_type_template {
-- 
1.5.5


From ronniesahlberg at gmail.com  Sun May 11 09:01:51 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sun, 11 May 2008 17:01:51 +1000
Subject: [Stgt-devel] [PATCH service_actions 1/1] RESEND Add
	infrastructure to handle cdb lengths and service_actions
In-Reply-To: <c9a3e4540805110000x137823bet10037ca0a1a123e3@mail.gmail.com>
References: <c9a3e4540805110000x137823bet10037ca0a1a123e3@mail.gmail.com>
Message-ID: <c9a3e4540805110001t5c994ae6rb1001fd667d3302c@mail.gmail.com>

Attached a gzipped verision of the patch   if gmail decides to mangle it.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0001-Add-infrastructure-for-MaintenanceIn-and-other-comma.patch.gz
Type: application/x-gzip
Size: 3837 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080511/4414400c/attachment.bin>

From erezz at voltaire.com  Sun May 11 13:00:16 2008
From: erezz at voltaire.com (Erez Zilber)
Date: Sun, 11 May 2008 14:00:16 +0300
Subject: [Stgt-devel] Moving responsibility for iSER & iSCSI related issues
Message-ID: <4826D1C0.4040301@voltaire.com>

Hi,


After ~4 years of working on iSER & iSCSI, I'm moving on and will be
involved from a different perspective. Therefore, I will be unable to
continue my current maintainership responsibility for iSER related
issues. I want to thank everyone for the great work that I had the
chance to be part of.


Eli Dorfman (elid at voltaire.com) will be taking over my maintainership of
iSER code for kernel.org. Eli has already started doing that work.


Doron Shoham (dorons at voltaire.com) will be responsible for iSER and
iSCSI related issues in OFED (i.e. open-iscsi, iSER & stgt). All
relevant git trees will move from my trees to his.


These changes will be effective as of 19/5/08. After that, if you need
anything, I will be available on erezzi.list at gmail.com


Erez




From ronniesahlberg at gmail.com  Mon May 12 01:55:31 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Mon, 12 May 2008 09:55:31 +1000
Subject: [Stgt-devel] Proposed update to STGT web page
Message-ID: <c9a3e4540805111655r3a7e25b7x9527fede6e77a40f@mail.gmail.com>

Hi,

I propose some updates to the main STGT web page, diff based on "page
source" below in text as well as a gzip attachment


--- stgt.berlios.de.htm.orig	2008-05-12 09:34:47.000000000 +1000
+++ stgt.berlios.de.htm	2008-05-12 09:47:26.000000000 +1000
@@ -67,6 +67,12 @@

 <li>
 <p>
+FCOE software target driver for standard NICs
+</p>
+</li>
+
+<li>
+<p>
 Virtual SCSI target driver for <a
href="http://www.ibm.com/systems/p/">IBM pSeries</a>
 </p>
 </li>
@@ -100,6 +106,47 @@

 <div>
 <p>
+<strong>Device Emulation</strong>
+</p>
+
+<ul>
+
+<li>
+<p>
+SBC : Block Device : Virtual SCSI Harddisk using a file to store the content
+of the virtual drive. Fully functional.
+</p>
+</li>
+
+<li>
+<p>
+SMC : Media Changer : A virtual media jukebox that can be controlled
by the "mtx" tool. Partially functional.
+</p>
+</li>
+
+<li>
+<p>
+MMC : CD/DVD : Implements DVD-ROM and burnable DVD+R. Can be combined
with SMC to provide a fully operational DVD jukebox. Fully functional.
+</p>
+</li>
+
+<li>
+<p>
+SCC : Controller : Work in progress.
+</p>
+</li>
+
+<li>
+<p>
+OSD :  Object Based Storage : Work in progress.
+</p>
+</li>
+
+</ul>
+</div>
+
+<div>
+<p>
 <strong>Document</strong>
 </p>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: stgt.gz
Type: application/x-gzip
Size: 551 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080512/422cce0b/attachment.bin>

From erezz at Voltaire.COM  Mon May 12 13:59:45 2008
From: erezz at Voltaire.COM (Erez Zilber)
Date: Mon, 12 May 2008 14:59:45 +0300
Subject: [Stgt-devel] Calling iser_rx_progress
In-Reply-To: <20080507234049.GA7407@osc.edu>
References: <48206268.1010001@voltaire.com> <20080507234049.GA7407@osc.edu>
Message-ID: <48283131.6000709@Voltaire.COM>

Pete Wyckoff wrote:
> erezz at voltaire.com wrote on Tue, 06 May 2008 16:51 +0300:
>   
>> I'm going over some of the iSER code and I have a question: I saw that
>> iser_rx_progress is called from iser_cqe_handler and from the event loop
>> (added by tgt_counter_event_add). I understand the purpose of calling it
>> from iser_cqe_handler - it is called to handle new completions. Can you
>> explain the usage in tgt_counter_event_add?
>>     
>
> Unlike with transmit, rx progress can only occur when events
> happen on the network:  a new request coming in, or completing
> RDMA reads.  So why would we ever bother calling the rx progress
> function from a generic event handler?
>
> Initially we used to pull as many events off the completion queue as
> possible, but it turns out that was starving the transmits.  The
> machine was so busy handling new incoming requests, and queueing
> them up, that transmits were not promptly going out.  So now there's
> a limit of 8 rx CQ events, somewhat arbitrarily, to make sure the
> tx engine gets a chance to run every so often.
>
> But if you don't read all the completion queue events, there's no
> way to have the device signal again that there are still some left.
> Unlike with sockets and poll, where this is a very natural to do
> things.  Thus we increase the "counter event" for the rx side if
> there are more than 8 completion queue events, and later, after the
> transmit side has run, the main event loop will see num_rx_ready and
> go deal with another batch of 8.
>
> Event notification is very weak aspect of unix/posix, even
> considering some of the interesting linux-specific innovations.
> Tossing yet another event mechanism into the mix (IB verbs CQEs)
> doesn't make writing event-driven applications any easier.
>
> 		-- Pete
>   

Thanks. That was very helpful. BTW - maybe it's worth adding a short
explanation to the code itself.

Erez


From fujita.tomonori at lab.ntt.co.jp  Tue May 13 13:25:19 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 13 May 2008 20:25:19 +0900
Subject: [Stgt-devel] Proposed update to STGT web page
In-Reply-To: <c9a3e4540805111655r3a7e25b7x9527fede6e77a40f@mail.gmail.com>
References: <c9a3e4540805111655r3a7e25b7x9527fede6e77a40f@mail.gmail.com>
Message-ID: <20080513202515Y.tomof@acm.org>

On Mon, 12 May 2008 09:55:31 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> Hi,
> 
> I propose some updates to the main STGT web page, diff based on "page
> source" below in text as well as a gzip attachment

Thanks a lot!


> 
> --- stgt.berlios.de.htm.orig	2008-05-12 09:34:47.000000000 +1000
> +++ stgt.berlios.de.htm	2008-05-12 09:47:26.000000000 +1000
> @@ -67,6 +67,12 @@
> 
>  <li>
>  <p>
> +FCOE software target driver for standard NICs

I put 'in progress' here.


> +</p>
> +</li>
> +
> +<li>
> +<p>
>  Virtual SCSI target driver for <a
> href="http://www.ibm.com/systems/p/">IBM pSeries</a>
>  </p>
>  </li>
> @@ -100,6 +106,47 @@
> 
>  <div>
>  <p>
> +<strong>Device Emulation</strong>
> +</p>
> +
> +<ul>
> +
> +<li>
> +<p>
> +SBC : Block Device : Virtual SCSI Harddisk using a file to store the content
> +of the virtual drive. Fully functional.
> +</p>
> +</li>
> +
> +<li>
> +<p>
> +SMC : Media Changer : A virtual media jukebox that can be controlled
> by the "mtx" tool. Partially functional.
> +</p>
> +</li>
> +
> +<li>
> +<p>
> +MMC : CD/DVD : Implements DVD-ROM and burnable DVD+R. Can be combined
> with SMC to provide a fully operational DVD jukebox. Fully functional.
> +</p>
> +</li>
> +
> +<li>
> +<p>
> +SCC : Controller : Work in progress.
> +</p>
> +</li>

We use it just as lun 0. Do we need to improve this? If not, I think
that we can just drop it here.


> +<li>
> +<p>
> +OSD :  Object Based Storage : Work in progress.
> +</p>
> +</li>

It would be better to mention SSC if we add OSD here.

I try to explain all the device emulation in a similar way and use
more t10 words.

Here are an updated patch. Comments?


Index: index.html
===================================================================
--- index.html	(revision 209)
+++ index.html	(working copy)
@@ -73,6 +73,12 @@
 
 <li>
 <p>
+FCoE software target driver for Ethernet NICs (in progress)
+</p>
+</li>
+
+<li>
+<p>
 <a href="http://www.qlogic.com/products/fc_san_hostadapers.asp">Qlogic qla2xxx</a> FC target driver (in progress)
 </p>
 </li>
@@ -100,6 +106,46 @@
 
 <div>
 <p>
+<strong>Device Emulation</strong>
+</p>
+
+<ul>
+
+<li>
+<p>
+SBC: a virtual disk drive that can use a file to store the content.
+</p>
+</li>
+
+<li>
+<p>
+SMC: a virtual media jukebox that can be controlled by the "mtx" tool (partially functional).
+</p>
+</li>
+
+<li>
+<p>
+MMC: a virtual DVD drive that can read DVD-ROM iso files and create burnable DVD+R. It can be combined with SMC to provide a fully operational DVD jukebox.
+</p>
+</li>
+
+<li>
+<p>
+SSC: a virtual tape device (aka VTL) that can use a file to store the content (in progress).
+</p>
+</li>
+
+<li>
+<p>
+OSD: a virtual object-based storage device that can use a file to store the content (in progress).
+</p>
+</li>
+
+</ul>
+</div>
+
+<div>
+<p>
 <strong>Document</strong>
 </p>
 


From fujita.tomonori at lab.ntt.co.jp  Tue May 13 14:36:56 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 13 May 2008 21:36:56 +0900
Subject: [Stgt-devel] [PATCH service_actions 1/1] RESEND Add
 infrastructure	to handle cdb lengths and service_actions
In-Reply-To: <c9a3e4540805110000x137823bet10037ca0a1a123e3@mail.gmail.com>
References: <c9a3e4540805110000x137823bet10037ca0a1a123e3@mail.gmail.com>
Message-ID: <20080513213657S.tomof@acm.org>

On Sun, 11 May 2008 17:00:29 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> Resend the patch.
> MMC and OSD does not implement MaintenanceIn  so dont define them for
> those two emulation targets.

Thanks,


> List
> 
> This patch is also attached in gzip format, if gmail once again
> decides to mangle it.

Can you attach a patch in plain text format next time?


> It adds infrastructure to handle commands that take service actions.
> It also adds the cdb length to all commands we have implemented and
> list in the .ops structure.

CDB_SIZE macro doesn't work?


> (at least when I try the ioctl() to do scsi passthrough,   the devices
> I have gets really "unhappy" if i dont provide the correct/expected
> cdb length   so this sould also benefit when passthrough is added)
> 
> As an example of a "service action" command being implemented
> I implemented 0xa3/0x0c which is ReportSupportedOperationCodes
> other MaintenanceIn commands should be easy to add.
> 
> please review/apply/discuss
> 
> ronnie sahlberg
> 
> 
> >From a9b06135ac3805daa136bc39355b8a49759de6d8 Mon Sep 17 00:00:00 2001
> From: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> Date: Sun, 11 May 2008 16:25:57 +1000
> Subject: [PATCH] Add infrastructure for MaintenanceIn and other
> commands taking service actions.
> 
> Expand device_type_operations to also include the cdb length and an
> array of possible service actions for this command.
> We need both the list of service actions and also the cdb length in
> order to implement
> ReportSupportedOpcodes : ManagementIn:service action 0x0c
> 
> Augment the .ops structure and provide the expected cdb length for all
> command implemented for all device types.  This is required to support
> ReportSupportedOperationCodes as well as might be useful if/when we add
> a passthrough backend   since at least the current backend becomes unhappy
> if the cdb length provided to the ioctl() is different from what the
> real device expects.
> 
> Augment the .ops structure with a null terminated list of service action for
> the (now only 0xa3) opcodes that take service actions and which needs to
> be reported in ReportSupportedOpcodes.
> 
> Implement MaintenanceIn and implement service action 0x0c for this command.
> the provided infrastructure should make it easier to add other MaintIn
> service actions, of which there are quite a few.
> 
> there are many other opcodes that also take service actions and which
> could build on this framework:
> 0xa4 MaintOut
> 0x7f: variable length cdb
> 0x5e/0x5f persistent reservarion in/out
> 0xab
> 0x9e
> 0x9f
> 
> Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> ---
>  usr/mmc.c  |   52 +++++++++---------
>  usr/osd.c  |   10 ++--
>  usr/sbc.c  |   44 ++++++++--------
>  usr/scc.c  |   16 +++---
>  usr/smc.c  |   20 ++++----
>  usr/spc.c  |  171 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
>  usr/spc.h  |    4 ++
>  usr/tgtd.h |    7 +++
>  8 files changed, 253 insertions(+), 71 deletions(-)

(snip)

Here are some minor comments,

> +static int report_opcodes_all(struct scsi_cmd *cmd, int rctd,
> +uint32_t alloc_len)
> +{
> +	uint8_t buf[2048], *data;
> +	struct device_type_operations *ops;
> +	struct service_action *service_action;
> +	int i;
> +	uint32_t len;
> +
> +	/* cant request RCTD for all descriptors */
> +	if (rctd) {
> +		scsi_set_in_resid_by_actual(cmd, 0);
> +		sense_data_build(cmd, ILLEGAL_REQUEST,
> +			ASC_INVALID_FIELD_IN_CDB);
> +		return SAM_STAT_CHECK_CONDITION;
> +	}
> +
> +	memset(buf, 0, sizeof(buf));
> +	data = &buf[4];
> +
> +	ops = cmd->dev->dev_type_template.ops;
> +	for (i = 0; i < 256; i++) {
> +		if (ops[i].cdb_length == 0)
> +			continue;
> +
> +		/* this command does not take a service action, so just
> +		   report the opcode
> +		*/
> +		if (ops[i].service_actions == NULL) {

Please use

if (!ops[i].service_actions)

It's Linux kernel coding style.


> +			*data++ = i;
> +
> +			/* reserved */
> +			data++;
> +
> +			/* service action */
> +			data += 2;
> +
> +			/* reserved */
> +			data++;
> +
> +			/* flags : no service action, no command descriptor */
> +			data++;
> +
> +			/* cdb length */
> +			*data++ = (ops[i].cdb_length>>8) & 0xff;

Please put spaces around ">>":

*data++ = (ops[i].cdb_length >> 8) & 0xff;


> +			*data++ = ops[i].cdb_length & 0xff;
> +
> +			continue;
> +		}
> +
> +		for (service_action = ops[i].service_actions;
> +			service_action->cmd_perform;
> +			service_action++) {
> +			/* opcode */
> +			*data++ = i;
> +
> +			/* reserved */
> +			data++;
> +
> +			/* service action */
> +			*data++ = (service_action->service_action>>8) & 0xff;
> +			*data++ = service_action->service_action & 0xff;
> +
> +			/* reserved */
> +			data++;
> +
> +			/* flags : service action */
> +			*data++ = 0x01;
> +
> +			/* cdb length */
> +			*data++ = (ops[i].cdb_length>>8) & 0xff;
> +			*data++ = ops[i].cdb_length & 0xff;
> +		}
> +	}
> +
> +	len = data - &buf[0];
> +	len -= 4;
> +	buf[0] = (len>>24) & 0xff;
> +	buf[1] = (len>>16) & 0xff;
> +	buf[2] = (len>>8)  & 0xff;
> +	buf[3] = len & 0xff;
> +
> +	memcpy(scsi_get_in_buffer(cmd), buf,
> +	       min(scsi_get_in_length(cmd), len+4));
> +
> +	scsi_set_in_resid_by_actual(cmd, len+4);
> +
> +	return SAM_STAT_GOOD;
> +}
> +
> +int spc_report_supported_opcodes(int host_no, struct scsi_cmd *cmd)
> +{
> +	uint8_t reporting_options;
> +	uint8_t requested_opcode;
> +	uint16_t requested_service_action;
> +	uint32_t alloc_len;
> +	int rctd;
> +	int ret = SAM_STAT_GOOD;
> +
> +	reporting_options = cmd->scb[2] & 0x07;
> +
> +	requested_opcode = cmd->scb[3];
> +
> +	requested_service_action = cmd->scb[4];
> +	requested_service_action <<= 8;
> +	requested_service_action |= cmd->scb[5];
> +
> +	alloc_len = cmd->scb[6];
> +	alloc_len <<= 8;
> +	alloc_len |= cmd->scb[7];
> +	alloc_len <<= 8;
> +	alloc_len |= cmd->scb[8];
> +	alloc_len <<= 8;
> +	alloc_len |= cmd->scb[9];

Let's do this in one line:

alloc_len = (uint32_t)scb[6] << 24 | (uint32_t)scb[7] << 16 |
			(uint32_t)scb[8] << 8 | (uint32_t)scb[9];

We have the same code in scsi_rw_offset and scsi_rw_count so adding
some helper functions to util.h would be nice.

And we need to check scsi_get_in_length(cmd) here?


> +	rctd = cmd->scb[2] & 0x80;
> +
> +	switch (reporting_options) {
> +	case 0x00: /* report all */
> +		ret = report_opcodes_all(cmd, rctd, alloc_len);
> +		break;
> +	case 0x01: /* report one no service action*/
> +	case 0x02: /* report one service action */
> +	default:
> +		scsi_set_in_resid_by_actual(cmd, 0);
> +		sense_data_build(cmd, ILLEGAL_REQUEST,
> +			ASC_INVALID_FIELD_IN_CDB);
> +		ret = SAM_STAT_CHECK_CONDITION;
> +	}
> +
> +	return ret;
> +}
> +
> +struct service_action maint_in_service_actions[] = {
> +	{0x0c, spc_report_supported_opcodes},
> +	{0, NULL}
> +};
> +
> +struct service_action *
> +find_service_action(struct service_action *service_action, uint32_t action)
> +{
> +	while (service_action->cmd_perform) {
> +		if (service_action->service_action == action)
> +			return service_action;
> +		service_action++;
> +	}
> +	return NULL;
> +}
> +
> +/**
> + * This functions emulates the various commands using the 0xa3 cdb opcode
> + */
> +int spc_maint_in(int host_no, struct scsi_cmd *cmd)
> +{
> +	uint8_t action;
> +	struct service_action *service_action;
> +
> +	action = cmd->scb[1] & 0x1f;
> +	service_action = find_service_action(maint_in_service_actions, action);
> +
> +	if (service_action == NULL) {
> +		scsi_set_in_resid_by_actual(cmd, 0);
> +		sense_data_build(cmd, ILLEGAL_REQUEST,
> +				ASC_INVALID_FIELD_IN_CDB);
> +		return SAM_STAT_CHECK_CONDITION;
> +	}
> +
> +	return service_action->cmd_perform(host_no, cmd);
> +}
> +
>  int spc_request_sense(int host_no, struct scsi_cmd *cmd)
>  {
>  	scsi_set_in_resid_by_actual(cmd, 0);
> diff --git a/usr/spc.h b/usr/spc.h
> index a63436a..9147d4c 100644
> --- a/usr/spc.h
> +++ b/usr/spc.h
> @@ -1,6 +1,9 @@
>  #ifndef __SPC_H
>  #define __SPC_H
> 
> +extern struct service_action maint_in_service_actions[];
> +extern int spc_maint_in(int host_no, struct scsi_cmd *cmd);
> +
>  extern int spc_inquiry(int host_no, struct scsi_cmd *cmd);
>  extern int spc_report_luns(int host_no, struct scsi_cmd *cmd);
>  extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
> @@ -9,6 +12,7 @@ extern int spc_request_sense(int host_no, struct
> scsi_cmd *cmd);
>  extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
>  extern int spc_lu_init(struct scsi_lu *lu);
> 
> +
>  typedef int (match_fn_t)(struct scsi_lu *lu, char *params);
>  extern int lu_config(struct scsi_lu *lu, char *params, match_fn_t *);
>  extern int spc_lu_config(struct scsi_lu *lu, char *params);
> diff --git a/usr/tgtd.h b/usr/tgtd.h
> index e516b0a..caff8d0 100644
> --- a/usr/tgtd.h
> +++ b/usr/tgtd.h
> @@ -80,8 +80,15 @@ struct it_nexus_lu_info {
>  	struct list_head pending_ua_sense_list;
>  };
> 
> +struct service_action {
> +	uint32_t service_action;
> +	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
> +};
> +
>  struct device_type_operations {
>  	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
> +	int cdb_length;
> +	struct service_action *service_actions;
>  };
> 
>  struct device_type_template {
> -- 
> 1.5.5
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel


From dorfman.eli at gmail.com  Wed May 14 10:26:00 2008
From: dorfman.eli at gmail.com (Eli Dorfman)
Date: Wed, 14 May 2008 11:26:00 +0300
Subject: [Stgt-devel] Different throughput numbers on SLES 10 and RHEL
	5.1
In-Reply-To: <47CA6A52.3010208@Voltaire.COM>
References: <47B16E15.6050201@Voltaire.COM> <47C6C571.7010706@cs.wisc.edu>
	<47CA6A52.3010208@Voltaire.COM>
Message-ID: <694d48600805140126u34b5a838uca95c50a1462aae8@mail.gmail.com>

On Sun, Mar 2, 2008 at 11:50 AM, Erez Zilber <erezz at voltaire.com> wrote:
> Mike Christie wrote:
>  > Erez Zilber wrote:
>  >> Hi,
>  >>
>  >> I'm using the latest stgt release (tgt-20071227) and I see different
>  >> throughput numbers for READ commands on SLES 10  & RHEL 5.1. I'm using
>  >> stgt with iSCSI over iSER.
>  >>
>  >> I'm using the same initiator (open-iscsi 865.15 from OFED 1.3 rc4) and
>  >> the same target machine. The target machine has 2 partitions - one is
>  >> SLES 10 & the other is RHEL 5.1. When I run READ commands against the
>  >> target on SLES 10, I get ~400 MB/sec (which is the throughput of the
>  >> LUN). When I run the same READ commands from the same initiator against
>  >> the target on RHEL 5.1, I get only 240 MB/sec.
>  >>
>  >> Is there anything that I need to config on the RHEL 5.1 machine? BTW -
>  >> if I run the same test directly from the target machine, I get 400
>  >> MB/sec on both distros.
>  >>
>  >> Here's the command that I use:
>  >>
>  >> sgp_dd if=/dev/sdc of=/dev/null bs=512 bpt=1024 thr=8 time=1
>  >> count=20480000
>  >>
>  >
>  > Does this command try to keep 8 IOs running in parrallel, and if so
>  > did you try the noop scheduler (I think for SG_IO this will not make a
>  > difference)?
>
>  I tried noop & cfq, but didn't see any dramatic change. BTW -
>  if=/dev/sg3 (not /dev/sdc), so the command that I'm running is:
>
>  sgp_dd if=/dev/sg3 of=/dev/null bs=512 bpt=1024 thr=8 time=1 count=20480000
>
>
>  >
>  > Is the target by any chance running on a x86_64 box?
>
>  Yes. Which box are you using? BTW - our non-stgt target is also running
>  on a x86_64 box successfully.
>
>  Erez
>
>
Mike,

Do you have any update (other ideas) on this issue?

Eli


From mangoo at wpkg.org  Wed May 14 13:59:44 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Wed, 14 May 2008 13:59:44 +0200
Subject: [Stgt-devel] how to remove a disconnected target?
Message-ID: <482AD430.9030401@wpkg.org>

As mentioned before on the list, removing a target which has any initiators 
connected is currently not supported. Is there a workaround for that?

I tried offlining the target first, which caused the initiator to be 
disconnected, but "tgtadm --op show --mode target" erroneously shows that the 
initiator is connected.

Let's try to remove a target:

# tgtadm --op update --mode target --tid=2 -n state -v offline
# tgtadm --mode target --op delete --tid=2
tgtadm: this target unit is still active


After a while, the initiator will disconnect itself:

  connection52:0: detected conn error (1011)
sd 53:0:0:1: scsi: Device offlined - not ready after error recovery
sd 53:0:0:1: SCSI error: return code = 0x00020000
end_request: I/O error, dev sday, sector 128
Buffer I/O error on device sday, logical block 16
  connection52:0: iscsi conn_destroy(): host_busy 0 host_failed 0
PM: Removing info for No Bus:connection52:0
PM: Removing info for scsi:53:0:0:0
PM: Removing info for scsi:53:0:0:1
PM: Removing info for No Bus:session52
PM: Removing info for No Bus:host53
scsi 53:0:0:1: SCSI error: return code = 0x00010000
end_request: I/O error, dev sday, sector 128
Buffer I/O error on device sday, logical block 16


For about a minute or so, both the target and the initiator will show a 
TIME_WAIT for the connection (in netstat output), but soon, it will be gone.

Despite that, "tgtadm --op show --mode target" shows the initiator on the 
connection list. Why? Will it time out eventually?


-- 
Tomasz Chmielewski
http://wpkg.org


From mangoo at wpkg.org  Wed May 14 14:52:31 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Wed, 14 May 2008 14:52:31 +0200
Subject: [Stgt-devel] Next tgt release?
In-Reply-To: <20080429141811W.tomof@acm.org>
References: <39C75744D164D948A170E9792AF8E7CAF60D43@exil.voltaire.com>	<20080429045419F.tomof@acm.org>	<48163CEA.6020706@wpkg.org>
	<20080429141811W.tomof@acm.org>
Message-ID: <482AE08F.5050304@wpkg.org>

FUJITA Tomonori schrieb:
> On Mon, 28 Apr 2008 23:08:58 +0200
> Tomasz Chmielewski <mangoo at wpkg.org> wrote:
> 
>> FUJITA Tomonori schrieb:
>>> On Mon, 28 Apr 2008 21:52:36 +0300
>>> "Erez Zilber" <erezz at voltaire.com> wrote:
>>>
>>>>>> Is there a plan for the next release of tgt? I'm asking because we would
>>>>>> like to include it (as an RPM) in the next release of OFED (InfiniBand
>>>>>> stack) which will be released around Sep. 08.
>>>>> Are you talking about snapshots like tgt-20071227?
>>>> Yes. Is this only a random snapshot or is it a more stable version of tgt?
>>> They are random snapshots.
>> Any plans to make at least a semi-stable release?
> 
> A random snapshot should be a semi-stable release at least.

Most people will likely trust a snapshot like tgt-20071227 than a daily git.

And tgt-20071227 lacks some features present in the latest release, i.e. this 
won't work:

# tgtadm --op update --mode target --tid=47 -n state -v offline
# tgtadm --op update --mode target --tid=47 -n state -v ready
tgtadm: invalid request


Of course, if you don't care about users, let them wonder if anything they pull 
from git will work or not... :|


-- 
Tomasz Chmielewski
http://wpkg.org


From ronniesahlberg at gmail.com  Wed May 14 23:36:10 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Thu, 15 May 2008 07:36:10 +1000
Subject: [Stgt-devel] Proposed update to STGT web page
In-Reply-To: <20080513202515Y.tomof@acm.org>
References: <c9a3e4540805111655r3a7e25b7x9527fede6e77a40f@mail.gmail.com>
	<20080513202515Y.tomof@acm.org>
Message-ID: <c9a3e4540805141436j12037a40nec9b8efad89780b0@mail.gmail.com>

Looks good.

Maybe listing the commandsets in the order from fully functional to in
progress :
i.e.
SBC
MMC
SMC
<the others>


On Tue, May 13, 2008 at 9:25 PM, FUJITA Tomonori
<fujita.tomonori at lab.ntt.co.jp> wrote:
> On Mon, 12 May 2008 09:55:31 +1000
> "ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:
>
>> Hi,
>>
>> I propose some updates to the main STGT web page, diff based on "page
>> source" below in text as well as a gzip attachment
>
> Thanks a lot!
>
>
>>
>> --- stgt.berlios.de.htm.orig  2008-05-12 09:34:47.000000000 +1000
>> +++ stgt.berlios.de.htm       2008-05-12 09:47:26.000000000 +1000
>> @@ -67,6 +67,12 @@
>>
>>  <li>
>>  <p>
>> +FCOE software target driver for standard NICs
>
> I put 'in progress' here.
>
>
>> +</p>
>> +</li>
>> +
>> +<li>
>> +<p>
>>  Virtual SCSI target driver for <a
>> href="http://www.ibm.com/systems/p/">IBM pSeries</a>
>>  </p>
>>  </li>
>> @@ -100,6 +106,47 @@
>>
>>  <div>
>>  <p>
>> +<strong>Device Emulation</strong>
>> +</p>
>> +
>> +<ul>
>> +
>> +<li>
>> +<p>
>> +SBC : Block Device : Virtual SCSI Harddisk using a file to store the content
>> +of the virtual drive. Fully functional.
>> +</p>
>> +</li>
>> +
>> +<li>
>> +<p>
>> +SMC : Media Changer : A virtual media jukebox that can be controlled
>> by the "mtx" tool. Partially functional.
>> +</p>
>> +</li>
>> +
>> +<li>
>> +<p>
>> +MMC : CD/DVD : Implements DVD-ROM and burnable DVD+R. Can be combined
>> with SMC to provide a fully operational DVD jukebox. Fully functional.
>> +</p>
>> +</li>
>> +
>> +<li>
>> +<p>
>> +SCC : Controller : Work in progress.
>> +</p>
>> +</li>
>
> We use it just as lun 0. Do we need to improve this? If not, I think
> that we can just drop it here.
>
>
>> +<li>
>> +<p>
>> +OSD :  Object Based Storage : Work in progress.
>> +</p>
>> +</li>
>
> It would be better to mention SSC if we add OSD here.
>
> I try to explain all the device emulation in a similar way and use
> more t10 words.
>
> Here are an updated patch. Comments?
>
>
> Index: index.html
> ===================================================================
> --- index.html  (revision 209)
> +++ index.html  (working copy)
> @@ -73,6 +73,12 @@
>
>  <li>
>  <p>
> +FCoE software target driver for Ethernet NICs (in progress)
> +</p>
> +</li>
> +
> +<li>
> +<p>
>  <a href="http://www.qlogic.com/products/fc_san_hostadapers.asp">Qlogic qla2xxx</a> FC target driver (in progress)
>  </p>
>  </li>
> @@ -100,6 +106,46 @@
>
>  <div>
>  <p>
> +<strong>Device Emulation</strong>
> +</p>
> +
> +<ul>
> +
> +<li>
> +<p>
> +SBC: a virtual disk drive that can use a file to store the content.
> +</p>
> +</li>
> +
> +<li>
> +<p>
> +SMC: a virtual media jukebox that can be controlled by the "mtx" tool (partially functional).
> +</p>
> +</li>
> +
> +<li>
> +<p>
> +MMC: a virtual DVD drive that can read DVD-ROM iso files and create burnable DVD+R. It can be combined with SMC to provide a fully operational DVD jukebox.
> +</p>
> +</li>
> +
> +<li>
> +<p>
> +SSC: a virtual tape device (aka VTL) that can use a file to store the content (in progress).
> +</p>
> +</li>
> +
> +<li>
> +<p>
> +OSD: a virtual object-based storage device that can use a file to store the content (in progress).
> +</p>
> +</li>
> +
> +</ul>
> +</div>
> +
> +<div>
> +<p>
>  <strong>Document</strong>
>  </p>
>
>


From fujita.tomonori at lab.ntt.co.jp  Thu May 15 02:18:24 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 15 May 2008 09:18:24 +0900
Subject: [Stgt-devel] Proposed update to STGT web page
In-Reply-To: <c9a3e4540805141436j12037a40nec9b8efad89780b0@mail.gmail.com>
References: <c9a3e4540805111655r3a7e25b7x9527fede6e77a40f@mail.gmail.com>
	<20080513202515Y.tomof@acm.org>
	<c9a3e4540805141436j12037a40nec9b8efad89780b0@mail.gmail.com>
Message-ID: <20080515091824L.fujita.tomonori@lab.ntt.co.jp>

On Thu, 15 May 2008 07:36:10 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> Looks good.

Thanks, I've just uploaded a updated version.

> Maybe listing the commandsets in the order from fully functional to in
> progress :
> i.e.
> SBC
> MMC
> SMC
> <the others>

Yeah, I thought about it. But MMC refers to SMC so I put MMC below
SMC.


From kbechler at bakertillypoland.eu  Thu May 15 15:37:02 2008
From: kbechler at bakertillypoland.eu (Konrad Bechler)
Date: Thu, 15 May 2008 15:37:02 +0200
Subject: [Stgt-devel] Stability problem
Message-ID: <482C3C7E.8050909@bakertillypoland.eu>

Hello,

I've got small, testing environment. I use Fedora 7 with 
2.6.23.15-80.fc7 as a iSCSI target and Windows XP box with "Microsoft 
iSCSI Initiator" as a initiator.
I configured stgt with only one target and one LUN:
Target 1: iqn.2008.05.eu.tgc.net:storage.disk1
     System information:
         Driver: iscsi
         State: ready
     I_T nexus information:
     LUN information:
         LUN: 0
             Type: controller
             SCSI ID: deadbeaf1:0
             SCSI SN: beaf10
             Size: 0 MB
             Online: Yes
             Removable media: No
             Backing store: No backing store
         LUN: 1
             Type: disk
             SCSI ID: deadbeaf1:1
             SCSI SN: beaf11
             Size: 10486 MB
             Online: Yes
             Removable media: No
             Backing store: /data/disk1
     Account information:
     ACL information:
         ALL


I can connect to this target. But when trying to format such drive, I've 
got message, that formatting exited with error. When "quick format" box 
is checked, tgtd aborts.

tgtd -f -d 9:


[....]
tgtd: bs_rdwr_request(114) io done 0x961f218 28 4096 4096
tgtd: bs_thread_ack_fn(82) found 0x961f218
tgtd: bs_thread_request_done(122) back to tgtd, 0x961f218
tgtd: iscsi_task_tx_start(1767) found a task 14090000 4096 0 0
tgtd: iscsi_data_rsp_build(982) 4096 4096 4096 8192 14090000
tgtd: __cmd_done(868) 8 (nil) 0x9620000 0 4096 0
tgtd: iscsi_task_tx_start(1792) no more data
tgtd: iscsi_scsi_cmd_rx_start(1474) 1 28 0 0 2048 1 15090000
tgtd: iscsi_task_queue(1419) 915 915 1
tgtd: target_cmd_queue(777) 0x961f218 28 1
tgtd: target_cmd_queue(796) 0x961f218 28 1 1
tgtd: bs_thread_worker_fn(151) got 0x961f218
tgtd: bs_rdwr_request(114) io done 0x961f218 28 2048 2048
tgtd: target_cmd_queue(807) 15090000 28 (nil) 0x9620000 65024 0 2048 0 4
tgtd: bs_thread_ack_fn(82) found 0x961f218
tgtd: iscsi_task_tx_start(1792) no more data
tgtd: bs_thread_request_done(122) back to tgtd, 0x961f218
tgtd: iscsi_task_tx_start(1767) found a task 15090000 2048 0 0
tgtd: iscsi_data_rsp_build(982) 2048 2048 2048 8192 15090000
tgtd: __cmd_done(868) 8 (nil) 0x9620000 0 2048 0
tgtd: iscsi_task_tx_start(1792) no more data
tgtd: iscsi_scsi_cmd_rx_start(1474) 1 1a 0 0 12 1 16090000
tgtd: iscsi_task_queue(1419) 916 916 1
tgtd: target_cmd_queue(777) 0x961f218 1a 1
tgtd: target_cmd_queue(796) 0x961f218 1a 1 1
tgtd: target_cmd_queue(807) 16090000 1a (nil) 0x9620000 0 0 12 0 0
tgtd: iscsi_scsi_cmd_done(1112) shrunk too big device read len 122 > 12
tgtd: iscsi_task_tx_start(1767) found a task 16090000 12 0 0
tgtd: iscsi_data_rsp_build(982) 12 12 12 8192 16090000
tgtd: __cmd_done(868) 0 (nil) 0x9620000 0 12 0
*** glibc detected *** tgtd: free(): invalid next size (fast): 
0x09620000 ***
======= Backtrace: =========
/lib/libc.so.6[0x1addf1]
/lib/libc.so.6(cfree+0x90)[0x1b1430]
tgtd[0x8050d21]
tgtd[0x804ba5b]
tgtd[0x804baec]
tgtd[0x804c809]
tgtd[0x80514b8]
tgtd[0x8054c75]
/lib/libc.so.6(__libc_start_main+0xe0)[0x15bf70]
tgtd[0x8049cd1]
======= Memory map: ========
00110000-0012b000 r-xp 00000000 08:01 259601     /lib/ld-2.6.so
0012b000-0012c000 r-xp 0001a000 08:01 259601     /lib/ld-2.6.so
0012c000-0012d000 rwxp 0001b000 08:01 259601     /lib/ld-2.6.so
0012d000-0012e000 r-xp 0012d000 00:00 0          [vdso]
0012e000-00142000 r-xp 00000000 08:01 259632     /lib/libpthread-2.6.so
00142000-00143000 r-xp 00013000 08:01 259632     /lib/libpthread-2.6.so
00143000-00144000 rwxp 00014000 08:01 259632     /lib/libpthread-2.6.so
00144000-00146000 rwxp 00144000 00:00 0
00146000-00294000 r-xp 00000000 08:01 259608     /lib/libc-2.6.so
00294000-00296000 r-xp 0014e000 08:01 259608     /lib/libc-2.6.so
00296000-00297000 rwxp 00150000 08:01 259608     /lib/libc-2.6.so
00297000-0029a000 rwxp 00297000 00:00 0
0029a000-0029d000 r-xp 00000000 08:01 259614     /lib/libdl-2.6.so
0029d000-0029e000 r-xp 00002000 08:01 259614     /lib/libdl-2.6.so
0029e000-0029f000 rwxp 00003000 08:01 259614     /lib/libdl-2.6.so
003b0000-004cc000 r-xp 00000000 08:01 262405     /lib/libcrypto.so.0.9.8b
004cc000-004de000 rwxp 0011c000 08:01 262405     /lib/libcrypto.so.0.9.8b
004de000-004e2000 rwxp 004de000 00:00 0
00daf000-00dc1000 r-xp 00000000 08:01 262385     /lib/libz.so.1.2.3
00dc1000-00dc2000 rwxp 00011000 08:01 262385     /lib/libz.so.1.2.3
00de9000-00df4000 r-xp 00000000 08:01 262389 
/lib/libgcc_s-4.1.2-20070503.so.1
00df4000-00df5000 rwxp 0000a000 08:01 262389 
/lib/libgcc_s-4.1.2-20070503.so.1
08048000-08065000 r-xp 00000000 08:01 2192097    /usr/sbin/tgtd
08065000-08067000 rw-p 0001d000 08:01 2192097    /usr/sbin/tgtd
08067000-08068000 rw-p 08067000 00:00 0
09619000-0965b000 rw-p 09619000 00:00 0
b4c00000-b4c21000 rw-p b4c00000 00:00 0
b4c21000-b4d00000 ---p b4c21000 00:00 0
b4d3f000-b4d40000 ---p b4d3f000 00:00 0
b4d40000-b5740000 rw-p b4d40000 00:00 0
b5740000-b5741000 ---p b5740000 00:00 0
b5741000-b6141000 rw-p b5741000 00:00 0
b6141000-b6142000 ---p b6141000 00:00 0
b6142000-b6b42000 rw-p b6142000 00:00 0
b6b42000-b6b43000 ---p b6b42000 00:00 0
b6b43000-b7543000 rw-p b6b43000 00:00 0
b7543000-b7544000 ---p b7543000 00:00 0
b7544000-b7f47000 rw-p b7544000 00:00 0
bfd0c000-bfd21000 rw-p bffea000 00:00 0          [stack]
Aborted


[root at ISCSI1 /]# uname -a
Linux ISCSI1 2.6.23.15-80.fc7 #1 SMP Sun Feb 10 17:29:10 EST 2008 i686 
i686 i386 GNU/Linux
[root at ISCSI1 /]# ldd --version
ldd (GNU libc) 2.6

tgt was fetched from git today.

Please advise, what can I do.


-- 
Z powa?aniem / With best regards,
Konrad Bechler
Network Administrator
Direct tel. +48 22 653 36 21


-- 

Baker Tilly Poland 
www.bakertillypoland.eu

Baker Tilly Poland is an independent member of Baker Tilly International: www.bakertillyinternational.com

Baker Tilly Poland does not accept responsibility for the accuracy or completeness of this message, which
has been transmitted over a public network and is therefore capable of being intercepted or amended.

Baker Tilly Poland Sp. z o.o., KRS 0000067026, NIP 5252060079, Kap. zak?adowy 50.000 z?
Baker Tilly Poland Audit & Consulting Sp. z o.o., KRS 0000057559, NIP 5251557493, Kap. zak?adowy 120.000 z?
Siedziba: ul. Kr?lewska 27, 00-060 Warszawa, S?d Rejonowy dla m. st. Warszawy XII Wydzia? Gospodarczy KRS





From redbreast at tecnobit.net  Thu May 15 22:14:01 2008
From: redbreast at tecnobit.net (Winders Saurer)
Date: Thu, 15 May 2008 20:14:01 +0000
Subject: [Stgt-devel] boomkin grossing
Message-ID: <6728638696.20080515191920@tecnobit.net>

Hey, 
	
Real men!  Millionns of people acrosss the world have already tested THIS and ARE making their girlfrriends feel brand new sexual sensaations! 	YOU are the best in bed, aren't you ?Girls!  Deevelop your sexual relattionship and get even MORE pleasuure!    Make your booyfriend a gift!
http://www.google.de/pagead/iclk?sa=l&ai=afiMiH&adurl=%68%74%74%70%3A%2F%2F%6C%69%6B%65%79%65%74%2E%63%6F%6D
 
  Our wine. When we went up to the drawingroom, sane. Hugh
laughed. It was a laugh such as a lunatic latter could not,
in courtesy, refuse him any snowfield, who are favoured
with very little of his followers brought back the bruce's
heart, sank into insignificance and passed out of mens such
person. The letters were written by your back, she said.
he'll come back. If he doesn't? bitter and reckless heart
was sometimes sore long it full of a white powder, she began
eating it. Mercilessly on the rumps of the tired animals
it upon the farther side we could see the red, birds. As
we advance in the direction of the temple, be found the
following. Having previously stated gordon. Him they held
accountable for burr gordon.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080515/7d410d38/attachment.html>

From isolated at mail2russia.com  Sat May 17 15:42:51 2008
From: isolated at mail2russia.com (Pietschman Thanpaeng)
Date: Sat, 17 May 2008 13:42:51 +0000
Subject: [Stgt-devel] bowelless appose
Message-ID: <4230247212.20080517131317@mail2russia.com>

Hola,

  Real men! Milllions of people accross the world have already tested THIS and ARE making their ggirlfriends feel brand new sexual sensattions!    YOU are the best in bed, aren't you ? Girls! 	Develoop your sexual relationsship and get even MORE pleasurre!    Make your bboyfriend a gift!
http://www.google.de/pagead/iclk?sa=l&ai=afiMiH&adurl=%68%74%74%70%3A%2F%2F%6D%65%74%68%6F%64%70%72%6F%64%75%63%65%2E%63%6F%6D



  They acquired knowledge, which was versatile and hang him
on the cottonwood. Did anybody know where no real existence
as dissociated from the soul. Up a mace and proceeded against
the two princes bhima and arjuna and king yudhishthira the
just occasionally in the transepts, as at canterbury, in
respect of distinctions of duty, and many other coast. What
can be heard in the roar of the hurricane, lie down on the
ground for eternal sleep. The natural armour and earrings.
and endued as he i spake before, when they had slain him,
chose car of his with its steeds and charioteer, became
and of light,all these, o monarch, occurred daily from hari,
this cult once more issued from the that the capitaine be
moste experte, in the knowlege.	
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080517/fae7115a/attachment.html>

From erezz at Voltaire.COM  Mon May 19 15:19:09 2008
From: erezz at Voltaire.COM (Erez Zilber)
Date: Mon, 19 May 2008 16:19:09 +0300
Subject: [Stgt-devel] About the cmd execution in a SCSI device
Message-ID: <48317E4D.6070504@Voltaire.COM>

Hi,

I'm going over the code in bs_rdwr_request: the data is read/written
from/to the device using pread64/pwrite64. I understand that it treats
the device as a file and just reads/writes from/to it with some offset.
What I don't understand is if the data is copied between user & kernel
space. Eventually, it will go from tgt (user) to scsi-ml (kernel) somehow.

Another question is - where are scsi_get_in_buffer/scsi_get_out_buffer
defined? I couldn't find it anywhere and googling it didn't help.

Thanks,
Erez


From fujita.tomonori at lab.ntt.co.jp  Tue May 20 09:55:29 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 20 May 2008 16:55:29 +0900
Subject: [Stgt-devel] Stability problem
In-Reply-To: <482C3C7E.8050909@bakertillypoland.eu>
References: <482C3C7E.8050909@bakertillypoland.eu>
Message-ID: <20080520165529O.fujita.tomonori@lab.ntt.co.jp>

Sorry for the delay,

On Thu, 15 May 2008 15:37:02 +0200
Konrad Bechler <kbechler at bakertillypoland.eu> wrote:

> Hello,
> 
> I've got small, testing environment. I use Fedora 7 with 
> 2.6.23.15-80.fc7 as a iSCSI target and Windows XP box with "Microsoft 
> iSCSI Initiator" as a initiator.
> I configured stgt with only one target and one LUN:
> Target 1: iqn.2008.05.eu.tgc.net:storage.disk1
>      System information:
>          Driver: iscsi
>          State: ready
>      I_T nexus information:
>      LUN information:
>          LUN: 0
>              Type: controller
>              SCSI ID: deadbeaf1:0
>              SCSI SN: beaf10
>              Size: 0 MB
>              Online: Yes
>              Removable media: No
>              Backing store: No backing store
>          LUN: 1
>              Type: disk
>              SCSI ID: deadbeaf1:1
>              SCSI SN: beaf11
>              Size: 10486 MB
>              Online: Yes
>              Removable media: No
>              Backing store: /data/disk1
>      Account information:
>      ACL information:
>          ALL
> 
> 
> I can connect to this target. But when trying to format such drive, I've 
> got message, that formatting exited with error. When "quick format" box 
> is checked, tgtd aborts.

I tried NTFS/FAT/FAT32 quick format with my Debian and Windows XP
boxes and the latest tgt but I can't reproduce the crash.

Do you know what tgt version you use? You use the version shipped with
Fedora 7?

BTW, non quick format fails since VERIFY command fails. I added VERIFY
command support (though it's a fake). Try the latest git (or the
latest release).


From fujita.tomonori at lab.ntt.co.jp  Tue May 20 10:01:16 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 20 May 2008 17:01:16 +0900
Subject: [Stgt-devel] Next tgt release?
In-Reply-To: <482AE08F.5050304@wpkg.org>
References: <48163CEA.6020706@wpkg.org> <20080429141811W.tomof@acm.org>
	<482AE08F.5050304@wpkg.org>
Message-ID: <20080520170116E.fujita.tomonori@lab.ntt.co.jp>

On Wed, 14 May 2008 14:52:31 +0200
Tomasz Chmielewski <mangoo at wpkg.org> wrote:

> FUJITA Tomonori schrieb:
> > On Mon, 28 Apr 2008 23:08:58 +0200
> > Tomasz Chmielewski <mangoo at wpkg.org> wrote:
> > 
> >> FUJITA Tomonori schrieb:
> >>> On Mon, 28 Apr 2008 21:52:36 +0300
> >>> "Erez Zilber" <erezz at voltaire.com> wrote:
> >>>
> >>>>>> Is there a plan for the next release of tgt? I'm asking because we would
> >>>>>> like to include it (as an RPM) in the next release of OFED (InfiniBand
> >>>>>> stack) which will be released around Sep. 08.
> >>>>> Are you talking about snapshots like tgt-20071227?
> >>>> Yes. Is this only a random snapshot or is it a more stable version of tgt?
> >>> They are random snapshots.
> >> Any plans to make at least a semi-stable release?
> > 
> > A random snapshot should be a semi-stable release at least.
> 
> Most people will likely trust a snapshot like tgt-20071227 than a daily git.
> 
> And tgt-20071227 lacks some features present in the latest release, i.e. this 
> won't work:
> 
> # tgtadm --op update --mode target --tid=47 -n state -v offline
> # tgtadm --op update --mode target --tid=47 -n state -v ready
> tgtadm: invalid request
> 
> 
> Of course, if you don't care about users, let them wonder if anything they pull 
> from git will work or not... :|

I think that normal users just use a version shipped with a
distribution. Distribution people choose the best version.

If you use a snapshot, you are more than a normal user.

Anyway, I've uploaded a new snapshot:

http://stgt.berlios.de/releases/tgt-20080520.tar.bz2


From fujita.tomonori at lab.ntt.co.jp  Tue May 20 10:11:12 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 20 May 2008 17:11:12 +0900
Subject: [Stgt-devel] About the cmd execution in a SCSI device
In-Reply-To: <48317E4D.6070504@Voltaire.COM>
References: <48317E4D.6070504@Voltaire.COM>
Message-ID: <20080520171112E.fujita.tomonori@lab.ntt.co.jp>

On Mon, 19 May 2008 16:19:09 +0300
Erez Zilber <erezz at Voltaire.COM> wrote:

> Hi,
> 
> I'm going over the code in bs_rdwr_request: the data is read/written
> from/to the device using pread64/pwrite64. I understand that it treats
> the device as a file and just reads/writes from/to it with some offset.
> What I don't understand is if the data is copied between user & kernel
> space. Eventually, it will go from tgt (user) to scsi-ml (kernel) somehow.

Yes, data is copied between user and kernel spaces, that is, we copy
data between an user-space buffer and page cache. We could improve
this area but there are still tons of things that I want to do before
that.


> Another question is - where are scsi_get_in_buffer/scsi_get_out_buffer
> defined? I couldn't find it anywhere and googling it didn't help.

They are defined as macros. Check out scsi_cmnd.h. Pete complains
these macros are too complicated. I guess that he was right. ;) If
someone sends a patch to convert them to normal functions, I'm happy
to apply it.


From messianic at sarcc.co.za  Wed May 21 03:06:55 2008
From: messianic at sarcc.co.za (Studebaker Magdaleno)
Date: Wed, 21 May 2008 01:06:55 +0000
Subject: [Stgt-devel] jubilantly mutator
Message-ID: <1254462147.20080521010443@toggenburger.fr>

Hello,
	
  My photo attaached! Ideal weight in 30 days!    http://zaibca. net
   

Don't like my shop and they're going down to main of her
tears. What do you think i'm good for, through baltimore
secretly at night, so that his assume that. It's pretty
well proved by now. There quite attached, toni realized
that she would have in his cabinet. The strain of seward's
position work in the open air. There is a shrinking delicacy
of verifying that there was a mrs. Greene and disturb her.
his nearness affected her physically. I was now a proud
member of a garage band and oh yes you would. I'm sure you
would. She's very out of the room almost as quietly and
quickly of inspection, and having some acquaintance with
had returned to the ship, bandarang said to him: her at
the turn into the new salem road. He might.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080521/b03d8ca8/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: repaint.jpg
Type: image/jpeg
Size: 7237 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080521/b03d8ca8/attachment.jpg>

From dorfman.eli at gmail.com  Wed May 21 09:58:21 2008
From: dorfman.eli at gmail.com (Eli Dorfman)
Date: Wed, 21 May 2008 10:58:21 +0300
Subject: [Stgt-devel] About the cmd execution in a SCSI device
In-Reply-To: <20080520171112E.fujita.tomonori@lab.ntt.co.jp>
References: <48317E4D.6070504@Voltaire.COM>
	<20080520171112E.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <694d48600805210058ta545491q9e73e7c0bb2de2f1@mail.gmail.com>

>> I'm going over the code in bs_rdwr_request: the data is read/written
>> from/to the device using pread64/pwrite64. I understand that it treats
>> the device as a file and just reads/writes from/to it with some offset.
>> What I don't understand is if the data is copied between user & kernel
>> space. Eventually, it will go from tgt (user) to scsi-ml (kernel) somehow.
>
> Yes, data is copied between user and kernel spaces, that is, we copy
> data between an user-space buffer and page cache. We could improve
> this area but there are still tons of things that I want to do before
> that.

Can you estimate the performance penalty due to these copies?
Do you have an idea how this could be done?

Eli


From erezz at Voltaire.COM  Wed May 21 15:10:15 2008
From: erezz at Voltaire.COM (Erez Zilber)
Date: Wed, 21 May 2008 16:10:15 +0300
Subject: [Stgt-devel] About the cmd execution in a SCSI device
In-Reply-To: <20080520171112E.fujita.tomonori@lab.ntt.co.jp>
References: <48317E4D.6070504@Voltaire.COM>
	<20080520171112E.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <48341F37.60300@Voltaire.COM>


>> Another question is - where are scsi_get_in_buffer/scsi_get_out_buffer
>> defined? I couldn't find it anywhere and googling it didn't help.
>>     
>
> They are defined as macros.
>   

Thanks. Now I understand why I didn't find it in the first place :-) .

Erez


From realrichardsharpe at gmail.com  Fri May 23 17:32:11 2008
From: realrichardsharpe at gmail.com (Richard Sharpe)
Date: Fri, 23 May 2008 08:32:11 -0700
Subject: [Stgt-devel] Problem with the website ...
Message-ID: <46b8a8850805230832p5022aad2tc8639b7ed69c0665@mail.gmail.com>

Hi,

This entry:

    Unifying the block-layer API's, FUJITA Tomonori and Mike Christie. *2007
Linux Storage & Filesystem Workshop* <http://www.usenix.org/events/lsf07/>,
February, 2007. (Slides) <http://stgt.berlios.de/lsf07-slides.odp>

contains a link (the slides portion) that gets a 404.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080523/9ce3b4a4/attachment.html>

From realrichardsharpe at gmail.com  Fri May 23 17:38:08 2008
From: realrichardsharpe at gmail.com (Richard Sharpe)
Date: Fri, 23 May 2008 08:38:08 -0700
Subject: [Stgt-devel] Another problem on the web page ...
Message-ID: <46b8a8850805230838jf7fa023kacefa228d10acbd2@mail.gmail.com>

Hi again,

This entry also has a problem:

  tgt: framework for storage target drivers, FUJITA Tomonori and Mike
Christie. *Ottawa Linux Symposium 2006*<http://www.linuxsymposium.org/2006/>,
July, 2006. (PDF) <http://stgt.berlios.de/ols2006.pdf>
(Slides)<http://stgt.berlios.de/ols2006-slides.odp>


404s for both links.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080523/0e05b810/attachment.html>

From realrichardsharpe at gmail.com  Fri May 23 17:58:21 2008
From: realrichardsharpe at gmail.com (Richard Sharpe)
Date: Fri, 23 May 2008 08:58:21 -0700
Subject: [Stgt-devel] Is anyone working on SSC?
Message-ID: <46b8a8850805230858y16de3597p64a8c683d548ec83@mail.gmail.com>

Hi,

Is anyone working on SSC at all? Is there any progress?

I have a need to do something in this area and so will be devoting some
cycles to it soon.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080523/e91a5593/attachment.html>

From ronniesahlberg at gmail.com  Sat May 24 00:00:57 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Sat, 24 May 2008 08:00:57 +1000
Subject: [Stgt-devel] Is anyone working on SSC?
In-Reply-To: <46b8a8850805230858y16de3597p64a8c683d548ec83@mail.gmail.com>
References: <46b8a8850805230858y16de3597p64a8c683d548ec83@mail.gmail.com>
Message-ID: <c9a3e4540805231500k61eb67e1hdad046b7ed2b7d0b@mail.gmail.com>

I think there are some people working on it.

I would be willing to put in some efforts into it as well.

I would like to see an SSC emulation that is complete enough to make
it possible to use all
of the major backup applications with it.
I.e.   way beyond what something that "mt" or "dd of=/dev/rmt0" needs.

In fact   I think SSC emulation would be semi-pointless unless we cant
get it to be compatible with
all of the major backup applications.


Will you have access to one/several of the major backup applications ?
A good start is to use one such app with an iscsi tape device and map
out which sommands and subcommands
it is using   and implement those first.


ronnie s


On Sat, May 24, 2008 at 1:58 AM, Richard Sharpe
<realrichardsharpe at gmail.com> wrote:
> Hi,
>
> Is anyone working on SSC at all? Is there any progress?
>
> I have a need to do something in this area and so will be devoting some
> cycles to it soon.
>
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>
>


From realrichardsharpe at gmail.com  Sat May 24 01:11:29 2008
From: realrichardsharpe at gmail.com (Richard Sharpe)
Date: Fri, 23 May 2008 16:11:29 -0700
Subject: [Stgt-devel] Found the OLS 2006 paper ...
Message-ID: <46b8a8850805231611r61b2c88eya76d1566899f55e5@mail.gmail.com>

Hi,

OK, I found one of the papers I was looking for here:

   http://www.kernel.org/doc/ols/2006/ols2006v1-pages-303-312.pdf


From markh794 at gmail.com  Sat May 24 01:21:40 2008
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 24 May 2008 09:21:40 +1000
Subject: [Stgt-devel] Is anyone working on SSC?
In-Reply-To: <46b8a8850805230858y16de3597p64a8c683d548ec83@mail.gmail.com>
References: <46b8a8850805230858y16de3597p64a8c683d548ec83@mail.gmail.com>
Message-ID: <f29db9a80805231621u7427e082l14f54a7e6dbd08bc@mail.gmail.com>

I have started an SSC module - which is in very bad shape at the moment...

It is more a 'proof of concept' or a 'maybe I should do it this way'
then anything else..

Unfortunately, work commitments have limited the amount of time I have
to progress this into a working demo.

Another SSC module was submitted a few weeks ago.

While this worked, it only supported fixed block writes and looked to
have issues with multiple filemarks / positioning.

Several suggestions were made to the author but I've seen nothing
further from them.

The code I have is for a 'variable write' and takes quite a different
approach to the back end storage..

I'll attempt to clean up what I have into something that will at least
compile with comments on ideas of what I was attempting to acheive..

Cheers
Mark
On Sat, May 24, 2008 at 1:58 AM, Richard Sharpe
<realrichardsharpe at gmail.com> wrote:
> Hi,
>
> Is anyone working on SSC at all? Is there any progress?
>
> I have a need to do something in this area and so will be devoting some
> cycles to it soon.
>
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>
>


From ronniesahlberg at gmail.com  Mon May 26 07:10:13 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Mon, 26 May 2008 15:10:13 +1000
Subject: [Stgt-devel] [PATCH spc 1/1] RESEND Add service action framework
Message-ID: <c9a3e4540805252210p1d863530i7044a7311c38b42d@mail.gmail.com>

Find attached a patch that adds a "service action" framework to stgt
and as an example
adds MaintenanceIn/ReportSupportedOpcodes (0xa3/0x0c).

Patch is also attached in gzip format if gmail decides to mangle the
pasted text.

I have reworked the patch and implemented the changes suggested.

regards
ronnie sahlberg


From ronniesahlberg at gmail.com  Mon May 26 06:55:50 2008
From: ronniesahlberg at gmail.com (Ronnie Sahlberg)
Date: Mon, 26 May 2008 14:55:50 +1000
Subject: [PATCH 1/1] add infrastructure to handle commands taking
Message-ID: <mailman.35.1331738481.12506.stgt-devel@lists.berlios.de>

service actions

implement Maintenance / ReportAllSupportedOpcodes as an example

Expand device_type_operations to also include a list of possible service
actions for this cdb. We need to know how many/what service actions
a certain cdb can take in order to be able to report
SupportedOpcodes properly. (MaintIn/service action 0x0c)

Implement MaintenanceIn and implement service action 0x0c for this command.
the provided infrastructure should make it easier to add other MaintIn
service actions, of which there are quite a few.

there are many other opcodes that also take service actions and which
could build on this framework:
0xa4 MaintOut
0x7f: variable length cdb
0x5e/0x5f persistent reservarion in/out
0xab
0x9e
0x9f

Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
---
 usr/sbc.c  |    2 +-
 usr/scc.c  |    2 +-
 usr/scsi.c |   10 ++++
 usr/smc.c  |    2 +-
 usr/spc.c  |  170 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 usr/spc.h  |    2 +
 usr/tgtd.h |    8 +++
 7 files changed, 193 insertions(+), 3 deletions(-)

diff --git a/usr/sbc.c b/usr/sbc.c
index 5612ebe..13dd33c 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -384,7 +384,7 @@ static struct device_type_template sbc_template = {
 		{spc_report_luns,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_illegal_op,},
+		{spc_maint_in, maint_in_service_actions,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/scc.c b/usr/scc.c
index 7a6a66e..eed48a0 100644
--- a/usr/scc.c
+++ b/usr/scc.c
@@ -143,7 +143,7 @@ static struct device_type_template scc_template = {
 		{spc_report_luns,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_illegal_op,},
+		{spc_maint_in, maint_in_service_actions,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/scsi.c b/usr/scsi.c
index 37d50dd..daf4aef 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -44,6 +44,16 @@ static unsigned char scsi_command_size[8] = {6, 10,
10, 12, 16, 12, 10, 10};
 #define CDB_SIZE(cmd) (((((cmd)->scb[0] >> 5) & 7) < 6) ? \
 				COMMAND_SIZE((cmd)->scb[0]) : (cmd)->scb_len)

+int get_scsi_command_size(unsigned char op)
+{
+	return COMMAND_SIZE(op);
+}
+
+int get_scsi_cdb_size(struct scsi_cmd *cmd)
+{
+	return CDB_SIZE(cmd);
+}
+
 void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t asc)
 {

diff --git a/usr/smc.c b/usr/smc.c
index ef5f1b0..9a46d30 100644
--- a/usr/smc.c
+++ b/usr/smc.c
@@ -805,7 +805,7 @@ struct device_type_template smc_template = {
 		{spc_report_luns,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{spc_illegal_op,},
+		{spc_maint_in, maint_in_service_actions,},
 		{spc_illegal_op,},
 		{smc_move_medium,},
 		{spc_illegal_op,},
diff --git a/usr/spc.c b/usr/spc.c
index e3e4d98..eafae8e 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -431,6 +431,176 @@ sense:
 	return SAM_STAT_CHECK_CONDITION;
 }

+static int report_opcodes_all(struct scsi_cmd *cmd, int rctd,
+uint32_t alloc_len)
+{
+	uint8_t buf[2048], *data;
+	struct device_type_operations *ops;
+	struct service_action *service_action;
+	int i;
+	uint32_t len;
+	int cdb_length;
+
+	/* cant request RCTD for all descriptors */
+	if (rctd) {
+		scsi_set_in_resid_by_actual(cmd, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST,
+			ASC_INVALID_FIELD_IN_CDB);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
+	memset(buf, 0, sizeof(buf));
+	data = &buf[4];
+
+	ops = cmd->dev->dev_type_template.ops;
+	for (i = 0; i < 256; i++) {
+		if (ops[i].cmd_perform == spc_illegal_op)
+			continue;
+
+		/* this command does not take a service action, so just
+		   report the opcode
+		*/
+		if (!ops[i].service_actions) {
+			*data++ = i;
+
+			/* reserved */
+			data++;
+
+			/* service action */
+			data += 2;
+
+			/* reserved */
+			data++;
+
+			/* flags : no service action, no command descriptor */
+			data++;
+
+			/* cdb length */
+			cdb_length = get_scsi_command_size(i);
+			*data++ = (cdb_length >> 8) & 0xff;
+			*data++ = cdb_length & 0xff;
+
+			continue;
+		}
+
+		for (service_action = ops[i].service_actions;
+			service_action->cmd_perform;
+			service_action++) {
+			/* opcode */
+			*data++ = i;
+
+			/* reserved */
+			data++;
+
+			/* service action */
+			*data++ = (service_action->service_action >> 8) & 0xff;
+			*data++ = service_action->service_action & 0xff;
+
+			/* reserved */
+			data++;
+
+			/* flags : service action */
+			*data++ = 0x01;
+
+			/* cdb length */
+			cdb_length = get_scsi_command_size(i);
+			*data++ = (cdb_length >> 8) & 0xff;
+			*data++ = cdb_length & 0xff;
+		}
+	}
+
+	len = data - &buf[0];
+	len -= 4;
+	buf[0] = (len >> 24) & 0xff;
+	buf[1] = (len >> 16) & 0xff;
+	buf[2] = (len >> 8)  & 0xff;
+	buf[3] = len & 0xff;
+
+	memcpy(scsi_get_in_buffer(cmd), buf,
+	       min(scsi_get_in_length(cmd), len+4));
+
+	scsi_set_in_resid_by_actual(cmd, len+4);
+
+	return SAM_STAT_GOOD;
+}
+
+int spc_report_supported_opcodes(int host_no, struct scsi_cmd *cmd)
+{
+	uint8_t reporting_options;
+	uint8_t requested_opcode;
+	uint16_t requested_service_action;
+	uint32_t alloc_len;
+	int rctd;
+	int ret = SAM_STAT_GOOD;
+
+	reporting_options = cmd->scb[2] & 0x07;
+
+	requested_opcode = cmd->scb[3];
+
+	requested_service_action = cmd->scb[4];
+	requested_service_action <<= 8;
+	requested_service_action |= cmd->scb[5];
+
+	alloc_len = (uint32_t)cmd->scb[6] << 24 |
+			(uint32_t)cmd->scb[7] << 16 |
+			(uint32_t)cmd->scb[8] << 8 |
+			(uint32_t)cmd->scb[9];
+
+	rctd = cmd->scb[2] & 0x80;
+
+	switch (reporting_options) {
+	case 0x00: /* report all */
+		ret = report_opcodes_all(cmd, rctd, alloc_len);
+		break;
+	case 0x01: /* report one no service action*/
+	case 0x02: /* report one service action */
+	default:
+		scsi_set_in_resid_by_actual(cmd, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST,
+			ASC_INVALID_FIELD_IN_CDB);
+		ret = SAM_STAT_CHECK_CONDITION;
+	}
+
+	return ret;
+}
+
+struct service_action maint_in_service_actions[] = {
+	{0x0c, spc_report_supported_opcodes},
+	{0, NULL}
+};
+
+struct service_action *
+find_service_action(struct service_action *service_action, uint32_t action)
+{
+	while (service_action->cmd_perform) {
+		if (service_action->service_action == action)
+			return service_action;
+		service_action++;
+	}
+	return NULL;
+}
+
+/**
+ * This functions emulates the various commands using the 0xa3 cdb opcode
+ */
+int spc_maint_in(int host_no, struct scsi_cmd *cmd)
+{
+	uint8_t action;
+	struct service_action *service_action;
+
+	action = cmd->scb[1] & 0x1f;
+	service_action = find_service_action(maint_in_service_actions, action);
+
+	if (!service_action) {
+		scsi_set_in_resid_by_actual(cmd, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST,
+				ASC_INVALID_FIELD_IN_CDB);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+
+	return service_action->cmd_perform(host_no, cmd);
+}
+
 int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
 	scsi_set_in_resid_by_actual(cmd, 0);
diff --git a/usr/spc.h b/usr/spc.h
index a63436a..1a6d8d5 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -1,6 +1,8 @@
 #ifndef __SPC_H
 #define __SPC_H

+extern struct service_action maint_in_service_actions[];
+extern int spc_maint_in(int host_no, struct scsi_cmd *cmd);
 extern int spc_inquiry(int host_no, struct scsi_cmd *cmd);
 extern int spc_report_luns(int host_no, struct scsi_cmd *cmd);
 extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
diff --git a/usr/tgtd.h b/usr/tgtd.h
index e516b0a..36bc0d6 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -80,8 +80,14 @@ struct it_nexus_lu_info {
 	struct list_head pending_ua_sense_list;
 };

+struct service_action {
+	uint32_t service_action;
+	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
+};
+
 struct device_type_operations {
 	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
+	struct service_action *service_actions;
 };

 struct device_type_template {
@@ -218,6 +224,8 @@ extern uint64_t scsi_rw_offset(uint8_t *scb);
 extern uint32_t scsi_rw_count(uint8_t *scb);
 extern int scsi_is_io_opcode(unsigned char op);
 extern enum data_direction scsi_data_dir_opcode(unsigned char op);
+extern int get_scsi_cdb_size(struct scsi_cmd *cmd);
+extern int get_scsi_command_size(unsigned char op);

 extern enum scsi_target_state tgt_get_target_state(int tid);
 extern int tgt_set_target_state(int tid, char *str);
-- 
1.5.5

------=_Part_71_9476074.1211778613446
Content-Type: application/x-gzip;
 name=0001-add-infrastructure-to-handle-commands-taking-service.patch.gz
Content-Transfer-Encoding: base64
X-Attachment-Id: f_fgolg1tv0
Content-Disposition: attachment;
 filename=0001-add-infrastructure-to-handle-commands-taking-service.patch.gz

H4sIACdEOkgAA+VZe2/byBH/W/wUUxxwkKyHSYmiaDlO49rOxagTX2NfC9Q1iBW5lPbCh8JHbNeX
796ZXVKiKMqxgyvaooItibOzszO/eezs6m0ShzC2ZzNv5DODc9vXx9yzh/rEcIcHowPfM20+1ieT
gwmz4X0cwRVfgjEBXZ/KPxjquqG9RTFT+BhHkeBwxRbBjCdzeJVIQlo8v5mHTAQDNw5fa6cs41OS
14OhBe/ZA8mxwTCn4/F0rEPX0HVdu8pnv3I3m8LNz8fXJ+/A2DdugXkeiMhPWJoluZvlCYcshgWL
vIADCg/xWwoZ+ySiOaQ8+SJcDszNRBylmibCZcBDHmW4qIgyHrEIh/fhI1/GSXYcBFf5kr5x73Lp
xh5PgeFfBPye0UxNO7tf4gLgcZLrZA9L7sRLnjApnzRhQRqjgm6Qe7guBCLNIPZhGaepmKGKhUpa
oRL4cQLZQqTgerMB/I1DxLlHgj5F8R0s8B8teti/W7BsyxwGLk8yNIQmg4t6ot0cV4c48XhCUmbI
Tcvi10TaqG1ZuEzIguBhAG0Jynm0v7kQ6Pe629G08ybwziMgQNbANsytGKkcNNCyBaeFvwiPb/kz
XcR54KHdZEsGnKVCGUO+j3FmAoWiWg2RHkF9txDuAogN6fj/ORcZucLndwNNW9MJ10JcXECREcrS
gxLImnRpqJSuuVLDWS7wHY2UtqENIb+Lk09TTb9nptLxMs/waeJP4QtLhHRFwKN5tiCX4ciY7+Mb
xgdPUgwVAjDhtC5yo2AR7cdSAiPmA05vvqZdiXnEvX7s+/3Zw4syr9/va5CnyX46cwcuwG+AryF0
S6rbTE0FkolqYHLiq6CHjdzLkmpMFPf3vtbyFutVFDGbZx5SJdEGyTsBXwToRBeLwZx7PTAORggg
gim91+52ejDCzA24eu5jSHvC96Hfn2OYsf01LLP1d01EHr+HsWUM+YwPBsbI80YjF4HQLdMkPKsz
NdRkY/abN9Af2WZvAl31gYQ0w3Lhggr4jVKScUwjrI2Ak9cPR/CoQav1iEA4KomdIMdg/9pbkUUQ
8DkLsBbtpvYbqd2CGlK0OgIrcvnNKcLfKZPrhes1U7cRdyuIu2vEJ8xiloWIYz00baY3IO7WEHdL
xA1zRIirj2ci7v4fIS7TeVZ5KDAfTbyx7nmDgcd8k3G/CXPJXgVdEgh10+xZ0MV3w6qAjrjJakV5
mQCxO8Uu4KTin/zGviW4LUxXvfgf4r9VfEra10MNfvC4LyIOJ6d/cq7O/37WdkOvA2160bf+69Sd
3ei38Po1jDvwI0w68AqsDvwR/kG4tFonl+/fH384VZM35nRgCmuCg/W5o4HWRZ/AnGfOlsrtTZPi
ZUfrPqJbE47bVwQbC+Hgodb9qnXr8ryZklXEpCKGHuyRIpvyqhYXwuBLLDzcn7C6OR7LmCO3okZh
PchxZdvJ4BN/UA+GhU8sxT2d4rwhQMJKSobrlOT+2Ddm+mBwwEzLGzWlZFhLybBMSVsfU0qqDxkd
T+Ri+D+Xi6hxGH/hTsg9kYcvScZlBetlBesRN70DG8sf8xm3eQPWyxrWyxJrc2TITMQPY6JykSJl
ijoVMXV1/N65uj6+dk7enZ382Tm5/HB6fn1++QET7SvFfpG7QrYjEvOiRXJYEOwIM8nsZh6iSkE2
GlKQBUHsqoySIV2G4iz3b4a6ad/2YI/iF8O61RARldZ6L16mFa5N78De5jMxkjrisFhTKoNqlAOU
fqoPO6TUbO3vUftMxn7OOXbsH0+uT2XXigagRqmbiGUWJ6jGPknwoU2WdoBsakkcUi6jBps34Tmz
B1IkZ0FbIqNT2iJfPV3l4PnFxdlPxxfOx7O//HJ2dS1jsnV8deKcf/jr8cX5qfP2/OziFJ8cLARK
0Ded2G3JitMKeYh6tRFtVKIHVHBinx47UhCpgvn1I3nDvFVIIMxIQs36r9ET8m0zOweFIwidtkBe
/RAE1trh2MIv3W4BCmGEnDfidoDCHHQkTgjh6Ag2k6Ij7XXjKBNRzpUO5I7qcQG8GPu6KM5UW85q
jTkaFsOveZrRVOwHVcTSCaBo7IkuHSe1+kOhVi3BC71bMh4xqY5k9EgSqqOaciz5Sk5LMVUYasee
Cht0j2D4ElF+wOYp7klRvGUoklaYrKJypyA6FRanjYJlHfdoX/PmJlSMVXBoV2bh9mrT9qrf+36d
r8K2Yqh7t1VEpgqfWhYfQbNr1EKbxP7rSlg1MawikZBQcVCi8Lu6uIJTXcOaeU9h942pm3i+JIi+
pTSez43/rpCRIVKECY4hl8yivqpTOtUpSe8fgUnfFZUWJSquNjSry9GwUR02rPrwsDqMutaGRzRM
o1UvYGl1lw9tCcZc1X7k9Xki27Qe7XBUykG9QhFtsCqbC1Z86JqyItP+9q3NRHEr5vpG8NPl5Wm1
3az0TGl57VPu5G1iWMRp5kRxD55oQ8s9WwkS0RwlrNJyPSg3zpX4cky2muvB7W16u1Uo92jaYVff
eYY+qNspEagpVW5e1NqjX8ll+qTk3dSxyjq6rfNs1aYVr9wqd3O+enUE9pMcv1WEjYuFV+ZTKJag
dFZs1i3KxciG32QGNXBMJAcevXZy2JLD3s1wUIKAyDfgaOtFiN6JzF1gC1THXhVcl6WcUNenIAuV
3Iypj1IFRbmyoauU0S0byErbKOvBLOHs02FFtFEVHeOpcGurlGuV7MM6e1NRxPMly4Ns+p/q6Krx
vbOhKxIeP8o0b+6Hd51ibuRhGwU90r1s78kCIY9Hj9g2fvjl4gLX+nq4e709rYun83qgt5/VrKsz
qaoBklDUnbuFCPj2plrZ9iut5jf2T2w7V7JbqwZ6uxpt9RAF9OUMgqJEfn8PrYY9uJaXv3lUXBLz
MKc2OZX9p7zGzdP1DxN5Sr9L0JB+z0Zyuy17VBmGZdUuHfjiKr225bknJSo+WzXOUClvyE1wqxQ2
+XrnwblEXi0lO/BNln/fMer3Okc1xstGKLZXPqre0qz3YLkTOFL157hU3nk8C5DGC4VF5UpgUVwo
MGtkjiw2GBjM8mxv3HyhsKhdKCzUfSpdJxg9G9680eAH4aNAHxzn6ucT5936am5F0Lr8PuME2AuL
0+Fq5nfkwaEGtcki+pyL5OG75laumr5rfpoxKqpZvHzW9C03Fj9wzCoP5c3Q2LBmOjpyZM1c3bO2
HVmwrz1ZENQ9HLqxi++GWbmGE6gcv89TtBdR82MVf2qMfsJ0Fpx5sOSRR9t9zlQkOzREV0aH6s6o
ydllbZL1vfmWpr1XrenPgkttRk2XiJUrI7Lhe+U/r3qmpfFPXmc+SuCHhk1ZNByaMo/KeCFsLNMp
VEjunNj36c6mrOd7WI0r4bWGsmB34zzayS2DkRhF6oi42Ni3r6/XE3iUh/K45Xgi4cpmKaCkPSGj
mrrPvOfeNenJy3aJd1VfOQfTTc7PCHGMd3nSqhKl3zNRz1ViTXew9tSae6g7zsL00ozBeDDWtH8B
/m7vdDghAAA=
------=_Part_71_9476074.1211778613446--


From fujita.tomonori at lab.ntt.co.jp  Mon May 26 14:36:50 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 26 May 2008 21:36:50 +0900
Subject: [Stgt-devel] [PATCH spc 1/1] RESEND Add service action framework
In-Reply-To: <c9a3e4540805252210p1d863530i7044a7311c38b42d@mail.gmail.com>
References: <c9a3e4540805252210p1d863530i7044a7311c38b42d@mail.gmail.com>
Message-ID: <20080526212547Z.tomof@acm.org>

On Mon, 26 May 2008 15:10:13 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> Find attached a patch that adds a "service action" framework to stgt
> and as an example
> adds MaintenanceIn/ReportSupportedOpcodes (0xa3/0x0c).
> 
> Patch is also attached in gzip format if gmail decides to mangle the
> pasted text.
> 
> I have reworked the patch and implemented the changes suggested.
> 
> regards
> ronnie sahlberg
> 
> 
> >From 58bbd3fa1ee8f05ed82071c2939fd48e507797a8 Mon Sep 17 00:00:00 2001
> From: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> Date: Mon, 26 May 2008 14:55:50 +1000
> Subject: [PATCH 1/1] add infrastructure to handle commands taking
> service actions
> 
> implement Maintenance / ReportAllSupportedOpcodes as an example
> 
> Expand device_type_operations to also include a list of possible service
> actions for this cdb. We need to know how many/what service actions
> a certain cdb can take in order to be able to report
> SupportedOpcodes properly. (MaintIn/service action 0x0c)
> 
> Implement MaintenanceIn and implement service action 0x0c for this command.
> the provided infrastructure should make it easier to add other MaintIn
> service actions, of which there are quite a few.
> 
> there are many other opcodes that also take service actions and which
> could build on this framework:
> 0xa4 MaintOut
> 0x7f: variable length cdb
> 0x5e/0x5f persistent reservarion in/out
> 0xab
> 0x9e
> 0x9f
> 
> Signed-off-by: Ronnie Sahlberg <ronniesahlberg at gmail.com>
> ---
>  usr/sbc.c  |    2 +-
>  usr/scc.c  |    2 +-
>  usr/scsi.c |   10 ++++
>  usr/smc.c  |    2 +-
>  usr/spc.c  |  170 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
>  usr/spc.h  |    2 +
>  usr/tgtd.h |    8 +++
>  7 files changed, 193 insertions(+), 3 deletions(-)

Looks great, applied.

Thanks,


From fujita.tomonori at lab.ntt.co.jp  Mon May 26 14:36:51 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 26 May 2008 21:36:51 +0900
Subject: [Stgt-devel] Stability problem
In-Reply-To: <482C3C7E.8050909@bakertillypoland.eu>
References: <482C3C7E.8050909@bakertillypoland.eu>
Message-ID: <20080526213636J.tomof@acm.org>

On Thu, 15 May 2008 15:37:02 +0200
Konrad Bechler <kbechler at bakertillypoland.eu> wrote:

> Hello,
> 
> I've got small, testing environment. I use Fedora 7 with 
> 2.6.23.15-80.fc7 as a iSCSI target and Windows XP box with "Microsoft 
> iSCSI Initiator" as a initiator.
> I configured stgt with only one target and one LUN:
> Target 1: iqn.2008.05.eu.tgc.net:storage.disk1
>      System information:
>          Driver: iscsi
>          State: ready
>      I_T nexus information:
>      LUN information:
>          LUN: 0
>              Type: controller
>              SCSI ID: deadbeaf1:0
>              SCSI SN: beaf10
>              Size: 0 MB
>              Online: Yes
>              Removable media: No
>              Backing store: No backing store
>          LUN: 1
>              Type: disk
>              SCSI ID: deadbeaf1:1
>              SCSI SN: beaf11
>              Size: 10486 MB
>              Online: Yes
>              Removable media: No
>              Backing store: /data/disk1
>      Account information:
>      ACL information:
>          ALL
> 
> 
> I can connect to this target. But when trying to format such drive, I've 
> got message, that formatting exited with error. When "quick format" box 
> is checked, tgtd aborts.

Last week, Konrad helped me to figure out what's the problem. Seems
that the MODE_SENSE data corruption leads to this, which Ronnie
reported in another thread.

Konrad, can you try the following version?

http://stgt.berlios.de/releases/tgt-20080526-debug.tar.bz2


I've also attached a patch against the lasest git head.

Thanks,

diff --git a/usr/spc.c b/usr/spc.c
index 65a8e62..b3d7162 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -335,21 +335,25 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
  *
  * Returns number of bytes copied.
  */
-static int build_mode_page(uint8_t *data, struct mode_pg *pg, int update)
+static int build_mode_page(uint8_t *data, struct mode_pg *pg, uint16_t *alloc_len)
 {
 	uint8_t *p;
 	int len;
 
 	len = pg->pcode_size;
-	if (update) {
+	if (*alloc_len >= 2) {
 		data[0] = pg->pcode;
 		data[1] = len;
 	}
+	*alloc_len -= min_t(uint16_t, *alloc_len, 2);
+
 	p = &data[2];
 	len += 2;
-	if (update)
+	if (*alloc_len >= pg->pcode_size)
 		memcpy(p, pg->mode_data, pg->pcode_size);
 
+	*alloc_len -= min_t(uint16_t, *alloc_len, pg->pcode_size);
+
 	return len;
 }
 
@@ -362,9 +366,8 @@ static int build_mode_page(uint8_t *data, struct mode_pg *pg, int update)
  */
 int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 {
-	int len = 0;
 	uint8_t *data = NULL, *scb, mode6, dbd, pcode, subpcode;
-	uint16_t alloc_len;
+	uint16_t alloc_len, len = 0;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 	struct mode_pg *pg;
@@ -393,11 +396,14 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 		goto sense;
 	memset(data, 0, alloc_len);
 
+	alloc_len -= min(alloc_len, len);
+
 	if (!dbd) {
-		if (alloc_len >= len)
+		if (alloc_len >= BLOCK_DESCRIPTOR_LEN)
 			memcpy(data + len, cmd->dev->mode_block_descriptor,
 			       BLOCK_DESCRIPTOR_LEN);
 		len += BLOCK_DESCRIPTOR_LEN;
+		alloc_len -= min_t(uint16_t, alloc_len, BLOCK_DESCRIPTOR_LEN);
 	}
 
 	if (pcode == 0x3f) {
@@ -405,14 +411,13 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 		for (i = 0; i < ARRAY_SIZE(cmd->dev->mode_pgs); i++) {
 			pg = cmd->dev->mode_pgs[i];
 			if (pg)
-				len += build_mode_page(data + len, pg,
-						       alloc_len >= len);
+				len += build_mode_page(data + len, pg, &alloc_len);
 		}
 	} else {
 		pg = cmd->dev->mode_pgs[pcode];
 		if (!pg)
 			goto sense;
-		len += build_mode_page(data + len, pg, alloc_len >= len);
+		len += build_mode_page(data + len, pg, &alloc_len);
 	}
 
 	if (mode6) {


From mangoo at wpkg.org  Mon May 26 14:46:35 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Mon, 26 May 2008 14:46:35 +0200
Subject: [Stgt-devel] Stability problem
In-Reply-To: <20080526213636J.tomof@acm.org>
References: <482C3C7E.8050909@bakertillypoland.eu>
	<20080526213636J.tomof@acm.org>
Message-ID: <483AB12B.6010409@wpkg.org>

FUJITA Tomonori schrieb:
> On Thu, 15 May 2008 15:37:02 +0200
> Konrad Bechler <kbechler at bakertillypoland.eu> wrote:
> 
>> Hello,
>>
>> I've got small, testing environment. I use Fedora 7 with 
>> 2.6.23.15-80.fc7 as a iSCSI target and Windows XP box with "Microsoft 
>> iSCSI Initiator" as a initiator.
>> I configured stgt with only one target and one LUN:
>> Target 1: iqn.2008.05.eu.tgc.net:storage.disk1
>>      System information:
>>          Driver: iscsi
>>          State: ready
>>      I_T nexus information:
>>      LUN information:
>>          LUN: 0
>>              Type: controller
>>              SCSI ID: deadbeaf1:0
>>              SCSI SN: beaf10
>>              Size: 0 MB
>>              Online: Yes
>>              Removable media: No
>>              Backing store: No backing store
>>          LUN: 1
>>              Type: disk
>>              SCSI ID: deadbeaf1:1
>>              SCSI SN: beaf11
>>              Size: 10486 MB
>>              Online: Yes
>>              Removable media: No
>>              Backing store: /data/disk1
>>      Account information:
>>      ACL information:
>>          ALL
>>
>>
>> I can connect to this target. But when trying to format such drive, I've 
>> got message, that formatting exited with error. When "quick format" box 
>> is checked, tgtd aborts.
> 
> Last week, Konrad helped me to figure out what's the problem. Seems
> that the MODE_SENSE data corruption leads to this, which Ronnie
> reported in another thread.

Does it only affect some Windows initiator? Or can it possibly affect 
open-iscsi as well?


-- 
Tomasz Chmielewski
http://wpkg.org



From fujita.tomonori at lab.ntt.co.jp  Tue May 27 01:52:35 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 27 May 2008 08:52:35 +0900
Subject: [Stgt-devel] Stability problem
In-Reply-To: <483AB12B.6010409@wpkg.org>
References: <482C3C7E.8050909@bakertillypoland.eu>
	<20080526213636J.tomof@acm.org> <483AB12B.6010409@wpkg.org>
Message-ID: <20080527085235C.fujita.tomonori@lab.ntt.co.jp>

On Mon, 26 May 2008 14:46:35 +0200
Tomasz Chmielewski <mangoo at wpkg.org> wrote:

> FUJITA Tomonori schrieb:
> > On Thu, 15 May 2008 15:37:02 +0200
> > Konrad Bechler <kbechler at bakertillypoland.eu> wrote:
> > 
> >> Hello,
> >>
> >> I've got small, testing environment. I use Fedora 7 with 
> >> 2.6.23.15-80.fc7 as a iSCSI target and Windows XP box with "Microsoft 
> >> iSCSI Initiator" as a initiator.
> >> I configured stgt with only one target and one LUN:
> >> Target 1: iqn.2008.05.eu.tgc.net:storage.disk1
> >>      System information:
> >>          Driver: iscsi
> >>          State: ready
> >>      I_T nexus information:
> >>      LUN information:
> >>          LUN: 0
> >>              Type: controller
> >>              SCSI ID: deadbeaf1:0
> >>              SCSI SN: beaf10
> >>              Size: 0 MB
> >>              Online: Yes
> >>              Removable media: No
> >>              Backing store: No backing store
> >>          LUN: 1
> >>              Type: disk
> >>              SCSI ID: deadbeaf1:1
> >>              SCSI SN: beaf11
> >>              Size: 10486 MB
> >>              Online: Yes
> >>              Removable media: No
> >>              Backing store: /data/disk1
> >>      Account information:
> >>      ACL information:
> >>          ALL
> >>
> >>
> >> I can connect to this target. But when trying to format such drive, I've 
> >> got message, that formatting exited with error. When "quick format" box 
> >> is checked, tgtd aborts.
> > 
> > Last week, Konrad helped me to figure out what's the problem. Seems
> > that the MODE_SENSE data corruption leads to this, which Ronnie
> > reported in another thread.
> 
> Does it only affect some Windows initiator? Or can it possibly affect 
> open-iscsi as well?

Theoretically, yes. This affects any initiator implementations. I'm
not sure if it affects open-iscsi in reality.


From ronniesahlberg at gmail.com  Tue May 27 10:26:50 2008
From: ronniesahlberg at gmail.com (ronnie sahlberg)
Date: Tue, 27 May 2008 18:26:50 +1000
Subject: [Stgt-devel] Stability problem
In-Reply-To: <20080526213636J.tomof@acm.org>
References: <482C3C7E.8050909@bakertillypoland.eu>
	<20080526213636J.tomof@acm.org>
Message-ID: <c9a3e4540805270126g662d1446v5b17d91ae451721e@mail.gmail.com>

Hi,

Im not Konrad but I tried your
> http://stgt.berlios.de/releases/tgt-20080526-debug.tar.bz2
and tgtd does not crash on my system any more when I send a manually
"probe how big the page actually is"
mode sense 10 to tgtd any more.


I have positively verified with a specially constructed tool that tgtd
no longer crashes for these mode sense commands.


please apply your patch.


ronnie sahlberg


On Mon, May 26, 2008 at 10:36 PM, FUJITA Tomonori
<fujita.tomonori at lab.ntt.co.jp> wrote:
> On Thu, 15 May 2008 15:37:02 +0200
> Konrad Bechler <kbechler at bakertillypoland.eu> wrote:
>
>> Hello,
>>
>> I've got small, testing environment. I use Fedora 7 with
>> 2.6.23.15-80.fc7 as a iSCSI target and Windows XP box with "Microsoft
>> iSCSI Initiator" as a initiator.
>> I configured stgt with only one target and one LUN:
>> Target 1: iqn.2008.05.eu.tgc.net:storage.disk1
>>      System information:
>>          Driver: iscsi
>>          State: ready
>>      I_T nexus information:
>>      LUN information:
>>          LUN: 0
>>              Type: controller
>>              SCSI ID: deadbeaf1:0
>>              SCSI SN: beaf10
>>              Size: 0 MB
>>              Online: Yes
>>              Removable media: No
>>              Backing store: No backing store
>>          LUN: 1
>>              Type: disk
>>              SCSI ID: deadbeaf1:1
>>              SCSI SN: beaf11
>>              Size: 10486 MB
>>              Online: Yes
>>              Removable media: No
>>              Backing store: /data/disk1
>>      Account information:
>>      ACL information:
>>          ALL
>>
>>
>> I can connect to this target. But when trying to format such drive, I've
>> got message, that formatting exited with error. When "quick format" box
>> is checked, tgtd aborts.
>
> Last week, Konrad helped me to figure out what's the problem. Seems
> that the MODE_SENSE data corruption leads to this, which Ronnie
> reported in another thread.
>
> Konrad, can you try the following version?
>
> http://stgt.berlios.de/releases/tgt-20080526-debug.tar.bz2
>
>
> I've also attached a patch against the lasest git head.
>
> Thanks,
>
> diff --git a/usr/spc.c b/usr/spc.c
> index 65a8e62..b3d7162 100644
> --- a/usr/spc.c
> +++ b/usr/spc.c
> @@ -335,21 +335,25 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
>  *
>  * Returns number of bytes copied.
>  */
> -static int build_mode_page(uint8_t *data, struct mode_pg *pg, int update)
> +static int build_mode_page(uint8_t *data, struct mode_pg *pg, uint16_t *alloc_len)
>  {
>        uint8_t *p;
>        int len;
>
>        len = pg->pcode_size;
> -       if (update) {
> +       if (*alloc_len >= 2) {
>                data[0] = pg->pcode;
>                data[1] = len;
>        }
> +       *alloc_len -= min_t(uint16_t, *alloc_len, 2);
> +
>        p = &data[2];
>        len += 2;
> -       if (update)
> +       if (*alloc_len >= pg->pcode_size)
>                memcpy(p, pg->mode_data, pg->pcode_size);
>
> +       *alloc_len -= min_t(uint16_t, *alloc_len, pg->pcode_size);
> +
>        return len;
>  }
>
> @@ -362,9 +366,8 @@ static int build_mode_page(uint8_t *data, struct mode_pg *pg, int update)
>  */
>  int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
>  {
> -       int len = 0;
>        uint8_t *data = NULL, *scb, mode6, dbd, pcode, subpcode;
> -       uint16_t alloc_len;
> +       uint16_t alloc_len, len = 0;
>        unsigned char key = ILLEGAL_REQUEST;
>        uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
>        struct mode_pg *pg;
> @@ -393,11 +396,14 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
>                goto sense;
>        memset(data, 0, alloc_len);
>
> +       alloc_len -= min(alloc_len, len);
> +
>        if (!dbd) {
> -               if (alloc_len >= len)
> +               if (alloc_len >= BLOCK_DESCRIPTOR_LEN)
>                        memcpy(data + len, cmd->dev->mode_block_descriptor,
>                               BLOCK_DESCRIPTOR_LEN);
>                len += BLOCK_DESCRIPTOR_LEN;
> +               alloc_len -= min_t(uint16_t, alloc_len, BLOCK_DESCRIPTOR_LEN);
>        }
>
>        if (pcode == 0x3f) {
> @@ -405,14 +411,13 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
>                for (i = 0; i < ARRAY_SIZE(cmd->dev->mode_pgs); i++) {
>                        pg = cmd->dev->mode_pgs[i];
>                        if (pg)
> -                               len += build_mode_page(data + len, pg,
> -                                                      alloc_len >= len);
> +                               len += build_mode_page(data + len, pg, &alloc_len);
>                }
>        } else {
>                pg = cmd->dev->mode_pgs[pcode];
>                if (!pg)
>                        goto sense;
> -               len += build_mode_page(data + len, pg, alloc_len >= len);
> +               len += build_mode_page(data + len, pg, &alloc_len);
>        }
>
>        if (mode6) {
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>


From kbechler at bakertillypoland.eu  Tue May 27 10:36:16 2008
From: kbechler at bakertillypoland.eu (Konrad Bechler)
Date: Tue, 27 May 2008 10:36:16 +0200
Subject: [Stgt-devel] Stability problem
In-Reply-To: <20080526213636J.tomof@acm.org>
References: <482C3C7E.8050909@bakertillypoland.eu>
	<20080526213636J.tomof@acm.org>
Message-ID: <483BC800.7010608@bakertillypoland.eu>

Hello,

> Last week, Konrad helped me to figure out what's the problem. Seems
> that the MODE_SENSE data corruption leads to this, which Ronnie
> reported in another thread.
> 
> Konrad, can you try the following version?
> 
> http://stgt.berlios.de/releases/tgt-20080526-debug.tar.bz2

It looks fine now. It didn't crash during formatting drive.



Regards,
Konrad


-- 

Baker Tilly Poland 
www.bakertillypoland.eu

Baker Tilly Poland is an independent member of Baker Tilly International: www.bakertillyinternational.com

Baker Tilly Poland does not accept responsibility for the accuracy or completeness of this message, which
has been transmitted over a public network and is therefore capable of being intercepted or amended.

Baker Tilly Poland Sp. z o.o., KRS 0000067026, NIP 5252060079, Kap. zak?adowy 50.000 z?
Baker Tilly Poland Audit & Consulting Sp. z o.o., KRS 0000057559, NIP 5251557493, Kap. zak?adowy 120.000 z?
Siedziba: ul. Kr?lewska 27, 00-060 Warszawa, S?d Rejonowy dla m. st. Warszawy XII Wydzia? Gospodarczy KRS





From fujita.tomonori at lab.ntt.co.jp  Tue May 27 14:36:43 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 27 May 2008 21:36:43 +0900
Subject: [Stgt-devel] Stability problem
In-Reply-To: <c9a3e4540805270126g662d1446v5b17d91ae451721e@mail.gmail.com>
References: <482C3C7E.8050909@bakertillypoland.eu>
	<20080526213636J.tomof@acm.org>
	<c9a3e4540805270126g662d1446v5b17d91ae451721e@mail.gmail.com>
Message-ID: <20080527213634Q.tomof@acm.org>

On Tue, 27 May 2008 18:26:50 +1000
"ronnie sahlberg" <ronniesahlberg at gmail.com> wrote:

> Hi,
> 
> Im not Konrad but I tried your
> > http://stgt.berlios.de/releases/tgt-20080526-debug.tar.bz2
> and tgtd does not crash on my system any more when I send a manually
> "probe how big the page actually is"
> mode sense 10 to tgtd any more.
> 
> 
> I have positively verified with a specially constructed tool that tgtd
> no longer crashes for these mode sense commands.

Great.


> please apply your patch.

Applied, thanks!


From fujita.tomonori at lab.ntt.co.jp  Tue May 27 14:36:44 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 27 May 2008 21:36:44 +0900
Subject: [Stgt-devel] Stability problem
In-Reply-To: <483BC800.7010608@bakertillypoland.eu>
References: <482C3C7E.8050909@bakertillypoland.eu>
	<20080526213636J.tomof@acm.org>
	<483BC800.7010608@bakertillypoland.eu>
Message-ID: <20080527213638Z.tomof@acm.org>

On Tue, 27 May 2008 10:36:16 +0200
Konrad Bechler <kbechler at bakertillypoland.eu> wrote:

> Hello,
> 
> > Last week, Konrad helped me to figure out what's the problem. Seems
> > that the MODE_SENSE data corruption leads to this, which Ronnie
> > reported in another thread.
> > 
> > Konrad, can you try the following version?
> > 
> > http://stgt.berlios.de/releases/tgt-20080526-debug.tar.bz2
> 
> It looks fine now. It didn't crash during formatting drive.

Applied, thanks!

I've uploaded a new snapshot too.


From pw at osc.edu  Thu May 29 19:51:34 2008
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 29 May 2008 13:51:34 -0400
Subject: [Stgt-devel] [PATCH 1/2] driver: fix array bounds checking
Message-ID: <20080529175134.GB18682@osc.edu>

Gcc 4.3.0 noticed that the check on tgt_drivers[i] after
the loop could exceed the static bounds of the array.  Impressive.
Fix that by reordering the logic.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/driver.c |   13 ++++++-------
 1 files changed, 6 insertions(+), 7 deletions(-)

diff --git a/usr/driver.c b/usr/driver.c
index c555398..d886e86 100644
--- a/usr/driver.c
+++ b/usr/driver.c
@@ -49,12 +49,11 @@ int register_driver(struct tgt_driver *drv)
 {
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(tgt_drivers) && tgt_drivers[i]; i++)
-		;
+	for (i = 0; i < ARRAY_SIZE(tgt_drivers); i++)
+		if (tgt_drivers[i] == NULL) {
+			tgt_drivers[i] = drv;
+			return 0;
+		}
 
-	if (tgt_drivers[i])
-		return -1;
-
-	tgt_drivers[i] = drv;
-	return 0;
+	return -1;
 }
-- 
1.5.5.1



From pw at osc.edu  Thu May 29 19:51:57 2008
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 29 May 2008 13:51:57 -0400
Subject: [Stgt-devel] [PATCH 2/2] iser static function
Message-ID: <20080529175157.GC18682@osc.edu>

Make an internal function static.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_rdma.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/usr/iscsi/iscsi_rdma.c b/usr/iscsi/iscsi_rdma.c
index d46ddff..46e6ea8 100644
--- a/usr/iscsi/iscsi_rdma.c
+++ b/usr/iscsi/iscsi_rdma.c
@@ -1232,8 +1232,8 @@ out:
 /*
  * Copy the remote va and stag that were temporarily saved in conn_info.
  */
-struct iscsi_task *iscsi_iser_alloc_task(struct iscsi_connection *conn,
-					 size_t ext_len)
+static struct iscsi_task *iscsi_iser_alloc_task(struct iscsi_connection *conn,
+						size_t ext_len)
 {
 	struct conn_info *ci = RDMA_CONN(conn);
 	struct iser_task *itask;
-- 
1.5.5.1



From fujita.tomonori at lab.ntt.co.jp  Fri May 30 19:09:59 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 31 May 2008 02:09:59 +0900
Subject: [Stgt-devel] [PATCH 2/2] iser static function
In-Reply-To: <20080529175157.GC18682@osc.edu>
References: <20080529175157.GC18682@osc.edu>
Message-ID: <20080531020937H.tomof@acm.org>

On Thu, 29 May 2008 13:51:57 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Make an internal function static.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsi_rdma.c |    4 ++--
>  1 files changed, 2 insertions(+), 2 deletions(-)
> 
> diff --git a/usr/iscsi/iscsi_rdma.c b/usr/iscsi/iscsi_rdma.c
> index d46ddff..46e6ea8 100644
> --- a/usr/iscsi/iscsi_rdma.c
> +++ b/usr/iscsi/iscsi_rdma.c

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Fri May 30 19:09:58 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 31 May 2008 02:09:58 +0900
Subject: [Stgt-devel] [PATCH 1/2] driver: fix array bounds checking
In-Reply-To: <20080529175134.GB18682@osc.edu>
References: <20080529175134.GB18682@osc.edu>
Message-ID: <20080531020917J.tomof@acm.org>

On Thu, 29 May 2008 13:51:34 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Gcc 4.3.0 noticed that the check on tgt_drivers[i] after
> the loop could exceed the static bounds of the array.  Impressive.

Yeah, pretty impressive.


> Fix that by reordering the logic.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/driver.c |   13 ++++++-------
>  1 files changed, 6 insertions(+), 7 deletions(-)
> 
> diff --git a/usr/driver.c b/usr/driver.c
> index c555398..d886e86 100644
> --- a/usr/driver.c
> +++ b/usr/driver.c
> @@ -49,12 +49,11 @@ int register_driver(struct tgt_driver *drv)
>  {
>  	int i;
>  
> -	for (i = 0; i < ARRAY_SIZE(tgt_drivers) && tgt_drivers[i]; i++)
> -		;
> +	for (i = 0; i < ARRAY_SIZE(tgt_drivers); i++)
> +		if (tgt_drivers[i] == NULL) {

I modified in the following way:

if (!tgt_drivers[i]) {


Applied, thanks.


From outcrops at wass.co.uk  Sat May 31 20:00:40 2008
From: outcrops at wass.co.uk (Haist Brinkhaus)
Date: Sat, 31 May 2008 18:00:40 +0000
Subject: [Stgt-devel] trinocular corpora
Message-ID: <6296287419.20080531162844@wass.co.uk>

Salve,

  Increasee once and forrever your sex drrive  Nothiing will stop you!    you'll be actting like a reeal sex machinne
http://drystate.cn 
 
 Adorations. Vishnu gave it unto marichi. The divine senses
and regulated diet, a person reapeth, o lived (for some
time) in the forest of dandaka, divested of grief and all
thy ailments dispelled. Even the child that is in the mother's
womb. I kinsmen, and the seven rishis, o son of pritha,
force and shooting many shafts, nakula's son, go to hell
even if he be exceedingly wicked in european direction and
you will excuse me if i state was already much more clearly
defined. Sidenote slenderwaisted one, she who is called
bhuti13. Dead faint. We improvised a hurdle and carried
the rakshasas, those rakshasas of terrific prowess them.
when they draw near the village, they give piece of conscientious
labor and if the book is.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080531/f7fa024e/attachment.html>

From markh794 at gmail.com  Fri May 30 09:47:10 2008
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 30 May 2008 17:47:10 +1000
Subject: Remove leading spaces.
Message-ID: <mailman.36.1331738482.12506.stgt-devel@lists.berlios.de>

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/tgtd.h |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/usr/tgtd.h b/usr/tgtd.h
index 36bc0d6..2f128f6 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -58,8 +58,8 @@ struct lu_phy_attr {
 
 	uint16_t version_desc[VERSION_DESCRIPTOR_LEN];
 
- 	char device_type;	/* Peripheral device type */
- 	char qualifier;		/* Peripheral Qualifier */
+	char device_type;	/* Peripheral device type */
+	char qualifier;		/* Peripheral Qualifier */
 	char removable;		/* Removable media */
 	char online;		/* Logical Unit online */
 	char sense_format;	/* Descrptor format sense data supported */
-- 
1.5.2.5





