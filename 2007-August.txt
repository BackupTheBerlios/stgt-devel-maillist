From tomof at acm.org  Thu Aug  2 07:25:14 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Thu, 2 Aug 2007 14:25:14 +0900
Subject: [Stgt-devel] [PATCH] spt warning fix
In-Reply-To: <20070730172944.GB12789@osc.edu>
References: <20070730172911.GA12789@osc.edu> <20070730172944.GB12789@osc.edu>
Message-ID: <20070801130245A.tomof@acm.org>

On Mon, 30 Jul 2007 13:29:44 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Remove unused variable.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/spt.c |    1 -
>  1 files changed, 0 insertions(+), 1 deletions(-)

Applied.


From tomof at acm.org  Thu Aug  2 07:25:23 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Thu, 2 Aug 2007 14:25:23 +0900
Subject: [Stgt-devel] [PATCH] silence gcc
In-Reply-To: <20070730173044.GE12789@osc.edu>
References: <20070730172911.GA12789@osc.edu> <20070730173044.GE12789@osc.edu>
Message-ID: <20070801130331V.tomof@acm.org>

On Mon, 30 Jul 2007 13:30:44 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Avoid bogus unused variable warning from gcc.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsid.c |    2 +-
>  usr/spc.c          |    2 +-
>  2 files changed, 2 insertions(+), 2 deletions(-)

Applied, thanks.


From tomof at acm.org  Thu Aug  2 07:25:20 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Thu, 2 Aug 2007 14:25:20 +0900
Subject: [Stgt-devel] [PATCH] remove unneeded kernel header
In-Reply-To: <20070730173026.GD12789@osc.edu>
References: <20070730172911.GA12789@osc.edu> <20070730173026.GD12789@osc.edu>
Message-ID: <20070801130307B.tomof@acm.org>

On Mon, 30 Jul 2007 13:30:26 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> This netlink header is unused and causes build problems on old machines.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/target.c |    1 -
>  1 files changed, 0 insertions(+), 1 deletions(-)

Applied, thanks.


From tomof at acm.org  Thu Aug  2 07:25:26 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Thu, 2 Aug 2007 14:25:26 +0900
Subject: [Stgt-devel] [PATCH] iscsi no zero data buffer
In-Reply-To: <20070730173110.GF12789@osc.edu>
References: <20070730172911.GA12789@osc.edu> <20070730173110.GF12789@osc.edu>
Message-ID: <20070801130453O.tomof@acm.org>

On Mon, 30 Jul 2007 13:31:10 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Avoid zeroing out all the bytes of every incoming and outgoing data
> buffer.  This has a measurable performance impact.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsid.c |    3 ++-
>  1 files changed, 2 insertions(+), 1 deletions(-)

Applied, thanks.

Surely this degrade the performance unnecessarily.


From tomof at acm.org  Thu Aug  2 07:25:29 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Thu, 2 Aug 2007 14:25:29 +0900
Subject: [Stgt-devel] [PATCH] iscsi no spin with async bs
In-Reply-To: <20070730173144.GG12789@osc.edu>
References: <20070730172911.GA12789@osc.edu> <20070730173144.GG12789@osc.edu>
Message-ID: <20070801130703Q.tomof@acm.org>

On Mon, 30 Jul 2007 13:31:44 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> A missing call to tgt_event_modify(fd, EPOLLIN) is added.  Without this, an
> asynchronous backing store would cause tgtd to spin in epoll, always
> reporting EPOLLOUT on the socket but having nothing to write.  When the
> thread completes the command, the bs will cause cmd_done, turning EPOLLOUT
> back on.
> 
> No change for synchronous backing stores, as epoll does not get called
> until the command completes.
> 
> It would also spin briefly waiting for the rest of the unsolicited packets,
> in both sync and async cases.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsid.c |   10 +++++-----
>  1 files changed, 5 insertions(+), 5 deletions(-)

Applied, thanks.

BTW, I think that all the backing store code works asynchronously.


From tomof at acm.org  Thu Aug  2 07:25:33 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Thu, 2 Aug 2007 14:25:33 +0900
Subject: [Stgt-devel] [PATCH] fix no blkgetsize64
In-Reply-To: <20070730173006.GC12789@osc.edu>
References: <20070730172911.GA12789@osc.edu> <20070730173006.GC12789@osc.edu>
Message-ID: <20070801131019X.tomof@acm.org>

On Mon, 30 Jul 2007 13:30:06 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Fix build for old machines that do not have 64-bit BLKGETSIZE.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/util.c |   10 ++++++++++
>  1 files changed, 10 insertions(+), 0 deletions(-)

Thanks, I don't want to add another ifdef to *.c files (we already
have some and I want to remove them).

Adding ifdef to header files is ok, but do we really need to support
old stuff?


From tomof at acm.org  Thu Aug  2 07:34:07 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Thu, 2 Aug 2007 14:34:07 +0900
Subject: [Stgt-devel] iser patches
In-Reply-To: <20070730185449.GN12789@osc.edu>
References: <20070730185449.GN12789@osc.edu>
Message-ID: <20070801131915D.tomof@acm.org>

On Mon, 30 Jul 2007 14:54:49 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Here are the seven patches that make up the iSER changes.  They sit
> on top of the previous six in the misc-fixes branch.
> 
> Full tree at git://git.osc.edu/tgt .  Please review, for eventual
> inclusion in STGT.

Great! I'll do.


From agr at powerkom-dd.de  Thu Aug  2 08:48:33 2007
From: agr at powerkom-dd.de (Arne Redlich)
Date: Thu, 02 Aug 2007 08:48:33 +0200
Subject: [Stgt-devel] [PATCH] fix no blkgetsize64
In-Reply-To: <20070730173006.GC12789@osc.edu> (Pete Wyckoff's message of "Mon\,
	30 Jul 2007 13\:30\:06 -0400")
References: <20070730172911.GA12789@osc.edu> <20070730173006.GC12789@osc.edu>
Message-ID: <87abtajuta.fsf@powerkom-dd.de>

Pete Wyckoff <pw at osc.edu> writes:

> Fix build for old machines that do not have 64-bit BLKGETSIZE.
>
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/util.c |   10 ++++++++++
>  1 files changed, 10 insertions(+), 0 deletions(-)
>
> diff --git a/usr/util.c b/usr/util.c
> index 9f54820..54bf399 100644
> --- a/usr/util.c
> +++ b/usr/util.c
> @@ -101,11 +101,21 @@ int backed_file_open(char *path, int oflag, uint64_t *size)
>  	if (S_ISREG(st.st_mode))
>  		*size = st.st_size;
>  	else if (S_ISBLK(st.st_mode)) {
> +#ifdef BLKGETSIZE64
>  		err = ioctl(fd, BLKGETSIZE64, size);
>  		if (err < 0) {
>  			eprintf("Cannot get size, %m\n");
>  			goto close_fd;
>  		}
> +#else
> +		unsigned long usize;
> +		err = ioctl(fd, BLKGETSIZE, &usize);
> +		if (err < 0) {
> +			eprintf("Cannot get size (ulong), %m\n");
> +			goto close_fd;
> +		}
> +		*size = usize;
> +#endif

Unfortunately there's a minor but nasty bug in here: BLKGETSIZE64 returns
the size in bytes, while BLKGETSIZE returns the number of sectors -
cf. linux/fs.h.

Arne


From pw at osc.edu  Thu Aug  2 15:57:24 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 2 Aug 2007 09:57:24 -0400
Subject: [Stgt-devel] [PATCH] fix no blkgetsize64
In-Reply-To: <87abtajuta.fsf@powerkom-dd.de>
References: <20070730172911.GA12789@osc.edu> <20070730173006.GC12789@osc.edu>
	<87abtajuta.fsf@powerkom-dd.de>
Message-ID: <20070802135724.GA23844@osc.edu>

agr at powerkom-dd.de wrote on Thu, 02 Aug 2007 08:48 +0200:
> Pete Wyckoff <pw at osc.edu> writes:
> 
> > Fix build for old machines that do not have 64-bit BLKGETSIZE.
> >
> > Signed-off-by: Pete Wyckoff <pw at osc.edu>
> > ---
> >  usr/util.c |   10 ++++++++++
> >  1 files changed, 10 insertions(+), 0 deletions(-)
> >
> > diff --git a/usr/util.c b/usr/util.c
> > index 9f54820..54bf399 100644
> > --- a/usr/util.c
> > +++ b/usr/util.c
> > @@ -101,11 +101,21 @@ int backed_file_open(char *path, int oflag, uint64_t *size)
> >  	if (S_ISREG(st.st_mode))
> >  		*size = st.st_size;
> >  	else if (S_ISBLK(st.st_mode)) {
> > +#ifdef BLKGETSIZE64
> >  		err = ioctl(fd, BLKGETSIZE64, size);
> >  		if (err < 0) {
> >  			eprintf("Cannot get size, %m\n");
> >  			goto close_fd;
> >  		}
> > +#else
> > +		unsigned long usize;
> > +		err = ioctl(fd, BLKGETSIZE, &usize);
> > +		if (err < 0) {
> > +			eprintf("Cannot get size (ulong), %m\n");
> > +			goto close_fd;
> > +		}
> > +		*size = usize;
> > +#endif
> 
> Unfortunately there's a minor but nasty bug in here: BLKGETSIZE64 returns
> the size in bytes, while BLKGETSIZE returns the number of sectors -
> cf. linux/fs.h.

Oh!  Thanks for pointing that out.  The old machine where I found
the need for this did not have the helpful comment in linux/fs.h,
and I was too lazy to actually verify the value was correct.

This patch was motivated by testing on an RHAS3 i686 machine.  I was
just going for architectural coverage, and have no plans to run
there.  No need to suffer the ugly #define this way either.  I'll
drop the patch.

		-- Pete


From pw at osc.edu  Thu Aug  2 20:58:59 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 2 Aug 2007 14:58:59 -0400
Subject: [Stgt-devel] stgt backing store & SSC
In-Reply-To: <46AF0795.1010306@gmail.com>
References: <46AF0795.1010306@gmail.com>
Message-ID: <20070802185859.GA24502@osc.edu>

markh794 at gmail.com wrote on Tue, 31 Jul 2007 19:57 +1000:
> For Variable block SSC device, the block size written needs to be 
> tracked.
[..]
> My current thoughts of a solution:
> ========================
> A block header describes each block written -> Analogy to the 'tar' 
> format where a header is written, followed by the 'data' followed by 
> another header, followed by more data...repeat...until blank header...
[..]
> However the current implementation for iSCSI -> bs_sync uses a 
> pread64()/pwrite64() and writes data based on information stored in 
> scsi_cmd -
>  pwrite64(fd, cmd->uaddr, cmd->len, cmd->offset)
>  pread64(fd, cmd->uaddr, cmd->len, cmd->offset)
> 
> 
> Would it be OK to add a 'blk_header' structure to struct scsi_cmd and if 
> blk_header is set, write this blk header as well ?
> I will attempt to put the above idea into code and submit for comment...

I think rather than trying to add stuff to existing backing stores
that you should consider writing your own.  You need to store both
"metadata" (block descriptors) and data, and none of the BSes are
set up for that.

The complexity of trying to glue in the blk_header so that all BSes
know how to tack that on top seems big.  Then you have to tell them
to read the header, and consider fields in that when determining how
much further data to read.  It gets messy fast.

In the lu_init for the ssc device, you can change the BS.  Then in
your READ/WRITE command handler, you can make calls into your own
BS that knows how to store this information.  (Look out for the
allocation size hack in target.c for TYPE_SPT; you may need
something similar.)

In general, the current separation of backing store from device only
really works for block storage.  We need an OSD-only backing store
for OSD too (not in tree).  May be cleaner just to rid the concept
of backing store from everything except the device code.

		-- Pete


From blackmagic02881 at gmail.com  Thu Aug  2 21:18:13 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 02 Aug 2007 15:18:13 -0400
Subject: [Stgt-devel] stgt backing store & SSC
In-Reply-To: <20070802185859.GA24502@osc.edu>
References: <46AF0795.1010306@gmail.com>  <20070802185859.GA24502@osc.edu>
Message-ID: <1186082293.3819.23.camel@dhcp-141.ibrix.com>

On Thu, 2007-08-02 at 14:58 -0400, Pete Wyckoff wrote:
> markh794 at gmail.com wrote on Tue, 31 Jul 2007 19:57 +1000:
> > For Variable block SSC device, the block size written needs to be 
> > tracked.
> [..]
> > My current thoughts of a solution:
> > ========================
> > A block header describes each block written -> Analogy to the 'tar' 
> > format where a header is written, followed by the 'data' followed by 
> > another header, followed by more data...repeat...until blank header...
> [..]
> > However the current implementation for iSCSI -> bs_sync uses a 
> > pread64()/pwrite64() and writes data based on information stored in 
> > scsi_cmd -
> >  pwrite64(fd, cmd->uaddr, cmd->len, cmd->offset)
> >  pread64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > 
> > 
> > Would it be OK to add a 'blk_header' structure to struct scsi_cmd and if 
> > blk_header is set, write this blk header as well ?
> > I will attempt to put the above idea into code and submit for comment...
> 
> I think rather than trying to add stuff to existing backing stores
> that you should consider writing your own.  You need to store both
> "metadata" (block descriptors) and data, and none of the BSes are
> set up for that.
> 
> The complexity of trying to glue in the blk_header so that all BSes
> know how to tack that on top seems big.  Then you have to tell them
> to read the header, and consider fields in that when determining how
> much further data to read.  It gets messy fast.

also considering tape can have compression and encryption, then each
block is variable size even in fixed size mode. so support variable size
is a must eventually.


> 
> In the lu_init for the ssc device, you can change the BS.  Then in
> your READ/WRITE command handler, you can make calls into your own
> BS that knows how to store this information.  (Look out for the
> allocation size hack in target.c for TYPE_SPT; you may need
> something similar.)
> 
> In general, the current separation of backing store from device only
> really works for block storage.  We need an OSD-only backing store
> for OSD too (not in tree).  May be cleaner just to rid the concept
> of backing store from everything except the device code.
> 
> 		-- Pete
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
-- 
Ming Zhang


@#$%^ purging memory... (*!%
http://blackmagic02881.wordpress.com/
http://www.linkedin.com/in/blackmagic02881
--------------------------------------------



From markh794 at gmail.com  Fri Aug  3 02:47:29 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 3 Aug 2007 10:47:29 +1000
Subject: [Stgt-devel] stgt backing store & SSC
In-Reply-To: <20070802185859.GA24502@osc.edu>
References: <46AF0795.1010306@gmail.com> <20070802185859.GA24502@osc.edu>
Message-ID: <f29db9a80708021747g6279647cr6f6b107f35d2f2c2@mail.gmail.com>

On 8/3/07, Pete Wyckoff <pw at osc.edu> wrote:
> markh794 at gmail.com wrote on Tue, 31 Jul 2007 19:57 +1000:
> > For Variable block SSC device, the block size written needs to be
> > tracked.
> [..]
> > My current thoughts of a solution:
> > ========================
> > A block header describes each block written -> Analogy to the 'tar'
> > format where a header is written, followed by the 'data' followed by
> > another header, followed by more data...repeat...until blank header...
> [..]
> > However the current implementation for iSCSI -> bs_sync uses a
> > pread64()/pwrite64() and writes data based on information stored in
> > scsi_cmd -
> >  pwrite64(fd, cmd->uaddr, cmd->len, cmd->offset)
> >  pread64(fd, cmd->uaddr, cmd->len, cmd->offset)
> >
> >
> > Would it be OK to add a 'blk_header' structure to struct scsi_cmd and if
> > blk_header is set, write this blk header as well ?
> > I will attempt to put the above idea into code and submit for comment...
>
> I think rather than trying to add stuff to existing backing stores
> that you should consider writing your own.  You need to store both
> "metadata" (block descriptors) and data, and none of the BSes are
> set up for that.
>
> The complexity of trying to glue in the blk_header so that all BSes
> know how to tack that on top seems big.  Then you have to tell them
> to read the header, and consider fields in that when determining how
> much further data to read.

>It gets messy fast.

Yep. Got there :)

>
> In the lu_init for the ssc device, you can change the BS.  Then in
> your READ/WRITE command handler, you can make calls into your own
> BS that knows how to store this information.  (Look out for the
> allocation size hack in target.c for TYPE_SPT; you may need
> something similar.)

Thanks for the tip. I was trying to identify the best place to patch
in a modified BS and had not thought of lu_init.

> In general, the current separation of backing store from device only
> really works for block storage.  We need an OSD-only backing store
> for OSD too (not in tree).  May be cleaner just to rid the concept
> of backing store from everything except the device code.
>
>                 -- Pete
>

Regards
Mark


From markh794 at gmail.com  Fri Aug  3 02:53:33 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 3 Aug 2007 10:53:33 +1000
Subject: [Stgt-devel] stgt backing store & SSC
In-Reply-To: <1186082293.3819.23.camel@dhcp-141.ibrix.com>
References: <46AF0795.1010306@gmail.com> <20070802185859.GA24502@osc.edu>
	<1186082293.3819.23.camel@dhcp-141.ibrix.com>
Message-ID: <f29db9a80708021753r1901b444hd95c2bb0565c9e9a@mail.gmail.com>

On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> On Thu, 2007-08-02 at 14:58 -0400, Pete Wyckoff wrote:
> > markh794 at gmail.com wrote on Tue, 31 Jul 2007 19:57 +1000:
> > > For Variable block SSC device, the block size written needs to be
> > > tracked.
> > [..]
> > > My current thoughts of a solution:
> > > ========================
> > > A block header describes each block written -> Analogy to the 'tar'
> > > format where a header is written, followed by the 'data' followed by
> > > another header, followed by more data...repeat...until blank header...
> > [..]
> > > However the current implementation for iSCSI -> bs_sync uses a
> > > pread64()/pwrite64() and writes data based on information stored in
> > > scsi_cmd -
> > >  pwrite64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > >  pread64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > >
> > >
> > > Would it be OK to add a 'blk_header' structure to struct scsi_cmd and if
> > > blk_header is set, write this blk header as well ?
> > > I will attempt to put the above idea into code and submit for comment...
> >
> > I think rather than trying to add stuff to existing backing stores
> > that you should consider writing your own.  You need to store both
> > "metadata" (block descriptors) and data, and none of the BSes are
> > set up for that.
> >
> > The complexity of trying to glue in the blk_header so that all BSes
> > know how to tack that on top seems big.  Then you have to tell them
> > to read the header, and consider fields in that when determining how
> > much further data to read.  It gets messy fast.
>
> also considering tape can have compression and encryption, then each
> block is variable size even in fixed size mode. so support variable size
> is a must eventually.

Yep. The SSC metadata (header for each tape block) contains a
structure with a 'block type' , size of original data & size of data
stored.

All accounted for. Just no code for compression or encryption - as yet..

enum {
        BLK_NOOP,
        BLK_UNCOMPRESS_DATA,
        BLK_COMPRESSED_DATA,
        BLK_ENCRYPTED_DATA,
        BLK_FILEMARK,
        BLK_BOT,
        BLK_EOD,
};
struct blk_header {
        uint32_t blk_type;
        uint32_t blk_size;
        uint32_t disk_blk_size;
        loff_t blk_number;
        loff_t prev_blk;
        loff_t curr_blk;
        loff_t next_blk;
};


> > In the lu_init for the ssc device, you can change the BS.  Then in
> > your READ/WRITE command handler, you can make calls into your own
> > BS that knows how to store this information.  (Look out for the
> > allocation size hack in target.c for TYPE_SPT; you may need
> > something similar.)
> >
> > In general, the current separation of backing store from device only
> > really works for block storage.  We need an OSD-only backing store
> > for OSD too (not in tree).  May be cleaner just to rid the concept
> > of backing store from everything except the device code.
> >
> >               -- Pete
> > _______________________________________________
> > Stgt-devel mailing list
> > Stgt-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/stgt-devel
> --
> Ming Zhang
>
>
> @#$%^ purging memory... (*!%
> http://blackmagic02881.wordpress.com/
> http://www.linkedin.com/in/blackmagic02881
> --------------------------------------------
>
>


From blackmagic02881 at gmail.com  Fri Aug  3 02:57:23 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 02 Aug 2007 20:57:23 -0400
Subject: [Stgt-devel] stgt backing store & SSC
In-Reply-To: <f29db9a80708021753r1901b444hd95c2bb0565c9e9a@mail.gmail.com>
References: <46AF0795.1010306@gmail.com> <20070802185859.GA24502@osc.edu>
	<1186082293.3819.23.camel@dhcp-141.ibrix.com>
	<f29db9a80708021753r1901b444hd95c2bb0565c9e9a@mail.gmail.com>
Message-ID: <1186102643.3773.9.camel@localhost.localdomain>

On Fri, 2007-08-03 at 10:53 +1000, Mark Harvey wrote:
> On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > On Thu, 2007-08-02 at 14:58 -0400, Pete Wyckoff wrote:
> > > markh794 at gmail.com wrote on Tue, 31 Jul 2007 19:57 +1000:
> > > > For Variable block SSC device, the block size written needs to be
> > > > tracked.
> > > [..]
> > > > My current thoughts of a solution:
> > > > ========================
> > > > A block header describes each block written -> Analogy to the 'tar'
> > > > format where a header is written, followed by the 'data' followed by
> > > > another header, followed by more data...repeat...until blank header...
> > > [..]
> > > > However the current implementation for iSCSI -> bs_sync uses a
> > > > pread64()/pwrite64() and writes data based on information stored in
> > > > scsi_cmd -
> > > >  pwrite64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > > >  pread64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > > >
> > > >
> > > > Would it be OK to add a 'blk_header' structure to struct scsi_cmd and if
> > > > blk_header is set, write this blk header as well ?
> > > > I will attempt to put the above idea into code and submit for comment...
> > >
> > > I think rather than trying to add stuff to existing backing stores
> > > that you should consider writing your own.  You need to store both
> > > "metadata" (block descriptors) and data, and none of the BSes are
> > > set up for that.
> > >
> > > The complexity of trying to glue in the blk_header so that all BSes
> > > know how to tack that on top seems big.  Then you have to tell them
> > > to read the header, and consider fields in that when determining how
> > > much further data to read.  It gets messy fast.
> >
> > also considering tape can have compression and encryption, then each
> > block is variable size even in fixed size mode. so support variable size
> > is a must eventually.
> 
> Yep. The SSC metadata (header for each tape block) contains a
> structure with a 'block type' , size of original data & size of data
> stored.
> 
> All accounted for. Just no code for compression or encryption - as yet..
> 
> enum {
>         BLK_NOOP,
>         BLK_UNCOMPRESS_DATA,
>         BLK_COMPRESSED_DATA,
>         BLK_ENCRYPTED_DATA,
>         BLK_FILEMARK,
>         BLK_BOT,
>         BLK_EOD,
> };

are these bits? can i have multiple bits set like compressed before
encryption? also leave room for data deduplication for example storing a
token. ;)


> struct blk_header {
>         uint32_t blk_type;
>         uint32_t blk_size;
>         uint32_t disk_blk_size;
>         loff_t blk_number;
>         loff_t prev_blk;
>         loff_t curr_blk;
>         loff_t next_blk;
> };
> 
> 
> > > In the lu_init for the ssc device, you can change the BS.  Then in
> > > your READ/WRITE command handler, you can make calls into your own
> > > BS that knows how to store this information.  (Look out for the
> > > allocation size hack in target.c for TYPE_SPT; you may need
> > > something similar.)
> > >
> > > In general, the current separation of backing store from device only
> > > really works for block storage.  We need an OSD-only backing store
> > > for OSD too (not in tree).  May be cleaner just to rid the concept
> > > of backing store from everything except the device code.
> > >
> > >               -- Pete
> > > _______________________________________________
> > > Stgt-devel mailing list
> > > Stgt-devel at lists.berlios.de
> > > https://lists.berlios.de/mailman/listinfo/stgt-devel
> > --
> > Ming Zhang
> >
> >
> > @#$%^ purging memory... (*!%
> > http://blackmagic02881.wordpress.com/
> > http://www.linkedin.com/in/blackmagic02881
> > --------------------------------------------
> >
> >
-- 
Ming Zhang


@#$%^ purging memory... (*!%
http://blackmagic02881.wordpress.com/
http://www.linkedin.com/in/blackmagic02881
--------------------------------------------



From markh794 at gmail.com  Fri Aug  3 02:59:41 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 3 Aug 2007 10:59:41 +1000
Subject: [Stgt-devel] Unused variable in struct scsi_cmd
Message-ID: <f29db9a80708021759t47fab05aqe67d0f6a5782aea3@mail.gmail.com>

The scsi_cmd structure defined in tgtd.h contains two similar named variables.
uint32_t data_len and uint32_t len.

I could not identify any code that used 'data_len'

Also removing this from the structure resulted in a successful compile
for iSCSI.

I assume this is a dead variable and can be safely removed ?

Regards
Mark


From markh794 at gmail.com  Fri Aug  3 03:07:02 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 3 Aug 2007 11:07:02 +1000
Subject: [Stgt-devel] stgt backing store & SSC
In-Reply-To: <1186102643.3773.9.camel@localhost.localdomain>
References: <46AF0795.1010306@gmail.com> <20070802185859.GA24502@osc.edu>
	<1186082293.3819.23.camel@dhcp-141.ibrix.com>
	<f29db9a80708021753r1901b444hd95c2bb0565c9e9a@mail.gmail.com>
	<1186102643.3773.9.camel@localhost.localdomain>
Message-ID: <f29db9a80708021807k23484ecfp94fc16ab469c20be@mail.gmail.com>

On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> On Fri, 2007-08-03 at 10:53 +1000, Mark Harvey wrote:
> > On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > On Thu, 2007-08-02 at 14:58 -0400, Pete Wyckoff wrote:
> > > > markh794 at gmail.com wrote on Tue, 31 Jul 2007 19:57 +1000:
> > > > > For Variable block SSC device, the block size written needs to be
> > > > > tracked.
> > > > [..]
> > > > > My current thoughts of a solution:
> > > > > ========================
> > > > > A block header describes each block written -> Analogy to the 'tar'
> > > > > format where a header is written, followed by the 'data' followed by
> > > > > another header, followed by more data...repeat...until blank header...
> > > > [..]
> > > > > However the current implementation for iSCSI -> bs_sync uses a
> > > > > pread64()/pwrite64() and writes data based on information stored in
> > > > > scsi_cmd -
> > > > >  pwrite64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > > > >  pread64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > > > >
> > > > >
> > > > > Would it be OK to add a 'blk_header' structure to struct scsi_cmd and if
> > > > > blk_header is set, write this blk header as well ?
> > > > > I will attempt to put the above idea into code and submit for comment...
> > > >
> > > > I think rather than trying to add stuff to existing backing stores
> > > > that you should consider writing your own.  You need to store both
> > > > "metadata" (block descriptors) and data, and none of the BSes are
> > > > set up for that.
> > > >
> > > > The complexity of trying to glue in the blk_header so that all BSes
> > > > know how to tack that on top seems big.  Then you have to tell them
> > > > to read the header, and consider fields in that when determining how
> > > > much further data to read.  It gets messy fast.
> > >
> > > also considering tape can have compression and encryption, then each
> > > block is variable size even in fixed size mode. so support variable size
> > > is a must eventually.
> >
> > Yep. The SSC metadata (header for each tape block) contains a
> > structure with a 'block type' , size of original data & size of data
> > stored.
> >
> > All accounted for. Just no code for compression or encryption - as yet..
> >
> > enum {
> >         BLK_NOOP,
> >         BLK_UNCOMPRESS_DATA,
> >         BLK_COMPRESSED_DATA,
> >         BLK_ENCRYPTED_DATA,
> >         BLK_FILEMARK,
> >         BLK_BOT,
> >         BLK_EOD,
> > };
>
> are these bits? can i have multiple bits set like compressed before
> encryption? also leave room for data deduplication for example storing a
> token. ;)
>

Arr.. no.

Good catch.

I'll re-do it so they are bits.

Re: Data deduplication
I was thinking a separate 'cache' file will be required and 'hashed'
some way for this.

I can not really see any advantage of storing a fixed deduplication
method in the SSC block header.

I have not thought this thru... So any input on this will be welcome.

Cheers
Mark

>
> --
> Ming Zhang
>
>
> @#$%^ purging memory... (*!%
> http://blackmagic02881.wordpress.com/
> http://www.linkedin.com/in/blackmagic02881
> --------------------------------------------
>
>


From blackmagic02881 at gmail.com  Fri Aug  3 03:19:14 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 02 Aug 2007 21:19:14 -0400
Subject: [Stgt-devel] stgt backing store & SSC
In-Reply-To: <f29db9a80708021807k23484ecfp94fc16ab469c20be@mail.gmail.com>
References: <46AF0795.1010306@gmail.com> <20070802185859.GA24502@osc.edu>
	<1186082293.3819.23.camel@dhcp-141.ibrix.com>
	<f29db9a80708021753r1901b444hd95c2bb0565c9e9a@mail.gmail.com>
	<1186102643.3773.9.camel@localhost.localdomain>
	<f29db9a80708021807k23484ecfp94fc16ab469c20be@mail.gmail.com>
Message-ID: <1186103954.3773.31.camel@localhost.localdomain>

On Fri, 2007-08-03 at 11:07 +1000, Mark Harvey wrote:
> On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > On Fri, 2007-08-03 at 10:53 +1000, Mark Harvey wrote:
> > > On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > > On Thu, 2007-08-02 at 14:58 -0400, Pete Wyckoff wrote:
> > > > > markh794 at gmail.com wrote on Tue, 31 Jul 2007 19:57 +1000:
> > > > > > For Variable block SSC device, the block size written needs to be
> > > > > > tracked.
> > > > > [..]
> > > > > > My current thoughts of a solution:
> > > > > > ========================
> > > > > > A block header describes each block written -> Analogy to the 'tar'
> > > > > > format where a header is written, followed by the 'data' followed by
> > > > > > another header, followed by more data...repeat...until blank header...
> > > > > [..]
> > > > > > However the current implementation for iSCSI -> bs_sync uses a
> > > > > > pread64()/pwrite64() and writes data based on information stored in
> > > > > > scsi_cmd -
> > > > > >  pwrite64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > > > > >  pread64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > > > > >
> > > > > >
> > > > > > Would it be OK to add a 'blk_header' structure to struct scsi_cmd and if
> > > > > > blk_header is set, write this blk header as well ?
> > > > > > I will attempt to put the above idea into code and submit for comment...
> > > > >
> > > > > I think rather than trying to add stuff to existing backing stores
> > > > > that you should consider writing your own.  You need to store both
> > > > > "metadata" (block descriptors) and data, and none of the BSes are
> > > > > set up for that.
> > > > >
> > > > > The complexity of trying to glue in the blk_header so that all BSes
> > > > > know how to tack that on top seems big.  Then you have to tell them
> > > > > to read the header, and consider fields in that when determining how
> > > > > much further data to read.  It gets messy fast.
> > > >
> > > > also considering tape can have compression and encryption, then each
> > > > block is variable size even in fixed size mode. so support variable size
> > > > is a must eventually.
> > >
> > > Yep. The SSC metadata (header for each tape block) contains a
> > > structure with a 'block type' , size of original data & size of data
> > > stored.
> > >
> > > All accounted for. Just no code for compression or encryption - as yet..
> > >
> > > enum {
> > >         BLK_NOOP,
> > >         BLK_UNCOMPRESS_DATA,
> > >         BLK_COMPRESSED_DATA,
> > >         BLK_ENCRYPTED_DATA,
> > >         BLK_FILEMARK,
> > >         BLK_BOT,
> > >         BLK_EOD,
> > > };
> >
> > are these bits? can i have multiple bits set like compressed before
> > encryption? also leave room for data deduplication for example storing a
> > token. ;)
> >
> 
> Arr.. no.
> 
> Good catch.
> 
> I'll re-do it so they are bits.

thx. bit might now be good enough as well. ;)

> 
> Re: Data deduplication
> I was thinking a separate 'cache' file will be required and 'hashed'
> some way for this.
> 
> I can not really see any advantage of storing a fixed deduplication
> method in the SSC block header.

dedup is just another compression method. even with compression u can
have different algorithms and with encryption u have different
algorithms or ways or all these just kinds of data transformation.

just need a type to mark what kind of data transformation it uses and
each transform provide a pluggable way to fetch/store data.

for example like de-dup. u can store a token here and then when need to
read this data, u check the header to see if overread or under read
because of the block size issue. (forgot how SSC call these...:-()

then with token u can contact another data service to find data and
return.

so once u define the infrastructure, these can be added later...
 

> 
> I have not thought this thru... So any input on this will be welcome.
> 
> Cheers
> Mark
> 
> >
> > --
> > Ming Zhang
> >
> >
> > @#$%^ purging memory... (*!%
> > http://blackmagic02881.wordpress.com/
> > http://www.linkedin.com/in/blackmagic02881
> > --------------------------------------------
> >
> >
-- 
Ming Zhang


@#$%^ purging memory... (*!%
http://blackmagic02881.wordpress.com/
http://www.linkedin.com/in/blackmagic02881
--------------------------------------------



From markh794 at gmail.com  Fri Aug  3 04:44:56 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 3 Aug 2007 12:44:56 +1000
Subject: [Stgt-devel] Data deduplication, stgt backing store & SSC
Message-ID: <f29db9a80708021944y706616c5q7f0c2241369ad695@mail.gmail.com>

Re: deduplication

Just so we are both on the same page...

My understanding of the term deduplication is where the is some sort
of finger print for each block of data. The block of data is only
stored if its finger print is unique. Non-unique finger prints blocks
are then 'referenced' back to the original finger-print block of data.

i.e. Very similar to Single Instance Store but at a block layer.
Single Instance Store (SIS) is more used at an application layer (e.g.
MS Exchange does SIS on each email)

May be adding some sort of field (fit md5sum ??) in the header so
indexing virtual media will be quicker ?

64bytes for each block of data seems a little extravagant at this point in time.
Although unlike disk, tape blocks are typically 64k, 128k or larger.

Regards
Mark

On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> On Fri, 2007-08-03 at 11:07 +1000, Mark Harvey wrote:
> > On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > On Fri, 2007-08-03 at 10:53 +1000, Mark Harvey wrote:
> > > > On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > > > On Thu, 2007-08-02 at 14:58 -0400, Pete Wyckoff wrote:
> > > > > > markh794 at gmail.com wrote on Tue, 31 Jul 2007 19:57 +1000:
> > > > > > > For Variable block SSC device, the block size written needs to be
> > > > > > > tracked.
> > > > > > [..]
> > > > > > > My current thoughts of a solution:
> > > > > > > ========================
> > > > > > > A block header describes each block written -> Analogy to the 'tar'
> > > > > > > format where a header is written, followed by the 'data' followed by
> > > > > > > another header, followed by more data...repeat...until blank header...
> > > > > > [..]
> > > > > > > However the current implementation for iSCSI -> bs_sync uses a
> > > > > > > pread64()/pwrite64() and writes data based on information stored in
> > > > > > > scsi_cmd -
> > > > > > >  pwrite64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > > > > > >  pread64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > > > > > >
> > > > > > >
> > > > > > > Would it be OK to add a 'blk_header' structure to struct scsi_cmd and if
> > > > > > > blk_header is set, write this blk header as well ?
> > > > > > > I will attempt to put the above idea into code and submit for comment...
> > > > > >
> > > > > > I think rather than trying to add stuff to existing backing stores
> > > > > > that you should consider writing your own.  You need to store both
> > > > > > "metadata" (block descriptors) and data, and none of the BSes are
> > > > > > set up for that.
> > > > > >
> > > > > > The complexity of trying to glue in the blk_header so that all BSes
> > > > > > know how to tack that on top seems big.  Then you have to tell them
> > > > > > to read the header, and consider fields in that when determining how
> > > > > > much further data to read.  It gets messy fast.
> > > > >
> > > > > also considering tape can have compression and encryption, then each
> > > > > block is variable size even in fixed size mode. so support variable size
> > > > > is a must eventually.
> > > >
> > > > Yep. The SSC metadata (header for each tape block) contains a
> > > > structure with a 'block type' , size of original data & size of data
> > > > stored.
> > > >
> > > > All accounted for. Just no code for compression or encryption - as yet..
> > > >
> > > > enum {
> > > >         BLK_NOOP,
> > > >         BLK_UNCOMPRESS_DATA,
> > > >         BLK_COMPRESSED_DATA,
> > > >         BLK_ENCRYPTED_DATA,
> > > >         BLK_FILEMARK,
> > > >         BLK_BOT,
> > > >         BLK_EOD,
> > > > };
> > >
> > > are these bits? can i have multiple bits set like compressed before
> > > encryption? also leave room for data deduplication for example storing a
> > > token. ;)
> > >
> >
> > Arr.. no.
> >
> > Good catch.
> >
> > I'll re-do it so they are bits.
>
> thx. bit might now be good enough as well. ;)
>
> >
> > Re: Data deduplication
> > I was thinking a separate 'cache' file will be required and 'hashed'
> > some way for this.
> >
> > I can not really see any advantage of storing a fixed deduplication
> > method in the SSC block header.
>
> dedup is just another compression method. even with compression u can
> have different algorithms and with encryption u have different
> algorithms or ways or all these just kinds of data transformation.
>
> just need a type to mark what kind of data transformation it uses and
> each transform provide a pluggable way to fetch/store data.
>
> for example like de-dup. u can store a token here and then when need to
> read this data, u check the header to see if overread or under read
> because of the block size issue. (forgot how SSC call these...:-()
>
> then with token u can contact another data service to find data and
> return.
>
> so once u define the infrastructure, these can be added later...
>
>
> >
> > I have not thought this thru... So any input on this will be welcome.
> >
> > Cheers
> > Mark
> >
> > >
> > > --
> > > Ming Zhang
> > >
> > >
> > > @#$%^ purging memory... (*!%
> > > http://blackmagic02881.wordpress.com/
> > > http://www.linkedin.com/in/blackmagic02881
> > > --------------------------------------------
> > >
> > >
> --
> Ming Zhang
>
>
> @#$%^ purging memory... (*!%
> http://blackmagic02881.wordpress.com/
> http://www.linkedin.com/in/blackmagic02881
> --------------------------------------------
>
>


From blackmagic02881 at gmail.com  Fri Aug  3 05:07:44 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 02 Aug 2007 23:07:44 -0400
Subject: [Stgt-devel] Data deduplication, stgt backing store & SSC
In-Reply-To: <f29db9a80708021944y706616c5q7f0c2241369ad695@mail.gmail.com>
References: <f29db9a80708021944y706616c5q7f0c2241369ad695@mail.gmail.com>
Message-ID: <1186110464.3773.41.camel@localhost.localdomain>

On Fri, 2007-08-03 at 12:44 +1000, Mark Harvey wrote:
> Re: deduplication
> 
> Just so we are both on the same page...
> 
> My understanding of the term deduplication is where the is some sort
> of finger print for each block of data. The block of data is only
> stored if its finger print is unique. Non-unique finger prints blocks
> are then 'referenced' back to the original finger-print block of data.

yes. exactly. just different solution has different pros and cons. fix
block, variable block, algorithm, ...

i do not expect a easy OSS de-dup can have here but at least our
infrasture should enable this possibility.

> 
> i.e. Very similar to Single Instance Store but at a block layer.
> Single Instance Store (SIS) is more used at an application layer (e.g.
> MS Exchange does SIS on each email)

yes

> 
> May be adding some sort of field (fit md5sum ??) in the header so
> indexing virtual media will be quicker ?
> 
> 64bytes for each block of data seems a little extravagant at this point in time.
> Although unlike disk, tape blocks are typically 64k, 128k or larger.


> 
> Regards
> Mark
> 
> On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > On Fri, 2007-08-03 at 11:07 +1000, Mark Harvey wrote:
> > > On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > > On Fri, 2007-08-03 at 10:53 +1000, Mark Harvey wrote:
> > > > > On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > > > > On Thu, 2007-08-02 at 14:58 -0400, Pete Wyckoff wrote:
> > > > > > > markh794 at gmail.com wrote on Tue, 31 Jul 2007 19:57 +1000:
> > > > > > > > For Variable block SSC device, the block size written needs to be
> > > > > > > > tracked.
> > > > > > > [..]
> > > > > > > > My current thoughts of a solution:
> > > > > > > > ========================
> > > > > > > > A block header describes each block written -> Analogy to the 'tar'
> > > > > > > > format where a header is written, followed by the 'data' followed by
> > > > > > > > another header, followed by more data...repeat...until blank header...
> > > > > > > [..]
> > > > > > > > However the current implementation for iSCSI -> bs_sync uses a
> > > > > > > > pread64()/pwrite64() and writes data based on information stored in
> > > > > > > > scsi_cmd -
> > > > > > > >  pwrite64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > > > > > > >  pread64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > > > > > > >
> > > > > > > >
> > > > > > > > Would it be OK to add a 'blk_header' structure to struct scsi_cmd and if
> > > > > > > > blk_header is set, write this blk header as well ?
> > > > > > > > I will attempt to put the above idea into code and submit for comment...
> > > > > > >
> > > > > > > I think rather than trying to add stuff to existing backing stores
> > > > > > > that you should consider writing your own.  You need to store both
> > > > > > > "metadata" (block descriptors) and data, and none of the BSes are
> > > > > > > set up for that.
> > > > > > >
> > > > > > > The complexity of trying to glue in the blk_header so that all BSes
> > > > > > > know how to tack that on top seems big.  Then you have to tell them
> > > > > > > to read the header, and consider fields in that when determining how
> > > > > > > much further data to read.  It gets messy fast.
> > > > > >
> > > > > > also considering tape can have compression and encryption, then each
> > > > > > block is variable size even in fixed size mode. so support variable size
> > > > > > is a must eventually.
> > > > >
> > > > > Yep. The SSC metadata (header for each tape block) contains a
> > > > > structure with a 'block type' , size of original data & size of data
> > > > > stored.
> > > > >
> > > > > All accounted for. Just no code for compression or encryption - as yet..
> > > > >
> > > > > enum {
> > > > >         BLK_NOOP,
> > > > >         BLK_UNCOMPRESS_DATA,
> > > > >         BLK_COMPRESSED_DATA,
> > > > >         BLK_ENCRYPTED_DATA,
> > > > >         BLK_FILEMARK,
> > > > >         BLK_BOT,
> > > > >         BLK_EOD,
> > > > > };
> > > >
> > > > are these bits? can i have multiple bits set like compressed before
> > > > encryption? also leave room for data deduplication for example storing a
> > > > token. ;)
> > > >
> > >
> > > Arr.. no.
> > >
> > > Good catch.
> > >
> > > I'll re-do it so they are bits.
> >
> > thx. bit might now be good enough as well. ;)
> >
> > >
> > > Re: Data deduplication
> > > I was thinking a separate 'cache' file will be required and 'hashed'
> > > some way for this.
> > >
> > > I can not really see any advantage of storing a fixed deduplication
> > > method in the SSC block header.
> >
> > dedup is just another compression method. even with compression u can
> > have different algorithms and with encryption u have different
> > algorithms or ways or all these just kinds of data transformation.
> >
> > just need a type to mark what kind of data transformation it uses and
> > each transform provide a pluggable way to fetch/store data.
> >
> > for example like de-dup. u can store a token here and then when need to
> > read this data, u check the header to see if overread or under read
> > because of the block size issue. (forgot how SSC call these...:-()
> >
> > then with token u can contact another data service to find data and
> > return.
> >
> > so once u define the infrastructure, these can be added later...
> >
> >
> > >
> > > I have not thought this thru... So any input on this will be welcome.
> > >
> > > Cheers
> > > Mark
> > >
> > > >
> > > > --
> > > > Ming Zhang
> > > >
> > > >
> > > > @#$%^ purging memory... (*!%
> > > > http://blackmagic02881.wordpress.com/
> > > > http://www.linkedin.com/in/blackmagic02881
> > > > --------------------------------------------
> > > >
> > > >
> > --
> > Ming Zhang
> >
> >
> > @#$%^ purging memory... (*!%
> > http://blackmagic02881.wordpress.com/
> > http://www.linkedin.com/in/blackmagic02881
> > --------------------------------------------
> >
> >
-- 
Ming Zhang


@#$%^ purging memory... (*!%
http://blackmagic02881.wordpress.com/
http://www.linkedin.com/in/blackmagic02881
--------------------------------------------



From markh794 at gmail.com  Fri Aug  3 06:46:50 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 3 Aug 2007 14:46:50 +1000
Subject: [Stgt-devel] Data deduplication, stgt backing store & SSC
In-Reply-To: <1186110464.3773.41.camel@localhost.localdomain>
References: <f29db9a80708021944y706616c5q7f0c2241369ad695@mail.gmail.com>
	<1186110464.3773.41.camel@localhost.localdomain>
Message-ID: <f29db9a80708022146o1c57ce8ep24225bb0e7b22d12@mail.gmail.com>

Good & agreed..

Now to find or identify the best infrastructure framework to implement.

Regards
Mark

On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> On Fri, 2007-08-03 at 12:44 +1000, Mark Harvey wrote:
> > Re: deduplication
> >
> > Just so we are both on the same page...
> >
> > My understanding of the term deduplication is where the is some sort
> > of finger print for each block of data. The block of data is only
> > stored if its finger print is unique. Non-unique finger prints blocks
> > are then 'referenced' back to the original finger-print block of data.
>
> yes. exactly. just different solution has different pros and cons. fix
> block, variable block, algorithm, ...
>
> i do not expect a easy OSS de-dup can have here but at least our
> infrasture should enable this possibility.
>
> >
> > i.e. Very similar to Single Instance Store but at a block layer.
> > Single Instance Store (SIS) is more used at an application layer (e.g.
> > MS Exchange does SIS on each email)
>
> yes
>
> >
> > May be adding some sort of field (fit md5sum ??) in the header so
> > indexing virtual media will be quicker ?
> >
> > 64bytes for each block of data seems a little extravagant at this point in time.
> > Although unlike disk, tape blocks are typically 64k, 128k or larger.
>
>
> >
> > Regards
> > Mark
> >
> > On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > On Fri, 2007-08-03 at 11:07 +1000, Mark Harvey wrote:
> > > > On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > > > On Fri, 2007-08-03 at 10:53 +1000, Mark Harvey wrote:
> > > > > > On 8/3/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > > > > > On Thu, 2007-08-02 at 14:58 -0400, Pete Wyckoff wrote:
> > > > > > > > markh794 at gmail.com wrote on Tue, 31 Jul 2007 19:57 +1000:
> > > > > > > > > For Variable block SSC device, the block size written needs to be
> > > > > > > > > tracked.
> > > > > > > > [..]
> > > > > > > > > My current thoughts of a solution:
> > > > > > > > > ========================
> > > > > > > > > A block header describes each block written -> Analogy to the 'tar'
> > > > > > > > > format where a header is written, followed by the 'data' followed by
> > > > > > > > > another header, followed by more data...repeat...until blank header...
> > > > > > > > [..]
> > > > > > > > > However the current implementation for iSCSI -> bs_sync uses a
> > > > > > > > > pread64()/pwrite64() and writes data based on information stored in
> > > > > > > > > scsi_cmd -
> > > > > > > > >  pwrite64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > > > > > > > >  pread64(fd, cmd->uaddr, cmd->len, cmd->offset)
> > > > > > > > >
> > > > > > > > >
> > > > > > > > > Would it be OK to add a 'blk_header' structure to struct scsi_cmd and if
> > > > > > > > > blk_header is set, write this blk header as well ?
> > > > > > > > > I will attempt to put the above idea into code and submit for comment...
> > > > > > > >
> > > > > > > > I think rather than trying to add stuff to existing backing stores
> > > > > > > > that you should consider writing your own.  You need to store both
> > > > > > > > "metadata" (block descriptors) and data, and none of the BSes are
> > > > > > > > set up for that.
> > > > > > > >
> > > > > > > > The complexity of trying to glue in the blk_header so that all BSes
> > > > > > > > know how to tack that on top seems big.  Then you have to tell them
> > > > > > > > to read the header, and consider fields in that when determining how
> > > > > > > > much further data to read.  It gets messy fast.
> > > > > > >
> > > > > > > also considering tape can have compression and encryption, then each
> > > > > > > block is variable size even in fixed size mode. so support variable size
> > > > > > > is a must eventually.
> > > > > >
> > > > > > Yep. The SSC metadata (header for each tape block) contains a
> > > > > > structure with a 'block type' , size of original data & size of data
> > > > > > stored.
> > > > > >
> > > > > > All accounted for. Just no code for compression or encryption - as yet..
> > > > > >
> > > > > > enum {
> > > > > >         BLK_NOOP,
> > > > > >         BLK_UNCOMPRESS_DATA,
> > > > > >         BLK_COMPRESSED_DATA,
> > > > > >         BLK_ENCRYPTED_DATA,
> > > > > >         BLK_FILEMARK,
> > > > > >         BLK_BOT,
> > > > > >         BLK_EOD,
> > > > > > };
> > > > >
> > > > > are these bits? can i have multiple bits set like compressed before
> > > > > encryption? also leave room for data deduplication for example storing a
> > > > > token. ;)
> > > > >
> > > >
> > > > Arr.. no.
> > > >
> > > > Good catch.
> > > >
> > > > I'll re-do it so they are bits.
> > >
> > > thx. bit might now be good enough as well. ;)
> > >
> > > >
> > > > Re: Data deduplication
> > > > I was thinking a separate 'cache' file will be required and 'hashed'
> > > > some way for this.
> > > >
> > > > I can not really see any advantage of storing a fixed deduplication
> > > > method in the SSC block header.
> > >
> > > dedup is just another compression method. even with compression u can
> > > have different algorithms and with encryption u have different
> > > algorithms or ways or all these just kinds of data transformation.
> > >
> > > just need a type to mark what kind of data transformation it uses and
> > > each transform provide a pluggable way to fetch/store data.
> > >
> > > for example like de-dup. u can store a token here and then when need to
> > > read this data, u check the header to see if overread or under read
> > > because of the block size issue. (forgot how SSC call these...:-()
> > >
> > > then with token u can contact another data service to find data and
> > > return.
> > >
> > > so once u define the infrastructure, these can be added later...
> > >
> > >
> > > >
> > > > I have not thought this thru... So any input on this will be welcome.
> > > >
> > > > Cheers
> > > > Mark
> > > >
> > > > >
> > > > > --
> > > > > Ming Zhang
> > > > >
> > > > >
> > > > > @#$%^ purging memory... (*!%
> > > > > http://blackmagic02881.wordpress.com/
> > > > > http://www.linkedin.com/in/blackmagic02881
> > > > > --------------------------------------------
> > > > >
> > > > >
> > > --
> > > Ming Zhang
> > >
> > >
> > > @#$%^ purging memory... (*!%
> > > http://blackmagic02881.wordpress.com/
> > > http://www.linkedin.com/in/blackmagic02881
> > > --------------------------------------------
> > >
> > >
> --
> Ming Zhang
>
>
> @#$%^ purging memory... (*!%
> http://blackmagic02881.wordpress.com/
> http://www.linkedin.com/in/blackmagic02881
> --------------------------------------------
>
>


From albert.pauw at gmail.com  Tue Aug  7 09:47:49 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Tue, 07 Aug 2007 09:47:49 +0200
Subject: [Stgt-devel] Inconsistency in usage of scsi_id and iscsi_sn?
Message-ID: <46B823A5.3010309@gmail.com>

I noticed something inconsistent (or so it seems).

If I define something like this:

tgtadm --lld iscsi --mode logicalunit --op update --tid 2 --lun 1 
--params 
vendor_id=MITSUMI,product_id=FD001,product_rev=0001,removable=1,sense_format=0
tgtadm --lld iscsi --mode logicalunit --op update --tid 2 --lun 1 --name 
scsi_id --value "CDROM ISO"
tgtadm --lld iscsi --mode logicalunit --op update --tid 2 --lun 1 --name 
scsi_sn --value "001"

and log into that target (using open-iscsi) I get in my dmesg:

scsi2 : iSCSI Initiator over TCP/IP
scsi 2:0:0:0: RAID              IET      Controller       0001 PQ: 0 ANSI: 5
scsi 2:0:0:0: Attached scsi generic sg2 type 12
scsi 2:0:0:1: CD-ROM            MITSUMI  FD001            0001 PQ: 0 ANSI: 5
sr1: scsi-1 drive
sr 2:0:0:1: Attached scsi CD-ROM sr1
sr 2:0:0:1: Attached scsi generic sg3 type 5

However, if I use the command:

tgtadm --lld iscsi --op show --mode target

it shows up as (part of it at least):

        LUN: 1
            Type: cd/dvd
            SCSI ID: CDROM ISO
            SCSI SN: 001
            Size: 628M
            Online: Yes
            Poweron/Reset: No
            Removable media: Yes

so the scsi_id and scsi_sn are not used on the initiator and never turn 
up, it's the vendor_id and product_id that show up.

Can somebody shed some light on this (seemingly) inconsistent behaviour?

Thanks,

Albert





-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070807/94c6da39/attachment.html>

From erezz at voltaire.com  Tue Aug  7 11:21:40 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Tue, 07 Aug 2007 12:21:40 +0300
Subject: [Stgt-devel] dd fails with iSER
Message-ID: <46B839A4.2080306@voltaire.com>

Pete,


I was able to setup stgt with iSER support. However, when I try to run a
simple sgp_dd (or dd) command, I get SCSI errors on the initiator side:


writing blk=256: Host_status=0x02 [DID_BUS_BUSY]
error finishing sg out command


If I connect to the target over TCP, everything works ok. Also, if I
connect to our iSCSI over iSER target (not stgt), it also works ok with
iSER.


Is there any required patch for iSER/open-iscsi on the initiator side?
Is there any debug info that I can see on the target side?


-- 

____________________________________________________________

Erez Zilber | 972-9-971-7689

Software Engineer, Storage Team

Voltaire ? _The Grid Backbone_

__

www.voltaire.com <http://www.voltaire.com/>





From markh794 at gmail.com  Tue Aug  7 12:51:32 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Tue, 07 Aug 2007 20:51:32 +1000
Subject: [Stgt-devel] Inconsistency in usage of scsi_id and iscsi_sn?
In-Reply-To: <46B823A5.3010309@gmail.com>
References: <46B823A5.3010309@gmail.com>
Message-ID: <46B84EB4.4090509@gmail.com>

Try a 'lsscsi -g' and then a "sg_inq -v /dev/sg??' where ?? is the sg 
path returned from 'lsscsi -g'
And
sg_inq -p 80 /dev/sg??
sg_inq -p 83 /dev/sg??

Some of the parameters are used inq params 80, 83 etc

I need to refer back to the code to identify exactly where each param is 
used. (A follow up email tomorrow).

Note: lsscsi & sg3_utils available from www.torque.net/sg/

Cheers
Mark

Albert Pauw wrote:
> I noticed something inconsistent (or so it seems).
>
> If I define something like this:
>
> tgtadm --lld iscsi --mode logicalunit --op update --tid 2 --lun 1 
> --params 
> vendor_id=MITSUMI,product_id=FD001,product_rev=0001,removable=1,sense_format=0 
>
> tgtadm --lld iscsi --mode logicalunit --op update --tid 2 --lun 1 
> --name scsi_id --value "CDROM ISO"
> tgtadm --lld iscsi --mode logicalunit --op update --tid 2 --lun 1 
> --name scsi_sn --value "001"
>
> and log into that target (using open-iscsi) I get in my dmesg:
>
> scsi2 : iSCSI Initiator over TCP/IP
> scsi 2:0:0:0: RAID              IET      Controller       0001 PQ: 0 
> ANSI: 5
> scsi 2:0:0:0: Attached scsi generic sg2 type 12
> scsi 2:0:0:1: CD-ROM            MITSUMI  FD001            0001 PQ: 0 
> ANSI: 5
> sr1: scsi-1 drive
> sr 2:0:0:1: Attached scsi CD-ROM sr1
> sr 2:0:0:1: Attached scsi generic sg3 type 5
>
> However, if I use the command:
>
> tgtadm --lld iscsi --op show --mode target
>
> it shows up as (part of it at least):
>
>        LUN: 1
>            Type: cd/dvd
>            SCSI ID: CDROM ISO
>            SCSI SN: 001
>            Size: 628M
>            Online: Yes
>            Poweron/Reset: No
>            Removable media: Yes
>
> so the scsi_id and scsi_sn are not used on the initiator and never 
> turn up, it's the vendor_id and product_id that show up.
>
> Can somebody shed some light on this (seemingly) inconsistent behaviour?
>
> Thanks,
>
> Albert
>
>
>
>
>
>
> ------------------------------------------------------------------------
>
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>   



From albert.pauw at gmail.com  Tue Aug  7 13:01:50 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Tue, 07 Aug 2007 13:01:50 +0200
Subject: [Stgt-devel] Inconsistency in usage of scsi_id and iscsi_sn?
In-Reply-To: <46B84EB4.4090509@gmail.com>
References: <46B823A5.3010309@gmail.com> <46B84EB4.4090509@gmail.com>
Message-ID: <46B8511E.6080806@gmail.com>

Mark Harvey wrote:
> Try a 'lsscsi -g' and then a "sg_inq -v /dev/sg??' where ?? is the sg 
> path returned from 'lsscsi -g'
> And
> sg_inq -p 80 /dev/sg??
> sg_inq -p 83 /dev/sg??
>
> Some of the parameters are used inq params 80, 83 etc
>
> I need to refer back to the code to identify exactly where each param 
> is used. (A follow up email tomorrow).
>
> Note: lsscsi & sg3_utils available from www.torque.net/sg/
>
> Cheers
> Mark
[root at orange ~]# sg_inq -v /dev/sg3
    inquiry cdb: 12 00 00 00 24 00
standard INQUIRY:
    inquiry cdb: 12 00 00 00 42 00
  PQual=0  Device_type=5  RMB=1  version=0x05  [SPC-3]
  [AERC=0]  [TrmTsk=1]  NormACA=0  HiSUP=0  Resp_data_format=2
  SCCS=0  ACC=0  TGPS=0  3PC=0  Protect=0  BQue=0
  EncServ=0  MultiP=0  [MChngr=0]  [ACKREQQ=0]  Addr16=0
  [RelAdr=0]  WBus16=0  Sync=0  Linked=0  [TranDis=0]  CmdQue=1
  [SPI: Clocking=0x0  QAS=0  IUS=0]
    length=66 (0x42)   Peripheral device type: cd/dvd
 Vendor identification: MITSUMI
 Product identification: FD001
 Product revision level: 0001
    inquiry cdb: 12 01 00 00 fc 00
    inquiry: requested 252 bytes but got 7 bytes
    inquiry cdb: 12 01 80 00 fc 00
    inquiry: requested 252 bytes but got 12 bytes
 Unit serial number: 001

[root at orange ~]# sg_inq -p 0x83 /dev/sg3
VPD INQUIRY: Device Identification page
  Designation descriptor number 1, descriptor length: 28
    id_type: T10 vendor identification,  code_set: Binary
    associated with the addressed logical unit
      vendor id: CDROM IS
      vendor specific: O

[root at orange ~]# sg_inq -p 0x80 /dev/sg3
VPD INQUIRY: Unit serial number page
  Unit serial number: 001

By the way, as you can see it's sg_inq -p 0x80/0x83 (hex, not decimal) 
but that was easy to figure out.
If you look at the vendor id and vendor specific of the -p 0x83, then it 
looks like the scsi_id is send,
but in a wrong way. The scsi_id was set up as "CDROM ISO", here you can 
see that vendor id is seen
as "CDROM IS" and vendor specific as "O?.

Albert




From pw at osc.edu  Wed Aug  8 00:42:48 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 7 Aug 2007 18:42:48 -0400
Subject: [Stgt-devel] dd fails with iSER
In-Reply-To: <46B839A4.2080306@voltaire.com>
References: <46B839A4.2080306@voltaire.com>
Message-ID: <20070807224248.GB31979@osc.edu>

erezz at voltaire.com wrote on Tue, 07 Aug 2007 12:21 +0300:
> I was able to setup stgt with iSER support. However, when I try to run a
> simple sgp_dd (or dd) command, I get SCSI errors on the initiator side:
> 
> writing blk=256: Host_status=0x02 [DID_BUS_BUSY]
> error finishing sg out command
> 
> If I connect to the target over TCP, everything works ok. Also, if I
> connect to our iSCSI over iSER target (not stgt), it also works ok with
> iSER.
> 
> Is there any required patch for iSER/open-iscsi on the initiator side?
> Is there any debug info that I can see on the target side?

Interesting.  I tend to use the bsg interface here for testing, and
may not have gone through all the paths in sg or sd.  Thanks for
testing!

I do have one initiator side patch for iser that I believe is just
to support bidirectional commands.  I'll try some dd without it to
see if it matters (on Thursday).  Can you send some of the exact
command lines that fail?

To debug the target, run as "tgtd -d 9" and it will produce lots of
messages to syslog.  We use a local patch here to send the messages
to stderr instead, but I think syslog should work for you.  If you
send the interesting parts from the log, I can help decipher the
messages.

		-- Pete


From erezz at voltaire.com  Wed Aug  8 11:11:34 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Wed, 08 Aug 2007 12:11:34 +0300
Subject: [Stgt-devel] dd fails with iSER
In-Reply-To: <20070807224248.GB31979@osc.edu>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
Message-ID: <46B988C6.8020707@voltaire.com>

Pete Wyckoff wrote:

> erezz at voltaire.com wrote on Tue, 07 Aug 2007 12:21 +0300:
>   
>> I was able to setup stgt with iSER support. However, when I try to run a
>> simple sgp_dd (or dd) command, I get SCSI errors on the initiator side:
>>
>> writing blk=256: Host_status=0x02 [DID_BUS_BUSY]
>> error finishing sg out command
>>
>> If I connect to the target over TCP, everything works ok. Also, if I
>> connect to our iSCSI over iSER target (not stgt), it also works ok with
>> iSER.
>>
>> Is there any required patch for iSER/open-iscsi on the initiator side?
>> Is there any debug info that I can see on the target side?
>>     
>
> Interesting.  I tend to use the bsg interface here for testing, and
> may not have gone through all the paths in sg or sd.  Thanks for
> testing!
>   

I'm not familiar with bsg. How do you use it?
> I do have one initiator side patch for iser that I believe is just
> to support bidirectional commands.  I'll try some dd without it to
> see if it matters (on Thursday).  Can you send some of the exact
> command lines that fail?
>   

Try something like the following command:

sgp_dd if=/dev/sg3 of=/dev/null count=10
> To debug the target, run as "tgtd -d 9" and it will produce lots of
> messages to syslog.  We use a local patch here to send the messages
> to stderr instead, but I think syslog should work for you.  If you
> send the interesting parts from the log, I can help decipher the
> messages.
>   
When I run with "tgtd -d 9", I don't see any logs. I only see:

Aug  8 12:01:27 noni tgtd: Target daemon logger with pid=6353 started!

Erez



From pw at osc.edu  Thu Aug  9 22:22:34 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 9 Aug 2007 16:22:34 -0400
Subject: [Stgt-devel] dd fails with iSER
In-Reply-To: <46B988C6.8020707@voltaire.com>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com>
Message-ID: <20070809202234.GA26911@osc.edu>

erezz at voltaire.com wrote on Wed, 08 Aug 2007 12:11 +0300:
> sgp_dd if=/dev/sg3 of=/dev/null count=10
[..]

My usual tree is 2.6.22-rc5 with bidi patches from Tomo and Boaz
mixed in, plus local fixes for iser bidirectional and AHS.  I tried
a stock 2.6.23-rc2, no bidi, and did indeed find one problem, which
is worked around with the below (also in git).  It was not an issue
of missing kernel patches on the initiator (whew).

But there is a larger problem which we must address soon related to
flow control of outstanding RDMA operations.  The reason we hadn't
run into the problem here is that we always adjust the transfer
settings for better performance:

        ./tgtadm --lld iscsi --mode target --op update --tid 1 \
                 --name MaxRecvDataSegmentLength --value 262144
        ./tgtadm --lld iscsi --mode target --op update --tid 1 \
                 --name FirstBurstLength --value 262144

The default values are 8k and 64k respectively.  It is the very
small 8k that gets us into trouble by requiring lots of small RDMA
operations to satisfy a transfer.

There is also a spot in /etc/iscsi/iscsid.conf where you can adjust
the default value for the initiator:

	node.conn[0].iscsi.MaxRecvDataSegmentLength = 262144

Its default is a more reasonable 128k.

I'll look into this matter further, but this hopefully will let you
do some basic testing.

> When I run with "tgtd -d 9", I don't see any logs. I only see:
> 
> Aug  8 12:01:27 noni tgtd: Target daemon logger with pid=6353 started!

It seems to produce logs at level <31>, which syslog ignores.  You
can do this though:

./tgtd -d 9 -f &

Then run the tgtadm commands and you should see output on stderr.

		-- Pete



From pw at osc.edu  Thu Aug  9 22:14:35 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 9 Aug 2007 16:14:35 -0400
Subject: [PATCH] iser more rdma bufs
Message-ID: <mailman.16.1331738474.12506.stgt-devel@lists.berlios.de>

Increase the number of slots used for RDMA transfers.  This does not
actually require more buffer space, just lists for keeping track of
outstanding operations.

It is best to minimize the number of RDMA transfers required for data
motion, however.  This can be done by increasing the maximum data transfer
length parameter in both the target and the initiator.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_rdma.c |   43 +++++++++++++++++++++++++------------------
 1 files changed, 25 insertions(+), 18 deletions(-)

diff --git a/usr/iscsi/iscsi_rdma.c b/usr/iscsi/iscsi_rdma.c
index adff476..5c308fa 100644
--- a/usr/iscsi/iscsi_rdma.c
+++ b/usr/iscsi/iscsi_rdma.c
@@ -164,6 +164,14 @@ struct conn_info {
 #define MAX_RSIZE 8192
 #define ISER_INITIAL_POST 10  /*XXX make this a global variable and set it to what gets negotiated at login*/
 
+/*
+ * Number of outstanding RDMAs per command; should instead wait for previous
+ * RDMAs to complete before starting new ones.  For RDMA write, each one
+ * will be no bigger than max burst, so we end up issuing lots when the
+ * max_recv_dlength value is very low.
+ */
+#define RDMA_PER_COMMAND 32
+
 #define MEMPOOL_SZ (64)
 /* 512K + sizeof(iscsi_task) + AHS size */
 #define MEM_SZ (roundup((1 << 19) + sizeof(struct iscsi_task) + 260+28+48, \
@@ -250,7 +258,7 @@ static int iser_match_qp(uint32_t qp_num)
 static int iser_init_comm(struct conn_info *conn, ssize_t ssize,
 			  ssize_t rsize, int id)
 {
-	int i;
+	int i, j;
 	unsigned long size;
 	uint8_t *srbuf, *listbuf;
 	struct rdmalist *rdmal;
@@ -275,8 +283,9 @@ static int iser_init_comm(struct conn_info *conn, ssize_t ssize,
 	INIT_LIST_HEAD(&conn->rdmal);
 	INIT_LIST_HEAD(&conn->rdmal_write_busy);
 
-	size = ISER_INITIAL_POST * (sizeof(struct rdmalist)
-		+ sizeof(struct sendlist) + sizeof(struct recvlist));
+	size = ISER_INITIAL_POST * (RDMA_PER_COMMAND * sizeof(struct rdmalist)
+				    + sizeof(struct sendlist)
+				    + sizeof(struct recvlist));
 	conn->listbuf = malloc(size);
 	if (!conn->listbuf) {
 		eprintf("malloc listbuf %lu\n", size);
@@ -286,31 +295,29 @@ static int iser_init_comm(struct conn_info *conn, ssize_t ssize,
 	srbuf = conn->srbuf;
 	listbuf = conn->listbuf;
 	for (i=0; i<ISER_INITIAL_POST; i++){
-		rdmal = (void *) listbuf;
-		listbuf += sizeof(*rdmal);
+
+		for (j=0; j<RDMA_PER_COMMAND; j++) {
+			rdmal = (void *) listbuf;
+			listbuf += sizeof(*rdmal);
+			rdmal->conn_index = id;
+			rdmal->free = 1;
+			list_add_tail(&rdmal->list, &conn->rdmal);
+		}
 
 		sendl = (void *) listbuf;
 		listbuf += sizeof(*sendl);
+		sendl->buf = srbuf;
+		srbuf += ssize;
+		sendl->conn_index = id;
+		sendl->free = 1;
+		list_add_tail(&sendl->list, &conn->sendl);
 
 		recvl = (void *) listbuf;
 		listbuf += sizeof(*recvl);
-
 		recvl->buf = srbuf;
 		srbuf += rsize;
-
-		sendl->buf = srbuf;
-		srbuf += ssize;
-
-		rdmal->conn_index = id;
-		sendl->conn_index = id;
 		recvl->conn_index = id;
-
-		sendl->free = 1;
-		rdmal->free = 1;
-
-		list_add_tail(&sendl->list, &conn->sendl);
 		list_add_tail(&recvl->list, &conn->recvl);
-		list_add_tail(&rdmal->list, &conn->rdmal);
 	}
 	conn->slen = ssize;
 	conn->rlen = rsize;
-- 
1.5.2.4



From bardov at gmail.com  Fri Aug 10 18:34:50 2007
From: bardov at gmail.com (Dan Bar Dov)
Date: Fri, 10 Aug 2007 19:34:50 +0300
Subject: [Stgt-devel] RFC: tgt service script
Message-ID: <d6944c490708100934h74c6e6xe0781cc31e1935cd@mail.gmail.com>

Attached is a fedora service script that starts tgt daemon and iscsi-tgt
targets.

The configuration is saved is /etc/iscsi_tgt.conf which looks like that:
# -*-Shell-script-*-
# DEBUG=yes

# flags to pass to tgtd
TGTDARGS=

# list of targets to configure (symbolic names)
TARGETS="FIRST"

# for each target, setup values specific for that target
FIRST_name="iqn.2001-04.com.example:1"
# target id (tid)
FIRST_id=1
# list of devices for the named target. Order of devices
# determines LUN (first being #1)
FIRST_lus="/dev/sda2"
# list of access permissions
FIRST_acl="ALL"

On my setup (FC6, kernel 2.6.22.1) this script works

Dan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070810/a26a0b6d/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: iscsi_tgt.conf
Type: application/octet-stream
Size: 380 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070810/a26a0b6d/attachment.obj>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: iscsi_tgt
Type: application/octet-stream
Size: 1862 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070810/a26a0b6d/attachment-0001.obj>

From pw at osc.edu  Sat Aug 11 17:29:44 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 11 Aug 2007 11:29:44 -0400
Subject: [Stgt-devel] dd fails with iSER
In-Reply-To: <20070809202234.GA26911@osc.edu>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com> <20070809202234.GA26911@osc.edu>
Message-ID: <20070811152944.GA30943@osc.edu>

pw at osc.edu wrote on Thu, 09 Aug 2007 16:22 -0400:
> There is also a spot in /etc/iscsi/iscsid.conf where you can adjust
> the default value for the initiator:
> 
> 	node.conn[0].iscsi.MaxRecvDataSegmentLength = 262144
> 
> Its default is a more reasonable 128k.

This advice is correct, but for the wrong reasons.  The situation is
more complex than I had thought.  The iSER spec doesn't provide
guidance on how to set the maximum data segment lentgh for RDMA
transfers.  It adds two new parameters:

   InitiatorRecvDataSegmentLength - size of data segment in control PDUs
   	sent to initiator
   TargetRecvDataSegmentLength - size of data segment in control PDUs
   	sent to target

and tells us to ignore MaxRecvDataSegmentLength.  But it doesn't say
how we should figure out the limit for data-type PDUs, i.e. for RDMA
transfers, or even if there should be one.  The phrase "control
PDUs" means non-RDMA transfers.

One approach would be to have the target RDMA the entire data
segment in a single operation.  This approach minimizes the
overhead, but doesn't let us pipeline and may not be possible for
large transfer sizes.  The OS won't let us pin all the memory
required for the transfer, perhaps.

Instead I've added another patch that changes the MaxRDSL in the
target to be whatever was negotiated for IRDSL.  Since I see no way
in the spec how the target could send data in a control type PDU,
IRDSL wasn't doing anything for us anyway.  And open-iscsi uses its
conn->max_recv_dlength as the starting point for IRDSL, which seems
reasonable.

Incidentally, Erez, it was you who added IRDSL support to open-iscsi
back in Oct 2005.  Apparently you agree with my interpretation?

So the final story is:

    - you can leave the previous patch "iser more rdma bufs" applied
	as it is harmless and probably a good idea anyway

    - apply the patch below for completeness

    - make sure you have the quoted line above in your iscsid.conf

You should see no change in behavior, but now the code is at least
rational, I think.  (git.osc.edu is up to date with this patch too.)

		-- Pete



From pw at osc.edu  Sat Aug 11 16:55:50 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 11 Aug 2007 10:55:50 -0400
Subject: [PATCH] iser fix initiator dlength
Message-ID: <mailman.17.1331738474.12506.stgt-devel@lists.berlios.de>

Set the iscsi param max_xmit_dlength from the initiator_rdsl param in
the case of RDMA.  Otherwise the data_rsp_build and r2t_build use the
wrong size in RDMA mode.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    8 ++++++++
 1 files changed, 8 insertions(+), 0 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 15c3623..a3fa6af 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -517,6 +517,14 @@ static void login_finish(struct iscsi_connection *conn)
 				break;
 			}
 		}
+		/*
+		 * data_rsp_build and r2t_build use this parameter
+		 * to size packets going to the initiator.  Set it
+		 * here rather than "if rdma" in those functions.
+		 */
+		if (conn->tp->rdma)
+			conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val =
+				conn->session_param[ISCSI_PARAM_INITIATOR_RDSL].val;
 		memcpy(conn->isid, conn->session->isid, sizeof(conn->isid));
 		conn->tsih = conn->session->tsih;
 
-- 
1.5.2.4



From bardov at gmail.com  Sat Aug 11 17:49:06 2007
From: bardov at gmail.com (Dan Bar Dov)
Date: Sat, 11 Aug 2007 18:49:06 +0300
Subject: [Stgt-devel] dd fails with iSER
In-Reply-To: <20070811152944.GA30943@osc.edu>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com> <20070809202234.GA26911@osc.edu>
	<20070811152944.GA30943@osc.edu>
Message-ID: <d6944c490708110849t37a3b1e7o791b4366805b7fa9@mail.gmail.com>

On 8/11/07, Pete Wyckoff <pw at osc.edu> wrote:
>
> pw at osc.edu wrote on Thu, 09 Aug 2007 16:22 -0400:
> > There is also a spot in /etc/iscsi/iscsid.conf where you can adjust
> > the default value for the initiator:
> >
> >       node.conn[0].iscsi.MaxRecvDataSegmentLength = 262144
> >
> > Its default is a more reasonable 128k.
>
> This advice is correct, but for the wrong reasons.  The situation is
> more complex than I had thought.  The iSER spec doesn't provide
> guidance on how to set the maximum data segment lentgh for RDMA
> transfers.  It adds two new parameters:
>
>    InitiatorRecvDataSegmentLength - size of data segment in control PDUs
>         sent to initiator
>    TargetRecvDataSegmentLength - size of data segment in control PDUs
>         sent to target
>
> and tells us to ignore MaxRecvDataSegmentLength.  But it doesn't say
> how we should figure out the limit for data-type PDUs, i.e. for RDMA
> transfers, or even if there should be one.  The phrase "control
> PDUs" means non-RDMA transfers.


There are no "data-type" PDUs in ISER, that's why no limit for them is
mentioned. Control type PDUs can carry unsolicited data, but that is true
only for write ops. As to RDMA ops, the initiator communicates the size of
transfer and registration key, allowing the target to do the transfer, be it
read or write, in on or several RDMA ops, as many as it likes. The initiator
controls the overall using the info in the control PDU plus the ISER header.
The separation of MRDSL to IRDSL and TRDSL is necessary since in RDMA each
side needs to prepare a post-recv buffer, and each side communicates to the
other side what its capabilities are.

Dan

One approach would be to have the target RDMA the entire data
> segment in a single operation.  This approach minimizes the
> overhead, but doesn't let us pipeline and may not be possible for
> large transfer sizes.  The OS won't let us pin all the memory
> required for the transfer, perhaps.
>
> Instead I've added another patch that changes the MaxRDSL in the
> target to be whatever was negotiated for IRDSL.  Since I see no way
> in the spec how the target could send data in a control type PDU,
> IRDSL wasn't doing anything for us anyway.  And open-iscsi uses its
> conn->max_recv_dlength as the starting point for IRDSL, which seems
> reasonable.
>
> Incidentally, Erez, it was you who added IRDSL support to open-iscsi
> back in Oct 2005.  Apparently you agree with my interpretation?
>
> So the final story is:
>
>     - you can leave the previous patch "iser more rdma bufs" applied
>         as it is harmless and probably a good idea anyway
>
>     - apply the patch below for completeness
>
>     - make sure you have the quoted line above in your iscsid.conf
>
> You should see no change in behavior, but now the code is at least
> rational, I think.  (git.osc.edu is up to date with this patch too.)
>
>                 -- Pete
>
>
> From e1881832761741fcc8b0baf8de3e02d5fc2b8739 Mon Sep 17 00:00:00 2001
> From: Pete Wyckoff <pw at osc.edu>
> Date: Sat, 11 Aug 2007 10:55:50 -0400
> Subject: [PATCH] iser fix initiator dlength
>
> Set the iscsi param max_xmit_dlength from the initiator_rdsl param in
> the case of RDMA.  Otherwise the data_rsp_build and r2t_build use the
> wrong size in RDMA mode.
>
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
> usr/iscsi/iscsid.c |    8 ++++++++
> 1 files changed, 8 insertions(+), 0 deletions(-)
>
> diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> index 15c3623..a3fa6af 100644
> --- a/usr/iscsi/iscsid.c
> +++ b/usr/iscsi/iscsid.c
> @@ -517,6 +517,14 @@ static void login_finish(struct iscsi_connection
> *conn)
>                                 break;
>                         }
>                 }
> +               /*
> +                * data_rsp_build and r2t_build use this parameter
> +                * to size packets going to the initiator.  Set it
> +                * here rather than "if rdma" in those functions.
> +                */
> +               if (conn->tp->rdma)
> +
> conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val =
> +
> conn->session_param[ISCSI_PARAM_INITIATOR_RDSL].val;
>                 memcpy(conn->isid, conn->session->isid,
> sizeof(conn->isid));
>                 conn->tsih = conn->session->tsih;
>
> --
> 1.5.2.4
>
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070811/9fe43ea7/attachment.html>

From nezhinsky at gmail.com  Sun Aug 12 12:12:32 2007
From: nezhinsky at gmail.com (Alexander Nezhinsky)
Date: Sun, 12 Aug 2007 12:12:32 +0200
Subject: [Stgt-devel] dd fails with iSER
In-Reply-To: <d6944c490708110849t37a3b1e7o791b4366805b7fa9@mail.gmail.com>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com> <20070809202234.GA26911@osc.edu>
	<20070811152944.GA30943@osc.edu>
	<d6944c490708110849t37a3b1e7o791b4366805b7fa9@mail.gmail.com>
Message-ID: <5eb093080708120312i1287f1f7p2fcaed789bf70cc7@mail.gmail.com>

> > and tells us to ignore MaxRecvDataSegmentLength.  But it doesn't say
> > how we should figure out the limit for data-type PDUs, i.e. for RDMA
> > transfers, or even if there should be one.  The phrase "control
> > PDUs" means non-RDMA transfers.
>
> There are no "data-type" PDUs in ISER, that's why no limit for them is
> mentioned. Control type PDUs can carry unsolicited data, but that is true
> only for write ops. As to RDMA ops, the initiator communicates the size of
> transfer and registration key, allowing the target to do the transfer, be it
> read or write, in on or several RDMA ops, as many as it likes.

iSER spec is silent about the granularity of RDMA transfers
because it says nothing about the meaning of MaxBurstLength and
MaxRecvDataSegmentLength, when applied to the solicited data of
a write op, and to the entire data of a read op.

On the other hand, it maps R2T PDUs to RDMA Reads,
and Data-IN to RDMA Writes (changing their meaning), but does not
require that their sizes must be governed by either
MaxBurstLength (for R2Ts) or MaxRecvDataSegmentLength
(for Data-INs).

Thus we can interpret them freely, from the formal point of view.
Moreover, this does not contradict the spirit of the protocol,
which makes all RDMA transfers a target's responsibility.

> > One approach would be to have the target RDMA the entire data
> > segment in a single operation.  This approach minimizes the
> > overhead, but doesn't let us pipeline and may not be possible for
> > large transfer sizes.  The OS won't let us pin all the memory
> > required for the transfer, perhaps.

Another approach is to break both read and write RDMA transfers into
smaller units, allowing internal queuing, pipelining and efficient use
of memory.

This means that the target should set for itself some internal values
of MaxBurstLength and Data-IN's MaxRecvDataSegmentLength.
These values will govern generation of R2Ts and Data-IN and these,
in turn, will initiate a series of RDMA transfers with the desired granularity.

> > Instead I've added another patch that changes the MaxRDSL in the
> > target to be whatever was negotiated for IRDSL.  Since I see no way
> > in the spec how the target could send data in a control type PDU,
> > IRDSL wasn't doing anything for us anyway.  And open-iscsi uses its
> > conn->max_recv_dlength as the starting point for IRDSL, which seems
> > reasonable.

One example of target sending data in a control type PDU is a Response
PDU carrying sense data. Other types are Text-Responses outside Login
phase and some Task mgmt Responses (for higher error levels).
Anyway, the negotiated IRDSL value don't explicitly affect the target.
It just guarantees that the initiator is able to receive our PDUs.

To summarize, the proposed approach uses the following policy:

1. If MaxRDSL declared by the other side is different from the negotiated
value of IRDSL, ignore it.
2. If no MaxRDSL was declared by the initiator, do not declare one
of your own. Otherwise declare the negotiated value of TRDSL.
3. In any case set the internal MRDSL values to those negotiated as
IRDSL,ORDSL.

4. When negotiating MaxBurstLength agree with any value proposed by
the initiator (it won't be used anyway). When negotiating IRDSL agree
with any value proposed by the initiator (unless there are some special
considerations regarding the potential control PDUs), and then use it
of course, when applicable.

5. Set some internal value for MaxBurstLength and use it to generate
R2T PDUs effectively splitting the RDMA Read transfers into smaller
portions of  limited size.
6. Introduce a new internal variable DataInMaxDSL that holds the
value of MRDSL to be internally applied to generation of Data-INs,
This effectively splits the RDMA Write transfers into smaller portions
of  limited size.

The internal values of MaxBurstLength  and DataInMaxDSL should try
to achieve good performance, while making reasonable memory
allocation requirements etc. They may be either hardcoded or tunable.

Alexander Nezhinsky


From erezz at voltaire.com  Sun Aug 12 15:04:15 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Sun, 12 Aug 2007 16:04:15 +0300
Subject: [Stgt-devel] dd fails with iSER
In-Reply-To: <20070811152944.GA30943@osc.edu>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com> <20070809202234.GA26911@osc.edu>
	<20070811152944.GA30943@osc.edu>
Message-ID: <46BF054F.9020209@voltaire.com>

Pete Wyckoff wrote:

> pw at osc.edu wrote on Thu, 09 Aug 2007 16:22 -0400:
>   
>> There is also a spot in /etc/iscsi/iscsid.conf where you can adjust
>> the default value for the initiator:
>>
>> 	node.conn[0].iscsi.MaxRecvDataSegmentLength = 262144
>>
>> Its default is a more reasonable 128k.
>>     
>
> This advice is correct, but for the wrong reasons.  The situation is
> more complex than I had thought.  The iSER spec doesn't provide
> guidance on how to set the maximum data segment lentgh for RDMA
> transfers.  It adds two new parameters:
>
>    InitiatorRecvDataSegmentLength - size of data segment in control PDUs
>    	sent to initiator
>    TargetRecvDataSegmentLength - size of data segment in control PDUs
>    	sent to target
>
> and tells us to ignore MaxRecvDataSegmentLength.  But it doesn't say
> how we should figure out the limit for data-type PDUs, i.e. for RDMA
> transfers, or even if there should be one.  The phrase "control
> PDUs" means non-RDMA transfers.
>
> One approach would be to have the target RDMA the entire data
> segment in a single operation.  This approach minimizes the
> overhead, but doesn't let us pipeline and may not be possible for
> large transfer sizes.  The OS won't let us pin all the memory
> required for the transfer, perhaps.
>
> Instead I've added another patch that changes the MaxRDSL in the
> target to be whatever was negotiated for IRDSL.

See what the spec says about this:

8.2 MaxRecvDataSegmentLength

[...]
Similarly, the target MUST consider the value of its local
MaxRecvDataSegmentLength (that it would have declared to the initiator)
as having the value of TargetRecvDataSegmentLength, and the value of the
remote MaxRecvDataSegmentLength (that would have been declared by the
initiator) as having the value of InitiatorRecvDataSegmentLength.

Therefore, setting MaxRDSL = IRDSL seems to be against the spec.
Instead, you should do: MaxRDSL = TRDSL

>   Since I see no way
> in the spec how the target could send data in a control type PDU,
> IRDSL wasn't doing anything for us anyway.
As Alex mentioned, the target does send control PDUs back to the initiator.
>   And open-iscsi uses its
> conn->max_recv_dlength as the starting point for IRDSL, which seems
> reasonable.
>   

The initiator follows the spec:

    } else if (iscsi_find_key_value("InitiatorRecvDataSegmentLength", text,
                    end, &value, &value_end)) {
        if (session->t->template->rdma) {
            conn->max_recv_dlength = MIN(conn->max_recv_dlength,
                             strtoul(value, NULL, 0));
        }
        text = value_end;
    } else if (iscsi_find_key_value("TargetRecvDataSegmentLength", text,
                    end, &value, &value_end)) {
        if (session->t->template->rdma) {
            conn->max_xmit_dlength = MIN(conn->max_xmit_dlength,
                             strtoul(value, NULL, 0));
        }
        text = value_end;

It sets InitiatorRecvDataSegmentLength to the minimum value that was
proposed by both sides. It sets conn->max_recv_dlength to the value that
was negotiated for InitiatorRecvDataSegmentLength (see 8.5 in the spec:
"It (InitiatorRecvDataSegmentLength) is used by the initiator and the
target to negotiate the maximum size of the data segment that a
target may send to the initiator in an iSCSI control-type PDU.")

The same thing happens with TargetRecvDataSegmentLength.

So, I suggest that we set MaxRDSL according to 8.2 in the iSER spec.

As for the default values that the target will propose - this is another
thing to consider, and is not covered by the spec (as Dan & Alex mentioned).

Erez



From erezz at voltaire.com  Sun Aug 12 15:16:04 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Sun, 12 Aug 2007 16:16:04 +0300
Subject: [Stgt-devel] dd fails with iSER
In-Reply-To: <5eb093080708120312i1287f1f7p2fcaed789bf70cc7@mail.gmail.com>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com> <20070809202234.GA26911@osc.edu>
	<20070811152944.GA30943@osc.edu>
	<d6944c490708110849t37a3b1e7o791b4366805b7fa9@mail.gmail.com>
	<5eb093080708120312i1287f1f7p2fcaed789bf70cc7@mail.gmail.com>
Message-ID: <46BF0814.3080907@voltaire.com>

Alexander Nezhinsky wrote:

> > > and tells us to ignore MaxRecvDataSegmentLength.  But it doesn't say
> > > how we should figure out the limit for data-type PDUs, i.e. for RDMA
> > > transfers, or even if there should be one.  The phrase "control
> > > PDUs" means non-RDMA transfers.
> >
> > There are no "data-type" PDUs in ISER, that's why no limit for them is
> > mentioned. Control type PDUs can carry unsolicited data, but that is
> true
> > only for write ops. As to RDMA ops, the initiator communicates the
> size of
> > transfer and registration key, allowing the target to do the
> transfer, be it
> > read or write, in on or several RDMA ops, as many as it likes.
>
> iSER spec is silent about the granularity of RDMA transfers
> because it says nothing about the meaning of MaxBurstLength and
> MaxRecvDataSegmentLength, when applied to the solicited data of
> a write op, and to the entire data of a read op.
>
> On the other hand, it maps R2T PDUs to RDMA Reads,
> and Data-IN to RDMA Writes (changing their meaning), but does not
> require that their sizes must be governed by either
> MaxBurstLength (for R2Ts) or MaxRecvDataSegmentLength
> (for Data-INs).
>
> Thus we can interpret them freely, from the formal point of view.
> Moreover, this does not contradict the spirit of the protocol,
> which makes all RDMA transfers a target's responsibility.
>
> > > One approach would be to have the target RDMA the entire data
> > > segment in a single operation.  This approach minimizes the
> > > overhead, but doesn't let us pipeline and may not be possible for
> > > large transfer sizes.  The OS won't let us pin all the memory
> > > required for the transfer, perhaps.
>
> Another approach is to break both read and write RDMA transfers into
> smaller units, allowing internal queuing, pipelining and efficient use
> of memory.
>
> This means that the target should set for itself some internal values
> of MaxBurstLength and Data-IN's MaxRecvDataSegmentLength.
> These values will govern generation of R2Ts and Data-IN and these,
> in turn, will initiate a series of RDMA transfers with the desired
> granularity.
>
> > > Instead I've added another patch that changes the MaxRDSL in the
> > > target to be whatever was negotiated for IRDSL.  Since I see no way
> > > in the spec how the target could send data in a control type PDU,
> > > IRDSL wasn't doing anything for us anyway.  And open-iscsi uses its
> > > conn->max_recv_dlength as the starting point for IRDSL, which seems
> > > reasonable.
>
> One example of target sending data in a control type PDU is a Response
> PDU carrying sense data. Other types are Text-Responses outside Login
> phase and some Task mgmt Responses (for higher error levels).
> Anyway, the negotiated IRDSL value don't explicitly affect the target.
> It just guarantees that the initiator is able to receive our PDUs.
>
> To summarize, the proposed approach uses the following policy:
>
> 1. If MaxRDSL declared by the other side is different from the negotiated
> value of IRDSL, ignore it.
>
Hold your horses:


8.2 MaxRecvDataSegmentLength
For an iSCSI connection belonging to a session in which
RDMAExtensions=Yes was negotiated on the leading connection of the
session, MaxRecvDataSegmentLength need not be declared in the Login
Phase.


We don't need to negotiate MaxRecvDataSegmentLength on an iSER
connection. Actually, we establish a connection over iSER and start the
login phase. If we were able to connect over iSER, we don't send keys
that aren't relevant for iSER. Here's the code from login.c in open-iscsi:


    if (session->type == ISCSI_SESSION_TYPE_DISCOVERY ||
           !session->t->template->rdma) {
        sprintf(value, "%d", conn->max_recv_dlength);
        if (!iscsi_add_text(pdu, data, max_data_length,
                    "MaxRecvDataSegmentLength", value))
            return 0;
    } else {
        sprintf(value, "%d", conn->max_recv_dlength);
        if (!iscsi_add_text(pdu, data, max_data_length,
                   "InitiatorRecvDataSegmentLength",
                    value))
            return 0;

        sprintf(value, "%d", conn->max_xmit_dlength);
        if (!iscsi_add_text(pdu, data, max_data_length,
                   "TargetRecvDataSegmentLength",
                    value))
            return 0;

        if (!iscsi_add_text(pdu, data, max_data_length,
                   "RDMAExtensions", "Yes"))
            return 0;
    }


Erez



From erezz at voltaire.com  Sun Aug 12 16:03:31 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Sun, 12 Aug 2007 17:03:31 +0300
Subject: [Stgt-devel] dd fails with iSER
In-Reply-To: <20070809202234.GA26911@osc.edu>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com> <20070809202234.GA26911@osc.edu>
Message-ID: <46BF1333.4020801@voltaire.com>


> > When I run with "tgtd -d 9", I don't see any logs. I only see:
> >
> > Aug  8 12:01:27 noni tgtd: Target daemon logger with pid=6353 started!
>
> It seems to produce logs at level <31>, which syslog ignores.  You
> can do this though:
>
> ./tgtd -d 9 -f &
>
> Then run the tgtadm commands and you should see output on stderr.
>

I ran the following command:

sgp_dd bs=512 of=/dev/null if=/dev/sg3 bpt=256 thr=8 time=1 count=8000

and got the following error:

[...]
iser_progress() Entry.
tgtd: iser_progress(1381) trying tx on fd 0 conn 0x636d90
tgtd: iscsi_task_tx_start(1750) found a task 3a 131072 0 0
tgtd: iscsi_data_rsp_build(969) 131072 131072 131072 131072 3a
[iSER]:in iser_rdma_write size 131072, 0x636f08.
tgtd: iser_rdma_write(1250) offset 131072 len 131072 last 1
[iSER]:in iser_post_rdma_wr size 131072 rem_va 46980000 rem_stag bef4005b.
[iSER]:iser_post_rdma_wr() Exit rdma = 0x63f090.
tgtd: iser_rdma_write(1267) removing ep 0 from tx ready list
tgtd: iser_event_modify(1434) ep 0 events 1
tgtd: iser_event_modify(1445) removing ep 0 from tx ready list
tgtd: iscsi_scsi_cmd_tx_done(1703) more data or sense or bidir 3a
[iSER]:iser_progress() Exit.
[iSER]:iser_progress() Entry.
[iSER]:iser_progress() Exit.
[iSER]:iser_progress() Entry.
[iSER]:iser_progress() Exit.
[iSER]:iser_progress() Entry.
[iSER]:iser_progress() Exit.
[iSER]:iser_cqe_handler() Entry.
[iSER]:iser_cqe_handler() Exit.
tgtd: bs_sync_handler(193) back to tgtd, 0x2aaaaab2c0f0
tgtd: iser_event_modify(1434) ep 0 events 5
tgtd: iser_event_modify(1438) adding ep 0 to tx ready list
tgtd: bs_sync_handler(193) back to tgtd, 0x2aaaaad300f0
tgtd: iser_event_modify(1434) ep 0 events 5
tgtd: iser_event_modify(1441) ep 0 was already on the list.  Track?
tgtd: bs_sync_handler(193) back to tgtd, 0x2aaaaae320f0
tgtd: iser_event_modify(1434) ep 0 events 5
tgtd: iser_event_modify(1441) ep 0 was already on the list.  Track?
[iSER]:tgtd: bs_sync_ack_fn(94) found 0x2aaaaac2e0f0
iser_progress() Entry.
tgtd: iser_progress(1381) trying tx on fd 0 conn 0x636d90
tgtd: iscsi_task_tx_start(1750) found a task 39 131072 131072 0
tgtd: iscsi_cmd_rsp_build(897) 0x2aaaaaaab010 28
[iSER]:in iscsi_iser_write_begin nbytes 48.
[iSER]:iscsi_iser_write_begin: alloc new send event 0x640010.
[iSER]:iscsi_iser_write_end: continue send event 0x640010, writeb 76.
tgtd: iscsi_iser_write_end(1065) waking up progress to finish cmd
[iSER]:iscsi_iser_write_end exit 0x640010.
tgtd: __cmd_done(618) 1 2aaaaaaab2b0 131072 0
tgtd: iser_progress(1381) trying tx on fd 0 conn 0x636d90
tgtd: iscsi_task_tx_start(1750) found a task 0 4294967295 0 0
[iSER]:in iscsi_iser_write_begin nbytes 48.
[iSER]:iscsi_iser_write_begin: alloc new send event 0x6410e0.
[iSER]:iscsi_iser_write_end: continue send event 0x6410e0, writeb 76.
tgtd: iscsi_iser_write_end(1065) waking up progress to finish cmd
[iSER]:iscsi_iser_write_end exit 0x6410e0.
tgtd: iser_progress(1381) trying tx on fd 0 conn 0x636d90
tgtd: iscsi_task_tx_start(1750) found a task 3b 131072 0 0
tgtd: iscsi_data_rsp_build(969) 131072 131072 131072 131072 3b
[iSER]:in iser_rdma_write size 131072, 0x636f08.
tgtd: iser_rdma_write(1250) offset 131072 len 131072 last 1
[iSER]:in iser_post_rdma_wr size 131072 rem_va 46980000 rem_stag bef4005b.
[iSER]:iser_post_rdma_wr() Exit rdma = 0x63f010.
tgtd: iser_rdma_write(1267) removing ep 0 from tx ready list
tgtd: iser_event_modify(1434) ep 0 events 1
tgtd: iser_event_modify(1445) removing ep 0 from tx ready list
tgtd: iscsi_scsi_cmd_tx_done(1703) more data or sense or bidir 3b
[iSER]:iser_progress() Exit.
[iSER]:iser_progress() Entry.
[iSER]:iser_progress() Exit.
[iSER]:iser_progress() Entry.
[iSER]:iser_progress() Exit.
[iSER]:iser_progress() Entry.
[iSER]:iser_progress() Exit.
[iSER]:iser_progress() Entry.
[iSER]:iser_progress() Exit.
[iSER]:iser_cqe_handler() Entry.
tgtd: iser_cqe_handler(888) bad WC status 10 for wr_id 0x63f090

If you need the whole log, I can send it.

Erez



From pw at osc.edu  Mon Aug 13 04:18:47 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sun, 12 Aug 2007 22:18:47 -0400
Subject: [Stgt-devel] dd fails with iSER
In-Reply-To: <5eb093080708120312i1287f1f7p2fcaed789bf70cc7@mail.gmail.com>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com> <20070809202234.GA26911@osc.edu>
	<20070811152944.GA30943@osc.edu>
	<d6944c490708110849t37a3b1e7o791b4366805b7fa9@mail.gmail.com>
	<5eb093080708120312i1287f1f7p2fcaed789bf70cc7@mail.gmail.com>
Message-ID: <20070813021847.GA26036@osc.edu>

nezhinsky at gmail.com wrote on Sun, 12 Aug 2007 12:12 +0200:
> To summarize, the proposed approach uses the following policy:
> 
> 1. If MaxRDSL declared by the other side is different from the negotiated
> value of IRDSL, ignore it.
> 2. If no MaxRDSL was declared by the initiator, do not declare one
> of your own. Otherwise declare the negotiated value of TRDSL.
> 3. In any case set the internal MRDSL values to those negotiated as
> IRDSL,ORDSL.
> 
> 4. When negotiating MaxBurstLength agree with any value proposed by
> the initiator (it won't be used anyway). When negotiating IRDSL agree
> with any value proposed by the initiator (unless there are some special
> considerations regarding the potential control PDUs), and then use it
> of course, when applicable.
> 
> 5. Set some internal value for MaxBurstLength and use it to generate
> R2T PDUs effectively splitting the RDMA Read transfers into smaller
> portions of  limited size.
> 6. Introduce a new internal variable DataInMaxDSL that holds the
> value of MRDSL to be internally applied to generation of Data-INs,
> This effectively splits the RDMA Write transfers into smaller portions
> of  limited size.
> 
> The internal values of MaxBurstLength  and DataInMaxDSL should try
> to achieve good performance, while making reasonable memory
> allocation requirements etc. They may be either hardcoded or tunable.

Thank you for the extensive explanation.  Dan also hit on the key
point:  only the target is involved in choosing RDMA sizes (read or
write).  MaxRDSL has no influence on RDMA sizes.  And for the clue
that there are data segments from target to initiatior in some
cases whose lengths are  governed by IRDSL.

I was imagining a situation where the initiator would want to limit
the amount of incoming data when talking to many servers, to avoid
the TCP throughput collapse problem due to congestive backoff.  But
the initiatior could simply ask for less data from each target, i.e.
issue multiple requests.  There's no reason the initiator should be
able to limit the maximum RDMA read or write size that the target
can issue.

I'll have to spend some time straightening out the uses of
MaxBurstLength and [MTI]RDSL in the tgt code, and make distinct the
parameter settings from the internal maximum lengths, then make sure
things work as planned in both TCP and iSER modes.

Erez:  you are right, open-iscsi (865) does not send MRDSL in RDMA
mode, as is correct.

		-- Pete


From erezz at voltaire.com  Tue Aug 14 16:04:15 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Tue, 14 Aug 2007 17:04:15 +0300
Subject: [Stgt-devel] dd fails with iSER
In-Reply-To: <20070813022159.GB26036@osc.edu>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com> <20070809202234.GA26911@osc.edu>
	<46BF1333.4020801@voltaire.com> <20070813022159.GB26036@osc.edu>
Message-ID: <46C1B65F.9070504@voltaire.com>

Pete Wyckoff wrote:

> erezz at voltaire.com wrote on Sun, 12 Aug 2007 17:03 +0300:
>   
>> I ran the following command:
>>
>> sgp_dd bs=512 of=/dev/null if=/dev/sg3 bpt=256 thr=8 time=1 count=8000
>>
>> and got the following error:
>>     
>
> I'm on travel this week, but want to fix this!  Everything works
> here unfortunately.  WC status 10 == IBV_WC_REM_ACCESS_ERR, which
> means that the other side was somehow unhappy.  Maybe wrong rkey.
> We've never seen that error, even in testing, so I will probably ask
> you for more debugging information on both sides.
>
> If you are motivated, you might check the key and VA that appears
> in the initiator request and make sure the target tries to use those
> same values when it does RDMA.
>   

Pete,

I went over the iSER target code, and something looks strange (unless
I'm missing something here):

iscsi_iser_read calls iser_parse_hdr, which reads the iSER header and
saves the remote va & stag on the conn_info object. Later,
iser_rdma_read/write is called (from another context?), and uses the
remote va & stag. The problem that I see is: what happens if another cmd
is received before RDMA read/write is performed for the 1st cmd?

I can see that on the log file:

The last 3 cmds that were received have stags 6004a, 6004b & 6004c
respectively.

[iSER]:iSCSI control type PDU.
[iSER]:rem_write_stag 6004a rem_write_va 69cea000.
[iSER]:iscsi_iser_read ret 48.
tgtd: iscsi_scsi_cmd_rx_start(1462) 1 2a 0 8192 131072 1 42
[iSER]:meml 0x634d88 buf 0x2aaaaad30010.
tgtd: iscsi_scsi_cmd_rx_start(1489) 0 122880 0 8192
[iSER]:in iscsi_iser_read buf 0x2aaaaad302b0 nbytes 8192.
[iSER]:iscsi_iser_read ret 8192.
tgtd: iscsi_task_queue(1403) 42 42 1
tgtd: iser_event_modify(1435) ep 0 events 5
tgtd: iser_event_modify(1442) ep 0 was already on the list.  Track?
[iSER]:handle_wc() Done processing recv 0x642228, reposted it.
[iSER]:handle_wc() Incoming Cmd - COMPLETE (8268 bytes).
[iSER]:in iscsi_iser_read buf 0x636eb0 nbytes 48.
[iSER]:iSCSI control type PDU.
[iSER]:rem_write_stag 6004b rem_write_va 6a74a000.
[iSER]:iscsi_iser_read ret 48.
tgtd: iscsi_scsi_cmd_rx_start(1462) 1 2a 0 8192 131072 1 43
[iSER]:meml 0x634da0 buf 0x2aaaaadb1010.
tgtd: iscsi_scsi_cmd_rx_start(1489) 0 122880 0 8192
[iSER]:in iscsi_iser_read buf 0x2aaaaadb12b0 nbytes 8192.
[iSER]:iscsi_iser_read ret 8192.
tgtd: iscsi_task_queue(1403) 43 43 1
tgtd: iser_event_modify(1435) ep 0 events 5
tgtd: iser_event_modify(1442) ep 0 was already on the list.  Track?
[iSER]:handle_wc() Done processing recv 0x6432f8, reposted it.
[iSER]:handle_wc() Incoming Cmd - COMPLETE (8268 bytes).
[iSER]:in iscsi_iser_read buf 0x636eb0 nbytes 48.
[iSER]:iSCSI control type PDU.
[iSER]:rem_write_stag 6004c rem_write_va 6a18a000.
[iSER]:iscsi_iser_read ret 48.

Later, RDMA read is performed for the cmds. For all cmds, the stag is
6004c - just like the last stag that was received:

[iSER]:in iser_rdma_read.
[iSER]:in iser_post_rdma_wr size 122880 rem_va 6a18a000 rem_stag 6004c
wr_id = 0x63f010 (itt = 0x3d)
.
[iSER]:iser_post_rdma_wr() Exit rdma = 0x63f010.
tgtd: iser_progress(1382) trying tx on fd 0 conn 0x636d90
tgtd: iscsi_task_tx_start(1750) found a task 3e 131072 8192 122880
[iSER]:in iser_rdma_read.
[iSER]:in iser_post_rdma_wr size 122880 rem_va 6a1a8000 rem_stag 6004c
wr_id = 0x63f090 (itt = 0x3e)
.
[iSER]:iser_post_rdma_wr() Exit rdma = 0x63f090.
tgtd: iser_progress(1382) trying tx on fd 0 conn 0x636d90
tgtd: iscsi_task_tx_start(1750) found a task 3f 131072 8192 122880
[iSER]:in iser_rdma_read.
[iSER]:in iser_post_rdma_wr size 122880 rem_va 6a1c6000 rem_stag 6004c
wr_id = 0x63f110 (itt = 0x3f)

Erez



From pw at osc.edu  Tue Aug 14 17:11:54 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 14 Aug 2007 10:11:54 -0500
Subject: [Stgt-devel] dd fails with iSER
In-Reply-To: <46C1B65F.9070504@voltaire.com>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com> <20070809202234.GA26911@osc.edu>
	<46BF1333.4020801@voltaire.com> <20070813022159.GB26036@osc.edu>
	<46C1B65F.9070504@voltaire.com>
Message-ID: <20070814151154.GA6131@osc.edu>

erezz at voltaire.com wrote on Tue, 14 Aug 2007 17:04 +0300:
> I went over the iSER target code, and something looks strange (unless
> I'm missing something here):
> 
> iscsi_iser_read calls iser_parse_hdr, which reads the iSER header and
> saves the remote va & stag on the conn_info object. Later,
> iser_rdma_read/write is called (from another context?), and uses the
> remote va & stag. The problem that I see is: what happens if another cmd
> is received before RDMA read/write is performed for the 1st cmd?
> 
> I can see that on the log file:
> 
> The last 3 cmds that were received have stags 6004a, 6004b & 6004c
> respectively.
> 
> [iSER]:iSCSI control type PDU.
> [iSER]:rem_write_stag 6004a rem_write_va 69cea000.
> [iSER]:iscsi_iser_read ret 48.
> tgtd: iscsi_scsi_cmd_rx_start(1462) 1 2a 0 8192 131072 1 42
> [iSER]:meml 0x634d88 buf 0x2aaaaad30010.
> tgtd: iscsi_scsi_cmd_rx_start(1489) 0 122880 0 8192
> [iSER]:in iscsi_iser_read buf 0x2aaaaad302b0 nbytes 8192.
> [iSER]:iscsi_iser_read ret 8192.
> tgtd: iscsi_task_queue(1403) 42 42 1
> tgtd: iser_event_modify(1435) ep 0 events 5
> tgtd: iser_event_modify(1442) ep 0 was already on the list.  Track?
> [iSER]:handle_wc() Done processing recv 0x642228, reposted it.
> [iSER]:handle_wc() Incoming Cmd - COMPLETE (8268 bytes).
> [iSER]:in iscsi_iser_read buf 0x636eb0 nbytes 48.
> [iSER]:iSCSI control type PDU.
> [iSER]:rem_write_stag 6004b rem_write_va 6a74a000.
> [iSER]:iscsi_iser_read ret 48.
> tgtd: iscsi_scsi_cmd_rx_start(1462) 1 2a 0 8192 131072 1 43
> [iSER]:meml 0x634da0 buf 0x2aaaaadb1010.
> tgtd: iscsi_scsi_cmd_rx_start(1489) 0 122880 0 8192
> [iSER]:in iscsi_iser_read buf 0x2aaaaadb12b0 nbytes 8192.
> [iSER]:iscsi_iser_read ret 8192.
> tgtd: iscsi_task_queue(1403) 43 43 1
> tgtd: iser_event_modify(1435) ep 0 events 5
> tgtd: iser_event_modify(1442) ep 0 was already on the list.  Track?
> [iSER]:handle_wc() Done processing recv 0x6432f8, reposted it.
> [iSER]:handle_wc() Incoming Cmd - COMPLETE (8268 bytes).
> [iSER]:in iscsi_iser_read buf 0x636eb0 nbytes 48.
> [iSER]:iSCSI control type PDU.
> [iSER]:rem_write_stag 6004c rem_write_va 6a18a000.
> [iSER]:iscsi_iser_read ret 48.
> 
> Later, RDMA read is performed for the cmds. For all cmds, the stag is
> 6004c - just like the last stag that was received:
> 
> [iSER]:in iser_rdma_read.
> [iSER]:in iser_post_rdma_wr size 122880 rem_va 6a18a000 rem_stag 6004c
> wr_id = 0x63f010 (itt = 0x3d)
> .
> [iSER]:iser_post_rdma_wr() Exit rdma = 0x63f010.
> tgtd: iser_progress(1382) trying tx on fd 0 conn 0x636d90
> tgtd: iscsi_task_tx_start(1750) found a task 3e 131072 8192 122880
> [iSER]:in iser_rdma_read.
> [iSER]:in iser_post_rdma_wr size 122880 rem_va 6a1a8000 rem_stag 6004c
> wr_id = 0x63f090 (itt = 0x3e)
> .
> [iSER]:iser_post_rdma_wr() Exit rdma = 0x63f090.
> tgtd: iser_progress(1382) trying tx on fd 0 conn 0x636d90
> tgtd: iscsi_task_tx_start(1750) found a task 3f 131072 8192 122880
> [iSER]:in iser_rdma_read.
> [iSER]:in iser_post_rdma_wr size 122880 rem_va 6a1c6000 rem_stag 6004c
> wr_id = 0x63f110 (itt = 0x3f)

You're absolutely right.  That's a pretty glaring problem and
there's even a TODO in struct conn_info that notices there is an
issue.  With the OSD initiator applications we use, multiple
commands are not in flight.

Probably what has to happen is to move the per-task stag and va
fields from conn_info into iscsi_task.  You are certainly welcome to
hack on the code yourself, or somebody here will take a look at it
if you don't find the time.

Thanks for taking the time to figure out this bug.

		-- Pete



From waldi at berlios.de  Tue Aug 14 20:36:02 2007
From: waldi at berlios.de (Bastian Blank)
Date: Tue, 14 Aug 2007 20:36:02 +0200
Subject: [Stgt-devel] ibmvio is slow
In-Reply-To: <20070619171838.GA13219@wavehammer.waldi.eu.org>
References: <20070619171838.GA13219@wavehammer.waldi.eu.org>
Message-ID: <20070814183602.GA14092@wavehammer.waldi.eu.org>

On Tue, Jun 19, 2007 at 07:18:38PM +0200, Bastian Blank wrote:
> But it is slow. I can write at most 15MiB/s to the disks, regardless of
> the count of the initiators and disks.

I did another round of tests with 2.6.22 and a corresponsing patchset
and an uptodate tgtd with disabled controller lun (it breaks my setup
which needs the boot disk on lun 0).

Writing on an exported device shows weird behaviour. iostat shows many
write _and_ read requests, even if the initiator only emits write
requests:

| Device:         rrqm/s   wrqm/s   r/s   w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
| sdb            3733.90  4177.60 525.80 72.70 34138.40 34002.40   113.85    19.94   33.32   1.38  82.76

If the initiator emits read requests, it is okay:

| Device:         rrqm/s   wrqm/s   r/s   w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
| sdb           13798.50     0.40 1955.31  0.20 126057.72     4.81    64.47     1.18    0.60   0.43  83.21

There is only lvm between it. This looks like some sort of read-ahead
for the data, which should not happen for write requests. I tried to dig
a little bit in the block code but was not able to found the cause.

Bonnie shows the following:
| Version  1.03       ------Sequential Output------ --Sequential Input- --Random-
|                     -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
| Machine        Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
| test.track.rz.un 2G           21914  10 15207   4           59795   6 305.8   0

Bastian

-- 
Emotions are alien to me.  I'm a scientist.
		-- Spock, "This Side of Paradise", stardate 3417.3


From blackmagic02881 at gmail.com  Tue Aug 14 21:07:02 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Tue, 14 Aug 2007 15:07:02 -0400
Subject: [Stgt-devel] ibmvio is slow
In-Reply-To: <20070814183602.GA14092@wavehammer.waldi.eu.org>
References: <20070619171838.GA13219@wavehammer.waldi.eu.org>
	<20070814183602.GA14092@wavehammer.waldi.eu.org>
Message-ID: <1187118422.3825.30.camel@dhcp-141.ibrix.com>

On Tue, 2007-08-14 at 20:36 +0200, Bastian Blank wrote:
> On Tue, Jun 19, 2007 at 07:18:38PM +0200, Bastian Blank wrote:
> > But it is slow. I can write at most 15MiB/s to the disks, regardless of
> > the count of the initiators and disks.
> 
> I did another round of tests with 2.6.22 and a corresponsing patchset
> and an uptodate tgtd with disabled controller lun (it breaks my setup
> which needs the boot disk on lun 0).
> 
> Writing on an exported device shows weird behaviour. iostat shows many
> write _and_ read requests, even if the initiator only emits write
> requests:

what kind of write io u did? make a fs and run bonnie?

try simple dd on a raw device (no fs) and see the performance. if write
result is much better and u do not see read in iostat, u meet an align
issue simply like what we had in IET list.


> 
> | Device:         rrqm/s   wrqm/s   r/s   w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
> | sdb            3733.90  4177.60 525.80 72.70 34138.40 34002.40   113.85    19.94   33.32   1.38  82.76
> 
> If the initiator emits read requests, it is okay:
> 
> | Device:         rrqm/s   wrqm/s   r/s   w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
> | sdb           13798.50     0.40 1955.31  0.20 126057.72     4.81    64.47     1.18    0.60   0.43  83.21
> 
> There is only lvm between it. This looks like some sort of read-ahead
> for the data, which should not happen for write requests. I tried to dig
> a little bit in the block code but was not able to found the cause.
> 
> Bonnie shows the following:
> | Version  1.03       ------Sequential Output------ --Sequential Input- --Random-
> |                     -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
> | Machine        Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
> | test.track.rz.un 2G           21914  10 15207   4           59795   6 305.8   0
> 
> Bastian
> 
-- 
Ming Zhang


@#$%^ purging memory... (*!%
http://blackmagic02881.wordpress.com/
http://www.linkedin.com/in/blackmagic02881
--------------------------------------------



From waldi at berlios.de  Tue Aug 14 21:20:54 2007
From: waldi at berlios.de (Bastian Blank)
Date: Tue, 14 Aug 2007 21:20:54 +0200
Subject: [Stgt-devel] ibmvio is slow
In-Reply-To: <20070814183602.GA14092@wavehammer.waldi.eu.org>
References: <20070619171838.GA13219@wavehammer.waldi.eu.org>
	<20070814183602.GA14092@wavehammer.waldi.eu.org>
Message-ID: <20070814192054.GA17560@wavehammer.waldi.eu.org>

On Tue, Aug 14, 2007 at 08:36:02PM +0200, Bastian Blank wrote:
> There is only lvm between it. This looks like some sort of read-ahead
> for the data, which should not happen for write requests. I tried to dig
> a little bit in the block code but was not able to found the cause.

I found something:

scsi_host_get_command
| int write = (data_dir == DMA_TO_DEVICE);

According to ibmvstgt, this is a write to the scsi device, aka data
transfer to this system.

| rq = blk_get_request(shost->uspace_req_q, !write, gfp_mask);

The second parameter should be READ or WRITE, not true/false and it
seems to have the wrong direction.

Bastian

-- 
War is never imperative.
		-- McCoy, "Balance of Terror", stardate 1709.2


From waldi at berlios.de  Tue Aug 14 21:21:38 2007
From: waldi at berlios.de (Bastian Blank)
Date: Tue, 14 Aug 2007 21:21:38 +0200
Subject: [Stgt-devel] ibmvio is slow
In-Reply-To: <1187118422.3825.30.camel@dhcp-141.ibrix.com>
References: <20070619171838.GA13219@wavehammer.waldi.eu.org>
	<20070814183602.GA14092@wavehammer.waldi.eu.org>
	<1187118422.3825.30.camel@dhcp-141.ibrix.com>
Message-ID: <20070814192138.GB17560@wavehammer.waldi.eu.org>

On Tue, Aug 14, 2007 at 03:07:02PM -0400, Ming Zhang wrote:
> try simple dd on a raw device (no fs) and see the performance. if write
> result is much better and u do not see read in iostat, u meet an align
> issue simply like what we had in IET list.

Does not help.

| Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
| sdb            2493.21  3600.20  359.64  121.78 22810.79 30863.54   111.49   126.38  267.37   2.08  99.94

Bastian

-- 
Where there's no emotion, there's no motive for violence.
		-- Spock, "Dagger of the Mind", stardate 2715.1


From blackmagic02881 at gmail.com  Tue Aug 14 21:24:35 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Tue, 14 Aug 2007 15:24:35 -0400
Subject: [Stgt-devel] ibmvio is slow
In-Reply-To: <20070814192138.GB17560@wavehammer.waldi.eu.org>
References: <20070619171838.GA13219@wavehammer.waldi.eu.org>
	<20070814183602.GA14092@wavehammer.waldi.eu.org>
	<1187118422.3825.30.camel@dhcp-141.ibrix.com>
	<20070814192138.GB17560@wavehammer.waldi.eu.org>
Message-ID: <1187119475.3825.32.camel@dhcp-141.ibrix.com>


On Tue, 2007-08-14 at 21:21 +0200, Bastian Blank wrote:
> On Tue, Aug 14, 2007 at 03:07:02PM -0400, Ming Zhang wrote:
> > try simple dd on a raw device (no fs) and see the performance. if write
> > result is much better and u do not see read in iostat, u meet an align
> > issue simply like what we had in IET list.
> 
> Does not help.
> 
> | Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await  svctm  %util
> | sdb            2493.21  3600.20  359.64  121.78 22810.79 30863.54   111.49   126.38  267.37   2.08  99.94
> 


ok. then that is not the cause.


> Bastian
> 
-- 
Ming Zhang


@#$%^ purging memory... (*!%
http://blackmagic02881.wordpress.com/
http://www.linkedin.com/in/blackmagic02881
--------------------------------------------



From pw at osc.edu  Wed Aug 15 00:52:06 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 14 Aug 2007 17:52:06 -0500
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
Message-ID: <20070814225206.GA11031@osc.edu>

This might be a hack.  In fixing the defaults earlier, I put the
SCSI default for MaxRecvDataSegmentLength in place for the
ISCSI_PARAM_MAX_XMIT_DLENGTH.  But really it should be whatever
the initiator tells us.  So override the "minimum" function and
just set the thing directly.  Perhaps this parameter should live
outside the conn->session_param[] structure---there are many exceptions
for it scattered around the code.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    7 ++++++-
 1 files changed, 6 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index e092462..a1bae20 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -305,7 +305,12 @@ static void text_scan_login(struct iscsi_connection *conn)
 			}
 
 			err = param_check_val(session_keys, idx, &val);
-			err = param_set_val(session_keys, conn->session_param, idx, &val);
+			if (idx == ISCSI_PARAM_MAX_XMIT_DLENGTH)
+				/* just record whatever he wants,
+				 * assuming it fits in the limits */
+				conn->session_param[idx].val = val;
+			else
+				err = param_set_val(session_keys, conn->session_param, idx, &val);
 
 			switch (conn->session_param[idx].state) {
 			case KEY_STATE_START:
-- 
1.5.2.4



From tomof at acm.org  Wed Aug 15 05:11:32 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Wed, 15 Aug 2007 12:11:32 +0900
Subject: [Stgt-devel] ibmvio is slow
In-Reply-To: <20070814183602.GA14092@wavehammer.waldi.eu.org>
References: <20070619171838.GA13219@wavehammer.waldi.eu.org>
	<20070814183602.GA14092@wavehammer.waldi.eu.org>
Message-ID: <20070813011302O.tomof@acm.org>

On Tue, 14 Aug 2007 20:36:02 +0200
Bastian Blank <waldi at berlios.de> wrote:

> On Tue, Jun 19, 2007 at 07:18:38PM +0200, Bastian Blank wrote:
> > But it is slow. I can write at most 15MiB/s to the disks, regardless of
> > the count of the initiators and disks.
> 
> I did another round of tests with 2.6.22 and a corresponsing patchset
> and an uptodate tgtd with disabled controller lun (it breaks my setup
> which needs the boot disk on lun 0).

As I said, there are several areas to improve ibmvio performance. I've
done none of them so far.


From tomof at acm.org  Wed Aug 15 05:11:37 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Wed, 15 Aug 2007 12:11:37 +0900
Subject: [Stgt-devel] ibmvio is slow
In-Reply-To: <20070814192054.GA17560@wavehammer.waldi.eu.org>
References: <20070619171838.GA13219@wavehammer.waldi.eu.org>
	<20070814183602.GA14092@wavehammer.waldi.eu.org>
	<20070814192054.GA17560@wavehammer.waldi.eu.org>
Message-ID: <20070813011924U.tomof@acm.org>

On Tue, 14 Aug 2007 21:20:54 +0200
Bastian Blank <waldi at berlios.de> wrote:

> On Tue, Aug 14, 2007 at 08:36:02PM +0200, Bastian Blank wrote:
> > There is only lvm between it. This looks like some sort of read-ahead
> > for the data, which should not happen for write requests. I tried to dig
> > a little bit in the block code but was not able to found the cause.
> 
> I found something:
> 
> scsi_host_get_command
> | int write = (data_dir == DMA_TO_DEVICE);
> 
> According to ibmvstgt, this is a write to the scsi device, aka data
> transfer to this system.
> 
> | rq = blk_get_request(shost->uspace_req_q, !write, gfp_mask);
> 
> The second parameter should be READ or WRITE, not true/false and it
> seems to have the wrong direction.

No. The code is correct.

READ is zero so it works though we can do better here.

The in-kernel ibmvio driver (ibmvstgt) uses the block layer functions
in reverse. You can try your correct direction to see data corruption.


From tomof at acm.org  Wed Aug 15 05:11:39 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Wed, 15 Aug 2007 12:11:39 +0900
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <20070814225206.GA11031@osc.edu>
References: <20070814225206.GA11031@osc.edu>
Message-ID: <20070813013049E.tomof@acm.org>

On Tue, 14 Aug 2007 17:52:06 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> This might be a hack.  In fixing the defaults earlier, I put the
> SCSI default for MaxRecvDataSegmentLength in place for the
> ISCSI_PARAM_MAX_XMIT_DLENGTH.  But really it should be whatever
> the initiator tells us.

Not sure. Initiators can declarer whatever about MRDSL, the target can
use a lower value than it. And the target administrator should be able
to configure it.

That's the current behaivoir (taken from IET).


From erezz at voltaire.com  Wed Aug 15 11:26:57 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Wed, 15 Aug 2007 12:26:57 +0300
Subject: [Stgt-devel] Adding iser_task object (was: dd fails with iSER)
In-Reply-To: <20070814151154.GA6131@osc.edu>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com> <20070809202234.GA26911@osc.edu>
	<46BF1333.4020801@voltaire.com> <20070813022159.GB26036@osc.edu>
	<46C1B65F.9070504@voltaire.com> <20070814151154.GA6131@osc.edu>
Message-ID: <46C2C6E1.6040604@voltaire.com>

Pete Wyckoff wrote:

> erezz at voltaire.com wrote on Tue, 14 Aug 2007 17:04 +0300:
>   
>> I went over the iSER target code, and something looks strange (unless
>> I'm missing something here):
>>
>> iscsi_iser_read calls iser_parse_hdr, which reads the iSER header and
>> saves the remote va & stag on the conn_info object. Later,
>> iser_rdma_read/write is called (from another context?), and uses the
>> remote va & stag. The problem that I see is: what happens if another cmd
>> is received before RDMA read/write is performed for the 1st cmd?
>>
>> I can see that on the log file:
>>
>> The last 3 cmds that were received have stags 6004a, 6004b & 6004c
>> respectively.
>>
>> [iSER]:iSCSI control type PDU.
>> [iSER]:rem_write_stag 6004a rem_write_va 69cea000.
>> [iSER]:iscsi_iser_read ret 48.
>> tgtd: iscsi_scsi_cmd_rx_start(1462) 1 2a 0 8192 131072 1 42
>> [iSER]:meml 0x634d88 buf 0x2aaaaad30010.
>> tgtd: iscsi_scsi_cmd_rx_start(1489) 0 122880 0 8192
>> [iSER]:in iscsi_iser_read buf 0x2aaaaad302b0 nbytes 8192.
>> [iSER]:iscsi_iser_read ret 8192.
>> tgtd: iscsi_task_queue(1403) 42 42 1
>> tgtd: iser_event_modify(1435) ep 0 events 5
>> tgtd: iser_event_modify(1442) ep 0 was already on the list.  Track?
>> [iSER]:handle_wc() Done processing recv 0x642228, reposted it.
>> [iSER]:handle_wc() Incoming Cmd - COMPLETE (8268 bytes).
>> [iSER]:in iscsi_iser_read buf 0x636eb0 nbytes 48.
>> [iSER]:iSCSI control type PDU.
>> [iSER]:rem_write_stag 6004b rem_write_va 6a74a000.
>> [iSER]:iscsi_iser_read ret 48.
>> tgtd: iscsi_scsi_cmd_rx_start(1462) 1 2a 0 8192 131072 1 43
>> [iSER]:meml 0x634da0 buf 0x2aaaaadb1010.
>> tgtd: iscsi_scsi_cmd_rx_start(1489) 0 122880 0 8192
>> [iSER]:in iscsi_iser_read buf 0x2aaaaadb12b0 nbytes 8192.
>> [iSER]:iscsi_iser_read ret 8192.
>> tgtd: iscsi_task_queue(1403) 43 43 1
>> tgtd: iser_event_modify(1435) ep 0 events 5
>> tgtd: iser_event_modify(1442) ep 0 was already on the list.  Track?
>> [iSER]:handle_wc() Done processing recv 0x6432f8, reposted it.
>> [iSER]:handle_wc() Incoming Cmd - COMPLETE (8268 bytes).
>> [iSER]:in iscsi_iser_read buf 0x636eb0 nbytes 48.
>> [iSER]:iSCSI control type PDU.
>> [iSER]:rem_write_stag 6004c rem_write_va 6a18a000.
>> [iSER]:iscsi_iser_read ret 48.
>>
>> Later, RDMA read is performed for the cmds. For all cmds, the stag is
>> 6004c - just like the last stag that was received:
>>
>> [iSER]:in iser_rdma_read.
>> [iSER]:in iser_post_rdma_wr size 122880 rem_va 6a18a000 rem_stag 6004c
>> wr_id = 0x63f010 (itt = 0x3d)
>> .
>> [iSER]:iser_post_rdma_wr() Exit rdma = 0x63f010.
>> tgtd: iser_progress(1382) trying tx on fd 0 conn 0x636d90
>> tgtd: iscsi_task_tx_start(1750) found a task 3e 131072 8192 122880
>> [iSER]:in iser_rdma_read.
>> [iSER]:in iser_post_rdma_wr size 122880 rem_va 6a1a8000 rem_stag 6004c
>> wr_id = 0x63f090 (itt = 0x3e)
>> .
>> [iSER]:iser_post_rdma_wr() Exit rdma = 0x63f090.
>> tgtd: iser_progress(1382) trying tx on fd 0 conn 0x636d90
>> tgtd: iscsi_task_tx_start(1750) found a task 3f 131072 8192 122880
>> [iSER]:in iser_rdma_read.
>> [iSER]:in iser_post_rdma_wr size 122880 rem_va 6a1c6000 rem_stag 6004c
>> wr_id = 0x63f110 (itt = 0x3f)
>>     
>
> You're absolutely right.  That's a pretty glaring problem and
> there's even a TODO in struct conn_info that notices there is an
> issue.  With the OSD initiator applications we use, multiple
> commands are not in flight.
>
> Probably what has to happen is to move the per-task stag and va
> fields from conn_info into iscsi_task.  You are certainly welcome to
> hack on the code yourself, or somebody here will take a look at it
> if you don't find the time.
>   

At first, I thought that this will be easy to fix - just move the va &
stag from the conn object to the task object. However, when ep_read
(iscsi_iser_read in iSER's case) is called, the task isn't allocated
yet. iSER must save the data from the received iSER header in some task
object (e.g. iser_task).

The solution that I see for that is:

    * When iSER detects that a new cmd was received, it allocates an
      iSER task (iser_task). iser_task will contain the following data:
          o read va & stag
          o write va & stag
          o itt

    The new iser_task will be stored (in a hash table according to its
    itt?), and will be used later.

    * When the target calls ep_rdma_read/write, it will also send the
      iscsi_task object (or itt, at least). iSER will extract the
      iser_task (according to the itt) and use the va & stag.
    * The iser_task will be released when iscsi_task is released.


Please send your comments. Can you think about other possible solutions?

Erez



From pw at osc.edu  Wed Aug 15 18:15:59 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 15 Aug 2007 11:15:59 -0500
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <20070813013049E.tomof@acm.org>
References: <20070814225206.GA11031@osc.edu> <20070813013049E.tomof@acm.org>
Message-ID: <20070815161559.GA13710@osc.edu>

tomof at acm.org wrote on Wed, 15 Aug 2007 12:11 +0900:
> On Tue, 14 Aug 2007 17:52:06 -0500
> Pete Wyckoff <pw at osc.edu> wrote:
> 
> > This might be a hack.  In fixing the defaults earlier, I put the
> > SCSI default for MaxRecvDataSegmentLength in place for the
> > ISCSI_PARAM_MAX_XMIT_DLENGTH.  But really it should be whatever
> > the initiator tells us.
> 
> Not sure. Initiators can declarer whatever about MRDSL, the target can
> use a lower value than it. And the target administrator should be able
> to configure it.
> 
> That's the current behaivoir (taken from IET).

True.  There are a few cases.

1.  ini sends mrdsl > target mxdsl.  Apply minimum, use target max.
2.  ini sends mrdsl < target mxdsl.  Apply minimum, use ini max.
3.  ini does not mention mrdsl.  Target should set its mxdsl to the
    standard default (8192), not use its default max.

This last case was broken before my earlier patch "iscsi param
cleanup".  Now it is fixed but I changed the target default to 8k.
I want the target to agree to use a larger value if the initiator is
willing, but still get case #3 correct if the initiator does not
specify.

Here's a better patch.  Tested with all cases of ini <,>,= target,
and target 8k or 256k mxdsl.

		-- Pete

--------------------------------------------------------------------------

From pw at osc.edu  Wed Aug 15 18:09:46 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 15 Aug 2007 12:09:46 -0400
Subject: [PATCH] iscsi fix xmit param
Message-ID: <mailman.18.1331738474.12506.stgt-devel@lists.berlios.de>

Repair one case in MaxRecvDataSegmentLength processing.  Default target
has always limited data segments to 8k, even if the initiator asks for
more.  It may be a good idea to increase this by, e.g:

    tgtadm --lld iscsi --mode target --op update --tid 1 \
	   --name MaxXmitDataSegmentLength --value 262144

so that target will generate up to min(initiator RDSL, 256k).  But if
you change this parameter, and initiator does not specify RDSL, target
will incorrectly use 256k instead of 8k.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |   10 +++++++---
 usr/iscsi/iscsid.h |    1 +
 usr/iscsi/target.c |    2 +-
 3 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index e092462..0a1932a 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -286,8 +286,10 @@ static void text_scan_login(struct iscsi_connection *conn)
 			unsigned int val;
 			char buf[32];
 
-			if (idx == ISCSI_PARAM_MAX_RECV_DLENGTH)
+			if (idx == ISCSI_PARAM_MAX_RECV_DLENGTH) {
 				idx = ISCSI_PARAM_MAX_XMIT_DLENGTH;
+				conn->mxdsl_negotiated = 1;
+			}
 
 			if (param_str_to_val(session_keys, idx, value, &val) < 0) {
 				if (conn->session_param[idx].state
@@ -349,8 +351,6 @@ static int text_check_param(struct iscsi_connection *conn)
 		if (p[i].state == KEY_STATE_START && p[i].val != session_keys[i].def) {
 			if (conn->state == STATE_LOGIN) {
 				if (i == ISCSI_PARAM_MAX_XMIT_DLENGTH) {
-					if (p[i].val > session_keys[i].def)
-						p[i].val = session_keys[i].def;
 					p[i].state = KEY_STATE_DONE;
 					continue;
 				}
@@ -471,6 +471,10 @@ static void login_finish(struct iscsi_connection *conn)
 {
 	switch (conn->session_type) {
 	case SESSION_NORMAL:
+		if (!conn->mxdsl_negotiated)
+			/* use spec default if he did not mention MRDSL */
+			conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val =
+				session_keys[ISCSI_PARAM_MAX_XMIT_DLENGTH].def;
 		if (!conn->session)
 			session_create(conn);
 		memcpy(conn->isid, conn->session->isid, sizeof(conn->isid));
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index a8c8cb1..2b08252 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -140,6 +140,7 @@ struct iscsi_connection {
 
 	int tid;
 	struct param session_param[ISCSI_PARAM_MAX];
+	int mxdsl_negotiated;
 
 	char *initiator;
 	uint8_t isid[6];
diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
index 2653839..53d8164 100644
--- a/usr/iscsi/target.c
+++ b/usr/iscsi/target.c
@@ -265,7 +265,7 @@ int iscsi_target_create(struct target *t)
 	struct iscsi_target *target;
 	struct param default_tgt_session_param[] = {
 		[ISCSI_PARAM_MAX_RECV_DLENGTH] = {0, 8192},
-		[ISCSI_PARAM_MAX_XMIT_DLENGTH] = {0, 8192},  /* do not edit */
+		[ISCSI_PARAM_MAX_XMIT_DLENGTH] = {0, 8192},
 		[ISCSI_PARAM_HDRDGST_EN] = {0, DIGEST_NONE},
 		[ISCSI_PARAM_DATADGST_EN] = {0, DIGEST_NONE},
 		[ISCSI_PARAM_INITIAL_R2T_EN] = {0, 1},
-- 
1.5.2.4



From pw at osc.edu  Wed Aug 15 20:06:17 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 15 Aug 2007 13:06:17 -0500
Subject: [Stgt-devel] Adding iser_task object (was: dd fails with iSER)
In-Reply-To: <46C2C6E1.6040604@voltaire.com>
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com> <20070809202234.GA26911@osc.edu>
	<46BF1333.4020801@voltaire.com> <20070813022159.GB26036@osc.edu>
	<46C1B65F.9070504@voltaire.com> <20070814151154.GA6131@osc.edu>
	<46C2C6E1.6040604@voltaire.com>
Message-ID: <20070815180617.GA14471@osc.edu>

erezz at voltaire.com wrote on Wed, 15 Aug 2007 12:26 +0300:
> At first, I thought that this will be easy to fix - just move the va &
> stag from the conn object to the task object. However, when ep_read
> (iscsi_iser_read in iSER's case) is called, the task isn't allocated
> yet. iSER must save the data from the received iSER header in some task
> object (e.g. iser_task).

You could add a new transport call .ep_task_init and call that near
the iscsi_alloc_task() in iscsi_scsi_cmd_rx_start().  It gets the
newly allocated struct iscsi_task.  The TCP case would be a noop.
The RDMA case would take the cached rem_stag values from the
connection structure and stick them in the task struct.  This is all
done synchronously while working on the single received PDU so
should be safe.  You only need to call ->ep_task_init(task) in the
SCSI command case, not TM functions or other places that will not do
RDMA data transfers.

> The solution that I see for that is:
> 
>     * When iSER detects that a new cmd was received, it allocates an
>       iSER task (iser_task). iser_task will contain the following data:
>           o read va & stag
>           o write va & stag
>           o itt
> 
>     The new iser_task will be stored (in a hash table according to its
>     itt?), and will be used later.
> 
>     * When the target calls ep_rdma_read/write, it will also send the
>       iscsi_task object (or itt, at least). iSER will extract the
>       iser_task (according to the itt) and use the va & stag.
>     * The iser_task will be released when iscsi_task is released.

This would work but seems a bit more complex than necessary.  It
does have the advantage of keeping RDMA bits (va, stag) out of the
generic iscsi task structure though.  If somebody complains about
adding another iscsi transport interface function just for RDMA.

		-- Pete


From erezz at voltaire.com  Wed Aug 15 21:28:04 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Wed, 15 Aug 2007 22:28:04 +0300
Subject: [Stgt-devel] Adding iser_task object (was: dd fails with iSER)
References: <46B839A4.2080306@voltaire.com> <20070807224248.GB31979@osc.edu>
	<46B988C6.8020707@voltaire.com> <20070809202234.GA26911@osc.edu>
	<46BF1333.4020801@voltaire.com> <20070813022159.GB26036@osc.edu>
	<46C1B65F.9070504@voltaire.com> <20070814151154.GA6131@osc.edu>
	<46C2C6E1.6040604@voltaire.com> <20070815180617.GA14471@osc.edu>
Message-ID: <39C75744D164D948A170E9792AF8E7CA110A57@exil.voltaire.com>

>erezz at voltaire.com wrote on Wed, 15 Aug 2007 12:26 +0300:
>> At first, I thought that this will be easy to fix - just move the va &
>> stag from the conn object to the task object. However, when ep_read
>> (iscsi_iser_read in iSER's case) is called, the task isn't allocated
>> yet. iSER must save the data from the received iSER header in some task
>> object (e.g. iser_task).
> 
> You could add a new transport call .ep_task_init and call that near
> the iscsi_alloc_task() in iscsi_scsi_cmd_rx_start().  It gets the
> newly allocated struct iscsi_task.  The TCP case would be a noop.
> The RDMA case would take the cached rem_stag values from the
> connection structure and stick them in the task struct.  This is all
> done synchronously while working on the single received PDU so
> should be safe.  You only need to call ->ep_task_init(task) in the
> SCSI command case, not TM functions or other places that will not do
> RDMA data transfers.

Do you mean to say that after do_recv is called and the va & stag are saved on conn_info, we can be sure that no other new command will be received before iscsi_alloc task is called? If yes, it should be easy, and I already have some of the code for it.
 
Erez


From pw at osc.edu  Wed Aug 15 21:44:26 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 15 Aug 2007 14:44:26 -0500
Subject: [Stgt-devel] Adding iser_task object (was: dd fails with iSER)
In-Reply-To: <39C75744D164D948A170E9792AF8E7CA110A57@exil.voltaire.com>
References: <20070807224248.GB31979@osc.edu> <46B988C6.8020707@voltaire.com>
	<20070809202234.GA26911@osc.edu> <46BF1333.4020801@voltaire.com>
	<20070813022159.GB26036@osc.edu>
	<46C1B65F.9070504@voltaire.com> <20070814151154.GA6131@osc.edu>
	<46C2C6E1.6040604@voltaire.com> <20070815180617.GA14471@osc.edu>
	<39C75744D164D948A170E9792AF8E7CA110A57@exil.voltaire.com>
Message-ID: <20070815194426.GG14977@osc.edu>

erezz at voltaire.com wrote on Wed, 15 Aug 2007 22:28 +0300:
> >erezz at voltaire.com wrote on Wed, 15 Aug 2007 12:26 +0300:
> >> At first, I thought that this will be easy to fix - just move the va &
> >> stag from the conn object to the task object. However, when ep_read
> >> (iscsi_iser_read in iSER's case) is called, the task isn't allocated
> >> yet. iSER must save the data from the received iSER header in some task
> >> object (e.g. iser_task).
> > 
> > You could add a new transport call .ep_task_init and call that near
> > the iscsi_alloc_task() in iscsi_scsi_cmd_rx_start().  It gets the
> > newly allocated struct iscsi_task.  The TCP case would be a noop.
> > The RDMA case would take the cached rem_stag values from the
> > connection structure and stick them in the task struct.  This is all
> > done synchronously while working on the single received PDU so
> > should be safe.  You only need to call ->ep_task_init(task) in the
> > SCSI command case, not TM functions or other places that will not do
> > RDMA data transfers.
> 
> Do you mean to say that after do_recv is called and the va & stag are saved on conn_info, we can be sure that no other new command will be received before iscsi_alloc task is called? If yes, it should be easy, and I already have some of the code for it.

Yes, I believe that is the case.  If the receive processing in
iscsid.c were parallel, we would be in trouble.  But it's not.

		-- Pete


From erezz at voltaire.com  Thu Aug 16 16:44:33 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Thu, 16 Aug 2007 17:44:33 +0300
Subject: [Stgt-devel] [PATCH] save stag & va for a scsi command on the task
	object
In-Reply-To: <20070815194426.GG14977@osc.edu>
References: <20070807224248.GB31979@osc.edu> <46B988C6.8020707@voltaire.com>
	<20070809202234.GA26911@osc.edu> <46BF1333.4020801@voltaire.com>
	<20070813022159.GB26036@osc.edu>
	<46C1B65F.9070504@voltaire.com> <20070814151154.GA6131@osc.edu>
	<46C2C6E1.6040604@voltaire.com> <20070815180617.GA14471@osc.edu>
	<39C75744D164D948A170E9792AF8E7CA110A57@exil.voltaire.com>
	<20070815194426.GG14977@osc.edu>
Message-ID: <46C462D1.6080101@voltaire.com>

When a command PDU is received, the iSER header contains the read/write
va & stag. This data was saved on the conn_info object. If another command PDU
was received before this data was used, its va & stag were written over the
data for the previous command. This fix saves the va & stag on the task object.

Signed-off-by: Erez Zilber <erezz at voltaire.com>
---
 usr/iscsi/iscsi_rdma.c |   47 +++++++++++++++++++++++++++++++++++++++++++----
 usr/iscsi/iscsi_tcp.c  |    6 ++++++
 usr/iscsi/iscsid.c     |   10 +++++++++-
 usr/iscsi/iscsid.h     |    3 +++
 usr/iscsi/transport.h  |    2 ++
 5 files changed, 63 insertions(+), 5 deletions(-)

diff --git a/usr/iscsi/iscsi_rdma.c b/usr/iscsi/iscsi_rdma.c
index cc3d836..0e4a080 100644
--- a/usr/iscsi/iscsi_rdma.c
+++ b/usr/iscsi/iscsi_rdma.c
@@ -119,6 +119,12 @@ struct rdmalist {
 	struct iscsi_task	*task;
 };
 
+struct iser_task {
+	/* read and write from the initiator's point of view */
+	uint32_t rem_read_stag, rem_write_stag;
+	uint64_t rem_read_va, rem_write_va;
+};
+
 /*
  * One of these for each iscsi_connection, adds more fields needed for iser.
  */
@@ -1230,6 +1236,7 @@ static int iser_rdma_write(int ind, struct iscsi_pdu *rsp,
 	struct conn_info *ci = &cl.conn[ind];
 	struct iscsi_data_rsp *datain = (struct iscsi_data_rsp *) &rsp->bhs;
 	int last_rdma = (task->offset == task->len);
+	struct iser_task *itask = (struct iser_task *)task->trans_data;
 
 	iser_out(4, "in %s size %d, %p", __func__, rsp->datasize, rsp);
 
@@ -1249,10 +1256,13 @@ static int iser_rdma_write(int ind, struct iscsi_pdu *rsp,
 	dprintf("offset %d len %d last %d\n", task->offset, task->len,
 		last_rdma);
 
+	iser_out(4, "%s() posting RDMA write req: "
+		 "rem_read_stag %x rem_read_va %lx", __func__,
+		 itask->rem_read_stag, itask->rem_read_va);
 	ret = iser_post_rdma_wr(ci, rdmal, rsp->datasize, IBV_WR_RDMA_WRITE,
 				last_rdma ? IBV_SEND_SIGNALED : 0,
-				ci->rem_read_va + offset, ci->rem_read_stag,
-				task);
+				itask->rem_read_va + offset,
+				itask->rem_read_stag, task);
 
 	if (ret < 0) {
 		eprintf("iser_post_rdma_wr failed\n");
@@ -1279,6 +1289,7 @@ static int iser_rdma_read(int ind, struct iscsi_pdu *rsp)
 	struct conn_info *ci = &cl.conn[ind];
 	struct iscsi_connection *conn = ci->iscsi_conn;
 	struct iscsi_task *task = conn->tx_task;
+	struct iser_task *itask = (struct iser_task *)task->trans_data;
 	struct iscsi_r2t_rsp *r2t = (struct iscsi_r2t_rsp *) &rsp->bhs;
 	uint8_t *buf;
 	uint32_t len;
@@ -1295,9 +1306,13 @@ static int iser_rdma_read(int ind, struct iscsi_pdu *rsp)
 		return -1;
 	}
 
+	iser_out(4, "%s() posting RDMA read req: "
+		 "rem_read_stag %x rem_read_va %lx", __func__,
+		 itask->rem_write_stag, itask->rem_write_va);
+
 	ret = iser_post_rdma_wr(ci, rdma, len, IBV_WR_RDMA_READ,
-				IBV_SEND_SIGNALED, ci->rem_write_va,
-				ci->rem_write_stag, task);
+				IBV_SEND_SIGNALED, itask->rem_write_va,
+				itask->rem_write_stag, task);
 	if (ret < 0) {
 		iser_out(4, "iser_post_rdma_wr failed");
 		return ret;
@@ -1447,10 +1462,34 @@ static void iser_event_modify(int ep, int events)
 	}
 }
 
+void iscsi_iser_task_init(struct iscsi_task *task)
+{
+	struct conn_info *ci;
+	struct iser_task *itask;
+
+	iser_out(8, "%s() Entry", __func__);
+
+	ci = &cl.conn[task->conn->fd];
+	if (!ci->valid) {
+		eprintf("conn %d not valid\n", task->conn->fd);
+		exit(1);
+	}
+
+	itask = (struct iser_task *)task->trans_data;
+
+	/* copy the remote va & stag that were temporarily saved in conn_info */
+	itask->rem_read_stag = ci->rem_read_stag;
+	itask->rem_read_va = ci->rem_read_va;
+	itask->rem_write_stag = ci->rem_write_stag;
+	itask->rem_write_va = ci->rem_write_va;
+}
+
 struct iscsi_transport iscsi_iser = {
 	.name			= "iser",
 	.rdma			= 1,
+	.trans_data_len		= sizeof(struct iser_task),
 	.ep_init		= iscsi_iser_init,
+	.ep_task_init		= iscsi_iser_task_init,
 	.ep_read		= iscsi_iser_read,
 	.ep_write_begin		= iscsi_iser_write_begin,
 	.ep_write_end		= iscsi_iser_write_end,
diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index e7f5989..b6e9630 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -251,10 +251,16 @@ void iscsi_tcp_free(void *buf)
 	free(buf);
 }
 
+void iscsi_tcp_task_init(struct iscsi_task *task)
+{
+}
+
 struct iscsi_transport iscsi_tcp = {
 	.name			= "iscsi",
 	.rdma			= 0,
+	.trans_data_len		= 0,
 	.ep_init		= iscsi_tcp_init,
+	.ep_task_init		= iscsi_tcp_task_init,
 	.ep_read		= iscsi_tcp_read,
 	.ep_write_begin		= iscsi_tcp_write_begin,
 	.ep_write_end		= iscsi_tcp_write_end,
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index a3fa6af..c174b98 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1022,11 +1022,17 @@ iscsi_alloc_task(struct iscsi_connection *conn, int ext_len)
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
 	struct iscsi_task *task;
 
-	task = conn->tp->ep_malloc(sizeof(*task) + ext_len);
+	task = conn->tp->ep_malloc(sizeof(*task) + conn->tp->trans_data_len +
+				   ext_len);
 	if (!task)
 		return NULL;
 	memset(task, 0, sizeof(*task));
 
+	if (conn->tp->trans_data_len) {
+		task->trans_data = (void *)((unsigned long)&task[1] + ext_len);
+		memset(task->trans_data, 0, conn->tp->trans_data_len);
+	}
+
 	memcpy(&task->req, req, sizeof(*req));
 	task->conn = conn;
 	INIT_LIST_HEAD(&task->c_hlist);
@@ -1470,6 +1476,8 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 	else
 		return -ENOMEM;
 
+	conn->tp->ep_task_init(task);
+
 	task->tag = req->itt;
 
 	if (ahs_len) {
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 95540f2..ae4490a 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -128,6 +128,9 @@ struct iscsi_task {
 	void *ahs;
 	void *data;
 
+	/* Transport specific data */
+	void *trans_data;
+
 	struct scsi_cmd scmd;
 
 	unsigned long extdata[0];
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index ebb9a23..54f8cd6 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -7,8 +7,10 @@ struct iscsi_task;
 struct iscsi_transport {
 	const char *name;
 	int rdma;
+	int trans_data_len;
 
 	int (*ep_init) (void);
+	void (*ep_task_init) (struct iscsi_task *task);
 	size_t (*ep_read) (int ep, void *buf, size_t nbytes);
 	size_t (*ep_write_begin) (int ep, void *buf, size_t nbytes);
 	void (*ep_write_end)(int ep);
-- 
1.5.2




From pw at osc.edu  Fri Aug 17 23:58:09 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Fri, 17 Aug 2007 17:58:09 -0400
Subject: [Stgt-devel] [PATCH] save stag & va for a scsi command on the
	task object
In-Reply-To: <46C462D1.6080101@voltaire.com>
References: <20070809202234.GA26911@osc.edu> <46BF1333.4020801@voltaire.com>
	<20070813022159.GB26036@osc.edu>
	<46C1B65F.9070504@voltaire.com> <20070814151154.GA6131@osc.edu>
	<46C2C6E1.6040604@voltaire.com> <20070815180617.GA14471@osc.edu>
	<39C75744D164D948A170E9792AF8E7CA110A57@exil.voltaire.com>
	<20070815194426.GG14977@osc.edu> <46C462D1.6080101@voltaire.com>
Message-ID: <20070817215809.GA19833@osc.edu>

erezz at voltaire.com wrote on Thu, 16 Aug 2007 17:44 +0300:
> When a command PDU is received, the iSER header contains the read/write
> va & stag. This data was saved on the conn_info object. If another command PDU
> was received before this data was used, its va & stag were written over the
> data for the previous command. This fix saves the va & stag on the task object.

Good stuff.  I checked it in with minor modifications to keep trans
data closer to the rest of the task fields and tweak debugging
messages a bit:

    http://git.osc.edu/?p=tgt.git;a=commitdiff;h=e2be218b262e77776c681602320d598aa854e5e8

		-- Pete


From tomof at acm.org  Sat Aug 18 07:10:56 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 18 Aug 2007 14:10:56 +0900
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <20070815161559.GA13710@osc.edu>
References: <20070814225206.GA11031@osc.edu> <20070813013049E.tomof@acm.org>
	<20070815161559.GA13710@osc.edu>
Message-ID: <200708180510.l7I5AuQv032534@mbox.iij4u.or.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: Re: [Stgt-devel] [PATCH] iscsi fix xmit param
Date: Wed, 15 Aug 2007 11:15:59 -0500

> tomof at acm.org wrote on Wed, 15 Aug 2007 12:11 +0900:
> > On Tue, 14 Aug 2007 17:52:06 -0500
> > Pete Wyckoff <pw at osc.edu> wrote:
> > 
> > > This might be a hack.  In fixing the defaults earlier, I put the
> > > SCSI default for MaxRecvDataSegmentLength in place for the
> > > ISCSI_PARAM_MAX_XMIT_DLENGTH.  But really it should be whatever
> > > the initiator tells us.
> > 
> > Not sure. Initiators can declarer whatever about MRDSL, the target can
> > use a lower value than it. And the target administrator should be able
> > to configure it.
> > 
> > That's the current behaivoir (taken from IET).
> 
> True.  There are a few cases.
> 
> 1.  ini sends mrdsl > target mxdsl.  Apply minimum, use target max.
> 2.  ini sends mrdsl < target mxdsl.  Apply minimum, use ini max.
> 3.  ini does not mention mrdsl.  Target should set its mxdsl to the
>     standard default (8192), not use its default max.
> 
> This last case was broken before my earlier patch "iscsi param
> cleanup".  Now it is fixed but I changed the target default to 8k.
> I want the target to agree to use a larger value if the initiator is
> willing, but still get case #3 correct if the initiator does not
> specify.

Really?

I think that if ini does not mention mrdsl and target doesn't use the
standard default mxdsl value (a target admin sets non default value),
text_check_param() sets xmdsl to the default value.


From tomof at acm.org  Sat Aug 18 07:18:57 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 18 Aug 2007 14:18:57 +0900
Subject: [Stgt-devel] [PATCH] save stag & va for a scsi command on
	the	task object
In-Reply-To: <20070817215809.GA19833@osc.edu>
References: <20070815194426.GG14977@osc.edu> <46C462D1.6080101@voltaire.com>
	<20070817215809.GA19833@osc.edu>
Message-ID: <200708180518.l7I5IwN8030705@mbox.iij4u.or.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: Re: [Stgt-devel] [PATCH] save stag & va for a scsi command on the	task object
Date: Fri, 17 Aug 2007 17:58:09 -0400

> erezz at voltaire.com wrote on Thu, 16 Aug 2007 17:44 +0300:
> > When a command PDU is received, the iSER header contains the read/write
> > va & stag. This data was saved on the conn_info object. If another command PDU
> > was received before this data was used, its va & stag were written over the
> > data for the previous command. This fix saves the va & stag on the task object.
> 
> Good stuff.  I checked it in with minor modifications to keep trans
> data closer to the rest of the task fields and tweak debugging
> messages a bit:
> 
>     http://git.osc.edu/?p=tgt.git;a=commitdiff;h=e2be218b262e77776c681602320d598aa854e5e8

With this, the iser patchset is ready for inclusion? Sorry, I've not
read it but if it can't handle multiple outsanding commands, surely
it's not ready.

If it works for all the iSER people (not only OSD people), please
resubmit a new version of the iSER patchset. And please the patch with
the patch style checker (scripts/checkpatch.pl) prior to submission.

Thanks,


From pw at osc.edu  Sat Aug 18 16:52:00 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 18 Aug 2007 10:52:00 -0400
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <200708180510.l7I5AuQv032534@mbox.iij4u.or.jp>
References: <20070814225206.GA11031@osc.edu> <20070813013049E.tomof@acm.org>
	<20070815161559.GA13710@osc.edu>
	<200708180510.l7I5AuQv032534@mbox.iij4u.or.jp>
Message-ID: <20070818145200.GA7518@osc.edu>

tomof at acm.org wrote on Sat, 18 Aug 2007 14:10 +0900:
> From: Pete Wyckoff <pw at osc.edu>
> Subject: Re: [Stgt-devel] [PATCH] iscsi fix xmit param
> Date: Wed, 15 Aug 2007 11:15:59 -0500
>
> > True.  There are a few cases.
> > 
> > 1.  ini sends mrdsl > target mxdsl.  Apply minimum, use target max.
> > 2.  ini sends mrdsl < target mxdsl.  Apply minimum, use ini max.
> > 3.  ini does not mention mrdsl.  Target should set its mxdsl to the
> >     standard default (8192), not use its default max.
> > 
> > This last case was broken before my earlier patch "iscsi param
> > cleanup".  Now it is fixed but I changed the target default to 8k.
> > I want the target to agree to use a larger value if the initiator is
> > willing, but still get case #3 correct if the initiator does not
> > specify.
> 
> Really?
> 
> I think that if ini does not mention mrdsl and target doesn't use the
> standard default mxdsl value (a target admin sets non default value),
> text_check_param() sets xmdsl to the default value.

It really was broken.  But this is an odd case as open-iscsi at
least always sends mrdsl, even if it is set to use the default.

If you roll back to 92d767a711ed82791b171ce7c9b722263076c519 or so,
just before "iscsi param cleanup" you'll see:

iscsi/param.c:   mxdsl = 262144
iscsi/target.c:  mxdsl = 8192

and this code in iscsi/iscsid.c:

	if (p[i].state == KEY_STATE_START && p[i].val != session_keys[i].def) {
		if (conn->state == STATE_LOGIN) {
			if (i == ISCSI_PARAM_MAX_XMIT_DLENGTH) {
				if (p[i].val > session_keys[i].def)
					p[i].val = session_keys[i].def;
				p[i].state = KEY_STATE_DONE;
				continue;
			}
			memset(buf, 0, sizeof(buf));
			param_val_to_str(session_keys, i, p[i].val,
					 buf);
			text_key_add(conn, session_keys[i].name, buf);
			p[i].state = KEY_STATE_REQUEST;
		}
		cnt++;
	}

(p[] is conn->session_param, which is initialized from target params
then modified by negotiation.)

If target admin does not change target mxdsl, and initiator does not
send mrdsl, this code will see 8192 != 262144 and use 8192.  Fine,
that's the default.

If target admin changes target mxdsl to 16384 using tgtadm, and
initiator does not send mrdsl, this code will see 16384 != 262144
and use 16384 without negotiation.  Bad, should use the default.

With the "iscsi param cleanup" patch and this new "iscsi fix xmit
param", I think everything works as it should.

		-- Pete


From pw at osc.edu  Sat Aug 18 17:00:26 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 18 Aug 2007 11:00:26 -0400
Subject: [Stgt-devel] [PATCH] save stag & va for a scsi command on
	the	task object
In-Reply-To: <200708180518.l7I5IwN8030705@mbox.iij4u.or.jp>
References: <20070815194426.GG14977@osc.edu> <46C462D1.6080101@voltaire.com>
	<20070817215809.GA19833@osc.edu>
	<200708180518.l7I5IwN8030705@mbox.iij4u.or.jp>
Message-ID: <20070818150026.GB7518@osc.edu>

tomof at acm.org wrote on Sat, 18 Aug 2007 14:18 +0900:
> From: Pete Wyckoff <pw at osc.edu>
> Subject: Re: [Stgt-devel] [PATCH] save stag & va for a scsi command on the	task object
> Date: Fri, 17 Aug 2007 17:58:09 -0400
> 
> > erezz at voltaire.com wrote on Thu, 16 Aug 2007 17:44 +0300:
> > > When a command PDU is received, the iSER header contains the read/write
> > > va & stag. This data was saved on the conn_info object. If another command PDU
> > > was received before this data was used, its va & stag were written over the
> > > data for the previous command. This fix saves the va & stag on the task object.
> > 
> > Good stuff.  I checked it in with minor modifications to keep trans
> > data closer to the rest of the task fields and tweak debugging
> > messages a bit:
> > 
> >     http://git.osc.edu/?p=tgt.git;a=commitdiff;h=e2be218b262e77776c681602320d598aa854e5e8
> 
> With this, the iser patchset is ready for inclusion? Sorry, I've not
> read it but if it can't handle multiple outsanding commands, surely
> it's not ready.
> 
> If it works for all the iSER people (not only OSD people), please
> resubmit a new version of the iSER patchset. And please the patch with
> the patch style checker (scripts/checkpatch.pl) prior to submission.

It's closer now.  That was a big problem that Erez fixed.  He
pointed out off-list that we should run the open-iscsi regression
suite against the iser code.  That is good advice.

Nice addition of checkpatch.  I'll see what it turns up.

		-- Pete


From tomof at acm.org  Sat Aug 18 17:08:32 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 19 Aug 2007 00:08:32 +0900
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <20070818145200.GA7518@osc.edu>
References: <20070815161559.GA13710@osc.edu>
	<200708180510.l7I5AuQv032534@mbox.iij4u.or.jp>
	<20070818145200.GA7518@osc.edu>
Message-ID: <200708181508.l7IF8XSE004437@mbox.iij4u.or.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: Re: [Stgt-devel] [PATCH] iscsi fix xmit param
Date: Sat, 18 Aug 2007 10:52:00 -0400

> tomof at acm.org wrote on Sat, 18 Aug 2007 14:10 +0900:
> > From: Pete Wyckoff <pw at osc.edu>
> > Subject: Re: [Stgt-devel] [PATCH] iscsi fix xmit param
> > Date: Wed, 15 Aug 2007 11:15:59 -0500
> >
> > > True.  There are a few cases.
> > > 
> > > 1.  ini sends mrdsl > target mxdsl.  Apply minimum, use target max.
> > > 2.  ini sends mrdsl < target mxdsl.  Apply minimum, use ini max.
> > > 3.  ini does not mention mrdsl.  Target should set its mxdsl to the
> > >     standard default (8192), not use its default max.
> > > 
> > > This last case was broken before my earlier patch "iscsi param
> > > cleanup".  Now it is fixed but I changed the target default to 8k.
> > > I want the target to agree to use a larger value if the initiator is
> > > willing, but still get case #3 correct if the initiator does not
> > > specify.
> > 
> > Really?
> > 
> > I think that if ini does not mention mrdsl and target doesn't use the
> > standard default mxdsl value (a target admin sets non default value),
> > text_check_param() sets xmdsl to the default value.
> 
> It really was broken.  But this is an odd case as open-iscsi at
> least always sends mrdsl, even if it is set to use the default.
> 
> If you roll back to 92d767a711ed82791b171ce7c9b722263076c519 or so,
> just before "iscsi param cleanup" you'll see:
> 
> iscsi/param.c:   mxdsl = 262144
> iscsi/target.c:  mxdsl = 8192
> 
> and this code in iscsi/iscsid.c:
> 
> 	if (p[i].state == KEY_STATE_START && p[i].val != session_keys[i].def) {
> 		if (conn->state == STATE_LOGIN) {
> 			if (i == ISCSI_PARAM_MAX_XMIT_DLENGTH) {
> 				if (p[i].val > session_keys[i].def)
> 					p[i].val = session_keys[i].def;
> 				p[i].state = KEY_STATE_DONE;
> 				continue;
> 			}
> 			memset(buf, 0, sizeof(buf));
> 			param_val_to_str(session_keys, i, p[i].val,
> 					 buf);
> 			text_key_add(conn, session_keys[i].name, buf);
> 			p[i].state = KEY_STATE_REQUEST;
> 		}
> 		cnt++;
> 	}
> 
> (p[] is conn->session_param, which is initialized from target params
> then modified by negotiation.)
> 
> If target admin does not change target mxdsl, and initiator does not
> send mrdsl, this code will see 8192 != 262144 and use 8192.  Fine,
> that's the default.
> 
> If target admin changes target mxdsl to 16384 using tgtadm, and
> initiator does not send mrdsl, this code will see 16384 != 262144
> and use 16384 without negotiation.  Bad, should use the default.
> 
> With the "iscsi param cleanup" patch and this new "iscsi fix xmit
> param", I think everything works as it should.

I still can't understand how the git head is broken (that is, 
what does this new "iscsi fix xmit param" patch fix?).


From tomof at acm.org  Sat Aug 18 17:14:27 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 19 Aug 2007 00:14:27 +0900
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <20070818145200.GA7518@osc.edu>
References: <20070815161559.GA13710@osc.edu>
	<200708180510.l7I5AuQv032534@mbox.iij4u.or.jp>
	<20070818145200.GA7518@osc.edu>
Message-ID: <200708181514.l7IFETsf025352@mbox.iij4u.or.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: Re: [Stgt-devel] [PATCH] iscsi fix xmit param
Date: Sat, 18 Aug 2007 10:52:00 -0400

> tomof at acm.org wrote on Sat, 18 Aug 2007 14:10 +0900:
> > From: Pete Wyckoff <pw at osc.edu>
> > Subject: Re: [Stgt-devel] [PATCH] iscsi fix xmit param
> > Date: Wed, 15 Aug 2007 11:15:59 -0500
> >
> > > True.  There are a few cases.
> > > 
> > > 1.  ini sends mrdsl > target mxdsl.  Apply minimum, use target max.
> > > 2.  ini sends mrdsl < target mxdsl.  Apply minimum, use ini max.
> > > 3.  ini does not mention mrdsl.  Target should set its mxdsl to the
> > >     standard default (8192), not use its default max.
> > > 
> > > This last case was broken before my earlier patch "iscsi param
> > > cleanup".  Now it is fixed but I changed the target default to 8k.
> > > I want the target to agree to use a larger value if the initiator is
> > > willing, but still get case #3 correct if the initiator does not
> > > specify.
> > 
> > Really?
> > 
> > I think that if ini does not mention mrdsl and target doesn't use the
> > standard default mxdsl value (a target admin sets non default value),
> > text_check_param() sets xmdsl to the default value.
> 
> It really was broken.  But this is an odd case as open-iscsi at
> least always sends mrdsl, even if it is set to use the default.
> 
> If you roll back to 92d767a711ed82791b171ce7c9b722263076c519 or so,
> just before "iscsi param cleanup" you'll see:
> 
> iscsi/param.c:   mxdsl = 262144
> iscsi/target.c:  mxdsl = 8192
> 
> and this code in iscsi/iscsid.c:
> 
> 	if (p[i].state == KEY_STATE_START && p[i].val != session_keys[i].def) {
> 		if (conn->state == STATE_LOGIN) {
> 			if (i == ISCSI_PARAM_MAX_XMIT_DLENGTH) {
> 				if (p[i].val > session_keys[i].def)
> 					p[i].val = session_keys[i].def;
> 				p[i].state = KEY_STATE_DONE;
> 				continue;
> 			}
> 			memset(buf, 0, sizeof(buf));
> 			param_val_to_str(session_keys, i, p[i].val,
> 					 buf);
> 			text_key_add(conn, session_keys[i].name, buf);
> 			p[i].state = KEY_STATE_REQUEST;
> 		}
> 		cnt++;
> 	}
> 
> (p[] is conn->session_param, which is initialized from target params
> then modified by negotiation.)
> 
> If target admin does not change target mxdsl, and initiator does not
> send mrdsl, this code will see 8192 != 262144 and use 8192.  Fine,
> that's the default.
> 
> If target admin changes target mxdsl to 16384 using tgtadm, and
> initiator does not send mrdsl, this code will see 16384 != 262144
> and use 16384 without negotiation.  Bad, should use the default.

session_keys[i].def doesn't change (it is always the iSCSI default
value).


> With the "iscsi param cleanup" patch and this new "iscsi fix xmit
> param", I think everything works as it should.


From pw at osc.edu  Sat Aug 18 17:57:16 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 18 Aug 2007 11:57:16 -0400
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <200708181508.l7IF8XSE004437@mbox.iij4u.or.jp>
References: <20070815161559.GA13710@osc.edu>
	<200708180510.l7I5AuQv032534@mbox.iij4u.or.jp>
	<20070818145200.GA7518@osc.edu>
	<200708181508.l7IF8XSE004437@mbox.iij4u.or.jp>
Message-ID: <20070818155716.GA7849@osc.edu>

tomof at acm.org wrote on Sun, 19 Aug 2007 00:08 +0900:
> I still can't understand how the git head is broken (that is, 
> what does this new "iscsi fix xmit param" patch fix?).

Bit different when looking at HEAD, but still a bit broken.

iscsi/param.c:   mxdsl = 8192
iscsi/target.c:  mxdsl = 8192

and this code in iscsi/iscsid.c:

	if (p[i].state == KEY_STATE_START && p[i].val != session_keys[i].def) {
		if (conn->state == STATE_LOGIN) {
			if (i == ISCSI_PARAM_MAX_XMIT_DLENGTH) {
				if (p[i].val > session_keys[i].def)
					p[i].val = session_keys[i].def;
				p[i].state = KEY_STATE_DONE;
				continue;
			}
			memset(buf, 0, sizeof(buf));
			param_val_to_str(session_keys, i, p[i].val,
					 buf);
			text_key_add(conn, session_keys[i].name, buf);
			p[i].state = KEY_STATE_REQUEST;
		}
		cnt++;
	}

(p[] is conn->session_param, which is initialized from target params
then modified by negotiation.)

If target admin does not change target mxdsl, and initiator does not
send mrdsl, this code will see 8192 == 8192 and use 8192.  Fine,
that's the default.

If target admin changes target mxdsl to 16384 using tgtadm, and
initiator does not send mrdsl, this code will see 16384 != 8192.
Then the ">" will shrink it back to 8192.  Good.

Now what if target admin changes mxdsl to 16384 using tgtadm.  And
initiator sends mrdsl 16384.  Minimum of these leads to target
accepting 16384 up in text_scan_login.  Then this code sees 16384 !=
8192, and that 16384 > 8192, thus shrinks it back to 8192.  So
although both initiator and target are willing to use bigger mrdsl,
they cannot.

Patch fixes that.

		-- Pete


From pw at osc.edu  Sat Aug 18 17:59:06 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 18 Aug 2007 11:59:06 -0400
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <200708181514.l7IFETsf025352@mbox.iij4u.or.jp>
References: <20070815161559.GA13710@osc.edu>
	<200708180510.l7I5AuQv032534@mbox.iij4u.or.jp>
	<20070818145200.GA7518@osc.edu>
	<200708181514.l7IFETsf025352@mbox.iij4u.or.jp>
Message-ID: <20070818155906.GB7849@osc.edu>

tomof at acm.org wrote on Sun, 19 Aug 2007 00:14 +0900:
> From: Pete Wyckoff <pw at osc.edu>
> Subject: Re: [Stgt-devel] [PATCH] iscsi fix xmit param
> Date: Sat, 18 Aug 2007 10:52:00 -0400
> 
> > tomof at acm.org wrote on Sat, 18 Aug 2007 14:10 +0900:
> > > From: Pete Wyckoff <pw at osc.edu>
> > > Subject: Re: [Stgt-devel] [PATCH] iscsi fix xmit param
> > > Date: Wed, 15 Aug 2007 11:15:59 -0500
> > >
> > > > True.  There are a few cases.
> > > > 
> > > > 1.  ini sends mrdsl > target mxdsl.  Apply minimum, use target max.
> > > > 2.  ini sends mrdsl < target mxdsl.  Apply minimum, use ini max.
> > > > 3.  ini does not mention mrdsl.  Target should set its mxdsl to the
> > > >     standard default (8192), not use its default max.
> > > > 
> > > > This last case was broken before my earlier patch "iscsi param
> > > > cleanup".  Now it is fixed but I changed the target default to 8k.
> > > > I want the target to agree to use a larger value if the initiator is
> > > > willing, but still get case #3 correct if the initiator does not
> > > > specify.
> > > 
> > > Really?
> > > 
> > > I think that if ini does not mention mrdsl and target doesn't use the
> > > standard default mxdsl value (a target admin sets non default value),
> > > text_check_param() sets xmdsl to the default value.
> > 
> > It really was broken.  But this is an odd case as open-iscsi at
> > least always sends mrdsl, even if it is set to use the default.
> > 
> > If you roll back to 92d767a711ed82791b171ce7c9b722263076c519 or so,
> > just before "iscsi param cleanup" you'll see:
> > 
> > iscsi/param.c:   mxdsl = 262144
> > iscsi/target.c:  mxdsl = 8192
> > 
> > and this code in iscsi/iscsid.c:
> > 
> > 	if (p[i].state == KEY_STATE_START && p[i].val != session_keys[i].def) {
> > 		if (conn->state == STATE_LOGIN) {
> > 			if (i == ISCSI_PARAM_MAX_XMIT_DLENGTH) {
> > 				if (p[i].val > session_keys[i].def)
> > 					p[i].val = session_keys[i].def;
> > 				p[i].state = KEY_STATE_DONE;
> > 				continue;
> > 			}
> > 			memset(buf, 0, sizeof(buf));
> > 			param_val_to_str(session_keys, i, p[i].val,
> > 					 buf);
> > 			text_key_add(conn, session_keys[i].name, buf);
> > 			p[i].state = KEY_STATE_REQUEST;
> > 		}
> > 		cnt++;
> > 	}
> > 
> > (p[] is conn->session_param, which is initialized from target params
> > then modified by negotiation.)
> > 
> > If target admin does not change target mxdsl, and initiator does not
> > send mrdsl, this code will see 8192 != 262144 and use 8192.  Fine,
> > that's the default.
> > 
> > If target admin changes target mxdsl to 16384 using tgtadm, and
> > initiator does not send mrdsl, this code will see 16384 != 262144
> > and use 16384 without negotiation.  Bad, should use the default.
> 
> session_keys[i].def doesn't change (it is always the iSCSI default
> value).

Understood, I wasn't assuming that.  In fact, I toyed with adding
lots of "const" to enforce this, but it causes a big diff for not a
lot of benefit.

		-- Pete



From tomof at acm.org  Sat Aug 18 18:16:36 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 19 Aug 2007 01:16:36 +0900
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <20070818155906.GB7849@osc.edu>
References: <20070818145200.GA7518@osc.edu>
	<200708181514.l7IFETsf025352@mbox.iij4u.or.jp>
	<20070818155906.GB7849@osc.edu>
Message-ID: <200708181616.l7IGGbYq020675@mbox.iij4u.or.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: Re: [Stgt-devel] [PATCH] iscsi fix xmit param
Date: Sat, 18 Aug 2007 11:59:06 -0400

> tomof at acm.org wrote on Sun, 19 Aug 2007 00:14 +0900:
> > From: Pete Wyckoff <pw at osc.edu>
> > Subject: Re: [Stgt-devel] [PATCH] iscsi fix xmit param
> > Date: Sat, 18 Aug 2007 10:52:00 -0400
> > 
> > > tomof at acm.org wrote on Sat, 18 Aug 2007 14:10 +0900:
> > > > From: Pete Wyckoff <pw at osc.edu>
> > > > Subject: Re: [Stgt-devel] [PATCH] iscsi fix xmit param
> > > > Date: Wed, 15 Aug 2007 11:15:59 -0500
> > > >
> > > > > True.  There are a few cases.
> > > > > 
> > > > > 1.  ini sends mrdsl > target mxdsl.  Apply minimum, use target max.
> > > > > 2.  ini sends mrdsl < target mxdsl.  Apply minimum, use ini max.
> > > > > 3.  ini does not mention mrdsl.  Target should set its mxdsl to the
> > > > >     standard default (8192), not use its default max.
> > > > > 
> > > > > This last case was broken before my earlier patch "iscsi param
> > > > > cleanup".  Now it is fixed but I changed the target default to 8k.
> > > > > I want the target to agree to use a larger value if the initiator is
> > > > > willing, but still get case #3 correct if the initiator does not
> > > > > specify.
> > > > 
> > > > Really?
> > > > 
> > > > I think that if ini does not mention mrdsl and target doesn't use the
> > > > standard default mxdsl value (a target admin sets non default value),
> > > > text_check_param() sets xmdsl to the default value.
> > > 
> > > It really was broken.  But this is an odd case as open-iscsi at
> > > least always sends mrdsl, even if it is set to use the default.
> > > 
> > > If you roll back to 92d767a711ed82791b171ce7c9b722263076c519 or so,
> > > just before "iscsi param cleanup" you'll see:
> > > 
> > > iscsi/param.c:   mxdsl = 262144
> > > iscsi/target.c:  mxdsl = 8192
> > > 
> > > and this code in iscsi/iscsid.c:
> > > 
> > > 	if (p[i].state == KEY_STATE_START && p[i].val != session_keys[i].def) {
> > > 		if (conn->state == STATE_LOGIN) {
> > > 			if (i == ISCSI_PARAM_MAX_XMIT_DLENGTH) {
> > > 				if (p[i].val > session_keys[i].def)
> > > 					p[i].val = session_keys[i].def;
> > > 				p[i].state = KEY_STATE_DONE;
> > > 				continue;
> > > 			}
> > > 			memset(buf, 0, sizeof(buf));
> > > 			param_val_to_str(session_keys, i, p[i].val,
> > > 					 buf);
> > > 			text_key_add(conn, session_keys[i].name, buf);
> > > 			p[i].state = KEY_STATE_REQUEST;
> > > 		}
> > > 		cnt++;
> > > 	}
> > > 
> > > (p[] is conn->session_param, which is initialized from target params
> > > then modified by negotiation.)
> > > 
> > > If target admin does not change target mxdsl, and initiator does not
> > > send mrdsl, this code will see 8192 != 262144 and use 8192.  Fine,
> > > that's the default.
> > > 
> > > If target admin changes target mxdsl to 16384 using tgtadm, and
> > > initiator does not send mrdsl, this code will see 16384 != 262144
> > > and use 16384 without negotiation.  Bad, should use the default.
> > 
> > session_keys[i].def doesn't change (it is always the iSCSI default
> > value).
> 
> Understood, I wasn't assuming that.  In fact, I toyed with adding
> lots of "const" to enforce this, but it causes a big diff for not a
> lot of benefit.

Yeah, it's too ugly and complicated. Please no cleanups or
improvement. :) I'm happy as long as it works.


From markh794 at gmail.com  Wed Aug 15 22:49:40 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 16 Aug 2007 06:49:40 +1000
Subject: [Stgt-devel] Inconsistency in usage of scsi_id and iscsi_sn?
In-Reply-To: <46B823A5.3010309@gmail.com>
References: <46B823A5.3010309@gmail.com>
Message-ID: <46C366E4.3050803@gmail.com>

Hi Albert,

The 'scsi_id' is used to set SCSI Inquiry Vital Product Data (VPD) Page 
0x83 - Device Identification.
The 'scsi_sn' is used to set SCSI Inquiry VPD Page 0x80 - Unit Serial 
Number.
The 'vendor_id' is used to set the Vendor Identification in the standard 
INQUIRY data (IBM, Quantum etc)
The 'product_id' is used to set the Product Identification in the 
standard INQUIRY data (Device model - SDLT600 etc)
The 'product_rev' is used to set the Product Revision (firmware) version 
in the standard INQUIRY data.

The spc module is currently identifying the data in 'T10 vendor ID" 
format which the 'sg_inq' was attempting to interpret and decode.
Note: Earlier releases of sg_inq did not attempt to interpret the 
information.

I have update the spc code to return data in "Vendor Unique" format and 
will submit a patch later.

VPD Page 0x83 is not used by most user-space utilities

The SCSI Inquiry command requires further work to expand the sort of 
information that can be returned by different logical units.

Cheers
Mark

Albert Pauw wrote:
> I noticed something inconsistent (or so it seems).
>
> If I define something like this:
>
> tgtadm --lld iscsi --mode logicalunit --op update --tid 2 --lun 1 
> --params 
> vendor_id=MITSUMI,product_id=FD001,product_rev=0001,removable=1,sense_format=0 
>
> tgtadm --lld iscsi --mode logicalunit --op update --tid 2 --lun 1 
> --name scsi_id --value "CDROM ISO"
> tgtadm --lld iscsi --mode logicalunit --op update --tid 2 --lun 1 
> --name scsi_sn --value "001"
>
> and log into that target (using open-iscsi) I get in my dmesg:
>
> scsi2 : iSCSI Initiator over TCP/IP
> scsi 2:0:0:0: RAID              IET      Controller       0001 PQ: 0 
> ANSI: 5
> scsi 2:0:0:0: Attached scsi generic sg2 type 12
> scsi 2:0:0:1: CD-ROM            MITSUMI  FD001            0001 PQ: 0 
> ANSI: 5
> sr1: scsi-1 drive
> sr 2:0:0:1: Attached scsi CD-ROM sr1
> sr 2:0:0:1: Attached scsi generic sg3 type 5
>
> However, if I use the command:
>
> tgtadm --lld iscsi --op show --mode target
>
> it shows up as (part of it at least):
>
>        LUN: 1
>            Type: cd/dvd
>            SCSI ID: CDROM ISO
>            SCSI SN: 001
>            Size: 628M
>            Online: Yes
>            Poweron/Reset: No
>            Removable media: Yes
>
> so the scsi_id and scsi_sn are not used on the initiator and never 
> turn up, it's the vendor_id and product_id that show up.
>
> Can somebody shed some light on this (seemingly) inconsistent behaviour?
>
> Thanks,
>
> Albert
>
>
>
>
>
>
> ------------------------------------------------------------------------
>
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>   




From markh794 at gmail.com  Fri Aug 24 09:08:09 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 24 Aug 2007 17:08:09 +1000
Subject: [Stgt-devel] [Patch 1/1] Remove non-alphabetic chars from iSCSI
	target name
Message-ID: <46CE83D9.8030701@gmail.com>

Test script configured the iSCSI target name using both '-' & '_' chars. 
The Microsoft iSCSI initiator will not handle these chars.

>From 6e469c7bb490b4a76900492c14aaf26320bf67a0 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Fri, 24 Aug 2007 16:56:08 +1000
Subject: Remove non-alphabetic chars from iSCSI tgt name.

Microsoft iSCSI initiator did not like '-' & '_' chars
in the iSCSI target name.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 scripts/tgt-core-test |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
index 8c58972..d2832cd 100755
--- a/scripts/tgt-core-test
+++ b/scripts/tgt-core-test
@@ -27,7 +27,7 @@ TID=1
 
 # Create Target ID 1..
 tgtadm --lld iscsi --mode target --op new --tid $TID \
-		-T iqn.2007-03:marks-vtl_tgt:`hostname`
+		-T iqn.2007-03:marksvtltgt:`hostname`
 sleep 1
 
 # Create first LUN - Disk
-- 
1.5.2.3






From markh794 at gmail.com  Fri Aug 24 09:10:18 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 24 Aug 2007 17:10:18 +1000
Subject: [Stgt-devel] [Patch 1/1] debug printf fix.
Message-ID: <46CE845A.7000004@gmail.com>

Missing new-line char at end of debug statements.


>From 5554bf06ddea81aa23dd6fe325072cac178a3f06 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Fri, 24 Aug 2007 16:58:59 +1000
Subject: debug printf fix

Added missing newline to dump_cdb() debug statements.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/spc.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/usr/spc.c b/usr/spc.c
index b56c0b3..ad71e4a 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -439,25 +439,25 @@ void dump_cdb(struct scsi_cmd *cmd)
 
 	switch(cmd->scb_len) {
 	case 6:
-		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x",
+		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x\n",
 			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5]);
 		break;
 	case 10:
-		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
+		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x\n"
 				" %02x %02x %02x %02x",
 			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
 			cdb[6], cdb[7], cdb[8], cdb[9]);
 		break;
 	case 12:
 		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
-				" %02x %02x %02x %02x %02x %02x",
+				" %02x %02x %02x %02x %02x %02x\n",
 			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
 			cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11]);
 		break;
 	case 16:
 		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
 				" %02x %02x %02x %02x %02x %02x"
-				" %02x %02x %02x %02x",
+				" %02x %02x %02x %02x\n",
 			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
 			cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11],
 			cdb[12], cdb[13], cdb[14], cdb[15]);
-- 
1.5.2.3






From markh794 at gmail.com  Fri Aug 24 10:15:52 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 24 Aug 2007 18:15:52 +1000
Subject: [Stgt-devel] [Patch 1/1] Add support for extra VPD pages within
	INQUIRY op code
Message-ID: <46CE93B8.8000908@gmail.com>


As always, feedback welcome.


Unfortunately I had to change the lu_init() interface so I could more 
easily include the TID in the SCSI VPD page 80h and 83h

Hence the number of files touched with this patch.

As indicated in the patch, I am unsure from the osd2r01.pdf 
documentation of what data should be included within VPD pages B0h and 
B1h for the OSD module.

Regards
Mark


>From e752630bf3c33b9f4a0c22d4cc7af28b141c926b Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Fri, 24 Aug 2007 18:04:24 +1000
Subject: Add support for VPD pages 0x80 - 0xff

Ability to add VPD pages between 80h and FFh per SCSI device type.

An array of 128 vpd structures added to ly_phy_attr struct.

Use alloc_vpd(data size) to pre-alloc data for custom VPD page.
- This data is appended to the 4 byte VPD header at runtime
  i.e. When an INQUIRY for the VPD page is received.

- A custom vpd_update(struct scsi_lu *lu, void *) is used to
  set/change data pre-allocated by alloc_vpd()

- All modules except use default page 80h & 83h defined in spc.c
  The osd module has two extra for VPD pages B0h and B1h
  - Note: garbage values are set and should be reviewed/updated
          by somebody who knows what should be set here.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 scripts/tgt-core-test |   11 +++
 usr/mmc.c             |    4 +-
 usr/osd.c             |   42 +++++++++-
 usr/sbc.c             |    4 +-
 usr/scc.c             |    4 +-
 usr/smc.c             |    4 +-
 usr/spc.c             |  220 ++++++++++++++++++++++++++++++++++++++-----------
 usr/spc.h             |    3 +-
 usr/target.c          |    9 +--
 usr/tgtd.h            |   16 +++-
 10 files changed, 245 insertions(+), 72 deletions(-)

diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
index 8c58972..cf92303 100755
--- a/scripts/tgt-core-test
+++ b/scripts/tgt-core-test
@@ -184,6 +184,17 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 	--params dump=1
 
 
+# Create OSD LUN
+LUN=6
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/hd_block --device-type=osd
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params scsi_sn=FRED06,scsi_id=FredOSD
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params vendor_id=OSD,product_id=OSD00,product_rev=0010,removable=1,sense_format=1
+
+
 # Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
 
diff --git a/usr/mmc.c b/usr/mmc.c
index 7f70943..fffb2b7 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -132,9 +132,9 @@ static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	return spc_mode_sense(host_no, cmd);
 }
 
-static int mmc_lu_init(struct scsi_lu *lu)
+static int mmc_lu_init(struct scsi_lu *lu, int tid)
 {
-	if (spc_lu_init(lu))
+	if (spc_lu_init(lu, tid))
 		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "VIRTUAL-CDROM", sizeof(lu->attrs.product_id));
diff --git a/usr/osd.c b/usr/osd.c
index 189fba4..80ae9c5 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -51,13 +51,35 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 	return cmd->dev->bst->bs_cmd_submit(cmd);
 }
 
+static void update_vpd_b0(struct scsi_lu *lu, void *p)
+{
+	int pg = 0xb0 & 0x7f;
+	struct vpd *vpd_pg = lu->attrs.vpd[pg];
+
+	memcpy(vpd_pg->data, p, vpd_pg->size);
+}
+
+static void update_vpd_b1(struct scsi_lu *lu, void *p)
+{
+	int pg = 0xb1 & 0x7f;
+	struct vpd *vpd_pg = lu->attrs.vpd[pg];
+
+	memcpy(vpd_pg->data, p, vpd_pg->size);
+}
+
 /*
- * XXX: missing support for b0 and b1, in page 0 and in inquiry code.
- * Figure out how to make spc_inquiry handle extra mode pages.
+ * FIXME: I've made up the value for these params. Somebody who knows what
+ * should be in these + size of pages need to put sane vaues for pg B0 & B1
+ * markh794 at gmail.com
  */
-static int osd_lu_init(struct scsi_lu *lu)
+#define OSD_INFORMATION_LEN 12
+#define OSD_SECURITY_TOKEN_LEN 12
+static int osd_lu_init(struct scsi_lu *lu, int tid)
 {
-	if (spc_lu_init(lu))
+	int pg;
+	struct vpd **lu_vpd = lu->attrs.vpd;
+
+	if (spc_lu_init(lu, tid))
 		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "OSD", sizeof(lu->attrs.product_id));
@@ -66,6 +88,18 @@ static int osd_lu_init(struct scsi_lu *lu)
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
 	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
+	/* VPD page 0xB0 */
+	pg = 0xb0 & 0x7f;
+	lu_vpd[pg] = alloc_vpd(OSD_INFORMATION_LEN);
+	lu_vpd[pg]->vpd_update = update_vpd_b0;
+	lu_vpd[pg]->vpd_update(lu, "Information");
+
+	/* VPD page 0xB1 */
+	pg = 0xb1 & 0x7f;
+	lu_vpd[pg] = alloc_vpd(OSD_SECURITY_TOKEN_LEN);
+	lu_vpd[pg]->vpd_update = update_vpd_b1;
+	lu_vpd[pg]->vpd_update(lu, "Security");
+
 	return 0;
 }
 
diff --git a/usr/sbc.c b/usr/sbc.c
index 33485e6..7d488fb 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -170,12 +170,12 @@ sense:
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int sbc_lu_init(struct scsi_lu *lu)
+static int sbc_lu_init(struct scsi_lu *lu, int tid)
 {
 	uint64_t size;
 	uint8_t *data;
 
-	if (spc_lu_init(lu))
+	if (spc_lu_init(lu, tid))
 		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "VIRTUAL-DISK", sizeof(lu->attrs.product_id));
diff --git a/usr/scc.c b/usr/scc.c
index 0a154a5..c52d4f1 100644
--- a/usr/scc.c
+++ b/usr/scc.c
@@ -36,9 +36,9 @@
 #include "tgtadm_error.h"
 #include "spc.h"
 
-static int scc_lu_init(struct scsi_lu *lu)
+static int scc_lu_init(struct scsi_lu *lu, int tid)
 {
-	if (spc_lu_init(lu))
+	if (spc_lu_init(lu, tid))
 		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "Controller",
diff --git a/usr/smc.c b/usr/smc.c
index 4f0ee4b..318cb4f 100644
--- a/usr/smc.c
+++ b/usr/smc.c
@@ -435,7 +435,7 @@ sense:
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int smc_lu_init(struct scsi_lu *lu)
+static int smc_lu_init(struct scsi_lu *lu, int tid)
 {
 	struct smc_info *smc;
 
@@ -445,7 +445,7 @@ static int smc_lu_init(struct scsi_lu *lu)
 	else
 		return -ENOMEM;
 
-	spc_lu_init(lu);
+	spc_lu_init(lu, tid);
 
 	strncpy(lu->attrs.product_id, "VIRTUAL-CHANGER",
 						sizeof(lu->attrs.product_id));
diff --git a/usr/spc.c b/usr/spc.c
index b56c0b3..08a4bc5 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -20,6 +20,7 @@
  * 02110-1301 USA
  */
 #include <errno.h>
+#include <inttypes.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -38,6 +39,96 @@
 #define PRODUCT_REV	"0"
 #define BLK_SHIFT	9
 
+/** Protocol Identifier Values
+ * 0 Fibre Channel (FCP-2)
+ * 1 Parallel SCSI (SPI-5)
+ * 2 SSA (SSA-S3P)
+ * 3 IEEE 1394 (SBP-3)
+ * 4 SCSI Remote Direct Memory Access (SRP)
+ * 5 iSCSI
+ * 6 SAS Serial SCSI Protocol (SAS)
+ * 7 Automation/Drive Interface (ADT)
+ * 8 AT Attachment Interface (ATA/ATAPI-7)
+ */
+#define PIV_FCP 0
+#define PIV_SPI 1
+#define PIV_S3P 2
+#define PIV_SBP 3
+#define PIV_SRP 4
+#define PIV_ISCSI 5
+#define PIV_SAS 6
+#define PIV_ADT 7
+#define PIV_ATA 8
+
+#define PIV_VALID 0x80
+
+/** Code Set
+ *  1 - Designator fild contains binary values
+ *  2 - Designator field contains ASCII printable chars
+ *  3 - Designaotor field contains UTF-8
+ */
+#define INQ_CODE_BIN 1
+#define INQ_CODE_ASCII 2
+#define INQ_CODE_UTF8 3
+
+/** Association field
+ * 00b - Associated with Logical Unit
+ * 01b - Associated with target port
+ * 10b - Associated with SCSI Target device
+ * 11b - Reserved
+ */
+#define ASS_LU	0
+#define ASS_TGT_PORT 0x10
+#define ASS_TGT_DEV 0x20
+
+/** Designator type - SPC-4 Reference
+ * 0 - Vendor specific - 7.6.3.3
+ * 1 - T10 vendor ID - 7.6.3.4
+ * 2 - EUI-64 - 7.6.3.5
+ * 3 - NAA - 7.6.3.6
+ * 4 - Relative Target port identifier - 7.6.3.7
+ * 5 - Target Port group - 7.6.3.8
+ * 6 - Logical Unit group - 7.6.3.9
+ * 7 - MD5 logical unit identifier - 7.6.3.10
+ * 8 - SCSI name string - 7.6.3.11
+ */
+#define DESG_VENDOR 0
+#define DESG_T10 1
+#define DESG_EUI64 2
+#define DESG_NAA 3
+#define DESG_REL_TGT_PORT 4
+#define DESG_TGT_PORT_GRP 5
+#define DESG_LU_GRP 6
+#define DESG_MD5 7
+#define DESG_SCSI 8
+
+static int valid_vpd(struct vpd **vpd, uint8_t page)
+{
+	if (vpd[page & 0x7f])
+		return 1;
+	return 0;
+}
+
+void update_vpd_80(struct scsi_lu *lu, void *sn)
+{
+	struct vpd *vpd_pg = lu->attrs.vpd[0];
+	char *data = (char *)vpd_pg->data;
+
+	snprintf(data, SCSI_SN_LEN, "%-8s", (char *)sn);
+}
+
+void update_vpd_83(struct scsi_lu *lu, void *id)
+{
+	struct vpd *vpd_pg = lu->attrs.vpd[3];
+	uint8_t	*data = vpd_pg->data;
+
+	data[0] = (PIV_ISCSI << 4) | INQ_CODE_ASCII;
+	data[1] = PIV_VALID | ASS_TGT_PORT | DESG_VENDOR;
+	data[3] = SCSI_ID_LEN;
+
+	strncpy((char *)data + 4, id, SCSI_ID_LEN);
+}
+
 int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int len = 0, ret = SAM_STAT_CHECK_CONDITION;
@@ -47,6 +138,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 	uint8_t devtype = 0;
 	struct lu_phy_attr *attrs;
+	struct vpd **vpd;
+	struct vpd *vpd_pg;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
@@ -97,44 +190,37 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 		ret = SAM_STAT_GOOD;
 	} else if (scb[1] & 0x1) {
 		/* EVPD bit set */
+		vpd = attrs->vpd;
 		if (scb[2] == 0x0) {
+			int i, j, tmp;
+
+			i = 5;
+			tmp = 1;
 			data[0] = devtype;
-			data[1] = 0x0;
-			data[3] = 3;
+			data[1] = 0;
+			data[2] = 0;
+			for (j = 0; j < 0x80; j++) {
+				if (vpd[j]) {
+					data[i] = j | 0x80;
+					tmp++;
+					i++;
+				}
+			}
+			data[3] = tmp;
 			data[4] = 0x0;
-			data[5] = 0x80;
-			data[6] = 0x83;
-			len = 7;
-			ret = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x80) {
-			int tmp = SCSI_SN_LEN;
-
-			data[1] = 0x80;
-			data[3] = SCSI_SN_LEN;
-			memset(data + 4, 0x20, 4);
-			len = 4 + SCSI_SN_LEN;
+			len = tmp + 4;
 			ret = SAM_STAT_GOOD;
+		} else if (valid_vpd(vpd, scb[2])) {
+			int tmp;
+			vpd_pg = vpd[scb[2] & 0x7f];
+			tmp = vpd_pg->size;
 
-			if (strlen(attrs->scsi_sn)) {
-				uint8_t *p;
-				char *q;
-
-				p = data + 4 + tmp - 1;
-				q = attrs->scsi_sn + SCSI_SN_LEN - 1;
-				for (; tmp > 0; tmp--, q)
-					*(p--) = *(q--);
-			}
-		} else if (scb[2] == 0x83) {
-			int tmp = SCSI_ID_LEN;
-
-			data[1] = 0x83;
-			data[3] = tmp + 4;
-			data[4] = 0x1;
-			data[5] = 0x1;
-			data[7] = tmp;
-			strncpy((char *) data + 8, attrs->scsi_id, SCSI_ID_LEN);
-
-			len = tmp + 8;
+			data[0] = devtype;
+			data[1] = scb[2];
+			data[2] = (tmp >> 8);
+			data[3] = tmp & 0xff;
+			memcpy(&data[4], vpd_pg->data, tmp);
+			len = tmp + 4;
 			ret = SAM_STAT_GOOD;
 		}
 	}
@@ -358,6 +444,19 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 }
 
+struct vpd *alloc_vpd(uint16_t size)
+{
+	struct vpd *vpd;
+
+	vpd = zalloc(sizeof(struct vpd) + size);
+	if (!vpd)
+		return NULL;
+
+	vpd->size = size;
+
+	return vpd;
+}
+
 static struct mode_pg *alloc_mode_pg(uint8_t pcode, uint8_t subpcode,
 				     uint16_t size)
 {
@@ -500,6 +599,11 @@ int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
 	int err = TGTADM_SUCCESS;
 	char *p;
 	char buf[256];
+	struct lu_phy_attr *attrs;
+	struct vpd **vpd;
+
+	attrs = &lu->attrs;
+	vpd = attrs->vpd;
 
 	if (!strncmp("targetOps", params, 9))
 		params = params + 10;
@@ -512,36 +616,38 @@ int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_scsi_id:
-			match_strncpy(lu->attrs.scsi_id, &args[0],
-				      sizeof(lu->attrs.scsi_id));
+			match_strncpy(attrs->scsi_id, &args[0],
+				      sizeof(attrs->scsi_id));
+			vpd[3]->vpd_update(lu, attrs->scsi_id);
 			break;
 		case Opt_scsi_sn:
-			match_strncpy(lu->attrs.scsi_sn, &args[0],
-				      sizeof(lu->attrs.scsi_sn));
+			match_strncpy(attrs->scsi_sn, &args[0],
+				      sizeof(attrs->scsi_sn));
+			vpd[0]->vpd_update(lu, attrs->scsi_sn);
 			break;
 		case Opt_vendor_id:
-			match_strncpy(lu->attrs.vendor_id, &args[0],
-				      sizeof(lu->attrs.vendor_id));
+			match_strncpy(attrs->vendor_id, &args[0],
+				      sizeof(attrs->vendor_id));
 			break;
 		case Opt_product_id:
-			match_strncpy(lu->attrs.product_id, &args[0],
-				      sizeof(lu->attrs.product_id));
+			match_strncpy(attrs->product_id, &args[0],
+				      sizeof(attrs->product_id));
 			break;
 		case Opt_product_rev:
-			match_strncpy(lu->attrs.product_rev, &args[0],
-				      sizeof(lu->attrs.product_rev));
+			match_strncpy(attrs->product_rev, &args[0],
+				      sizeof(attrs->product_rev));
 			break;
 		case Opt_sense_format:
 			match_strncpy(buf, &args[0], sizeof(buf));
-			lu->attrs.sense_format = atoi(buf);
+			attrs->sense_format = atoi(buf);
 			break;
 		case Opt_removable:
 			match_strncpy(buf, &args[0], sizeof(buf));
-			lu->attrs.removable = atoi(buf);
+			attrs->removable = atoi(buf);
 			break;
 		case Opt_online:
 			match_strncpy(buf, &args[0], sizeof(buf));
-			lu->attrs.online = atoi(buf);
+			attrs->online = atoi(buf);
 			break;
 		case Opt_mode_page:
 			match_strncpy(buf, &args[0], sizeof(buf));
@@ -559,12 +665,32 @@ int spc_lu_config(struct scsi_lu *lu, char *params)
 	return lu_config(lu, params, NULL);
 }
 
-int spc_lu_init(struct scsi_lu *lu)
+int spc_lu_init(struct scsi_lu *lu, int tid)
 {
+	struct vpd **lu_vpd = lu->attrs.vpd;
+
+	lu->attrs.device_type = lu->dev_type_template.type;
+	lu->attrs.qualifier = 0x0;
+
 	snprintf(lu->attrs.vendor_id, sizeof(lu->attrs.vendor_id),
 		 "%-16s", VENDOR_ID);
 	snprintf(lu->attrs.product_rev, sizeof(lu->attrs.product_rev),
 		 "%s", "0001");
+	snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
+		 "deadbeaf%d:%" PRIu64, tid, lu->lun);
+	snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
+		 "beaf%d%" PRIu64, tid, lu->lun);
+
+	/* VPD page 0x80 */
+	lu_vpd[0] = alloc_vpd(SCSI_SN_LEN);
+	lu_vpd[0]->vpd_update = update_vpd_80;
+	update_vpd_80(lu, lu->attrs.scsi_sn);
+
+	/* VPD page 0x83 */
+	lu_vpd[3] = alloc_vpd(SCSI_ID_LEN + 4); /* + Designator descriptor len*/
+	lu_vpd[3]->vpd_update = update_vpd_83;
+	update_vpd_83(lu, lu->attrs.scsi_id);
+
 	lu->attrs.removable = 0;
 	lu->attrs.sense_format = 0;
 	lu->attrs.online = 0;
diff --git a/usr/spc.h b/usr/spc.h
index 1cc8623..315b49e 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -7,7 +7,7 @@ extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
 extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
 extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
-extern int spc_lu_init(struct scsi_lu *lu);
+extern int spc_lu_init(struct scsi_lu *lu, int tid);
 
 typedef int (match_fn_t)(struct scsi_lu *lu, char *params);
 extern int lu_config(struct scsi_lu *lu, char *params, match_fn_t *);
@@ -15,5 +15,6 @@ extern int spc_lu_config(struct scsi_lu *lu, char *params);
 extern void dump_cdb(struct scsi_cmd *cmd);
 extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
 extern int add_mode_page(struct scsi_lu *lu, char *params);
+extern struct vpd *alloc_vpd(uint16_t size);
 
 #endif
diff --git a/usr/target.c b/usr/target.c
index 2474d05..b966579 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -266,7 +266,7 @@ int tgt_device_create(int tid, int dev_type, uint64_t lun, char *args, int backi
 	tgt_cmd_queue_init(&lu->cmd_queue);
 
  	if (lu->dev_type_template.lu_init) {
- 		ret = lu->dev_type_template.lu_init(lu);
+		ret = lu->dev_type_template.lu_init(lu, tid);
 		if (ret)
 			goto free_lu;
 	}
@@ -285,13 +285,6 @@ int tgt_device_create(int tid, int dev_type, uint64_t lun, char *args, int backi
 			goto free_lu;
 	}
 
-	lu->attrs.device_type = lu->dev_type_template.type;
-	lu->attrs.qualifier = 0x0;
-	snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
-		 "deadbeaf%d:%" PRIu64, tid, lun);
-	snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
-		 "beaf%d%" PRIu64, tid, lun);
-
 	if (tgt_drivers[target->lid]->lu_create)
 		tgt_drivers[target->lid]->lu_create(lu);
 
diff --git a/usr/tgtd.h b/usr/tgtd.h
index c39b9c2..6fc38c4 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -36,6 +36,15 @@ struct tgt_cmd_queue {
 	struct list_head queue;
 };
 
+struct scsi_lu;
+struct scsi_cmd;
+
+struct vpd {
+	uint16_t size;
+	void (*vpd_update)(struct scsi_lu *lu, void *data);
+	uint8_t data[0];
+};
+
 struct lu_phy_attr {
 	char scsi_id[SCSI_ID_LEN + 1];
 	char scsi_sn[SCSI_SN_LEN + 1];
@@ -52,10 +61,9 @@ struct lu_phy_attr {
 	char online;		/* Logical Unit online */
 	char reset;		/* Power-on or reset has occured */
 	char sense_format;	/* Descrptor format sense data supported */
-};
 
-struct scsi_lu;
-struct scsi_cmd;
+	struct vpd *vpd[0x80];	/* VPD pages 0x80 -> 0xff masked with 0x80*/
+};
 
 struct device_type_operations {
 	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
@@ -64,7 +72,7 @@ struct device_type_operations {
 struct device_type_template {
 	unsigned char type;
 
-	int (*lu_init)(struct scsi_lu *lu);
+	int (*lu_init)(struct scsi_lu *lu, int tid);
 	void (*lu_exit)(struct scsi_lu *lu);
 	int (*lu_config)(struct scsi_lu *lu, char *args);
 
-- 
1.5.2.3






From nezhinsky at gmail.com  Sat Aug 25 20:53:57 2007
From: nezhinsky at gmail.com (Alexander Nezhinsky)
Date: Sat, 25 Aug 2007 21:53:57 +0300
Subject: [Stgt-devel] [PATCH] Makefile auto dependencies
Message-ID: <5eb093080708251153p113bf281t6a4b3ac3e493c673@mail.gmail.com>

Added automatic dependencies generation to stgt Makefile.
Dependency files are generated using -MM flag of gcc and included to
the Makefile itself.
Also .PHONY target declarations added where appropriate.

Signed-off-by: Alexander Nezhinsky <nezhinsky at gmail.com>
---
 usr/Makefile |   14 +++++++++++++-
 1 files changed, 13 insertions(+), 1 deletions(-)

diff --git a/usr/Makefile b/usr/Makefile
index 0f2a116..4af9d35 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -51,17 +51,29 @@ PROGRAMS += tgtd tgtadm
 TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o
work.o parser.o \
                spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o

+TGTD_DEP = $(TGTD_OBJS:.o=.d)

+.PHONY:all
 all: $(PROGRAMS)

 tgtd: $(TGTD_OBJS)
        $(CC) $^ -o $@ $(LIBS)

+-include $(TGTD_DEP)
+
 tgtadm: tgtadm.o
        $(CC) $^ -o $@

+-include tgtadm.d
+
+%.o: %.c
+       $(CC) -c $(CFLAGS) $*.c -o $*.o
+       @$(CC) -MM $(CFLAGS) -MF $*.d -MT $*.o $*.c
+
+.PHONY: install
 install: $(PROGRAMS)
        install -m 0755 $(PROGRAMS) $(DESTDIR)/usr/sbin

+.PHONY: clean
 clean:
-       rm -f *.o $(PROGRAMS) iscsi/*.o ibmvio/*.o xen/*.o
+       rm -f *.[od] $(PROGRAMS) iscsi/*.[od] iscsi/*.[od]
ibmvio/*.[od] xen/*.[od]


From tomof at acm.org  Sun Aug 26 03:21:08 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 26 Aug 2007 10:21:08 +0900
Subject: [Stgt-devel] [Patch 1/1] Remove non-alphabetic chars from
 iSCSI	target name
In-Reply-To: <46CE83D9.8030701@gmail.com>
References: <46CE83D9.8030701@gmail.com>
Message-ID: <200708260121.l7Q1L9s9017586@mbox.iij4u.or.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 1/1] Remove non-alphabetic chars from iSCSI	target name
Date: Fri, 24 Aug 2007 17:08:09 +1000

> Test script configured the iSCSI target name using both '-' & '_' chars. 
> The Microsoft iSCSI initiator will not handle these chars.
> 
> >From 6e469c7bb490b4a76900492c14aaf26320bf67a0 Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Fri, 24 Aug 2007 16:56:08 +1000
> Subject: Remove non-alphabetic chars from iSCSI tgt name.
> 
> Microsoft iSCSI initiator did not like '-' & '_' chars
> in the iSCSI target name.

I think that '-' is ok.


From tomof at acm.org  Sun Aug 26 03:21:29 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 26 Aug 2007 10:21:29 +0900
Subject: [Stgt-devel] [Patch 1/1] debug printf fix.
In-Reply-To: <46CE845A.7000004@gmail.com>
References: <46CE845A.7000004@gmail.com>
Message-ID: <200708260121.l7Q1LUJx017750@mbox.iij4u.or.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 1/1] debug printf fix.
Date: Fri, 24 Aug 2007 17:10:18 +1000

> Missing new-line char at end of debug statements.
> 
> 
> >From 5554bf06ddea81aa23dd6fe325072cac178a3f06 Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Fri, 24 Aug 2007 16:58:59 +1000
> Subject: debug printf fix
> 
> Added missing newline to dump_cdb() debug statements.

Thanks, applied.


From tomof at acm.org  Sun Aug 26 03:24:02 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 26 Aug 2007 10:24:02 +0900
Subject: [Stgt-devel] [PATCH] Makefile auto dependencies
In-Reply-To: <5eb093080708251153p113bf281t6a4b3ac3e493c673@mail.gmail.com>
References: <5eb093080708251153p113bf281t6a4b3ac3e493c673@mail.gmail.com>
Message-ID: <200708260124.l7Q1O2BG018846@mbox.iij4u.or.jp>

From: "Alexander Nezhinsky" <nezhinsky at gmail.com>
Subject: [Stgt-devel] [PATCH] Makefile auto dependencies
Date: Sat, 25 Aug 2007 21:53:57 +0300

> Added automatic dependencies generation to stgt Makefile.
> Dependency files are generated using -MM flag of gcc and included to
> the Makefile itself.
> Also .PHONY target declarations added where appropriate.
> 
> Signed-off-by: Alexander Nezhinsky <nezhinsky at gmail.com>

Thanks, but the patch is corrupted.

fujita at iris:~/git/tgt/usr$ cd ..
fujita at iris:~/git/tgt$ patch -p1 < ~/Mail/iscsi/stgt/1225
patching file usr/Makefile
patch: **** malformed patch at line 65: work.o parser.o \



From nezhinsky at gmail.com  Sun Aug 26 14:11:20 2007
From: nezhinsky at gmail.com (Alexander Nezhinsky)
Date: Sun, 26 Aug 2007 15:11:20 +0300 (IDT)
Subject: [Stgt-devel] [PATCH] Makefile auto dependencies
Message-ID: <Pine.LNX.4.64.0708261435550.17107@localhost.localdomain>

Tomo,

Sorry. The patch isellf was ok, but gmail wrapped the line
with TGTD_OBJS as it was longer than 80 chars.
Remailing it from other mailer.

---
Added automatic dependencies generation to stgt Makefile.
Dependency files are generated using -MM flag of gcc and included to
the Makefile itself.
Also .PHONY target declarations added where appropriate.

Signed-off-by: Alexander Nezhinsky <nezhinsky at gmail.com>
---
  usr/Makefile |   14 +++++++++++++-
  1 files changed, 13 insertions(+), 1 deletions(-)

diff --git a/usr/Makefile b/usr/Makefile
index f48f259..c28f26a 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -46,17 +46,29 @@ PROGRAMS += tgtd tgtadm
  TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o parser.o \
  		spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o

+TGTD_DEP = $(TGTD_OBJS:.o=.d)

+.PHONY:all
  all: $(PROGRAMS)

  tgtd: $(TGTD_OBJS)
  	$(CC) $^ -o $@ $(LIBS)

+-include $(TGTD_DEP)
+
  tgtadm: tgtadm.o
  	$(CC) $^ -o $@

+-include tgtadm.d
+
+%.o: %.c
+	$(CC) -c $(CFLAGS) $*.c -o $*.o
+	@$(CC) -MM $(CFLAGS) -MF $*.d -MT $*.o $*.c
+
+.PHONY: install
  install: $(PROGRAMS)
  	install -m 0755 $(PROGRAMS) $(DESTDIR)/usr/sbin

+.PHONY: clean
  clean:
-	rm -f *.o $(PROGRAMS) iscsi/*.o ibmvio/*.o xen/*.o
+	rm -f *.[od] $(PROGRAMS) iscsi/*.[od] ibmvio/*.[od] xen/*.[od]


From fujita.tomonori at lab.ntt.co.jp  Mon Aug 27 03:20:12 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 27 Aug 2007 10:20:12 +0900
Subject: [Stgt-devel] [PATCH] Makefile auto dependencies
In-Reply-To: <Pine.LNX.4.64.0708261435550.17107@localhost.localdomain>
References: <Pine.LNX.4.64.0708261435550.17107@localhost.localdomain>
Message-ID: <20070827102012X.fujita.tomonori@lab.ntt.co.jp>

On Sun, 26 Aug 2007 15:11:20 +0300 (IDT)
Alexander Nezhinsky <nezhinsky at gmail.com> wrote:

> Tomo,
> 
> Sorry. The patch isellf was ok, but gmail wrapped the line
> with TGTD_OBJS as it was longer than 80 chars.
> Remailing it from other mailer.
> 
> ---
> Added automatic dependencies generation to stgt Makefile.
> Dependency files are generated using -MM flag of gcc and included to
> the Makefile itself.
> Also .PHONY target declarations added where appropriate.
> 
> Signed-off-by: Alexander Nezhinsky <nezhinsky at gmail.com>
> ---
>   usr/Makefile |   14 +++++++++++++-
>   1 files changed, 13 insertions(+), 1 deletions(-)

Hmm, I stil can't apply the patch cleanly.

rouen:~/git/tgt$ patch -p1 < ~/Mail/iscsi/stgt/2098
patching file usr/Makefile
Hunk #1 FAILED at 46.
1 out of 1 hunk FAILED -- saving rejects to file usr/Makefile.rej


Anyway, I applied it by hand this time.


From pw at osc.edu  Mon Aug 27 16:38:19 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 27 Aug 2007 10:38:19 -0400
Subject: [Stgt-devel] [Patch 1/1] Add support for extra VPD pages	within
	INQUIRY op code
In-Reply-To: <46CE93B8.8000908@gmail.com>
References: <46CE93B8.8000908@gmail.com>
Message-ID: <20070827143819.GD28047@osc.edu>

markh794 at gmail.com wrote on Fri, 24 Aug 2007 18:15 +1000:
> Unfortunately I had to change the lu_init() interface so I could more 
> easily include the TID in the SCSI VPD page 80h and 83h
> 
> Hence the number of files touched with this patch.
> 
> As indicated in the patch, I am unsure from the osd2r01.pdf 
> documentation of what data should be included within VPD pages B0h and 
> B1h for the OSD module.

This looks great.  Thanks for looking at the OSD oddball parameters.
I'll patch them up once this goes in.

> From: Mark Harvey <markh794 at gmail.com>
> Date: Fri, 24 Aug 2007 18:04:24 +1000
> Subject: Add support for VPD pages 0x80 - 0xff
> 
> Ability to add VPD pages between 80h and FFh per SCSI device type.
> 
> An array of 128 vpd structures added to ly_phy_attr struct.
> 
> Use alloc_vpd(data size) to pre-alloc data for custom VPD page.
> - This data is appended to the 4 byte VPD header at runtime
>   i.e. When an INQUIRY for the VPD page is received.
> 
> - A custom vpd_update(struct scsi_lu *lu, void *) is used to
>   set/change data pre-allocated by alloc_vpd()
> 
> - All modules except use default page 80h & 83h defined in spc.c
>   The osd module has two extra for VPD pages B0h and B1h
>   - Note: garbage values are set and should be reviewed/updated
>           by somebody who knows what should be set here.
> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>
> ---
[..]
> diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
[..]
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +	--params vendor_id=OSD,product_id=OSD00,product_rev=0010,removable=1,sense_format=1

OSD sense format is always descriptor.  Cannot be old style, says the
spec.  But there's lots more ways root can break things.

[..]
> -int spc_lu_init(struct scsi_lu *lu)
> +int spc_lu_init(struct scsi_lu *lu, int tid)
>  {
> +	struct vpd **lu_vpd = lu->attrs.vpd;
> +
> +	lu->attrs.device_type = lu->dev_type_template.type;
> +	lu->attrs.qualifier = 0x0;
> +
>  	snprintf(lu->attrs.vendor_id, sizeof(lu->attrs.vendor_id),
>  		 "%-16s", VENDOR_ID);
>  	snprintf(lu->attrs.product_rev, sizeof(lu->attrs.product_rev),
>  		 "%s", "0001");
> +	snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
> +		 "deadbeaf%d:%" PRIu64, tid, lu->lun);
> +	snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
> +		 "beaf%d%" PRIu64, tid, lu->lun);

The only reason you pass in the tid is to create these fake values?
Would it be better to add a struct target * in struct scsi_lu
instead?  Seems a bit hacky to pass around tid just for this.

[..]
> +struct vpd {
> +	uint16_t size;
> +	void (*vpd_update)(struct scsi_lu *lu, void *data);
> +	uint8_t data[0];
> +};
> +
>  struct lu_phy_attr {
>  	char scsi_id[SCSI_ID_LEN + 1];
>  	char scsi_sn[SCSI_SN_LEN + 1];
> @@ -52,10 +61,9 @@ struct lu_phy_attr {
>  	char online;		/* Logical Unit online */
>  	char reset;		/* Power-on or reset has occured */
>  	char sense_format;	/* Descrptor format sense data supported */
> -};
>  
> -struct scsi_lu;
> -struct scsi_cmd;
> +	struct vpd *vpd[0x80];	/* VPD pages 0x80 -> 0xff masked with 0x80*/
> +};

1 kB of pointer space.  Guess that's not a big deal.  A linked list
would have been the other option you could consider.  I was going to
say the need to add and subtract 0x80 here and there was cumbersome,
but fixing that would cost another 1 kB.

		-- Pete


From markh794 at gmail.com  Tue Aug 28 01:41:05 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Tue, 28 Aug 2007 09:41:05 +1000
Subject: [Stgt-devel] [Patch 1/1] Add support for extra VPD pages	within
 INQUIRY op code
In-Reply-To: <20070827143819.GD28047@osc.edu>
References: <46CE93B8.8000908@gmail.com> <20070827143819.GD28047@osc.edu>
Message-ID: <46D36111.9010102@gmail.com>

Pete Wyckoff wrote:
> markh794 at gmail.com wrote on Fri, 24 Aug 2007 18:15 +1000:
>   
>> Unfortunately I had to change the lu_init() interface so I could more 
>> easily include the TID in the SCSI VPD page 80h and 83h
>>
>> Hence the number of files touched with this patch.
>>
>> As indicated in the patch, I am unsure from the osd2r01.pdf 
>> documentation of what data should be included within VPD pages B0h and 
>> B1h for the OSD module.
>>     
>
> This looks great.  Thanks for looking at the OSD oddball parameters.
> I'll patch them up once this goes in.
>
>   

I need them for the SSC devices as well :)

>> From: Mark Harvey <markh794 at gmail.com>
>> Date: Fri, 24 Aug 2007 18:04:24 +1000
>> Subject: Add support for VPD pages 0x80 - 0xff
>>
>> Ability to add VPD pages between 80h and FFh per SCSI device type.
>>
>> An array of 128 vpd structures added to ly_phy_attr struct.
>>
>> Use alloc_vpd(data size) to pre-alloc data for custom VPD page.
>> - This data is appended to the 4 byte VPD header at runtime
>>   i.e. When an INQUIRY for the VPD page is received.
>>
>> - A custom vpd_update(struct scsi_lu *lu, void *) is used to
>>   set/change data pre-allocated by alloc_vpd()
>>
>> - All modules except use default page 80h & 83h defined in spc.c
>>   The osd module has two extra for VPD pages B0h and B1h
>>   - Note: garbage values are set and should be reviewed/updated
>>           by somebody who knows what should be set here.
>>
>> Signed-off-by: Mark Harvey <markh794 at gmail.com>
>> ---
>>     
> [..]
>   
>> diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
>>     
> [..]
>   
>> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> +	--params vendor_id=OSD,product_id=OSD00,product_rev=0010,removable=1,sense_format=1
>>     
>
> OSD sense format is always descriptor.  Cannot be old style, says the
> spec.  But there's lots more ways root can break things.
>
> [..]
>   
Yep - Give the user a loaded gun....
Its up the them if they ignore the standards and 'pull the trigger'. 
Maybe I should log an error via the OSD device if set contrary to the spec.
- Hopefully make it a little easier for somebody setting up an OSD 
device and discover what they did wrong.

>> -int spc_lu_init(struct scsi_lu *lu)
>> +int spc_lu_init(struct scsi_lu *lu, int tid)
>>  {
>> +	struct vpd **lu_vpd = lu->attrs.vpd;
>> +
>> +	lu->attrs.device_type = lu->dev_type_template.type;
>> +	lu->attrs.qualifier = 0x0;
>> +
>>  	snprintf(lu->attrs.vendor_id, sizeof(lu->attrs.vendor_id),
>>  		 "%-16s", VENDOR_ID);
>>  	snprintf(lu->attrs.product_rev, sizeof(lu->attrs.product_rev),
>>  		 "%s", "0001");
>> +	snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
>> +		 "deadbeaf%d:%" PRIu64, tid, lu->lun);
>> +	snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
>> +		 "beaf%d%" PRIu64, tid, lu->lun);
>>     
>
> The only reason you pass in the tid is to create these fake values?
>   
Yes

> Would it be better to add a struct target * in struct scsi_lu
> instead?  Seems a bit hacky to pass around tid just for this.
>   

Adding TID into the scsi_lu struct did cross my mind when I was doing this.
- More space consumed in the structure for a 'one off' use vs passing 
the TID.. I went with the passing of TID.

I don't mind either way.


> [..]
>   
>> +struct vpd {
>> +	uint16_t size;
>> +	void (*vpd_update)(struct scsi_lu *lu, void *data);
>> +	uint8_t data[0];
>> +};
>> +
>>  struct lu_phy_attr {
>>  	char scsi_id[SCSI_ID_LEN + 1];
>>  	char scsi_sn[SCSI_SN_LEN + 1];
>> @@ -52,10 +61,9 @@ struct lu_phy_attr {
>>  	char online;		/* Logical Unit online */
>>  	char reset;		/* Power-on or reset has occured */
>>  	char sense_format;	/* Descrptor format sense data supported */
>> -};
>>  
>> -struct scsi_lu;
>> -struct scsi_cmd;
>> +	struct vpd *vpd[0x80];	/* VPD pages 0x80 -> 0xff masked with 0x80*/
>> +};
>>     
>
> 1 kB of pointer space.  Guess that's not a big deal.  A linked list
> would have been the other option you could consider.  I was going to
> say the need to add and subtract 0x80 here and there was cumbersome,
> but fixing that would cost another 1 kB.
>
> 		-- Pete
>
>   

Original patches for MODE SENSE/SELECT used a linked list, which was 
then simplified to an array. Hence I went with the array this time..

As you say allocating 256 entries for less then 10 active entries 
(typically 2) seemed a little extreme. The mask of 0x7f seemed to be a 
simple enough trade off.

I have a similar issue when I implement LOG SENSE/SELECT set of commands 
as well.

Cheers
Mark



From nezhinsky at gmail.com  Tue Aug 28 20:57:42 2007
From: nezhinsky at gmail.com (Alexander Nezhinsky)
Date: Tue, 28 Aug 2007 21:57:42 +0300 (IDT)
Subject: [Stgt-devel] [PATCH] Makefile auto dependencies
Message-ID: <Pine.LNX.4.64.0708282145090.14963@oldsony>

On 8/27/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> Hmm, I stil can't apply the patch cleanly.
> 
> Anyway, I applied it by hand this time.

Tomo,

I don't know what was the reason, maybe some diffs against the
iser version creeped in.

Anyway, you forgot to remove a plus sign before the %.o rule, so the
dependencies are not really gererated. Hope this time it works,
i tested it against a freshly cloned repository.

This patch fixes this typo (+%.o: %.c) and also breaks the lines
longer than 80 chars into shorter ones.

Signed-off-by: Alexander Nezhinsky <nezhinsky at gmail.com>
---
  usr/Makefile |   11 +++++++----
  1 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/usr/Makefile b/usr/Makefile
index f97f0da..3ac45c0 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -40,11 +40,14 @@ LIBS += -lcrypto -lpthread
  endif

  INCLUDES += -I.
-CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE 
$(INCLUDES)
+
+CFLAGS += -D_LARGEFILE64_SOURCE
+CFLAGS += $(INCLUDES)
+CFLAGS += -g -O2 -Wall -Wstrict-prototypes -fPIC

  PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o 
parser.o \
-               spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o
+TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o \
+               parser.o spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o

  TGTD_DEP = $(TGTD_OBJS:.o=.d)

@@ -61,7 +64,7 @@ tgtadm: tgtadm.o

  -include tgtadm.d

-+%.o: %.c
+%.o: %.c
         $(CC) -c $(CFLAGS) $*.c -o $*.o
         @$(CC) -MM $(CFLAGS) -MF $*.d -MT $*.o $*.c


From nezhinsky at gmail.com  Tue Aug 28 21:21:20 2007
From: nezhinsky at gmail.com (Alexander Nezhinsky)
Date: Tue, 28 Aug 2007 22:21:20 +0300 (IDT)
Subject: [Stgt-devel] [PATCH] Makefile auto dependencies
Message-ID: <Pine.LNX.4.64.0708282204320.16462@oldsony>


Oh, I'm terribly sorry, as i already see that my previous mail is broken 
again. Resending ...

On 8/27/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> 
wrote: > Hmm, I stil can't apply the patch cleanly.
>
> Anyway, I applied it by hand this time.

This patch fixes a typo (+%.o: %.c) and also breaks the lines
longer than 80 chars into shorter ones.

Signed-off-by: Alexander Nezhinsky <nezhinsky at gmail.com>
---
  usr/Makefile |   11 +++++++----
  1 files changed, 7 insertions(+), 4 deletions(-)

diff --git a/usr/Makefile b/usr/Makefile
index f97f0da..3ac45c0 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -40,11 +40,14 @@ LIBS += -lcrypto -lpthread
  endif

  INCLUDES += -I.
-CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
+
+CFLAGS += -D_LARGEFILE64_SOURCE
+CFLAGS += $(INCLUDES)
+CFLAGS += -g -O2 -Wall -Wstrict-prototypes -fPIC

  PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o parser.o \
-		spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o
+TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o \
+		parser.o spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o

  TGTD_DEP = $(TGTD_OBJS:.o=.d)

@@ -61,7 +64,7 @@ tgtadm: tgtadm.o

  -include tgtadm.d

-+%.o: %.c
+%.o: %.c
 	$(CC) -c $(CFLAGS) $*.c -o $*.o
 	@$(CC) -MM $(CFLAGS) -MF $*.d -MT $*.o $*.c


From tomof at acm.org  Wed Aug 29 00:10:21 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Wed, 29 Aug 2007 07:10:21 +0900
Subject: [Stgt-devel] [PATCH] Makefile auto dependencies
In-Reply-To: <Pine.LNX.4.64.0708282145090.14963@oldsony>
References: <Pine.LNX.4.64.0708282145090.14963@oldsony>
Message-ID: <20070827045946C.tomof@acm.org>

On Tue, 28 Aug 2007 21:57:42 +0300 (IDT)
Alexander Nezhinsky <nezhinsky at gmail.com> wrote:

> On 8/27/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > Hmm, I stil can't apply the patch cleanly.
> > 
> > Anyway, I applied it by hand this time.
> 
> Tomo,
> 
> I don't know what was the reason, maybe some diffs against the
> iser version creeped in.
> 
> Anyway, you forgot to remove a plus sign before the %.o rule, so the
> dependencies are not really gererated. Hope this time it works,
> i tested it against a freshly cloned repository.
> 
> This patch fixes this typo (+%.o: %.c) and also breaks the lines
> longer than 80 chars into shorter ones.

This patch is malformed again.

fujita at arbre:~/git/tgt$ patch -p1 < /home/fujita/Mail/iscsi/stgt/1986
patching file usr/Makefile
patch: **** malformed patch at line 82: $(INCLUDES)


I just reverted the previous commit. I can't apply a patch by hand. So
someone who know a proper way to send a patch must resend the patches.


From nezhinsky at gmail.com  Fri Aug 31 15:21:53 2007
From: nezhinsky at gmail.com (Alexander Nezhinsky)
Date: Fri, 31 Aug 2007 16:21:53 +0300 (IDT)
Subject: [Stgt-devel] [PATCH] Makefile auto dependencies
Message-ID: <Pine.LNX.4.64.0708311614280.11401@oldsony>

Resending Makefile patch for the current head. 

Dependency files generated using -MM flag of gcc and included to
the Makefile itself.
.PHONY target declarations added where appropriate.
Few lines longer than 80 chars broken. 

Signed-off-by: Alexander Nezhinsky <nezhinsky at gmail.com>
---
 usr/Makefile |   29 ++++++++++++++++++++++-------
 1 files changed, 22 insertions(+), 7 deletions(-)

diff --git a/usr/Makefile b/usr/Makefile
index 43565df..c84fe86 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -33,8 +33,9 @@ endif
 
 ifneq ($(ISCSI),)
 CFLAGS += -DISCSI
-TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o iscsid.o target.o \
-	chap.o transport.o iscsi_tcp.o isns.o libcrc32c.o)
+TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o \
+		iscsid.o target.o chap.o transport.o iscsi_tcp.o \
+		isns.o libcrc32c.o)
 TGTD_OBJS += bs_sync.o
 LIBS += -lcrypto -lpthread
 endif
@@ -46,24 +47,38 @@ TGTD_OBJS += bs_mmap.o tgtif.o
 endif
 
 INCLUDES += -I.
-CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
+
+CFLAGS += -D_LARGEFILE64_SOURCE 
+CFLAGS += $(INCLUDES)
+CFLAGS += -g -O2 -Wall -Wstrict-prototypes -fPIC 
 
 PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o parser.o \
-		spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o
+TGTD_OBJS += tgtd.o mgmt.o target.o scsi.o log.o driver.o util.o work.o \
+		parser.o spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o
 
+TGTD_DEP = $(TGTD_OBJS:.o=.d)
 
+.PHONY:all
 all: $(PROGRAMS)
 
 tgtd: $(TGTD_OBJS)
 	$(CC) $^ -o $@ $(LIBS)
 
+-include $(TGTD_DEP)
+
 tgtadm: tgtadm.o
 	$(CC) $^ -o $@
 
+-include tgtadm.d
+
+%.o: %.c
+	$(CC) -c $(CFLAGS) $*.c -o $*.o
+	@$(CC) -MM $(CFLAGS) -MF $*.d -MT $*.o $*.c
+
+.PHONY: install
 install: $(PROGRAMS)
 	install -m 0755 $(PROGRAMS) $(DESTDIR)/usr/sbin
 
+.PHONY: clean
 clean:
-	rm -f *.o $(PROGRAMS) iscsi/*.o ibmvio/*.o xen/*.o fc/*.o
-
+	rm -f *.[od] $(PROGRAMS) iscsi/*.[od] ibmvio/*.[od] xen/*.[od]


From pw at osc.edu  Fri Aug 31 19:06:33 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Fri, 31 Aug 2007 13:06:33 -0400
Subject: [Stgt-devel] close completes before synchronize cache response
Message-ID: <20070831170633.GA5667@osc.edu>

Commit ae2f80cbc432fe8cc4da94bdf289a7d856f11ac2:

    Date:   Sun Aug 12 08:18:45 2007 +0900

    close a connection after sending a logout response
    
    For now we need to just close a connection after sending a logout
    response.
    
causes some initiator complaints with 2.6.22 on logout:

sd 15:0:0:1: [sdb] Synchronizing SCSI cache
iscsi: cmd 0x35 is not queued (6)
iscsi: cmd 0x35 is not queued (6)
iscsi: cmd 0x35 is not queued (6)
sd 15:0:0:1: [sdb] Result: hostbyte=DID_NO_CONNECT driverbyte=DRIVER_OK,SUGGEST_OK

What happens on the target is:

tgtd: [12:00:25.295827] iscsi_scsi_cmd_rx_start(1387) 1 35 0 0 0 1 5b
tgtd: [12:00:25.295836] iscsi_task_queue(1332) 4752 4752 1
tgtd: [12:00:25.295842] target_cmd_queue(532) 0x630240 35 1
tgtd: [12:00:25.295848] target_cmd_queue(549) 0x630240 35 1 1
tgtd: [12:00:25.295853] bs_sync_cmd_submit(296) 6 0 0 0 0 0x630240
tgtd: [12:00:25.295861] target_cmd_queue(558) 5b 35 0 0 0 0 1
tgtd: [12:00:25.295877] bs_sync_worker_fn(140) got 0x630240
tgtd: [12:00:25.307434] iscsi_task_queue(1332) 4753 4753 46
tgtd: [12:00:25.307471] iscsi_task_tx_start(1680) found a task 0 0 0 0
tgtd: [12:00:25.307524] conn_close(97) connection closed
tgtd: [12:00:25.307532] iscsi_event_handler(2045) connection closed
tgtd: [12:00:25.608082] bs_sync_worker_fn(156) io done 0x630240 35 0 0
tgtd: [12:00:25.608136] bs_sync_ack_fn(94) found 0x630240
tgtd: [12:00:25.608167] bs_sync_handler(193) back to tgtd, 0x630240
tgtd: [12:00:25.608200] __cmd_done(618) 0 0 0 0
tgtd: [12:00:25.608210] conn_free(79) freeing connection
tgtd: [12:00:25.608217] it_nexus_destroy(124) 1 1

(Mostly unmodified git, just timestamps and little stuff.)

The SYNCHRONIZE_CACHE command (0x35) gets started in bs_sync by a
separate thread.  Then the immediate LOGOUT command (0x46) is
received and sets conn->state = STATE_CLOSE, as added in this patch.
After 300 ms, bs_sync completes, and returns its result, but iscsi
does not send it because the connection is closed.  Linux
complains.

If I remove bs_sync and instead use a non-threaded BS that processes
commands synchronously, close processing waits until after the cache
has been synchronized, and the initiator does not complain.

Things do work, but are a bit messy.  I don't have a good idea
for a workaround just now.  What was the problem that this patch
fixed?  Can we delay the close until all command responses have been
sent somehow?

		-- Pete


From michaelc at cs.wisc.edu  Fri Aug 31 19:49:05 2007
From: michaelc at cs.wisc.edu (Mike Christie)
Date: Fri, 31 Aug 2007 12:49:05 -0500
Subject: [Stgt-devel] close completes before synchronize cache response
In-Reply-To: <20070831170633.GA5667@osc.edu>
References: <20070831170633.GA5667@osc.edu>
Message-ID: <46D85491.9060002@cs.wisc.edu>

Pete Wyckoff wrote:
> Commit ae2f80cbc432fe8cc4da94bdf289a7d856f11ac2:
> 
>     Date:   Sun Aug 12 08:18:45 2007 +0900
> 
>     close a connection after sending a logout response
>     
>     For now we need to just close a connection after sending a logout
>     response.
>     
> causes some initiator complaints with 2.6.22 on logout:
> 
> sd 15:0:0:1: [sdb] Synchronizing SCSI cache
> iscsi: cmd 0x35 is not queued (6)
> iscsi: cmd 0x35 is not queued (6)
> iscsi: cmd 0x35 is not queued (6)
> sd 15:0:0:1: [sdb] Result: hostbyte=DID_NO_CONNECT driverbyte=DRIVER_OK,SUGGEST_OK
> 

I think this case is a initiator issue. As you said though there could 
be a issue with the target too, but those errors above are from a 
initiator goof up.

Before sending the logout we should have been waiting for the sync cache 
commands to complete. There was a change in behavior in 2.6.21+'s 
scsi-ml layer where in previous kernels removing the device from 
userspace would wait for the sync cache to complete. The initiator would 
then set some internal bits so new commands were not queued and then it 
would send the logout command.

In 2.6.21, if you remove the device from userspace the sysfs operation 
returns right away, so the cache sync could be queued in the block/scsi 
layer, in the driver or it could be on the wire or it could be done. We 
do not know. So for 2.6.21+ the initiator was doing

echo 1 > /sys/block/sdX/device/delete

Then setting the internal bits to stop new io from being queued to the 
driver, and at this time the sync caches were finally getting queued to 
the driver and the driver would fail them with the value you see above 
because it thought they had already been sent and that we wanted to 
shutdown.

This is fixed in the iscsi git trees.


From albert.pauw at gmail.com  Fri Aug 31 20:41:55 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Fri, 31 Aug 2007 20:41:55 +0200
Subject: [Stgt-devel] Can't compile the git version
Message-ID: <46D860F3.3060304@gmail.com>

I saw that there was an update in the repository so I updated my git 
version of tgt (git-pull),
as I always do.

Unfortunately, this new version it will not compile anymore.

Did something get messed up in the repository as of today (August 31st)?

Tried to make a new clone on my machine, but that didn't work either.

Albert

Here are the errors:

tgtif.c:39:30: error: scsi/scsi_tgt_if.h: No such file or directory
tgtif.c: In function 'head_ring_hdr':
tgtif.c:68: error: invalid application of 'sizeof' to incomplete type 
'struct tgt_event'
tgtif.c: In function 'kreq_send':
tgtif.c:78: error: dereferencing pointer to incomplete type
tgtif.c:83: error: dereferencing pointer to incomplete type
tgtif.c:85: error: dereferencing pointer to incomplete type
tgtif.c: In function 'kspace_send_tsk_mgmt_res':
tgtif.c:93: error: storage size of 'ev' isn't known
tgtif.c:97: error: 'TGT_UEVENT_TSK_MGMT_RSP' undeclared (first use in 
this function)
tgtif.c:97: error: (Each undeclared identifier is reported only once
tgtif.c:97: error: for each function it appears in.)
tgtif.c:93: warning: unused variable 'ev'
tgtif.c: In function 'kspace_send_cmd_res':
tgtif.c:119: error: storage size of 'ev' isn't known
tgtif.c:128: error: 'TGT_UEVENT_CMD_RSP' undeclared (first use in this 
function)
tgtif.c:119: warning: unused variable 'ev'
tgtif.c: In function 'kern_queue_cmd':
tgtif.c:148: error: dereferencing pointer to incomplete type
tgtif.c:150: error: dereferencing pointer to incomplete type
tgtif.c:158: error: dereferencing pointer to incomplete type
tgtif.c:162: error: dereferencing pointer to incomplete type
tgtif.c:164: error: dereferencing pointer to incomplete type
tgtif.c:166: error: dereferencing pointer to incomplete type
tgtif.c:168: error: dereferencing pointer to incomplete type
tgtif.c:170: error: dereferencing pointer to incomplete type
tgtif.c:171: error: dereferencing pointer to incomplete type
tgtif.c:172: error: dereferencing pointer to incomplete type
tgtif.c: In function 'kern_cmd_done':
tgtif.c:189: error: dereferencing pointer to incomplete type
tgtif.c:191: error: dereferencing pointer to incomplete type
tgtif.c:196: error: dereferencing pointer to incomplete type
tgtif.c:196: error: dereferencing pointer to incomplete type
tgtif.c:201: error: dereferencing pointer to incomplete type
tgtif.c:201: error: dereferencing pointer to incomplete type
tgtif.c: In function 'kspace_send_it_nexus_res':
tgtif.c:208: error: storage size of 'ev' isn't known
tgtif.c:212: error: 'TGT_UEVENT_IT_NEXUS_RSP' undeclared (first use in 
this function)
tgtif.c:208: warning: unused variable 'ev'
tgtif.c: In function 'kern_it_nexus_request':
tgtif.c:224: error: dereferencing pointer to incomplete type
tgtif.c:225: error: dereferencing pointer to incomplete type
tgtif.c:227: error: dereferencing pointer to incomplete type
tgtif.c: In function 'kern_mgmt_request':
tgtif.c:246: error: dereferencing pointer to incomplete type
tgtif.c:248: error: dereferencing pointer to incomplete type
tgtif.c:253: error: dereferencing pointer to incomplete type
tgtif.c:254: error: dereferencing pointer to incomplete type
tgtif.c:255: error: dereferencing pointer to incomplete type
tgtif.c:256: error: dereferencing pointer to incomplete type
tgtif.c:257: error: dereferencing pointer to incomplete type
tgtif.c:258: error: dereferencing pointer to incomplete type
tgtif.c: In function 'kern_event_handler':
tgtif.c:266: error: dereferencing pointer to incomplete type
tgtif.c:269: error: dereferencing pointer to incomplete type
tgtif.c:271: error: dereferencing pointer to incomplete type
tgtif.c:272: error: 'TGT_KEVENT_CMD_REQ' undeclared (first use in this 
function)
tgtif.c:275: error: 'TGT_KEVENT_CMD_DONE' undeclared (first use in this 
function)
tgtif.c:278: error: 'TGT_KEVENT_IT_NEXUS_REQ' undeclared (first use in 
this function)
tgtif.c:281: error: 'TGT_KEVENT_TSK_MGMT_REQ' undeclared (first use in 
this function)
tgtif.c:285: error: dereferencing pointer to incomplete type
tgtif.c:288: error: dereferencing pointer to incomplete type
tgtif.c: In function 'kreq_init':
tgtif.c:333: error: 'TGT_RING_SIZE' undeclared (first use in this function)
tgtif.c:351: error: invalid application of 'sizeof' to incomplete type 
'struct tgt_event'
tgtif.c:351: warning: division by zero
make: *** [tgtif.o] Error 1

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070831/4666e87e/attachment.html>

From pw at osc.edu  Fri Aug 31 20:53:45 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Fri, 31 Aug 2007 14:53:45 -0400
Subject: [Stgt-devel] close completes before synchronize cache response
In-Reply-To: <46D85491.9060002@cs.wisc.edu>
References: <20070831170633.GA5667@osc.edu> <46D85491.9060002@cs.wisc.edu>
Message-ID: <20070831185345.GE5667@osc.edu>

michaelc at cs.wisc.edu wrote on Fri, 31 Aug 2007 12:49 -0500:
> Pete Wyckoff wrote:
> >Commit ae2f80cbc432fe8cc4da94bdf289a7d856f11ac2:
> >
> >    Date:   Sun Aug 12 08:18:45 2007 +0900
> >
> >    close a connection after sending a logout response
> >    
> >    For now we need to just close a connection after sending a logout
> >    response.
> >    
> >causes some initiator complaints with 2.6.22 on logout:
> >
> >sd 15:0:0:1: [sdb] Synchronizing SCSI cache
> >iscsi: cmd 0x35 is not queued (6)
> >iscsi: cmd 0x35 is not queued (6)
> >iscsi: cmd 0x35 is not queued (6)
> >sd 15:0:0:1: [sdb] Result: hostbyte=DID_NO_CONNECT 
> >driverbyte=DRIVER_OK,SUGGEST_OK
> >
> 
> I think this case is a initiator issue. As you said though there could 
> be a issue with the target too, but those errors above are from a 
> initiator goof up.
> 
> Before sending the logout we should have been waiting for the sync cache 
> commands to complete. There was a change in behavior in 2.6.21+'s 
> scsi-ml layer where in previous kernels removing the device from 
> userspace would wait for the sync cache to complete. The initiator would 
> then set some internal bits so new commands were not queued and then it 
> would send the logout command.
> 
> In 2.6.21, if you remove the device from userspace the sysfs operation 
> returns right away, so the cache sync could be queued in the block/scsi 
> layer, in the driver or it could be on the wire or it could be done. We 
> do not know. So for 2.6.21+ the initiator was doing
> 
> echo 1 > /sys/block/sdX/device/delete
> 
> Then setting the internal bits to stop new io from being queued to the 
> driver, and at this time the sync caches were finally getting queued to 
> the driver and the driver would fail them with the value you see above 
> because it thought they had already been sent and that we wanted to 
> shutdown.
> 
> This is fixed in the iscsi git trees.

Ah, it is all clear now that you point it out.  Of course the
initiatior should be waiting for the cache flush to complete on the
target.  I just assumed it was something in the target (or, more
likely, my patches on top of it).  Thanks for the explanation.

		-- Pete


From tomof at acm.org  Fri Aug 31 21:14:12 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 01 Sep 2007 04:14:12 +0900
Subject: [Stgt-devel] Can't compile the git version
In-Reply-To: <46D860F3.3060304@gmail.com>
References: <46D860F3.3060304@gmail.com>
Message-ID: <200708311914.l7VJEDTM032198@mbox.iij4u.or.jp>

From: Albert Pauw <albert.pauw at gmail.com>
Subject: [Stgt-devel] Can't compile the git version
Date: Fri, 31 Aug 2007 20:41:55 +0200

> I saw that there was an update in the repository so I updated my git 
> version of tgt (git-pull),
> as I always do.
> 
> Unfortunately, this new version it will not compile anymore.
> 
> Did something get messed up in the repository as of today (August 31st)?
> 
> Tried to make a new clone on my machine, but that didn't work either.

Sorry, I messed up when I added fc target mode support. Please try
this patch.

BTW, please use a plain-text mail format. I ignore html mails unless I
find an important subject.

diff --git a/usr/Makefile b/usr/Makefile
index 43565df..4c918d4 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -39,8 +39,8 @@ TGTD_OBJS += bs_sync.o
 LIBS += -lcrypto -lpthread
 endif
 
-ifneq ($(FC),)
-CFLAGS += -DFC -DUSE_KERNEL
+ifneq ($(FCP),)
+CFLAGS += -DFCP -DUSE_KERNEL
 TGTD_OBJS += $(addprefix fc/, fc.o)
 TGTD_OBJS += bs_mmap.o tgtif.o
 endif
diff --git a/usr/driver.c b/usr/driver.c
index 2f6e154..068b410 100644
--- a/usr/driver.c
+++ b/usr/driver.c
@@ -39,7 +39,7 @@ struct tgt_driver *tgt_drivers[] = {
 #ifdef XEN
 	&xen,
 #endif
-#ifdef FC
+#ifdef FCP
 	&fc,
 #endif
 	NULL,


