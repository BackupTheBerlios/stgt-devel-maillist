From pauw at o2.ie  Sun Apr  1 10:11:12 2007
From: pauw at o2.ie (Albert Pauw)
Date: Sun, 01 Apr 2007 10:11:12 +0200
Subject: [Stgt-devel] [PATCH] some shortcut options missing from tgtadm
Message-ID: <13491c613421c0.13421c013491c6@o2.ie>

A few short options were missing in tgtadm.c, this simple patch just adds these.

Albert

--- usr/tgtadm.c        2007-04-01 10:03:22.000000000 +0200
+++ usr/tgtadm.c.new    2007-04-01 10:03:02.000000000 +0200
@@ -110,7 +110,7 @@
        {NULL, 0, NULL, 0},
 };
 
-static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:";
+static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:B:Y:O:";
 
 static void usage(int status)
 {




From pauw at o2.ie  Sun Apr  1 20:25:23 2007
From: pauw at o2.ie (Albert Pauw)
Date: Sun, 01 Apr 2007 20:25:23 +0200
Subject: [Stgt-devel] [patch] support different type in one target.
Message-ID: <135ab4a1358dcf.1358dcf135ab4a@o2.ie>

Unfortunately, 

this patch does not update the Type field,
when the command "tgtadm --lld iscsi --op show --mode target" is given. The Type field is one field for the target only, there should be a Type field for every LUN when there are different types per LUN. Other than that, it does seem to work though.

Albert

--- snip ---

Hu Gang wrote:

this patch adding support mutiple scsi type as a modules.

Signed-off-by: hu gang <hugang at soulinfo.com>

---

 usr/mmc.c    |    5 +++++
 usr/osd.c    |    5 +++++
 usr/sbc.c    |    5 +++++
 usr/target.c |   61 +++++++++++++++++++++++++++++++++++++++++++---------------
 usr/tgtd.h   |    4 ++++
 5 files changed, 64 insertions(+), 16 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index 4eab50b..cbba763 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -213,3 +213,8 @@ struct device_type_template mmc_template
 		[0xb0 ... 0xff] = {spc_illegal_op},
 	}
 };
+
+__attribute__((constructor)) static void mmc_init(void)
+{
+    device_type_register(&mmc_template);
+}
diff --git a/usr/osd.c b/usr/osd.c
index da3853b..1612a20 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -209,3 +209,8 @@ struct device_type_template osd_template
 		[0xb0 ... 0xff] = {spc_illegal_op},
 	}
 };
+
+__attribute__((constructor)) static void osd_init(void)
+{
+        device_type_register(&osd_template);
+}
diff --git a/usr/sbc.c b/usr/sbc.c
index edcd6e8..66c0c2e 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -465,3 +465,8 @@ struct device_type_template sbc_template
 		[0xb0 ... 0xff] = {spc_illegal_op},
 	}
 };
+
+__attribute__((constructor)) static void sbc_init(void)
+{
+        device_type_register(&sbc_template);
+}
diff --git a/usr/target.c b/usr/target.c
index b49b143..e986985 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -36,8 +36,37 @@ #include "target.h"
 #include "scsi.h"
 #include "tgtadm.h"
 
-extern struct device_type_template sbc_template, mmc_template, osd_template,
-	spt_template;
+static LIST_HEAD(type_list);
+
+int device_type_register(struct device_type_template *t)
+{
+    list_add_tail(&t->list_entry, &type_list);
+    return 0;
+}
+
+static struct device_type_template *device_type_find_name(const char *name)
+{
+    struct device_type_template *t;
+    
+    list_for_each_entry(t, &type_list, list_entry) {
+        if (strcmp(name, t->name) == 0)
+            return t;
+    }
+
+    return NULL;
+}
+
+static struct device_type_template *device_type_find_type(unsigned char type)
+{
+    struct device_type_template *t;
+    
+    list_for_each_entry(t, &type_list, list_entry) {
+        if (t->type == type)
+            return t;
+    }
+
+    return NULL;
+}
 
 static LIST_HEAD(target_list);
 
@@ -205,6 +234,7 @@ int tgt_device_create(int tid, uint64_t 
 	struct target *target;
 	struct scsi_lu *lu, *pos;
     struct backingstore_template *bst;
+    struct device_type_template *tt;
 
 	dprintf("%d %" PRIu64 "\n", tid, lun);
 
@@ -237,23 +267,12 @@ int tgt_device_create(int tid, uint64_t 
 		return TGTADM_NOMEM;
     lu->bst = bst;
 
-	switch (t_type) {
-	case TYPE_DISK:
-		lu->dev_type_template = sbc_template;
-		break;
-	case TYPE_ROM:
-		lu->dev_type_template = mmc_template;
-		break;
-	case TYPE_OSD:
-		lu->dev_type_template = osd_template;
-		break;
-	case TYPE_SPT:
-		lu->dev_type_template = spt_template;
-		break;
-	default:
+    tt = device_type_find_type(t_type);
+    if (tt == NULL) {
 		free(lu);
 		return TGTADM_INVALID_REQUEST;
 	}
+    lu->dev_type_template = *tt;
 
 	err = tgt_device_path_update(target, lu, p);
 	if (err) {
@@ -1089,6 +1108,7 @@ int tgt_target_show_all(char *buf, int r
 	struct scsi_lu *lu;
 	struct acl_entry *acl;
 	struct it_nexus *nexus;
+    struct device_type_template *dtt;
 
 	list_for_each_entry(target, &target_list, target_siblings) {
 		shprintf(total, buf, rest,
@@ -1148,6 +1168,15 @@ int tgt_target_show_all(char *buf, int r
 		list_for_each_entry(acl, &target->acl_list, aclent_list)
 			shprintf(total, buf, rest, _TAB2 "%s\n", acl->address);
 	}
+
+    shprintf(total, buf, rest, "Device type:\n");
+    list_for_each_entry(dtt, &type_list, list_entry) {
+        shprintf(total, buf, rest, 
+                _TAB1 "Device Type: %d\n"
+                _TAB2 "Device Name: %s\n"
+                _TAB2 "Device Pid : %s\n",
+                dtt->type, dtt->name, dtt->pid ? dtt->pid : "");
+    }
 	return total;
 overflow:
 	return max;
diff --git a/usr/tgtd.h b/usr/tgtd.h
index de7d889..413271e 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -49,8 +49,12 @@ struct device_type_template {
 	void (*device_init)(struct scsi_lu *dev);
 
 	struct device_type_operations ops[256];
+
+    struct list_head list_entry;
 };
 
+extern int device_type_register(struct device_type_template *);
+
 struct scsi_lu {
 	int fd;
 	uint64_t addr; /* persistent mapped address */



From hare at suse.de  Wed Apr  4 08:43:32 2007
From: hare at suse.de (Hannes Reinecke)
Date: Wed, 04 Apr 2007 08:43:32 +0200
Subject: [Stgt-devel] Which license?
Message-ID: <46134914.1010208@suse.de>

Hi all,

our nice build system requires to state a license for each package. Only
currently there is only a inherited reference to the GPL in log.h (which
was copied via open-iscsi and iscsitarget).
So I would assume that the entire project runs under the GPL.
Is that true?
Can we have an explicit pointer somewhere (eg in the README) which
license this project runs under?

Tomo? Mike?

Cheers,

Hannes
-- 
Dr. Hannes Reinecke		      zSeries & Storage
hare at suse.de			      +49 911 74053 688
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
GF: Markus Rex, HRB 16746 (AG N?rnberg)


From hare at suse.de  Wed Apr  4 08:33:37 2007
From: hare at suse.de (Hannes Reinecke)
Date: Wed, 04 Apr 2007 08:33:37 +0200
Subject: [Stgt-devel] [PATCH] Fix memset arguments for mmc
Message-ID: <461346C1.3030405@suse.de>

Hi all,

our checker revealed an argument mixup in mmc.c; the length is the third
argument to memset, no the second.

Please apply.

Cheers,

Hannes
-- 
Dr. Hannes Reinecke		      zSeries & Storage
hare at suse.de			      +49 911 74053 688
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
GF: Markus Rex, HRB 16746 (AG N?rnberg)
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: tgt-mmc-read-toc-swapped-args
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070404/0be6df15/attachment.ksh>

From bastian at waldi.eu.org  Wed Apr  4 09:37:25 2007
From: bastian at waldi.eu.org (Bastian Blank)
Date: Wed, 4 Apr 2007 09:37:25 +0200
Subject: [Stgt-devel] license problems
Message-ID: <20070404073725.GA7553@wavehammer.waldi.eu.org>

Hi folks

The userspace scsi target code is undistributable in binary form.

The whole sources looks like GPL, which is incompatible with the OpenSSL
license. Two possible fixes:
- Change the license to include an exception for this case.
- Use libgcrypt.

See http://www.gnome.org/~markmc/openssl-and-the-gpl.html for further
information.

Bastian

-- 
No one may kill a man.  Not for any purpose.  It cannot be condoned.
		-- Kirk, "Spock's Brain", stardate 5431.6
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070404/1057155d/attachment.pgp>

From fujita.tomonori at lab.ntt.co.jp  Wed Apr  4 13:28:11 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 04 Apr 2007 20:28:11 +0900
Subject: [Stgt-devel] license problems
In-Reply-To: <20070404073725.GA7553@wavehammer.waldi.eu.org>
References: <20070404073725.GA7553@wavehammer.waldi.eu.org>
Message-ID: <20070404202811R.fujita.tomonori@lab.ntt.co.jp>

From: Bastian Blank <bastian at waldi.eu.org>
Subject: [Stgt-devel] license problems
Date: Wed, 4 Apr 2007 09:37:25 +0200

> Hi folks
> 
> The userspace scsi target code is undistributable in binary form.
> 
> The whole sources looks like GPL, which is incompatible with the OpenSSL
> license. Two possible fixes:
> - Change the license to include an exception for this case.
> - Use libgcrypt.
> 
> See http://www.gnome.org/~markmc/openssl-and-the-gpl.html for further
> information.

We did this before in IET. It's not so clear for me:

http://www.mail-archive.com/git at vger.kernel.org/msg00465.html


IET uses libssl too. Seems that many people distributes it in binary
form. So far, any GPL software copyright holders haven't claimed that
me infringe on their rights.


From fujita.tomonori at lab.ntt.co.jp  Wed Apr  4 13:36:01 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 04 Apr 2007 20:36:01 +0900
Subject: [Stgt-devel] [PATCH] Fix memset arguments for mmc
In-Reply-To: <461346C1.3030405@suse.de>
References: <461346C1.3030405@suse.de>
Message-ID: <20070404203601O.fujita.tomonori@lab.ntt.co.jp>

From: Hannes Reinecke <hare at suse.de>
Subject: [Stgt-devel] [PATCH] Fix memset arguments for mmc
Date: Wed, 04 Apr 2007 08:33:37 +0200

> Hi all,
> 
> our checker revealed an argument mixup in mmc.c; the length is the third
> argument to memset, no the second.
> 
> Please apply.

Applied, thanks.

Please send a patch with a sign-off next time.


From waldi at berlios.de  Wed Apr  4 20:27:53 2007
From: waldi at berlios.de (Bastian Blank)
Date: Wed, 4 Apr 2007 20:27:53 +0200
Subject: [Stgt-devel] ibmvio - rdma error
Message-ID: <20070404182753.GA25247@wavehammer.waldi.eu.org>

Hi folks

I tried the ibmvscsi support today. I use linux-2.6-target.git and the
tools trunk.

My test system did not even survive a bonnie call. I got many errors
like the followin:
| ibmvstgt_rdma(251) rdma error 1 135168
| ibmvstgt_rdma(251) rdma error 1 135168
| ibmvstgt_rdma(251) rdma error 1 139264
| ibmvstgt_rdma(251) rdma error 1 135168

After some time, ext3 reported a journal abort. So it gets garbage
instead of the real data. The filesystem is broken after that.

I'd unload anything and did a new try and got this:
| Unregister IBM virtual SCSI driver
| IBM eServer i/pSeries Virtual SCSI Target Driver
| scsi7 : ibmvstgt
| scsi8 : ibmvstgt
| ibmvstgt_rdma(251) rdma error 2 262144
| ibmvstgt_rdma(251) rdma error 2 262144
| ibmvstgt_rdma(251) rdma error 2 262144
| ibmvstgt_rdma(251) rdma error 2 262144

Bastian

-- 
	"That unit is a woman."
	"A mass of conflicting impulses."
		-- Spock and Nomad, "The Changeling", stardate 3541.9
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070404/ce58a061/attachment.pgp>

From waldi at berlios.de  Wed Apr  4 21:14:32 2007
From: waldi at berlios.de (Bastian Blank)
Date: Wed, 4 Apr 2007 21:14:32 +0200
Subject: [Stgt-devel] ibmvio - rdma error
In-Reply-To: <20070404182753.GA25247@wavehammer.waldi.eu.org>
References: <20070404182753.GA25247@wavehammer.waldi.eu.org>
Message-ID: <20070404191432.GA32505@wavehammer.waldi.eu.org>

On Wed, Apr 04, 2007 at 08:27:53PM +0200, Bastian Blank wrote:
> | ibmvstgt_rdma(251) rdma error 1 135168
> | ibmvstgt_rdma(251) rdma error 1 135168
> | ibmvstgt_rdma(251) rdma error 1 139264
> | ibmvstgt_rdma(251) rdma error 1 135168

This errors are ignored, so it is likely to use garbage.

Bastian

-- 
Many Myths are based on truth
		-- Spock, "The Way to Eden",  stardate 5832.3


From markh794 at gmail.com  Thu Apr  5 01:56:10 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 5 Apr 2007 09:56:10 +1000
Subject: [Stgt-devel] vtl patch.
Message-ID: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>

Apologies for this being an attachment. It is rather large to include
inline (57k).

Follow up to feedback from earlier postings, I have implemented the following:


This patch includes the following changes.

- Patch to tgtadm so multiple '--name, --value' arguments can be passed.
- Add device_shutdown() & device_config() to device_type_template
- Unprocessed '--name, --value' arguments are passed to
device_config() in each device template to process.
- smc & ssc 'modules' (INQUIRY cmd implemented - more to come)

- Updated documentation in doc/README.vtl

NOTE: Many of the features in the doc/README.vtl are not implemented
and are included for comment. Better syntax ideas welcome.

Output from "tgtadm --lld iscsi --mode target --op show"
Target 1: iqn.2007-03:marks-vtl_smc:laptop
    System information:
        Type: changer
        Driver: iscsi
        Status: running
    I_T nexus information:
    LUN information:
        LUN: 0
            SCSI ID: deadbeaf1:0
            SCSI SN: XYZZY
            Size: 0
            Backing store: /dev/null
    Account information:
    ACL information:
        ALL
Target 2: iqn.2007-03:marks-vtl_ssc:laptop
    System information:
        Type: tape
        Driver: iscsi
        Status: running
    I_T nexus information:
    LUN information:
        LUN: 0
            SCSI ID: deadbeaf2:0
            SCSI SN: XYZZY10
            Size: 0
            Backing store: /dev/null
        LUN: 1
            SCSI ID: deadbeaf2:1
            SCSI SN: XYZZY11
            Size: 0
            Backing store: /dev/null
        LUN: 2
            SCSI ID: deadbeaf2:2
            SCSI SN: XYZZY12
            Size: 0
            Backing store: /dev/null
    Account information:
    ACL information:
        ALL

And "# lsscsi -g"
[0:0:0:0]    tape    QUANTUM  SDLT600          0010  /dev/st0  /dev/sg0
[0:0:0:1]    tape    IBM      ULT3580-TD3      0010  /dev/st1  /dev/sg1
[0:0:0:2]    tape    SONY     SDX-900V         0010  /dev/st2  /dev/sg2
[1:0:0:0]    mediumx IET      VIRTUAL-CHANGER  0     -         /dev/sg3

Cheers
Mark Harvey
-------------- next part --------------
A non-text attachment was scrubbed...
Name: vtl-2007-4-5.diff
Type: text/x-patch
Size: 58213 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070405/d13cfb5c/attachment.bin>

From fujita.tomonori at lab.ntt.co.jp  Thu Apr  5 02:58:33 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 5 Apr 2007 09:58:33 +0900 (JST)
Subject: [Stgt-devel] Which license?
In-Reply-To: <46134914.1010208@suse.de>
References: <46134914.1010208@suse.de>
Message-ID: <20070405073714G.fujita.tomonori@lab.ntt.co.jp>

From: Hannes Reinecke <hare at suse.de>
Subject: [Stgt-devel] Which license?
Date: Wed, 04 Apr 2007 08:43:32 +0200

> our nice build system requires to state a license for each package. Only
> currently there is only a inherited reference to the GPL in log.h (which
> was copied via open-iscsi and iscsitarget).
> So I would assume that the entire project runs under the GPL.
> Is that true?

Yeah.


> Can we have an explicit pointer somewhere (eg in the README) which
> license this project runs under?

I updated the README.


Now I'm waiting for you guys to put tgt in SUSE Linux Enterprise
Server. :)


From blackmagic02881 at gmail.com  Thu Apr  5 03:22:57 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 04 Apr 2007 21:22:57 -0400
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
References: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
Message-ID: <1175736177.3622.7.camel@localhost.localdomain>

On Thu, 2007-04-05 at 09:56 +1000, Mark Harvey wrote:
> +smc_init(struct scsi_lu *lu) {
> +       struct smc_info * smc;
> +
> +       dprintf("Medium Changer init() called");
> +       smc = zalloc(sizeof(struct smc_info));
> +       if(! smc)
> +               return -ENOMEM;
> +       smc->phy = zalloc(sizeof(struct physicalAttributes));
> +       if(! smc->phy)
> +               return -ENOMEM;
> +       smc->log = zalloc(sizeof(struct smcLogPage));
> +       if(! smc->log)
> +               return -ENOMEM;
> +       lu->priv_p = smc;
> +       return 0;
> +}
> + 

potential memory leak on error path here? for example, if smc->log is
NULL, smc and smc-?phy should be freed.






From blackmagic02881 at gmail.com  Thu Apr  5 03:23:54 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 04 Apr 2007 21:23:54 -0400
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
References: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
Message-ID: <1175736234.3622.10.camel@localhost.localdomain>

On Thu, 2007-04-05 at 09:56 +1000, Mark Harvey wrote:
> +
> +static int
> +process_arg(char *key, char *value, struct scsi_lu *lu) {
> +       struct smc_info *smc = (struct smc_info *)lu->priv_p;
> +       int err = TGTADM_INVALID_REQUEST;
> +
> +       if(!strcmp(key, "VendorIdent")) {
> +               strncpy(smc->phy->VendorIdent, value,
> +                                               sizeof(smc->phy->VendorIdent));
> +               err = 0;
> +       }


can we use strcasecmp here so be case insensitive?


> +       if(!strcmp(key, "ProductIdent")) {
> +               strncpy(smc->phy->ProductIdent, value,
> +                                       sizeof(smc->phy->ProductIdent));
> +               err = 0;
> +       }
> +       if(!strcmp(key, "ProductRev")) {
> +               strncpy(smc->phy->ProductRev, value,
> +                                       sizeof(smc->phy->ProductRev));
> +               err = 0;
> +       }
> +       if(!strcmp(key, "SerialNumber")) {
> +               strncpy(smc->phy->SerialNumber, value,
> +                                       sizeof(smc->phy->SerialNumber));
> +               strncpy(lu->scsi_sn, value, SCSI_SN_LEN - 1);
> +//             strncpy(lu->scsi_sn, value,
> +//                             min((int)SCSI_SN_LEN - 1,
> (int)strlen(value)));
> +               err = 0;
> +       }
> +       dprintf("name: %s, Value: %s, return val: %d", key, value,
> err);
> +       return err;
> +} 



From blackmagic02881 at gmail.com  Thu Apr  5 03:28:18 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 04 Apr 2007 21:28:18 -0400
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
References: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
Message-ID: <1175736498.3622.12.camel@localhost.localdomain>


On Thu, 2007-04-05 at 09:56 +1000, Mark Harvey wrote:
> +       .ops    = {
> +               {spc_test_unit,},
> +               {spc_illegal_op,},
> +               {spc_illegal_op,},
> +               {spc_request_sense,},
> +               {spc_illegal_op,},
> +               {spc_illegal_op,},
> +               {spc_illegal_op,},
> +               {spc_illegal_op,},
> +
> +               {spc_illegal_op,},
> +               {spc_illegal_op,},
> +               {spc_illegal_op,}, 

instead of having tons of these spc_illegal_op, can we have them by
default to be NULL and the caller check if NULL, if NULL call
spc_illegal_op directly?





From blackmagic02881 at gmail.com  Thu Apr  5 03:30:00 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 04 Apr 2007 21:30:00 -0400
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
References: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
Message-ID: <1175736600.3622.14.camel@localhost.localdomain>

On Thu, 2007-04-05 at 09:56 +1000, Mark Harvey wrote:
> +ssc3_init(struct scsi_lu *lu) {
> +       struct  ssc_info * ssc_info;
> +
> +       dprintf("Tape device Init() called, path : %s",
> +                       lu->path);
> +       ssc_info = zalloc(sizeof(struct ssc_info));
> +       if(! ssc_info)
> +               return -ENOMEM;
> +       ssc_info->phy = zalloc(sizeof(struct physicalAttributes));
> +       if(! ssc_info->phy)
> +               return -ENOMEM;
> +       ssc_info->media = zalloc(sizeof(struct mediaInDrive));
> +       if(! ssc_info->media)
> +               return -ENOMEM;
> +       ssc_info->logPg = zalloc(sizeof(struct driveLogPage));
> +       if(! ssc_info->logPg)
> +               return -ENOMEM;
> + 

same memory leak here.




From blackmagic02881 at gmail.com  Thu Apr  5 03:30:41 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 04 Apr 2007 21:30:41 -0400
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
References: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
Message-ID: <1175736641.3622.16.camel@localhost.localdomain>

On Thu, 2007-04-05 at 09:56 +1000, Mark Harvey wrote:
> +static int
> +ssc3_config(struct scsi_lu *lu, char * str) {
> +       int     err = 0;
> +       char    key[80];
> +       char    value[80];
> +       char    * src = str;
> +       char    * dest = key;
> +
> +       while(*src != '\0') {
> +               if(*src == '=') {
> +                       *dest = '\0';   /* Null term key */
> +                       dest = value;   /* flip-flop dest pointer to
> value */
> +                       src++;
> +               } else if (*src == ' ') {
> +                       *dest = '\0';   /* Null term value */
> +                       dest = key;     /* flip-flop dest pointer to
> key */
> +                       err |= process_arg(key, value, lu);
> +                       src++;
> +               } else 
> +                       *dest++ = *src++;
> +       }
> +       return err;
> +}
> + 

looks like tgt should provide a generic parameter parsing helper
functions.



From markh794 at gmail.com  Thu Apr  5 04:36:21 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 5 Apr 2007 12:36:21 +1000
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <1175736498.3622.12.camel@localhost.localdomain>
References: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
	<1175736498.3622.12.camel@localhost.localdomain>
Message-ID: <f29db9a80704041936m3836d1ffyaef1f1f465b8e9e0@mail.gmail.com>

On 4/5/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
>
> On Thu, 2007-04-05 at 09:56 +1000, Mark Harvey wrote:
> > +       .ops    = {
> > +               {spc_test_unit,},
> > +               {spc_illegal_op,},
> > +               {spc_illegal_op,},
> > +               {spc_request_sense,},
> > +               {spc_illegal_op,},
> > +               {spc_illegal_op,},
> > +               {spc_illegal_op,},
> > +               {spc_illegal_op,},
> > +
> > +               {spc_illegal_op,},
> > +               {spc_illegal_op,},
> > +               {spc_illegal_op,},
>
> instead of having tons of these spc_illegal_op, can we have them by
> default to be NULL and the caller check if NULL, if NULL call
> spc_illegal_op directly?
>

I basically copied the sbc.c module and followed its syntax, and
called/set all un-implemented routines to spc_illegal_op for the time
being.

But I like your suggestion.

Cheers
Mark


From markh794 at gmail.com  Thu Apr  5 05:05:45 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 5 Apr 2007 13:05:45 +1000
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <f29db9a80704041936m3836d1ffyaef1f1f465b8e9e0@mail.gmail.com>
References: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
	<1175736498.3622.12.camel@localhost.localdomain>
	<f29db9a80704041936m3836d1ffyaef1f1f465b8e9e0@mail.gmail.com>
Message-ID: <f29db9a80704042005j62d50a53v58130a1f41916c55@mail.gmail.com>

Re-sending updated ssc3.c & smc.c in full.

Includes first couple of "improvements" pointed out by Ming.
 - memory leak fixed.
 - case insensitive compare.

The 3rd one (referenced below), I shall look at later on today.

Cheers
Mark Harvey


On 4/5/07, Mark Harvey <markh794 at gmail.com> wrote:
> On 4/5/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> >
> > On Thu, 2007-04-05 at 09:56 +1000, Mark Harvey wrote:
> > > +       .ops    = {
> > > +               {spc_test_unit,},
> > > +               {spc_illegal_op,},
> > > +               {spc_illegal_op,},
> > > +               {spc_request_sense,},
> > > +               {spc_illegal_op,},
> > > +               {spc_illegal_op,},
> > > +               {spc_illegal_op,},
> > > +               {spc_illegal_op,},
> > > +
> > > +               {spc_illegal_op,},
> > > +               {spc_illegal_op,},
> > > +               {spc_illegal_op,},
> >
> > instead of having tons of these spc_illegal_op, can we have them by
> > default to be NULL and the caller check if NULL, if NULL call
> > spc_illegal_op directly?
> >
>
> I basically copied the sbc.c module and followed its syntax, and
> called/set all un-implemented routines to spc_illegal_op for the time
> being.
>
> But I like your suggestion.
>
> Cheers
> Mark
>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ssc3.c
Type: text/x-csrc
Size: 10615 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070405/4fc217eb/attachment.c>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: smc.c
Type: text/x-csrc
Size: 5804 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070405/4fc217eb/attachment-0001.c>

From fujita.tomonori at lab.ntt.co.jp  Thu Apr  5 07:13:31 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 5 Apr 2007 14:13:31 +0900 (JST)
Subject: [Stgt-devel] mutual login failed
In-Reply-To: <14fabe514f80a7.14f80a714fabe5@o2.ie>
References: <14fabe514f80a7.14f80a714fabe5@o2.ie>
Message-ID: <20070405141325W.fujita.tomonori@lab.ntt.co.jp>

From: Albert Pauw <pauw at o2.ie>
Subject: [Stgt-devel] mutual login failed
Date: Fri, 30 Mar 2007 18:48:39 +0200

> I tried mutual login (in and outgoing) but it failed.

Thanks. Can you try this patch?



From fujita.tomonori at lab.ntt.co.jp  Thu Apr  5 07:11:48 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 5 Apr 2007 14:11:48 +0900
Subject: [PATCH] Fix outgoing authentication bugs
Message-ID: <mailman.4.1331738468.12506.stgt-devel@lists.berlios.de>

In the case of outgoing authentication, account_lookup() copies a user name.

Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
---
 usr/iscsi/chap.c |    6 ++++--
 usr/target.c     |    6 ++++--
 usr/tgtd.h       |    2 +-
 3 files changed, 9 insertions(+), 5 deletions(-)

diff --git a/usr/iscsi/chap.c b/usr/iscsi/chap.c
index c92275d..fc6fd8f 100644
--- a/usr/iscsi/chap.c
+++ b/usr/iscsi/chap.c
@@ -405,7 +405,8 @@ static int chap_initiator_auth_check_response(struct iscsi_connection *conn)
 	}
 
 	memset(pass, 0, sizeof(pass));
-	err = account_lookup(conn->tid, AUTH_DIR_INCOMING, value, pass, ISCSI_NAME_LEN);
+	err = account_lookup(conn->tid, AUTH_DIR_INCOMING, value, 0, pass,
+			     ISCSI_NAME_LEN);
 	if (err) {
 		eprintf("No valid user/pass combination for initiator %s "
 			    "found\n", conn->initiator);
@@ -502,7 +503,8 @@ static int chap_target_auth_create_response(struct iscsi_connection *conn)
 
 	memset(pass, 0, sizeof(pass));
 	memset(name, 0, sizeof(name));
-	err = account_lookup(conn->tid, AUTH_DIR_OUTGOING, name, pass, ISCSI_NAME_LEN);
+	err = account_lookup(conn->tid, AUTH_DIR_OUTGOING, name, sizeof(name),
+			     pass, sizeof(pass));
 	if (err) {
 		log_warning("CHAP target auth.: "
 			    "no outgoing credentials configured%s",
diff --git a/usr/target.c b/usr/target.c
index 8c1adf6..0178291 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -698,7 +698,7 @@ static struct account_entry *__account_lookup_user(char *user)
 	return NULL;
 }
 
-int account_lookup(int tid, int type, char *user, char *password, int plen)
+int account_lookup(int tid, int type, char *user, int ulen, char *password, int plen)
 {
 	int i;
 	struct target *target;
@@ -718,8 +718,10 @@ int account_lookup(int tid, int type, char *user, char *password, int plen)
 		}
 	} else {
 		ac = __account_lookup_id(target->account.out_aid);
-		if (ac)
+		if (ac) {
+			strncpy(user, ac->user, ulen);
 			goto found;
+		}
 	}
 
 	return -ENOENT;
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 7eecc0a..546c078 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -158,7 +158,7 @@ extern int acl_add(int tid, char *address);
 extern void acl_del(int tid, char *address);
 extern char *acl_get(int tid, int idx);
 
-extern int account_lookup(int tid, int type, char *user, char *password, int plen);
+extern int account_lookup(int tid, int type, char *user, int ulen, char *password, int plen);
 extern int account_add(char *user, char *password);
 extern void account_del(char *user);
 extern int account_ctl(int tid, int type, char *user, int bind);
-- 
1.4.4.3







From fujita.tomonori at lab.ntt.co.jp  Thu Apr  5 07:20:22 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 5 Apr 2007 14:20:22 +0900 (JST)
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <f29db9a80704042005j62d50a53v58130a1f41916c55@mail.gmail.com>
References: <1175736498.3622.12.camel@localhost.localdomain>
	<f29db9a80704041936m3836d1ffyaef1f1f465b8e9e0@mail.gmail.com>
	<f29db9a80704042005j62d50a53v58130a1f41916c55@mail.gmail.com>
Message-ID: <20070405142013H.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] vtl patch.
Date: Thu, 5 Apr 2007 13:05:45 +1000

> Re-sending updated ssc3.c & smc.c in full.

Thanks. I'll review and merge the patch soon.


> Includes first couple of "improvements" pointed out by Ming.
>  - memory leak fixed.
>  - case insensitive compare.
> 
> The 3rd one (referenced below), I shall look at later on today.

I like the current approach.


> Cheers
> Mark Harvey
> 
> 
> On 4/5/07, Mark Harvey <markh794 at gmail.com> wrote:
> > On 4/5/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > >
> > > On Thu, 2007-04-05 at 09:56 +1000, Mark Harvey wrote:
> > > > +       .ops    = {
> > > > +               {spc_test_unit,},
> > > > +               {spc_illegal_op,},
> > > > +               {spc_illegal_op,},
> > > > +               {spc_request_sense,},
> > > > +               {spc_illegal_op,},
> > > > +               {spc_illegal_op,},
> > > > +               {spc_illegal_op,},
> > > > +               {spc_illegal_op,},
> > > > +
> > > > +               {spc_illegal_op,},
> > > > +               {spc_illegal_op,},
> > > > +               {spc_illegal_op,},
> > >
> > > instead of having tons of these spc_illegal_op, can we have them by
> > > default to be NULL and the caller check if NULL, if NULL call
> > > spc_illegal_op directly?
> > >
> >
> > I basically copied the sbc.c module and followed its syntax, and
> > called/set all un-implemented routines to spc_illegal_op for the time
> > being.
> >
> > But I like your suggestion.
> >
> > Cheers
> > Mark
> >


From markh794 at gmail.com  Thu Apr  5 08:07:30 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 5 Apr 2007 16:07:30 +1000
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <20070405142013H.fujita.tomonori@lab.ntt.co.jp>
References: <1175736498.3622.12.camel@localhost.localdomain>
	<f29db9a80704041936m3836d1ffyaef1f1f465b8e9e0@mail.gmail.com>
	<f29db9a80704042005j62d50a53v58130a1f41916c55@mail.gmail.com>
	<20070405142013H.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80704042307o3e284516p1263b59dbf869887@mail.gmail.com>

On 4/5/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: Re: [Stgt-devel] vtl patch.
> Date: Thu, 5 Apr 2007 13:05:45 +1000
>
> > Re-sending updated ssc3.c & smc.c in full.
>
> Thanks. I'll review and merge the patch soon.
>
>
> > Includes first couple of "improvements" pointed out by Ming.
> >  - memory leak fixed.
> >  - case insensitive compare.
> >
> > The 3rd one (referenced below), I shall look at later on today.
>
> I like the current approach.


That simplifies things.

I'll move on with implementing some of the mandatory SCSI commands for
both the SSC and SMC targets in that case. And fix/re-do any code
already submitted for comment.

Cheers
Mark
>


From hare at suse.de  Thu Apr  5 08:21:48 2007
From: hare at suse.de (Hannes Reinecke)
Date: Thu, 05 Apr 2007 08:21:48 +0200
Subject: [Stgt-devel] Which license?
In-Reply-To: <20070405073714G.fujita.tomonori@lab.ntt.co.jp>
References: <46134914.1010208@suse.de>
	<20070405073714G.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <4614957C.6000408@suse.de>

FUJITA Tomonori wrote:
> From: Hannes Reinecke <hare at suse.de>
> Subject: [Stgt-devel] Which license?
> Date: Wed, 04 Apr 2007 08:43:32 +0200
> 
>> our nice build system requires to state a license for each package. Only
>> currently there is only a inherited reference to the GPL in log.h (which
>> was copied via open-iscsi and iscsitarget).
>> So I would assume that the entire project runs under the GPL.
>> Is that true?
> 
> Yeah.
> 
Ok, so I was correct.

>> Can we have an explicit pointer somewhere (eg in the README) which
>> license this project runs under?
> 
> I updated the README.
> 
Thanks.

> 
> Now I'm waiting for you guys to put tgt in SUSE Linux Enterprise
> Server. :)

tgt will be in openSUSE 10.3 and all follow-on releases.
We will be dropping iscsitarget in favour of tgt.

Now I only need to port all features of iscsitarget to tgt :-(

Cheers,

Hannes
-- 
Dr. Hannes Reinecke		      zSeries & Storage
hare at suse.de			      +49 911 74053 688
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
GF: Markus Rex, HRB 16746 (AG N?rnberg)


From fujita.tomonori at lab.ntt.co.jp  Thu Apr  5 09:32:06 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 5 Apr 2007 16:32:06 +0900 (JST)
Subject: [Stgt-devel] ibmvio - rdma error
In-Reply-To: <20070404191432.GA32505@wavehammer.waldi.eu.org>
References: <20070404182753.GA25247@wavehammer.waldi.eu.org>
	<20070404191432.GA32505@wavehammer.waldi.eu.org>
Message-ID: <20070405163154S.fujita.tomonori@lab.ntt.co.jp>

From: Bastian Blank <waldi at berlios.de>
Subject: Re: [Stgt-devel] ibmvio - rdma error
Date: Wed, 4 Apr 2007 21:14:32 +0200

> On Wed, Apr 04, 2007 at 08:27:53PM +0200, Bastian Blank wrote:
> > | ibmvstgt_rdma(251) rdma error 1 135168
> > | ibmvstgt_rdma(251) rdma error 1 135168
> > | ibmvstgt_rdma(251) rdma error 1 139264
> > | ibmvstgt_rdma(251) rdma error 1 135168
> 
> This errors are ignored, so it is likely to use garbage.

Yeah. I'll fix ibmvstgt and libsrp to return an error properly.

I've never seen this error before. I won't be close to my Pseries for
some days. I'll try to reproduce this error next week.


From waldi at berlios.de  Thu Apr  5 10:24:05 2007
From: waldi at berlios.de (Bastian Blank)
Date: Thu, 5 Apr 2007 10:24:05 +0200
Subject: [Stgt-devel] ibmvio - rdma error
In-Reply-To: <20070405163154S.fujita.tomonori@lab.ntt.co.jp>
References: <20070404182753.GA25247@wavehammer.waldi.eu.org>
	<20070404191432.GA32505@wavehammer.waldi.eu.org>
	<20070405163154S.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070405082405.GA26384@wavehammer.waldi.eu.org>

On Thu, Apr 05, 2007 at 04:32:06PM +0900, FUJITA Tomonori wrote:
> Yeah. I'll fix ibmvstgt and libsrp to return an error properly.

I have a patch already, attached. It fixes this error path.

> I've never seen this error before. I won't be close to my Pseries for
> some days. I'll try to reproduce this error next week.

The original ibmvscsis used maximum size of 128k (256 sectors) for the
rdma transfers. ibmvstgt uses 512 by default. If I reduce the maximum
size to 256, it seems to work.

Bastian

-- 
Power is danger.
		-- The Centurion, "Balance of Terror", stardate 1709.2
-------------- next part --------------
diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
index a7fbd10..bb0f299 100644
--- a/drivers/scsi/ibmvscsi/ibmvstgt.c
+++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
@@ -35,7 +35,7 @@
 #include "ibmvscsi.h"
 
 #define	INITIAL_SRP_LIMIT	16
-#define	DEFAULT_MAX_SECTORS	512
+#define	DEFAULT_MAX_SECTORS	256
 
 #define	TGT_NAME	"ibmvstgt"
 
@@ -248,8 +248,8 @@ static int ibmvstgt_rdma(struct scsi_cmnd *sc, struct scatterlist *sg, int nsg,
 						  md[i].va + mdone);
 
 			if (err != H_SUCCESS) {
-				eprintk("rdma error %d %d\n", dir, slen);
-				goto out;
+				eprintk("rdma error %d %d %ld\n", dir, slen, err);
+				return -EIO;
 			}
 
 			mlen -= slen;
@@ -265,14 +265,13 @@ static int ibmvstgt_rdma(struct scsi_cmnd *sc, struct scatterlist *sg, int nsg,
 				if (sidx > nsg) {
 					eprintk("out of sg %p %d %d\n",
 						iue, sidx, nsg);
-					goto out;
+					return -EIO;
 				}
 			}
 		};
 
 		rest -= mlen;
 	}
-out:
 	return 0;
 }
 
@@ -282,18 +281,19 @@ static int ibmvstgt_cmd_done(struct scsi_cmnd *sc,
 	unsigned long flags;
 	struct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;
 	struct srp_target *target = iue->target;
+	int err = 0;
 
 	dprintk("%p %p %x %u\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0],
 		cmd->usg_sg);
 
 	if (sc->use_sg)
-		srp_transfer_data(sc, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma, 1, 1);
+		err = srp_transfer_data(sc, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma, 1, 1);
 
 	spin_lock_irqsave(&target->lock, flags);
 	list_del(&iue->ilist);
 	spin_unlock_irqrestore(&target->lock, flags);
 
-	if (sc->result != SAM_STAT_GOOD) {
+	if (err < 0 || sc->result != SAM_STAT_GOOD) {
 		eprintk("operation failed %p %d %x\n",
 			iue, sc->result, vio_iu(iue)->srp.cmd.cdb[0]);
 		send_rsp(iue, sc, HARDWARE_ERROR, 0x00);
@@ -493,7 +493,8 @@ static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
 {
 	struct vio_port *vport = target_to_port(target);
 	struct iu_entry *iue;
-	long err, done;
+	long err;
+	int done = 0;
 
 	iue = srp_iu_get(target);
 	if (!iue) {
diff --git a/drivers/scsi/libsrp.c b/drivers/scsi/libsrp.c
index 89403b0..d1d7aaa 100644
--- a/drivers/scsi/libsrp.c
+++ b/drivers/scsi/libsrp.c
@@ -225,8 +225,7 @@ static int srp_indirect_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
 	struct srp_direct_buf *md = NULL;
 	struct scatterlist dummy, *sg = NULL;
 	dma_addr_t token = 0;
-	long err;
-	unsigned int done = 0;
+	int err = 0;
 	int nmd, nsg = 0, len;
 
 	if (dma_map || ext_desc) {
@@ -259,7 +258,7 @@ static int srp_indirect_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
 		err = rdma_io(sc, &dummy, 1, &id->table_desc, 1, DMA_TO_DEVICE,
 			      id->table_desc.len);
 		if (err < 0) {
-			eprintk("Error copying indirect table %ld\n", err);
+			eprintk("Error copying indirect table %d\n", err);
 			goto free_mem;
 		}
 	} else {
@@ -272,6 +271,7 @@ rdma:
 		nsg = dma_map_sg(iue->target->dev, sg, sc->use_sg, DMA_BIDIRECTIONAL);
 		if (!nsg) {
 			eprintk("fail to map %p %d\n", iue, sc->use_sg);
+			err = -EIO;
 			goto free_mem;
 		}
 		len = min(sc->request_bufflen, id->len);
@@ -287,7 +287,7 @@ free_mem:
 	if (token && dma_map)
 		dma_free_coherent(iue->target->dev, id->table_desc.len, md, token);
 
-	return done;
+	return err;
 }
 
 static int data_out_desc_size(struct srp_cmd *cmd)
@@ -352,7 +352,7 @@ int srp_transfer_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
 		break;
 	default:
 		eprintk("Unknown format %d %x\n", dir, format);
-		break;
+		err = -EIO;
 	}
 
 	return err;
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070405/dacca36f/attachment.pgp>

From waldi at berlios.de  Thu Apr  5 10:28:56 2007
From: waldi at berlios.de (Bastian Blank)
Date: Thu, 5 Apr 2007 10:28:56 +0200
Subject: [Stgt-devel] ibmvio - rdma error
In-Reply-To: <20070405082405.GA26384@wavehammer.waldi.eu.org>
References: <20070404182753.GA25247@wavehammer.waldi.eu.org>
	<20070404191432.GA32505@wavehammer.waldi.eu.org>
	<20070405163154S.fujita.tomonori@lab.ntt.co.jp>
	<20070405082405.GA26384@wavehammer.waldi.eu.org>
Message-ID: <20070405082856.GA26906@wavehammer.waldi.eu.org>

On Thu, Apr 05, 2007 at 10:24:05AM +0200, Bastian Blank wrote:
> The original ibmvscsis used maximum size of 128k (256 sectors) for the
> rdma transfers. ibmvstgt uses 512 by default. If I reduce the maximum
> size to 256, it seems to work.

I found an ibmvscsis version which uses 512 for the size but splits them
into 128k rdma transfers. I don't know if this works as this version
killed filesystems.

Bastian
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070405/233e9b49/attachment.pgp>

From fujita.tomonori at lab.ntt.co.jp  Thu Apr  5 10:39:06 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 5 Apr 2007 17:39:06 +0900 (JST)
Subject: [Stgt-devel] ibmvio - rdma error
In-Reply-To: <20070405082856.GA26906@wavehammer.waldi.eu.org>
References: <20070405163154S.fujita.tomonori@lab.ntt.co.jp>
	<20070405082405.GA26384@wavehammer.waldi.eu.org>
	<20070405082856.GA26906@wavehammer.waldi.eu.org>
Message-ID: <20070405173931I.fujita.tomonori@lab.ntt.co.jp>

From: Bastian Blank <waldi at berlios.de>
Subject: Re: [Stgt-devel] ibmvio - rdma error
Date: Thu, 5 Apr 2007 10:28:56 +0200

> On Thu, Apr 05, 2007 at 10:24:05AM +0200, Bastian Blank wrote:
> > The original ibmvscsis used maximum size of 128k (256 sectors) for the
> > rdma transfers. ibmvstgt uses 512 by default. If I reduce the maximum
> > size to 256, it seems to work.
> 
> I found an ibmvscsis version which uses 512 for the size but splits them
> into 128k rdma transfers. I don't know if this works as this version
> killed filesystems.

I thought ibmvscsis does it because it doesn't want to call
dma_alloc_coherent for too large data, however, there might be some
limit on RMDA transfer length.

Can you try the following patch to see what error we get?


diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
index a7fbd10..a725b8b 100644
--- a/drivers/scsi/ibmvscsi/ibmvstgt.c
+++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
@@ -248,7 +248,7 @@ static int ibmvstgt_rdma(struct scsi_cmnd *sc, struct scatterlist *sg, int nsg,
 						  md[i].va + mdone);
 
 			if (err != H_SUCCESS) {
-				eprintk("rdma error %d %d\n", dir, slen);
+				eprintk("rdma error %d %d %d\n", dir, slen, err);
 				goto out;
 			}
 




From waldi at berlios.de  Thu Apr  5 10:44:36 2007
From: waldi at berlios.de (Bastian Blank)
Date: Thu, 5 Apr 2007 10:44:36 +0200
Subject: [Stgt-devel] ibmvio - rdma error
In-Reply-To: <20070405173931I.fujita.tomonori@lab.ntt.co.jp>
References: <20070405163154S.fujita.tomonori@lab.ntt.co.jp>
	<20070405082405.GA26384@wavehammer.waldi.eu.org>
	<20070405082856.GA26906@wavehammer.waldi.eu.org>
	<20070405173931I.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070405084436.GA28380@wavehammer.waldi.eu.org>

On Thu, Apr 05, 2007 at 05:39:06PM +0900, FUJITA Tomonori wrote:
> Can you try the following patch to see what error we get?

I already did this. It is -4 (H_PARAMETER, Parameter invalid,
out-of-range or conflicting).

Bastian

-- 
I object to intellect without discipline;  I object to power without
constructive purpose.
		-- Spock, "The Squire of Gothos", stardate 2124.5
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070405/f79aba8e/attachment.pgp>

From pauw at o2.ie  Thu Apr  5 15:08:05 2007
From: pauw at o2.ie (Albert Pauw)
Date: Thu, 05 Apr 2007 15:08:05 +0200
Subject: [Stgt-devel] [patch] support different type in one target.
Message-ID: <13afbbe13ad404.13ad40413afbbe@o2.ie>

Regarding this patch (send in in March bu Hu Gang), I think this would be handy to
have with the vtl stuff. Then you will have one LUN for the changer, and one or more
LUNs for the drives. You only have to login once to get the vtl connected.

Note my previous remark regarding the "type" setting, which is now per target,
it should be set per LUN. That isn't changed by the patch.



From hare at suse.de  Thu Apr  5 15:11:17 2007
From: hare at suse.de (Hannes Reinecke)
Date: Thu, 05 Apr 2007 15:11:17 +0200
Subject: [Stgt-devel] [patch] support different type in one target.
In-Reply-To: <13afbbe13ad404.13ad40413afbbe@o2.ie>
References: <13afbbe13ad404.13ad40413afbbe@o2.ie>
Message-ID: <4614F575.7060005@suse.de>

Albert Pauw wrote:
> Regarding this patch (send in in March bu Hu Gang), I think this would be handy to
> have with the vtl stuff. Then you will have one LUN for the changer, and one or more
> LUNs for the drives. You only have to login once to get the vtl connected.
> 
> Note my previous remark regarding the "type" setting, which is now per target,
> it should be set per LUN. That isn't changed by the patch.
> 
Seconded. The 'type' is a per-LUN setting and should be implemented as such.

Cheers,

Hannes
-- 
Dr. Hannes Reinecke		      zSeries & Storage
hare at suse.de			      +49 911 74053 688
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
GF: Markus Rex, HRB 16746 (AG N?rnberg)


From waldi at berlios.de  Thu Apr  5 17:34:45 2007
From: waldi at berlios.de (Bastian Blank)
Date: Thu, 5 Apr 2007 17:34:45 +0200
Subject: [Stgt-devel] ibmvio - broken after tgtd restart
Message-ID: <20070405153445.GA25132@wavehammer.waldi.eu.org>

Hi folks

Active ibmvio targets are broken after I restart tgtd.

The client reports:
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc00000000227bbb8
| ibmvscsi: abort code 2 for task tag 0xc00000000227bbb8
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc00000000227bd40
| ibmvscsi: abort code 2 for task tag 0xc00000000227bd40
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc00000000227bec8
| ibmvscsi: abort code 2 for task tag 0xc00000000227bec8
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc00000000227c050
| ibmvscsi: abort code 2 for task tag 0xc00000000227c050
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc00000000227c1d8
| ibmvscsi: abort code 2 for task tag 0xc00000000227c1d8
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc00000000227c360
| ibmvscsi: abort code 2 for task tag 0xc00000000227c360
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc00000000227c4e8
| ibmvscsi: abort code 2 for task tag 0xc00000000227c4e8
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc00000000227c670
| ibmvscsi: abort code 2 for task tag 0xc00000000227c670
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc00000000227c7f8
| ibmvscsi: abort code 2 for task tag 0xc00000000227c7f8
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc00000000227c980
| ibmvscsi: abort code 2 for task tag 0xc00000000227c980
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc00000000227cb08
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc000000002278000
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc000000002278188
| ibmvscsi: aborting command. lun 0x8100000000000000, tag 0xc000000002278310
| ibmvscsi: resetting device. lun 0x8100000000000000

The server reports:
| ibmvstgt_tsk_mgmt_response(732) c000000020ffad50 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffacf0 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffad50 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffacf0 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffad50 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffacf0 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffad50 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffacf0 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffad50 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffacf0 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffad50 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffacf0 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffad50 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffacf0 -17
| ibmvstgt_tsk_mgmt_response(732) c000000020ffad50 0
| process_iu(502) Error getting IU from pool, c00000000bf41550
| process_iu(502) Error getting IU from pool, c00000000bf41550
| process_iu(502) Error getting IU from pool, c00000000bf41550
| process_iu(502) Error getting IU from pool, c00000000bf41550
| process_iu(502) Error getting IU from pool, c00000000bf41550
| process_iu(502) Error getting IU from pool, c00000000bf41550
| process_iu(502) Error getting IU from pool, c00000000bf41550
| process_iu(502) Error getting IU from pool, c00000000bf41550
| process_iu(502) Error getting IU from pool, c00000000bf41550
| process_iu(502) Error getting IU from pool, c00000000bf41550
| process_iu(502) Error getting IU from pool, c00000000bf41550
| process_iu(502) Error getting IU from pool, c00000000bf41550

After an unload-load cycle of ibmvstgt it seems to works again and the client
reports correctly:
| ibmvscsi: partner initialized
| ibmvscsic: sent SRP login
| ibmvscsi: SRP_LOGIN succeeded
| ibmvscsi: host srp version: 16.a, host partition XXX (YY), OS 2, max io 131072

But at least sometimes the client seems to hang.

Bastian

-- 
You!  What PLANET is this!
		-- McCoy, "The City on the Edge of Forever", stardate 3134.0
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070405/bc8b4621/attachment.pgp>

From pauw at o2.ie  Thu Apr  5 19:36:02 2007
From: pauw at o2.ie (Albert Pauw)
Date: Thu, 05 Apr 2007 19:36:02 +0200
Subject: [Stgt-devel] mutual login failed
Message-ID: <13caaae13c9a58.13c9a5813caaae@o2.ie>

> From: Albert Pauw <pauw at o2.ie>
> Subject: [Stgt-devel] mutual login failed
> Date: Fri, 30 Mar 2007 18:48:39 +0200

> > I tried mutual login (in and outgoing) but it failed.

> Thanks. Can you try this patch?

Hi Tomo,

tried your patch and it works, thanks!

Albert



From pauw at o2.ie  Thu Apr  5 20:14:03 2007
From: pauw at o2.ie (Albert Pauw)
Date: Thu, 05 Apr 2007 20:14:03 +0200
Subject: [Stgt-devel] [PATCH] some shortcut options missing from tgtadm
Message-ID: <13ce28813ca956.13ca95613ce288@o2.ie>

> A few short options were missing in tgtadm.c, 
> this simple patch just adds these.

Small correction, there should not be a ":" behind capital "O" in the options.

Albert

--- usr/tgtadm.c        2007-04-01 10:03:22.000000000 +0200
+++ usr/tgtadm.c.new    2007-04-01 10:03:02.000000000 +0200
@@ -110,7 +110,7 @@
        {NULL, 0, NULL, 0},
 };
 
-static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:";
+static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:B:Y:O";
 
 static void usage(int status)
 {



From pauw at o2.ie  Thu Apr  5 21:32:51 2007
From: pauw at o2.ie (Albert Pauw)
Date: Thu, 05 Apr 2007 21:32:51 +0200
Subject: [Stgt-devel] Thoughts on vtl setup
Message-ID: <13ce23213cf662.13cf66213ce232@o2.ie>

Here are a few thoughts I wanted to share regarding the virtual tape library, just shoot at it if you think otherwise. Hope you don't find this too nosy Mark (Harvey) as you started the idea.

General - Best would be to have the changer and the tapedrives on one target, the changer can be LUN 0, the drive(s) LUN 1 and onwards.

Configuration - Would be best to keep this simple. The changer can be a standard one, implementing all necessary functions. For the drives you define the type once, and how many drives you want. If you use symbolic names (as to numeric) for the drive types, then this can be easily expanded. E.g. LTO3, DDS4, etc. for the drive type. If you need three different type of drives, then you just add one of each type. Since these types are predefined you don't have to set other parameters for these drives (like size etc). Lastly you define the directory where the tapeslots are.

Tapes - Well, virtual tapes. I guess the filename can be the barcode, the extension the tape type, e.g. A00001.LTO2. However, when these files are accidentally renamed you loose the barcode and type. So every tape should have a header containing the barcode, and tape type. The barcode and tapetype should be in clear text (e.g. 4 characters LTO2). Another addition could be a two-byte field, containing bitfields, like this:

0000 0000 0000 RCCC

were
CCC -> compression 0-7, where 0 is no compression, 1 is LZ, etc. for different types of compression, if implemented. We can start without compression.

R -> Readonly bit, even if the file was readonly and set to readwrite, it would protect the data. Don't know if this setting can be done in the SCSI set.

Tape handling - Before starting stgt vtl and point it to the tapeslot directory you create tape slot subdirectories like this, where you define at startup the directory /var/tape as the slot directory:

/var/tape/slot-01
...
/var/tape/slot-24

In the /var/tape directory there would be symbolic links like this

/var/tape/drive-1 -> /var/slot-01/A00001.LTO3

if a tape is loaded into drive-1, when a drive is empty (startup setting) it does not have a symbolic link.

Note that by creating these directories by hand you can define how many slots you have, but also leave existing "tapes" in the slots between restarts of the vtl stgt service. And stopping the service should delete the symbolic drive links, so the drives "eject" the virtual tape and start up "empty" next time.

Well, just a thought.

Albert



From blackmagic02881 at gmail.com  Thu Apr  5 21:45:30 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 05 Apr 2007 15:45:30 -0400
Subject: [Stgt-devel] Thoughts on vtl setup
In-Reply-To: <13ce23213cf662.13cf66213ce232@o2.ie>
References: <13ce23213cf662.13cf66213ce232@o2.ie>
Message-ID: <1175802330.3622.89.camel@localhost.localdomain>

On Thu, 2007-04-05 at 21:32 +0200, Albert Pauw wrote:
> Here are a few thoughts I wanted to share regarding the virtual tape
> library, just shoot at it if you think otherwise. Hope you don't find
> this too nosy Mark (Harvey) as you started the idea.
> 
> General - Best would be to have the changer and the tapedrives on one
> target, the changer can be LUN 0, the drive(s) LUN 1 and onwards.

in real world, tape and changer most time does not use 1 target. though
some of them are. so ideally is to have both.

of course, for simplicity purpose, i agree with u. but since it is
emulation, it should looks like real stuff.

> 
> Configuration - Would be best to keep this simple. The changer can be
> a standard one, implementing all necessary functions. For the drives
> you define the type once, and how many drives you want. If you use
> symbolic names (as to numeric) for the drive types, then this can be
> easily expanded. E.g. LTO3, DDS4, etc. for the drive type. If you need
> three different type of drives, then you just add one of each type.
> Since these types are predefined you don't have to set other
> parameters for these drives (like size etc). Lastly you define the
> directory where the tapeslots are.

problem is different real changer will not always perform the same and
some have features others do not have. so no one emulation fit all
solution.

ideal way is the code implement as many feature sets as possible. and
specific model can enable/disable or override the generic
implementation.


> 
> Tapes - Well, virtual tapes. I guess the filename can be the barcode,
> the extension the tape type, e.g. A00001.LTO2. However, when these
> files are accidentally renamed you loose the barcode and type. So
> every tape should have a header containing the barcode, and tape type.
> The barcode and tapetype should be in clear text (e.g. 4 characters
> LTO2). Another addition could be a two-byte field, containing
> bitfields, like this:
> 
> 0000 0000 0000 RCCC

yes. need a header or extra meta file to describe the tapes.

> 
> were
> CCC -> compression 0-7, where 0 is no compression, 1 is LZ, etc. for
> different types of compression, if implemented. We can start without
> compression.

> 
> R -> Readonly bit, even if the file was readonly and set to readwrite,
> it would protect the data. Don't know if this setting can be done in
> the SCSI set.

virtual tape drive can read this and disable write. 

> 
> Tape handling - Before starting stgt vtl and point it to the tapeslot
> directory you create tape slot subdirectories like this, where you
> define at startup the directory /var/tape as the slot directory:
> 
> /var/tape/slot-01
> ...
> /var/tape/slot-24
> 
> In the /var/tape directory there would be symbolic links like this
> 
> /var/tape/drive-1 -> /var/slot-01/A00001.LTO3
> 
> if a tape is loaded into drive-1, when a drive is empty (startup
> setting) it does not have a symbolic link.
> 
> Note that by creating these directories by hand you can define how
> many slots you have, but also leave existing "tapes" in the slots
> between restarts of the vtl stgt service. And stopping the service
> should delete the symbolic drive links, so the drives "eject" the
> virtual tape and start up "empty" next time.

this sounds interesting. but what is the action to "insert" a tape to
drive? then program has to capture the symlink event.


> 
> Well, just a thought.
> 
> Albert
> 
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From pauw at o2.ie  Thu Apr  5 21:53:50 2007
From: pauw at o2.ie (Albert Pauw)
Date: Thu, 05 Apr 2007 21:53:50 +0200
Subject: [Stgt-devel] Thoughts on vtl setup
Message-ID: <13d268113d08f7.13d08f713d2681@o2.ie>

Hi Ming,

Ming Zhang wrote:
> On Thu, 2007-04-05 at 21:32 +0200, Albert Pauw wrote:
>> Here are a few thoughts I wanted to share regarding the virtual tape
>> library, just shoot at it if you think otherwise. Hope you don't find
>> this too nosy Mark (Harvey) as you started the idea.
>>
>> General - Best would be to have the changer and the tapedrives on one
>> target, the changer can be LUN 0, the drive(s) LUN 1 and onwards.
>
> in real world, tape and changer most time does not use 1 target. though
> some of them are. so ideally is to have both.
>
> of course, for simplicity purpose, i agree with u. but since it is
> emulation, it should looks like real stuff.
>
Maybe have  it standard set to one target, unless you define otherwise?
>> Configuration - Would be best to keep this simple. The changer can be
>> a standard one, implementing all necessary functions. For the drives
>> you define the type once, and how many drives you want. If you use
>> symbolic names (as to numeric) for the drive types, then this can be
>> easily expanded. E.g. LTO3, DDS4, etc. for the drive type. If you need
>> three different type of drives, then you just add one of each type.
>> Since these types are predefined you don't have to set other
>> parameters for these drives (like size etc). Lastly you define the
>> directory where the tapeslots are.
>
> problem is different real changer will not always perform the same and
> some have features others do not have. so no one emulation fit all
> solution.
>
> ideal way is the code implement as many feature sets as possible. and
> specific model can enable/disable or override the generic
> implementation.
>
Sounds the way to go!
>
>> Tapes - Well, virtual tapes. I guess the filename can be the barcode,
>> the extension the tape type, e.g. A00001.LTO2. However, when these
>> files are accidentally renamed you loose the barcode and type. So
>> every tape should have a header containing the barcode, and tape type.
>> The barcode and tapetype should be in clear text (e.g. 4 characters
>> LTO2). Another addition could be a two-byte field, containing
>> bitfields, like this:
>>
>> 0000 0000 0000 RCCC
>
> yes. need a header or extra meta file to describe the tapes.
A header is probably better, you can not loose it from the tape.
>
>> were
>> CCC -> compression 0-7, where 0 is no compression, 1 is LZ, etc. for
>> different types of compression, if implemented. We can start without
>> compression.
>
>> R -> Readonly bit, even if the file was readonly and set to readwrite,
>> it would protect the data. Don't know if this setting can be done in
>> the SCSI set.
>
> virtual tape drive can read this and disable write. 
That was the idea.
>
>> Tape handling - Before starting stgt vtl and point it to the tapeslot
>> directory you create tape slot subdirectories like this, where you
>> define at startup the directory /var/tape as the slot directory:
>>
>> /var/tape/slot-01
>> ...
>> /var/tape/slot-24
>>
>> In the /var/tape directory there would be symbolic links like this
>>
>> /var/tape/drive-1 -> /var/slot-01/A00001.LTO3
>>
>> if a tape is loaded into drive-1, when a drive is empty (startup
>> setting) it does not have a symbolic link.
>>
>> Note that by creating these directories by hand you can define how
>> many slots you have, but also leave existing "tapes" in the slots
>> between restarts of the vtl stgt service. And stopping the service
>> should delete the symbolic drive links, so the drives "eject" the
>> virtual tape and start up "empty" next time.
>
> this sounds interesting. but what is the action to "insert" a tape to
> drive? then program has to capture the symlink event.
>
Maybe define something like a mailslot? You can just move it to the proper slot, or have
it put in a free slot, just like a real StorageTek L700. A sort of CAB directory where you can put in
one or more tapes. When you "close" the CAB, it starts scanning the tapes.




From blackmagic02881 at gmail.com  Thu Apr  5 21:59:42 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 05 Apr 2007 15:59:42 -0400
Subject: [Stgt-devel] Thoughts on vtl setup
In-Reply-To: <13d268113d08f7.13d08f713d2681@o2.ie>
References: <13d268113d08f7.13d08f713d2681@o2.ie>
Message-ID: <1175803182.3622.93.camel@localhost.localdomain>

On Thu, 2007-04-05 at 21:53 +0200, Albert Pauw wrote:
> Hi Ming,
> 
> Ming Zhang wrote:
> > On Thu, 2007-04-05 at 21:32 +0200, Albert Pauw wrote:
> >> Here are a few thoughts I wanted to share regarding the virtual tape
> >> library, just shoot at it if you think otherwise. Hope you don't find
> >> this too nosy Mark (Harvey) as you started the idea.
> >>
> >> General - Best would be to have the changer and the tapedrives on one
> >> target, the changer can be LUN 0, the drive(s) LUN 1 and onwards.
> >
> > in real world, tape and changer most time does not use 1 target. though
> > some of them are. so ideally is to have both.
> >
> > of course, for simplicity purpose, i agree with u. but since it is
> > emulation, it should looks like real stuff.
> >
> Maybe have  it standard set to one target, unless you define otherwise?

suggestion, pls add one blank line before and after u reply so people
can find it easier. thanks.

not sure. Mark is the workhorse so he decide. ;)

> >> Configuration - Would be best to keep this simple. The changer can be
> >> a standard one, implementing all necessary functions. For the drives
> >> you define the type once, and how many drives you want. If you use
> >> symbolic names (as to numeric) for the drive types, then this can be
> >> easily expanded. E.g. LTO3, DDS4, etc. for the drive type. If you need
> >> three different type of drives, then you just add one of each type.
> >> Since these types are predefined you don't have to set other
> >> parameters for these drives (like size etc). Lastly you define the
> >> directory where the tapeslots are.
> >
> > problem is different real changer will not always perform the same and
> > some have features others do not have. so no one emulation fit all
> > solution.
> >
> > ideal way is the code implement as many feature sets as possible. and
> > specific model can enable/disable or override the generic
> > implementation.
> >
> Sounds the way to go!
> >
> >> Tapes - Well, virtual tapes. I guess the filename can be the barcode,
> >> the extension the tape type, e.g. A00001.LTO2. However, when these
> >> files are accidentally renamed you loose the barcode and type. So
> >> every tape should have a header containing the barcode, and tape type.
> >> The barcode and tapetype should be in clear text (e.g. 4 characters
> >> LTO2). Another addition could be a two-byte field, containing
> >> bitfields, like this:
> >>
> >> 0000 0000 0000 RCCC
> >
> > yes. need a header or extra meta file to describe the tapes.
> A header is probably better, you can not loose it from the tape.

fine. like preserve N KB for this purpose.

header version
header length
...

file data
...

so allow us to expand the header later if need.

> >
> >> were
> >> CCC -> compression 0-7, where 0 is no compression, 1 is LZ, etc. for
> >> different types of compression, if implemented. We can start without
> >> compression.
> >
> >> R -> Readonly bit, even if the file was readonly and set to readwrite,
> >> it would protect the data. Don't know if this setting can be done in
> >> the SCSI set.
> >
> > virtual tape drive can read this and disable write. 
> That was the idea.
> >
> >> Tape handling - Before starting stgt vtl and point it to the tapeslot
> >> directory you create tape slot subdirectories like this, where you
> >> define at startup the directory /var/tape as the slot directory:
> >>
> >> /var/tape/slot-01
> >> ...
> >> /var/tape/slot-24
> >>
> >> In the /var/tape directory there would be symbolic links like this
> >>
> >> /var/tape/drive-1 -> /var/slot-01/A00001.LTO3
> >>
> >> if a tape is loaded into drive-1, when a drive is empty (startup
> >> setting) it does not have a symbolic link.
> >>
> >> Note that by creating these directories by hand you can define how
> >> many slots you have, but also leave existing "tapes" in the slots
> >> between restarts of the vtl stgt service. And stopping the service
> >> should delete the symbolic drive links, so the drives "eject" the
> >> virtual tape and start up "empty" next time.
> >
> > this sounds interesting. but what is the action to "insert" a tape to
> > drive? then program has to capture the symlink event.
> >
> Maybe define something like a mailslot? You can just move it to the proper slot, or have
> it put in a free slot, just like a real StorageTek L700. A sort of CAB directory where you can put in
> one or more tapes. When you "close" the CAB, it starts scanning the tapes.
> 

why not a tgtadm ... --cmd load/unload <drive> <tape>?


> 
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From markh794 at gmail.com  Fri Apr  6 01:20:13 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 6 Apr 2007 09:20:13 +1000
Subject: [Stgt-devel] Thoughts on vtl setup
In-Reply-To: <13ce23213cf662.13cf66213ce232@o2.ie>
References: <13ce23213cf662.13cf66213ce232@o2.ie>
Message-ID: <f29db9a80704051620u5e5868a9u7e0f423f51d2dcfc@mail.gmail.com>

On 4/6/07, Albert Pauw <pauw at o2.ie> wrote:
> Here are a few thoughts I wanted to share regarding the virtual tape library, just shoot at it if you think otherwise. Hope you don't find this too nosy Mark (Harvey) as you started the idea.
>
Please chip in with any ideas / suggestions.

I'm looking at this from one angle. Other perspectives most welcome.


> General - Best would be to have the changer and the tapedrives on one target, the changer can be LUN 0, the drive(s) LUN 1 and onwards.
>

I can see no real benefit in limiting the vtl to fit this model.

My current implementation of a vtl (based on the scsi_debug linux
module and some user-space daemons) does in deed work this way. I have
the kernel module hard-coded so LUN 0 is reported as type 8, and all
other LUNs are type 1.

I ideally would like to be able to configure multiple changers with
SSC, SBC or MMC devices.

So the current 'limitation' of having one TID being tied to one device
type is not a limitation IMO.


> Configuration - Would be best to keep this simple. The changer can be a standard one, implementing all necessary functions. For the drives you define the type once, and how many drives you want. If you use symbolic names (as to numeric) for the drive types, then this can be easily expanded. E.g. LTO3, DDS4, etc. for the drive type. If you need three different type of drives, then you just add one of each type. Since these types are predefined you don't have to set other parameters for these drives (like size etc). Lastly you define the directory where the tapeslots are.
>

> Tapes - Well, virtual tapes. I guess the filename can be the barcode, the extension the tape type, e.g. A00001.LTO2. However, when these files are accidentally renamed you loose the barcode and type. So every tape should have a header containing the barcode, and tape type. The barcode and tapetype should be in clear text (e.g. 4 characters LTO2). Another addition could be a two-byte field, containing bitfields, like this:
>
> 0000 0000 0000 RCCC
>
> were
> CCC -> compression 0-7, where 0 is no compression, 1 is LZ, etc. for different types of compression, if implemented. We can start without compression.
>
> R -> Readonly bit, even if the file was readonly and set to readwrite, it would protect the data. Don't know if this setting can be done in the SCSI set.


Based on experience with my current vtl, this is generating a lot of
work for little to no gain.

I have a 'MAM' structure (fields pinched from IBM Ultrium
documentation) at the start of the virtual media. Within this
structure is information about the media type (WORM, cleaning, data,
media capacity).

I do not limit drive type x to read virtual media type y.
i.e. A drive configured as a SONY SDX-900V (AIT) can quite happily
read/write media created by a SDLT600 virtual drive. Extra checking of
the MAM data could limit this if required. But I can't see any real
benefit to this. Apart from a admin being able to determine the media
type by the file name. A small utility can quite easily read the MAM
information and print out the relevant data.



>
> Tape handling - Before starting stgt vtl and point it to the tapeslot directory you create tape slot subdirectories like this, where you define at startup the directory /var/tape as the slot directory:
>
> /var/tape/slot-01
> ...
> /var/tape/slot-24
>
> In the /var/tape directory there would be symbolic links like this
>
> /var/tape/drive-1 -> /var/slot-01/A00001.LTO3
>
> if a tape is loaded into drive-1, when a drive is empty (startup setting) it does not have a symbolic link.
>
> Note that by creating these directories by hand you can define how many slots you have, but also leave existing "tapes" in the slots between restarts of the vtl stgt service. And stopping the service should delete the symbolic drive links, so the drives "eject" the virtual tape and start up "empty" next time.
>
> Well, just a thought.

Again, this is based on experience with my current vtl implementation.


All 'movement' of media within the library (between slots and between
drives) are performed in core. No modification to any configuration
files exist.

I have a data structure for each slot and one field indicates if it
contains media. A move just sets/resets this bit + barcode of media in
the slot.

Setting up the linked list structures will be done at configuration
time using the following (proposed) syntax of:
The README.vtl has an example of a complete configuration setup.
       ==============================
=== Allocate 1 picker at address 256...
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        -n ElementType -v 1     \
        -n StartAddress -v 256  \
        -n Quanity -v 1         \
        -n Sides -v 2

=== Allocate 800 slots starting at address 1024
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        -n ElementType -v 2     \
        -n StartAddress -v 1024 \
        -n Quanity -v 800       \
        -n Sides -v 2

=== Allocate 10 Import/Export slots starting at address 128
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        -n ElementType -v 3     \
        -n StartAddress -v 128  \
        -n Quanity -v 10        \
        -n Sides -v 2

=== Allocate room for 8 drives
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        -n ElementType -v 4     \
        -n StartAddress -v 1    \
        -n Quanity -v 8         \
        -n Sides -v 1
       ==============================


I plan on sending a 'tgtcmd --tid --lun --op load -b <media ID>' type
command to signal a virtual drive that the media has been placed into
it. The virtual drive will then open the <media ID> as a file handle
(backing file)' for any read/write/positioning.


>
> Albert
>
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>


From markh794 at gmail.com  Fri Apr  6 02:31:19 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 6 Apr 2007 10:31:19 +1000
Subject: [Stgt-devel] Thoughts on vtl setup
In-Reply-To: <f29db9a80704051620u5e5868a9u7e0f423f51d2dcfc@mail.gmail.com>
References: <13ce23213cf662.13cf66213ce232@o2.ie>
	<f29db9a80704051620u5e5868a9u7e0f423f51d2dcfc@mail.gmail.com>
Message-ID: <f29db9a80704051731q23fc88f5w6cccaf3a29581c8f@mail.gmail.com>

[snip]
>
> I do not limit drive type x to read virtual media type y.
> i.e. A drive configured as a SONY SDX-900V (AIT) can quite happily
> read/write media created by a SDLT600 virtual drive. Extra checking of
> the MAM data could limit this if required. But I can't see any real
> benefit to this. Apart from a admin being able to determine the media
> type by the file name. A small utility can quite easily read the MAM
> information and print out the relevant data.

Don't you just hate it when you post something, then re-read it just
to find it makes no sense :(

I do not limit a drive type to read/write media type. i.e. All virtual
media is compatible with any type of virtual device. It would be
extreamly easy to add checks when opening the virtual media file for a
correct MAM type. But I can't see where this would not acheive
anything useful. If anybody can come up with a semi-valid reason, I
will add the check(s).


> Tapes - Well, virtual tapes. I guess the filename can be the barcode, the extension the tape type, e.g. A00001.LTO2. However, when these files are accidentally renamed you loose the barcode and type. So every tape should have a header containing the barcode, and tape type. The barcode and tapetype should be in clear text (e.g. 4 characters LTO2). Another addition could be a two-byte field, containing bitfields, like this:
>
> 0000 0000 0000 RCCC
>
> were
> CCC -> compression 0-7, where 0 is no compression, 1 is LZ, etc. for different types of compression, if implemented. We can start without compression.
>
> R -> Readonly bit, even if the file was readonly and set to readwrite, it would protect the data. Don't know if this setting can be done in the SCSI set.

Apart from a admin being able to determine the media type by the file
name I can see no useful advantage of this. A small utility can quite
easily read the MAM information and print out the relevant data.

There is a field in the MAM for 'Medium Serial Number'. When creating
the virtual media, I set this with 'barcode_<ctime>'

Each 'block' of data written has a header which contains the following
fields to describe the block of data:
Block Type -> End of data, Beginning of data, file mark, data block etc.
Block Size -> Size of raw data (uncompressed data size)
Disk Block Size -> Size of data to be read/written from/to file. Or
another way of putting it: how much data to skip to fine the next data
block header.

The BLOCK TYPE field could be expaneded to specify the compression
type used, however it has always been my intention to use the zlib
compression library routines. It has never made it into any actual
code.



>
[snip]


From blackmagic02881 at gmail.com  Fri Apr  6 02:34:58 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 05 Apr 2007 20:34:58 -0400
Subject: [Stgt-devel] Thoughts on vtl setup
In-Reply-To: <f29db9a80704051620u5e5868a9u7e0f423f51d2dcfc@mail.gmail.com>
References: <13ce23213cf662.13cf66213ce232@o2.ie>
	<f29db9a80704051620u5e5868a9u7e0f423f51d2dcfc@mail.gmail.com>
Message-ID: <1175819698.3622.118.camel@localhost.localdomain>

On Fri, 2007-04-06 at 09:20 +1000, Mark Harvey wrote:
> On 4/6/07, Albert Pauw <pauw at o2.ie> wrote:
> > Here are a few thoughts I wanted to share regarding the virtual tape
> library, just shoot at it if you think otherwise. Hope you don't find
> this too nosy Mark (Harvey) as you started the idea.
> >
> Please chip in with any ideas / suggestions.
> 
> I'm looking at this from one angle. Other perspectives most welcome.
> 
> 
> > General - Best would be to have the changer and the tapedrives on
> one target, the changer can be LUN 0, the drive(s) LUN 1 and onwards.
> >
> 
> I can see no real benefit in limiting the vtl to fit this model.
> 
> My current implementation of a vtl (based on the scsi_debug linux
> module and some user-space daemons) does in deed work this way. I have
> the kernel module hard-coded so LUN 0 is reported as type 8, and all
> other LUNs are type 1.
> 
> I ideally would like to be able to configure multiple changers with
> SSC, SBC or MMC devices.
> 
> So the current 'limitation' of having one TID being tied to one device
> type is not a limitation IMO.
> 
> 
> > Configuration - Would be best to keep this simple. The changer can
> be a standard one, implementing all necessary functions. For the
> drives you define the type once, and how many drives you want. If you
> use symbolic names (as to numeric) for the drive types, then this can
> be easily expanded. E.g. LTO3, DDS4, etc. for the drive type. If you
> need three different type of drives, then you just add one of each
> type. Since these types are predefined you don't have to set other
> parameters for these drives (like size etc). Lastly you define the
> directory where the tapeslots are.
> >
> 
> > Tapes - Well, virtual tapes. I guess the filename can be the
> barcode, the extension the tape type, e.g. A00001.LTO2. However, when
> these files are accidentally renamed you loose the barcode and type.
> So every tape should have a header containing the barcode, and tape
> type. The barcode and tapetype should be in clear text (e.g. 4
> characters LTO2). Another addition could be a two-byte field,
> containing bitfields, like this:
> >
> > 0000 0000 0000 RCCC
> >
> > were
> > CCC -> compression 0-7, where 0 is no compression, 1 is LZ, etc. for
> different types of compression, if implemented. We can start without
> compression.
> >
> > R -> Readonly bit, even if the file was readonly and set to
> readwrite, it would protect the data. Don't know if this setting can
> be done in the SCSI set.
> 
> 
> Based on experience with my current vtl, this is generating a lot of
> work for little to no gain.
> 
> I have a 'MAM' structure (fields pinched from IBM Ultrium
> documentation) at the start of the virtual media. Within this
> structure is information about the media type (WORM, cleaning, data,
> media capacity).
> 
> I do not limit drive type x to read virtual media type y.
> i.e. A drive configured as a SONY SDX-900V (AIT) can quite happily
> read/write media created by a SDLT600 virtual drive. Extra checking of
> the MAM data could limit this if required. But I can't see any real
> benefit to this. Apart from a admin being able to determine the media
> type by the file name. A small utility can quite easily read the MAM
> information and print out the relevant data.
> 

yes, this MAM is the metadata we meant. what i meant is to give MAM a
version so we can expand it later.

if i have a tape i try to switch the readonly and read/write, i need an
extra utility before i put into tape drive.

tape drive need to check MAM for some capability. 


> 
> 
> >
> > Tape handling - Before starting stgt vtl and point it to the
> tapeslot directory you create tape slot subdirectories like this,
> where you define at startup the directory /var/tape as the slot
> directory:
> >
> > /var/tape/slot-01
> > ...
> > /var/tape/slot-24
> >
> > In the /var/tape directory there would be symbolic links like this
> >
> > /var/tape/drive-1 -> /var/slot-01/A00001.LTO3
> >
> > if a tape is loaded into drive-1, when a drive is empty (startup
> setting) it does not have a symbolic link.
> >
> > Note that by creating these directories by hand you can define how
> many slots you have, but also leave existing "tapes" in the slots
> between restarts of the vtl stgt service. And stopping the service
> should delete the symbolic drive links, so the drives "eject" the
> virtual tape and start up "empty" next time.
> >
> > Well, just a thought.
> 
> Again, this is based on experience with my current vtl implementation.
> 
> 
> All 'movement' of media within the library (between slots and between
> drives) are performed in core. No modification to any configuration
> files exist.
> 
> I have a data structure for each slot and one field indicates if it
> contains media. A move just sets/resets this bit + barcode of media in
> the slot.
> 
> Setting up the linked list structures will be done at configuration
> time using the following (proposed) syntax of:
> The README.vtl has an example of a complete configuration setup.
>        ==============================
> === Allocate 1 picker at address 256...
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>         -n ElementType -v 1     \
>         -n StartAddress -v 256  \
>         -n Quanity -v 1         \
>         -n Sides -v 2
> 
> === Allocate 800 slots starting at address 1024
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>         -n ElementType -v 2     \
>         -n StartAddress -v 1024 \
>         -n Quanity -v 800       \
>         -n Sides -v 2
> 
> === Allocate 10 Import/Export slots starting at address 128
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>         -n ElementType -v 3     \
>         -n StartAddress -v 128  \
>         -n Quanity -v 10        \
>         -n Sides -v 2
> 
> === Allocate room for 8 drives
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>         -n ElementType -v 4     \
>         -n StartAddress -v 1    \
>         -n Quanity -v 8         \
>         -n Sides -v 1
>        ==============================
> 
> 
> I plan on sending a 'tgtcmd --tid --lun --op load -b <media ID>' type
> command to signal a virtual drive that the media has been placed into
> it. The virtual drive will then open the <media ID> as a file handle
> (backing file)' for any read/write/positioning.
> 

this is what i want. but can media id be a file id or file name?


> 
> >
> > Albert
> >
> > _______________________________________________
> > Stgt-devel mailing list
> > Stgt-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/stgt-devel
> >
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From blackmagic02881 at gmail.com  Fri Apr  6 02:47:47 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 05 Apr 2007 20:47:47 -0400
Subject: [Stgt-devel] Thoughts on vtl setup
In-Reply-To: <f29db9a80704051731q23fc88f5w6cccaf3a29581c8f@mail.gmail.com>
References: <13ce23213cf662.13cf66213ce232@o2.ie>
	<f29db9a80704051620u5e5868a9u7e0f423f51d2dcfc@mail.gmail.com>
	<f29db9a80704051731q23fc88f5w6cccaf3a29581c8f@mail.gmail.com>
Message-ID: <1175820467.3622.123.camel@localhost.localdomain>

On Fri, 2007-04-06 at 10:31 +1000, Mark Harvey wrote:
> [snip]
> >
> > I do not limit drive type x to read virtual media type y.
> > i.e. A drive configured as a SONY SDX-900V (AIT) can quite happily
> > read/write media created by a SDLT600 virtual drive. Extra checking
> of
> > the MAM data could limit this if required. But I can't see any real
> > benefit to this. Apart from a admin being able to determine the
> media
> > type by the file name. A small utility can quite easily read the MAM
> > information and print out the relevant data.
> 
> Don't you just hate it when you post something, then re-read it just
> to find it makes no sense :(
> 
> I do not limit a drive type to read/write media type. i.e. All virtual
> media is compatible with any type of virtual device. It would be
> extreamly easy to add checks when opening the virtual media file for a
> correct MAM type. But I can't see where this would not acheive
> anything useful. If anybody can come up with a semi-valid reason, I
> will add the check(s).
> 
> 
> > Tapes - Well, virtual tapes. I guess the filename can be the
> barcode, the extension the tape type, e.g. A00001.LTO2. However, when
> these files are accidentally renamed you loose the barcode and type.
> So every tape should have a header containing the barcode, and tape
> type. The barcode and tapetype should be in clear text (e.g. 4
> characters LTO2). Another addition could be a two-byte field,
> containing bitfields, like this:
> >
> > 0000 0000 0000 RCCC
> >
> > were
> > CCC -> compression 0-7, where 0 is no compression, 1 is LZ, etc. for
> different types of compression, if implemented. We can start without
> compression.
> >
> > R -> Readonly bit, even if the file was readonly and set to
> readwrite, it would protect the data. Don't know if this setting can
> be done in the SCSI set.
> 
> Apart from a admin being able to determine the media type by the file
> name I can see no useful advantage of this. A small utility can quite
> easily read the MAM information and print out the relevant data.
> 
> There is a field in the MAM for 'Medium Serial Number'. When creating
> the virtual media, I set this with 'barcode_<ctime>'
> 
> Each 'block' of data written has a header which contains the following
> fields to describe the block of data:
> Block Type -> End of data, Beginning of data, file mark, data block
> etc.
> Block Size -> Size of raw data (uncompressed data size)
> Disk Block Size -> Size of data to be read/written from/to file. Or
> another way of putting it: how much data to skip to fine the next data
> block header.
> 
> The BLOCK TYPE field could be expaneded to specify the compression
> type used, however it has always been my intention to use the zlib
> compression library routines. It has never made it into any actual
> code.

will one backup job use different compression algorithm? so it is per
block or per job?

ps, i think these questions can have endless discussions. so let us do
Xp way, release it, get merged, make a VBE based regression test suite
and then we can always refactoring it and add more stuff.

a workable non-compression vt/vtl is good enough to draw many people
eyeballs.



> 
> 
> 
> >
> [snip]
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From markh794 at gmail.com  Fri Apr  6 02:52:56 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 6 Apr 2007 10:52:56 +1000
Subject: [Stgt-devel] Thoughts on vtl setup
In-Reply-To: <1175819698.3622.118.camel@localhost.localdomain>
References: <13ce23213cf662.13cf66213ce232@o2.ie>
	<f29db9a80704051620u5e5868a9u7e0f423f51d2dcfc@mail.gmail.com>
	<1175819698.3622.118.camel@localhost.localdomain>
Message-ID: <f29db9a80704051752i21570127t7b2c7c187d6c16c2@mail.gmail.com>

On 4/6/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> On Fri, 2007-04-06 at 09:20 +1000, Mark Harvey wrote:
> > On 4/6/07, Albert Pauw <pauw at o2.ie> wrote:
> > > Here are a few thoughts I wanted to share regarding the virtual tape
> > library, just shoot at it if you think otherwise. Hope you don't find
> > this too nosy Mark (Harvey) as you started the idea.
> > >
> > Please chip in with any ideas / suggestions.
> >
> > I'm looking at this from one angle. Other perspectives most welcome.
> >
> >
> > > General - Best would be to have the changer and the tapedrives on
> > one target, the changer can be LUN 0, the drive(s) LUN 1 and onwards.
> > >
> >
> > I can see no real benefit in limiting the vtl to fit this model.
> >
> > My current implementation of a vtl (based on the scsi_debug linux
> > module and some user-space daemons) does in deed work this way. I have
> > the kernel module hard-coded so LUN 0 is reported as type 8, and all
> > other LUNs are type 1.
> >
> > I ideally would like to be able to configure multiple changers with
> > SSC, SBC or MMC devices.
> >
> > So the current 'limitation' of having one TID being tied to one device
> > type is not a limitation IMO.
> >
> >
> > > Configuration - Would be best to keep this simple. The changer can
> > be a standard one, implementing all necessary functions. For the
> > drives you define the type once, and how many drives you want. If you
> > use symbolic names (as to numeric) for the drive types, then this can
> > be easily expanded. E.g. LTO3, DDS4, etc. for the drive type. If you
> > need three different type of drives, then you just add one of each
> > type. Since these types are predefined you don't have to set other
> > parameters for these drives (like size etc). Lastly you define the
> > directory where the tapeslots are.
> > >
> >
> > > Tapes - Well, virtual tapes. I guess the filename can be the
> > barcode, the extension the tape type, e.g. A00001.LTO2. However, when
> > these files are accidentally renamed you loose the barcode and type.
> > So every tape should have a header containing the barcode, and tape
> > type. The barcode and tapetype should be in clear text (e.g. 4
> > characters LTO2). Another addition could be a two-byte field,
> > containing bitfields, like this:
> > >
> > > 0000 0000 0000 RCCC
> > >
> > > were
> > > CCC -> compression 0-7, where 0 is no compression, 1 is LZ, etc. for
> > different types of compression, if implemented. We can start without
> > compression.
> > >
> > > R -> Readonly bit, even if the file was readonly and set to
> > readwrite, it would protect the data. Don't know if this setting can
> > be done in the SCSI set.
> >
> >
> > Based on experience with my current vtl, this is generating a lot of
> > work for little to no gain.
> >
> > I have a 'MAM' structure (fields pinched from IBM Ultrium
> > documentation) at the start of the virtual media. Within this
> > structure is information about the media type (WORM, cleaning, data,
> > media capacity).
> >
> > I do not limit drive type x to read virtual media type y.
> > i.e. A drive configured as a SONY SDX-900V (AIT) can quite happily
> > read/write media created by a SDLT600 virtual drive. Extra checking of
> > the MAM data could limit this if required. But I can't see any real
> > benefit to this. Apart from a admin being able to determine the media
> > type by the file name. A small utility can quite easily read the MAM
> > information and print out the relevant data.
> >
>
> yes, this MAM is the metadata we meant. what i meant is to give MAM a
> version so we can expand it later.
>
> if i have a tape i try to switch the readonly and read/write, i need an
> extra utility before i put into tape drive.
>
> tape drive need to check MAM for some capability.
>
>
> >
> >
> > >
> > > Tape handling - Before starting stgt vtl and point it to the
> > tapeslot directory you create tape slot subdirectories like this,
> > where you define at startup the directory /var/tape as the slot
> > directory:
> > >
> > > /var/tape/slot-01
> > > ...
> > > /var/tape/slot-24
> > >
> > > In the /var/tape directory there would be symbolic links like this
> > >
> > > /var/tape/drive-1 -> /var/slot-01/A00001.LTO3
> > >
> > > if a tape is loaded into drive-1, when a drive is empty (startup
> > setting) it does not have a symbolic link.
> > >
> > > Note that by creating these directories by hand you can define how
> > many slots you have, but also leave existing "tapes" in the slots
> > between restarts of the vtl stgt service. And stopping the service
> > should delete the symbolic drive links, so the drives "eject" the
> > virtual tape and start up "empty" next time.
> > >
> > > Well, just a thought.
> >
> > Again, this is based on experience with my current vtl implementation.
> >
> >
> > All 'movement' of media within the library (between slots and between
> > drives) are performed in core. No modification to any configuration
> > files exist.
> >
> > I have a data structure for each slot and one field indicates if it
> > contains media. A move just sets/resets this bit + barcode of media in
> > the slot.
> >
> > Setting up the linked list structures will be done at configuration
> > time using the following (proposed) syntax of:
> > The README.vtl has an example of a complete configuration setup.
> >        ==============================
> > === Allocate 1 picker at address 256...
> > tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
> >         -n ElementType -v 1     \
> >         -n StartAddress -v 256  \
> >         -n Quanity -v 1         \
> >         -n Sides -v 2
> >
> > === Allocate 800 slots starting at address 1024
> > tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
> >         -n ElementType -v 2     \
> >         -n StartAddress -v 1024 \
> >         -n Quanity -v 800       \
> >         -n Sides -v 2
> >
> > === Allocate 10 Import/Export slots starting at address 128
> > tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
> >         -n ElementType -v 3     \
> >         -n StartAddress -v 128  \
> >         -n Quanity -v 10        \
> >         -n Sides -v 2
> >
> > === Allocate room for 8 drives
> > tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
> >         -n ElementType -v 4     \
> >         -n StartAddress -v 1    \
> >         -n Quanity -v 8         \
> >         -n Sides -v 1
> >        ==============================
> >
> >
> > I plan on sending a 'tgtcmd --tid --lun --op load -b <media ID>' type
> > command to signal a virtual drive that the media has been placed into
> > it. The virtual drive will then open the <media ID> as a file handle
> > (backing file)' for any read/write/positioning.
> >
>
> this is what i want. but can media id be a file id or file name?

I was thinking along the lines of a file name only. i.e. the library
will exec a "tgtadm --tid --lun --op load -b filename...." command to
the virtual SSC/SDC/MMC device.

If the information within the robot 'drive number 1' contains the TID
& LUN, then there will be enough information to build this command and
pass the virtual media ID filename as the '-b backing file'

When initially setting up the configuration, /dev/null is passed as
the default backing file.


>
>
> >
> > >
> > > Albert
> > >
> > > _______________________________________________
> > > Stgt-devel mailing list
> > > Stgt-devel at lists.berlios.de
> > > https://lists.berlios.de/mailman/listinfo/stgt-devel
> > >
> > _______________________________________________
> > Stgt-devel mailing list
> > Stgt-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/stgt-devel
>
>


From blackmagic02881 at gmail.com  Fri Apr  6 02:58:08 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 05 Apr 2007 20:58:08 -0400
Subject: [Stgt-devel] Thoughts on vtl setup
In-Reply-To: <f29db9a80704051752i21570127t7b2c7c187d6c16c2@mail.gmail.com>
References: <13ce23213cf662.13cf66213ce232@o2.ie>
	<f29db9a80704051620u5e5868a9u7e0f423f51d2dcfc@mail.gmail.com>
	<1175819698.3622.118.camel@localhost.localdomain>
	<f29db9a80704051752i21570127t7b2c7c187d6c16c2@mail.gmail.com>
Message-ID: <1175821088.3622.126.camel@localhost.localdomain>

On Fri, 2007-04-06 at 10:52 +1000, Mark Harvey wrote:
> On 4/6/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > On Fri, 2007-04-06 at 09:20 +1000, Mark Harvey wrote:
> > > On 4/6/07, Albert Pauw <pauw at o2.ie> wrote:
> > > > Here are a few thoughts I wanted to share regarding the virtual tape
> > > library, just shoot at it if you think otherwise. Hope you don't find
> > > this too nosy Mark (Harvey) as you started the idea.
> > > >
> > > Please chip in with any ideas / suggestions.
> > >
> > > I'm looking at this from one angle. Other perspectives most welcome.
> > >
> > >
> > > > General - Best would be to have the changer and the tapedrives on
> > > one target, the changer can be LUN 0, the drive(s) LUN 1 and onwards.
> > > >
> > >
> > > I can see no real benefit in limiting the vtl to fit this model.
> > >
> > > My current implementation of a vtl (based on the scsi_debug linux
> > > module and some user-space daemons) does in deed work this way. I have
> > > the kernel module hard-coded so LUN 0 is reported as type 8, and all
> > > other LUNs are type 1.
> > >
> > > I ideally would like to be able to configure multiple changers with
> > > SSC, SBC or MMC devices.
> > >
> > > So the current 'limitation' of having one TID being tied to one device
> > > type is not a limitation IMO.
> > >
> > >
> > > > Configuration - Would be best to keep this simple. The changer can
> > > be a standard one, implementing all necessary functions. For the
> > > drives you define the type once, and how many drives you want. If you
> > > use symbolic names (as to numeric) for the drive types, then this can
> > > be easily expanded. E.g. LTO3, DDS4, etc. for the drive type. If you
> > > need three different type of drives, then you just add one of each
> > > type. Since these types are predefined you don't have to set other
> > > parameters for these drives (like size etc). Lastly you define the
> > > directory where the tapeslots are.
> > > >
> > >
> > > > Tapes - Well, virtual tapes. I guess the filename can be the
> > > barcode, the extension the tape type, e.g. A00001.LTO2. However, when
> > > these files are accidentally renamed you loose the barcode and type.
> > > So every tape should have a header containing the barcode, and tape
> > > type. The barcode and tapetype should be in clear text (e.g. 4
> > > characters LTO2). Another addition could be a two-byte field,
> > > containing bitfields, like this:
> > > >
> > > > 0000 0000 0000 RCCC
> > > >
> > > > were
> > > > CCC -> compression 0-7, where 0 is no compression, 1 is LZ, etc. for
> > > different types of compression, if implemented. We can start without
> > > compression.
> > > >
> > > > R -> Readonly bit, even if the file was readonly and set to
> > > readwrite, it would protect the data. Don't know if this setting can
> > > be done in the SCSI set.
> > >
> > >
> > > Based on experience with my current vtl, this is generating a lot of
> > > work for little to no gain.
> > >
> > > I have a 'MAM' structure (fields pinched from IBM Ultrium
> > > documentation) at the start of the virtual media. Within this
> > > structure is information about the media type (WORM, cleaning, data,
> > > media capacity).
> > >
> > > I do not limit drive type x to read virtual media type y.
> > > i.e. A drive configured as a SONY SDX-900V (AIT) can quite happily
> > > read/write media created by a SDLT600 virtual drive. Extra checking of
> > > the MAM data could limit this if required. But I can't see any real
> > > benefit to this. Apart from a admin being able to determine the media
> > > type by the file name. A small utility can quite easily read the MAM
> > > information and print out the relevant data.
> > >
> >
> > yes, this MAM is the metadata we meant. what i meant is to give MAM a
> > version so we can expand it later.
> >
> > if i have a tape i try to switch the readonly and read/write, i need an
> > extra utility before i put into tape drive.
> >
> > tape drive need to check MAM for some capability.
> >
> >
> > >
> > >
> > > >
> > > > Tape handling - Before starting stgt vtl and point it to the
> > > tapeslot directory you create tape slot subdirectories like this,
> > > where you define at startup the directory /var/tape as the slot
> > > directory:
> > > >
> > > > /var/tape/slot-01
> > > > ...
> > > > /var/tape/slot-24
> > > >
> > > > In the /var/tape directory there would be symbolic links like this
> > > >
> > > > /var/tape/drive-1 -> /var/slot-01/A00001.LTO3
> > > >
> > > > if a tape is loaded into drive-1, when a drive is empty (startup
> > > setting) it does not have a symbolic link.
> > > >
> > > > Note that by creating these directories by hand you can define how
> > > many slots you have, but also leave existing "tapes" in the slots
> > > between restarts of the vtl stgt service. And stopping the service
> > > should delete the symbolic drive links, so the drives "eject" the
> > > virtual tape and start up "empty" next time.
> > > >
> > > > Well, just a thought.
> > >
> > > Again, this is based on experience with my current vtl implementation.
> > >
> > >
> > > All 'movement' of media within the library (between slots and between
> > > drives) are performed in core. No modification to any configuration
> > > files exist.
> > >
> > > I have a data structure for each slot and one field indicates if it
> > > contains media. A move just sets/resets this bit + barcode of media in
> > > the slot.
> > >
> > > Setting up the linked list structures will be done at configuration
> > > time using the following (proposed) syntax of:
> > > The README.vtl has an example of a complete configuration setup.
> > >        ==============================
> > > === Allocate 1 picker at address 256...
> > > tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
> > >         -n ElementType -v 1     \
> > >         -n StartAddress -v 256  \
> > >         -n Quanity -v 1         \
> > >         -n Sides -v 2
> > >
> > > === Allocate 800 slots starting at address 1024
> > > tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
> > >         -n ElementType -v 2     \
> > >         -n StartAddress -v 1024 \
> > >         -n Quanity -v 800       \
> > >         -n Sides -v 2
> > >
> > > === Allocate 10 Import/Export slots starting at address 128
> > > tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
> > >         -n ElementType -v 3     \
> > >         -n StartAddress -v 128  \
> > >         -n Quanity -v 10        \
> > >         -n Sides -v 2
> > >
> > > === Allocate room for 8 drives
> > > tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
> > >         -n ElementType -v 4     \
> > >         -n StartAddress -v 1    \
> > >         -n Quanity -v 8         \
> > >         -n Sides -v 1
> > >        ==============================
> > >
> > >
> > > I plan on sending a 'tgtcmd --tid --lun --op load -b <media ID>' type
> > > command to signal a virtual drive that the media has been placed into
> > > it. The virtual drive will then open the <media ID> as a file handle
> > > (backing file)' for any read/write/positioning.
> > >
> >
> > this is what i want. but can media id be a file id or file name?
> 
> I was thinking along the lines of a file name only. i.e. the library
> will exec a "tgtadm --tid --lun --op load -b filename...." command to
> the virtual SSC/SDC/MMC device.
> 
> If the information within the robot 'drive number 1' contains the TID
> & LUN, then there will be enough information to build this command and
> pass the virtual media ID filename as the '-b backing file'

tgtadm will pass tid, lun, op, and param to daemon, and then look up
target, its lu, and parse the parameter to that lun.

> 
> When initially setting up the configuration, /dev/null is passed as
> the default backing file.
> 

not bad.

> 
> >
> >
> > >
> > > >
> > > > Albert
> > > >
> > > > _______________________________________________
> > > > Stgt-devel mailing list
> > > > Stgt-devel at lists.berlios.de
> > > > https://lists.berlios.de/mailman/listinfo/stgt-devel
> > > >
> > > _______________________________________________
> > > Stgt-devel mailing list
> > > Stgt-devel at lists.berlios.de
> > > https://lists.berlios.de/mailman/listinfo/stgt-devel
> >
> >



From markh794 at gmail.com  Fri Apr  6 03:26:36 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 6 Apr 2007 11:26:36 +1000
Subject: [Stgt-devel] patch howto
Message-ID: <f29db9a80704051826k32bc6bag6bf74aa72b492faa@mail.gmail.com>

Being a newbe with regards to shared development, how should I submit
further patches / coding to this list ?

Should I base it on git master + patches already emailed to this list
or a complete diff against the git master branch ?

Cheers
Mark


From fujita.tomonori at lab.ntt.co.jp  Fri Apr  6 17:28:39 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 07 Apr 2007 00:28:39 +0900
Subject: [Stgt-devel] patch howto
In-Reply-To: <f29db9a80704051826k32bc6bag6bf74aa72b492faa@mail.gmail.com>
References: <f29db9a80704051826k32bc6bag6bf74aa72b492faa@mail.gmail.com>
Message-ID: <20070407002839L.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] patch howto
Date: Fri, 6 Apr 2007 11:26:36 +1000

> Being a newbe with regards to shared development, how should I submit
> further patches / coding to this list ?

Please see the README file (developers note section). In short, I
would appreciate if you could send a patch in the Linux kernel
development way.


> Should I base it on git master + patches already emailed to this list
> or a complete diff against the git master branch ?


From fujita.tomonori at lab.ntt.co.jp  Fri Apr  6 17:36:04 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 7 Apr 2007 00:36:04 +0900 (JST)
Subject: [Stgt-devel] ibmvio - rdma error
In-Reply-To: <20070405084436.GA28380@wavehammer.waldi.eu.org>
References: <20070405082856.GA26906@wavehammer.waldi.eu.org>
	<20070405173931I.fujita.tomonori@lab.ntt.co.jp>
	<20070405084436.GA28380@wavehammer.waldi.eu.org>
Message-ID: <20070407003634E.fujita.tomonori@lab.ntt.co.jp>

From: Bastian Blank <waldi at berlios.de>
Subject: Re: [Stgt-devel] ibmvio - rdma error
Date: Thu, 5 Apr 2007 10:44:36 +0200

> On Thu, Apr 05, 2007 at 05:39:06PM +0900, FUJITA Tomonori wrote:
> > Can you try the following patch to see what error we get?
> 
> I already did this.

Oops. Sorry.

> It is -4 (H_PARAMETER, Parameter invalid, out-of-range or
> conflicting).

Seems that we hit a limit on RDMA transfer.

I slightly modified your patch. How about this?

I'll forward the patch to upstream. Let me know your sign-off.

diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
index a7fbd10..46f9ca1 100644
--- a/drivers/scsi/ibmvscsi/ibmvstgt.c
+++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
@@ -35,7 +35,7 @@
 #include "ibmvscsi.h"
 
 #define	INITIAL_SRP_LIMIT	16
-#define	DEFAULT_MAX_SECTORS	512
+#define	DEFAULT_MAX_SECTORS	128
 
 #define	TGT_NAME	"ibmvstgt"
 
@@ -248,8 +248,8 @@ static int ibmvstgt_rdma(struct scsi_cmnd *sc, struct scatterlist *sg, int nsg,
 						  md[i].va + mdone);
 
 			if (err != H_SUCCESS) {
-				eprintk("rdma error %d %d\n", dir, slen);
-				goto out;
+				eprintk("rdma error %d %d %ld\n", dir, slen, err);
+				return -EIO;
 			}
 
 			mlen -= slen;
@@ -265,14 +265,13 @@ static int ibmvstgt_rdma(struct scsi_cmnd *sc, struct scatterlist *sg, int nsg,
 				if (sidx > nsg) {
 					eprintk("out of sg %p %d %d\n",
 						iue, sidx, nsg);
-					goto out;
+					return -EIO;
 				}
 			}
 		};
 
 		rest -= mlen;
 	}
-out:
 	return 0;
 }
 
@@ -282,18 +281,19 @@ static int ibmvstgt_cmd_done(struct scsi_cmnd *sc,
 	unsigned long flags;
 	struct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;
 	struct srp_target *target = iue->target;
+	int err = 0;
 
 	dprintk("%p %p %x %u\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0],
 		cmd->usg_sg);
 
 	if (sc->use_sg)
-		srp_transfer_data(sc, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma, 1, 1);
+		err = srp_transfer_data(sc, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma, 1, 1);
 
 	spin_lock_irqsave(&target->lock, flags);
 	list_del(&iue->ilist);
 	spin_unlock_irqrestore(&target->lock, flags);
 
-	if (sc->result != SAM_STAT_GOOD) {
+	if (err|| sc->result != SAM_STAT_GOOD) {
 		eprintk("operation failed %p %d %x\n",
 			iue, sc->result, vio_iu(iue)->srp.cmd.cdb[0]);
 		send_rsp(iue, sc, HARDWARE_ERROR, 0x00);
@@ -493,7 +493,8 @@ static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
 {
 	struct vio_port *vport = target_to_port(target);
 	struct iu_entry *iue;
-	long err, done;
+	long err;
+	int done = 1;
 
 	iue = srp_iu_get(target);
 	if (!iue) {
@@ -508,7 +509,6 @@ static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
 
 	if (err != H_SUCCESS) {
 		eprintk("%ld transferring data error %p\n", err, iue);
-		done = 1;
 		goto out;
 	}
 
diff --git a/drivers/scsi/libsrp.c b/drivers/scsi/libsrp.c
index 89403b0..37a0f4d 100644
--- a/drivers/scsi/libsrp.c
+++ b/drivers/scsi/libsrp.c
@@ -225,8 +225,7 @@ static int srp_indirect_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
 	struct srp_direct_buf *md = NULL;
 	struct scatterlist dummy, *sg = NULL;
 	dma_addr_t token = 0;
-	long err;
-	unsigned int done = 0;
+	int err = 0;
 	int nmd, nsg = 0, len;
 
 	if (dma_map || ext_desc) {
@@ -258,8 +257,8 @@ static int srp_indirect_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
 		sg_dma_address(&dummy) = token;
 		err = rdma_io(sc, &dummy, 1, &id->table_desc, 1, DMA_TO_DEVICE,
 			      id->table_desc.len);
-		if (err < 0) {
-			eprintk("Error copying indirect table %ld\n", err);
+		if (err) {
+			eprintk("Error copying indirect table %d\n", err);
 			goto free_mem;
 		}
 	} else {
@@ -272,6 +271,7 @@ rdma:
 		nsg = dma_map_sg(iue->target->dev, sg, sc->use_sg, DMA_BIDIRECTIONAL);
 		if (!nsg) {
 			eprintk("fail to map %p %d\n", iue, sc->use_sg);
+			err = -EIO;
 			goto free_mem;
 		}
 		len = min(sc->request_bufflen, id->len);
@@ -287,7 +287,7 @@ free_mem:
 	if (token && dma_map)
 		dma_free_coherent(iue->target->dev, id->table_desc.len, md, token);
 
-	return done;
+	return err;
 }
 
 static int data_out_desc_size(struct srp_cmd *cmd)
@@ -352,7 +352,7 @@ int srp_transfer_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
 		break;
 	default:
 		eprintk("Unknown format %d %x\n", dir, format);
-		break;
+		err = -EINVAL;
 	}
 
 	return err;
-- 
1.4.4.3



From fujita.tomonori at lab.ntt.co.jp  Fri Apr  6 17:43:33 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 07 Apr 2007 00:43:33 +0900
Subject: [Stgt-devel] Which license?
In-Reply-To: <4614957C.6000408@suse.de>
References: <46134914.1010208@suse.de>
	<20070405073714G.fujita.tomonori@lab.ntt.co.jp>
	<4614957C.6000408@suse.de>
Message-ID: <20070407004333S.fujita.tomonori@lab.ntt.co.jp>

From: Hannes Reinecke <hare at suse.de>
Subject: Re: [Stgt-devel] Which license?
Date: Thu, 05 Apr 2007 08:21:48 +0200

> > Now I'm waiting for you guys to put tgt in SUSE Linux Enterprise
> > Server. :)
> 
> tgt will be in openSUSE 10.3 and all follow-on releases.
> We will be dropping iscsitarget in favour of tgt.

Cool.


> Now I only need to port all features of iscsitarget to tgt :-(

- header and data digest
- iSNS
- dynamic management (we can add something but if we delete a target
(or a lun) having utstanding command, tgt would crash)

Anything eles?

I'm working on the last one. I would greatly apprecate if you could
work on the rest.


From waldi at berlios.de  Fri Apr  6 18:13:05 2007
From: waldi at berlios.de (Bastian Blank)
Date: Fri, 6 Apr 2007 18:13:05 +0200
Subject: [Stgt-devel] ibmvio - rdma error
In-Reply-To: <20070407003634E.fujita.tomonori@lab.ntt.co.jp>
References: <20070405082856.GA26906@wavehammer.waldi.eu.org>
	<20070405173931I.fujita.tomonori@lab.ntt.co.jp>
	<20070405084436.GA28380@wavehammer.waldi.eu.org>
	<20070407003634E.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070406161305.GA22606@wavehammer.waldi.eu.org>

On Sat, Apr 07, 2007 at 12:36:04AM +0900, FUJITA Tomonori wrote:
> diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
> index a7fbd10..46f9ca1 100644
> --- a/drivers/scsi/ibmvscsi/ibmvstgt.c
> +++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
> @@ -35,7 +35,7 @@
>  #include "ibmvscsi.h"
>  
>  #define	INITIAL_SRP_LIMIT	16
> -#define	DEFAULT_MAX_SECTORS	512
> +#define	DEFAULT_MAX_SECTORS	128

256, not 128.

> -	if (sc->result != SAM_STAT_GOOD) {
> +	if (err|| sc->result != SAM_STAT_GOOD) {

coding style?

> @@ -508,7 +509,6 @@ static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
>  
>  	if (err != H_SUCCESS) {
>  		eprintk("%ld transferring data error %p\n", err, iue);
> -		done = 1;
>  		goto out;
>  	}

Replace that with:
        if (err != H_SUCCESS) 
                eprintk("%ld transferring data error %p\n", err, iue);
        else if (crq->format == VIOSRP_MAD_FORMAT)
                done = process_mad_iu(iue);
        else
                done = process_srp_iu(iue);

        if (done)
                srp_iu_put(iue);

No more goto.

Revised patch attached.

Signed-off-by: Bastian Blank <bastian at waldi.eu.org>

Bastian

-- 
She won' go Warp 7, Cap'n!  The batteries are dead!
-------------- next part --------------
diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
index a7fbd10..84534b5 100644
--- a/drivers/scsi/ibmvscsi/ibmvstgt.c
+++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
@@ -35,7 +35,7 @@
 #include "ibmvscsi.h"
 
 #define	INITIAL_SRP_LIMIT	16
-#define	DEFAULT_MAX_SECTORS	512
+#define	DEFAULT_MAX_SECTORS	256
 
 #define	TGT_NAME	"ibmvstgt"
 
@@ -248,8 +248,8 @@ static int ibmvstgt_rdma(struct scsi_cmnd *sc, struct scatterlist *sg, int nsg,
 						  md[i].va + mdone);
 
 			if (err != H_SUCCESS) {
-				eprintk("rdma error %d %d\n", dir, slen);
-				goto out;
+				eprintk("rdma error %d %d %ld\n", dir, slen, err);
+				return -EIO;
 			}
 
 			mlen -= slen;
@@ -265,14 +265,13 @@ static int ibmvstgt_rdma(struct scsi_cmnd *sc, struct scatterlist *sg, int nsg,
 				if (sidx > nsg) {
 					eprintk("out of sg %p %d %d\n",
 						iue, sidx, nsg);
-					goto out;
+					return -EIO;
 				}
 			}
 		};
 
 		rest -= mlen;
 	}
-out:
 	return 0;
 }
 
@@ -282,18 +281,19 @@ static int ibmvstgt_cmd_done(struct scsi_cmnd *sc,
 	unsigned long flags;
 	struct iu_entry *iue = (struct iu_entry *) sc->SCp.ptr;
 	struct srp_target *target = iue->target;
+	int err = 0;
 
 	dprintk("%p %p %x %u\n", iue, target, vio_iu(iue)->srp.cmd.cdb[0],
 		cmd->usg_sg);
 
 	if (sc->use_sg)
-		srp_transfer_data(sc, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma, 1, 1);
+		err = srp_transfer_data(sc, &vio_iu(iue)->srp.cmd, ibmvstgt_rdma, 1, 1);
 
 	spin_lock_irqsave(&target->lock, flags);
 	list_del(&iue->ilist);
 	spin_unlock_irqrestore(&target->lock, flags);
 
-	if (sc->result != SAM_STAT_GOOD) {
+	if (err || sc->result != SAM_STAT_GOOD) {
 		eprintk("operation failed %p %d %x\n",
 			iue, sc->result, vio_iu(iue)->srp.cmd.cdb[0]);
 		send_rsp(iue, sc, HARDWARE_ERROR, 0x00);
@@ -493,7 +493,8 @@ static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
 {
 	struct vio_port *vport = target_to_port(target);
 	struct iu_entry *iue;
-	long err, done;
+	long err;
+	int done = 1;
 
 	iue = srp_iu_get(target);
 	if (!iue) {
@@ -506,17 +507,13 @@ static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
 	err = h_copy_rdma(crq->IU_length, vport->riobn,
 			  iue->remote_token, vport->liobn, iue->sbuf->dma);
 
-	if (err != H_SUCCESS) {
+	if (err != H_SUCCESS)
 		eprintk("%ld transferring data error %p\n", err, iue);
-		done = 1;
-		goto out;
-	}
-
-	if (crq->format == VIOSRP_MAD_FORMAT)
+	else if (crq->format == VIOSRP_MAD_FORMAT)
 		done = process_mad_iu(iue);
 	else
 		done = process_srp_iu(iue);
-out:
+
 	if (done)
 		srp_iu_put(iue);
 }
diff --git a/drivers/scsi/libsrp.c b/drivers/scsi/libsrp.c
index 89403b0..37a0f4d 100644
--- a/drivers/scsi/libsrp.c
+++ b/drivers/scsi/libsrp.c
@@ -225,8 +225,7 @@ static int srp_indirect_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
 	struct srp_direct_buf *md = NULL;
 	struct scatterlist dummy, *sg = NULL;
 	dma_addr_t token = 0;
-	long err;
-	unsigned int done = 0;
+	int err = 0;
 	int nmd, nsg = 0, len;
 
 	if (dma_map || ext_desc) {
@@ -258,8 +257,8 @@ static int srp_indirect_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
 		sg_dma_address(&dummy) = token;
 		err = rdma_io(sc, &dummy, 1, &id->table_desc, 1, DMA_TO_DEVICE,
 			      id->table_desc.len);
-		if (err < 0) {
-			eprintk("Error copying indirect table %ld\n", err);
+		if (err) {
+			eprintk("Error copying indirect table %d\n", err);
 			goto free_mem;
 		}
 	} else {
@@ -272,6 +271,7 @@ rdma:
 		nsg = dma_map_sg(iue->target->dev, sg, sc->use_sg, DMA_BIDIRECTIONAL);
 		if (!nsg) {
 			eprintk("fail to map %p %d\n", iue, sc->use_sg);
+			err = -EIO;
 			goto free_mem;
 		}
 		len = min(sc->request_bufflen, id->len);
@@ -287,7 +287,7 @@ free_mem:
 	if (token && dma_map)
 		dma_free_coherent(iue->target->dev, id->table_desc.len, md, token);
 
-	return done;
+	return err;
 }
 
 static int data_out_desc_size(struct srp_cmd *cmd)
@@ -352,7 +352,7 @@ int srp_transfer_data(struct scsi_cmnd *sc, struct srp_cmd *cmd,
 		break;
 	default:
 		eprintk("Unknown format %d %x\n", dir, format);
-		break;
+		err = -EINVAL;
 	}
 
 	return err;
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070406/b37172aa/attachment.pgp>

From fujita.tomonori at lab.ntt.co.jp  Fri Apr  6 18:38:57 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 07 Apr 2007 01:38:57 +0900
Subject: [Stgt-devel] ibmvio - rdma error
In-Reply-To: <20070406161305.GA22606@wavehammer.waldi.eu.org>
References: <20070405084436.GA28380@wavehammer.waldi.eu.org>
	<20070407003634E.fujita.tomonori@lab.ntt.co.jp>
	<20070406161305.GA22606@wavehammer.waldi.eu.org>
Message-ID: <20070407013857S.fujita.tomonori@lab.ntt.co.jp>

From: Bastian Blank <waldi at berlios.de>
Subject: Re: [Stgt-devel] ibmvio - rdma error
Date: Fri, 6 Apr 2007 18:13:05 +0200

> On Sat, Apr 07, 2007 at 12:36:04AM +0900, FUJITA Tomonori wrote:
> > diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
> > index a7fbd10..46f9ca1 100644
> > --- a/drivers/scsi/ibmvscsi/ibmvstgt.c
> > +++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
> > @@ -35,7 +35,7 @@
> >  #include "ibmvscsi.h"
> >  
> >  #define	INITIAL_SRP_LIMIT	16
> > -#define	DEFAULT_MAX_SECTORS	512
> > +#define	DEFAULT_MAX_SECTORS	128
> 
> 256, not 128.

Are you sure 256 should work though it seems to work? We know 128
works. If you definitely sure (e.g. you read the IBM document), I'm
happy to use 256.


> > -	if (sc->result != SAM_STAT_GOOD) {
> > +	if (err|| sc->result != SAM_STAT_GOOD) {
> 
> coding style?
> 
> > @@ -508,7 +509,6 @@ static void process_iu(struct viosrp_crq *crq, struct srp_target *target)
> >  
> >  	if (err != H_SUCCESS) {
> >  		eprintk("%ld transferring data error %p\n", err, iue);
> > -		done = 1;
> >  		goto out;
> >  	}
> 
> Replace that with:
>         if (err != H_SUCCESS) 
>                 eprintk("%ld transferring data error %p\n", err, iue);
>         else if (crq->format == VIOSRP_MAD_FORMAT)
>                 done = process_mad_iu(iue);
>         else
>                 done = process_srp_iu(iue);
> 
>         if (done)
>                 srp_iu_put(iue);
> 
> No more goto.

I think that using goto for an error path is common in Linux kernel
(and simple).


> Revised patch attached.
> 
> Signed-off-by: Bastian Blank <bastian at waldi.eu.org>

OK, thanks.


From waldi at berlios.de  Fri Apr  6 19:06:52 2007
From: waldi at berlios.de (Bastian Blank)
Date: Fri, 6 Apr 2007 19:06:52 +0200
Subject: [Stgt-devel] ibmvio - rdma error
In-Reply-To: <20070407013857S.fujita.tomonori@lab.ntt.co.jp>
References: <20070405084436.GA28380@wavehammer.waldi.eu.org>
	<20070407003634E.fujita.tomonori@lab.ntt.co.jp>
	<20070406161305.GA22606@wavehammer.waldi.eu.org>
	<20070407013857S.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070406170652.GA26391@wavehammer.waldi.eu.org>

On Sat, Apr 07, 2007 at 01:38:57AM +0900, FUJITA Tomonori wrote:
> > 256, not 128.
> 
> Are you sure 256 should work though it seems to work? We know 128
> works. If you definitely sure (e.g. you read the IBM document), I'm
> happy to use 256.

No, I don't have IBM documentation. Only two versions of ibmvscsis which
explicitely splits the transfers at 128k and two versions which don't
care at all.

> > Signed-off-by: Bastian Blank <bastian at waldi.eu.org>

Bastian

-- 
Deflector shields just came on, Captain.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070406/8bdd039b/attachment.pgp>

From brking at linux.vnet.ibm.com  Fri Apr  6 20:02:50 2007
From: brking at linux.vnet.ibm.com (Brian King)
Date: Fri, 06 Apr 2007 13:02:50 -0500
Subject: [Stgt-devel] ibmvio - rdma error
In-Reply-To: <20070407013857S.fujita.tomonori@lab.ntt.co.jp>
References: <20070405084436.GA28380@wavehammer.waldi.eu.org>
	<20070407003634E.fujita.tomonori@lab.ntt.co.jp>
	<20070406161305.GA22606@wavehammer.waldi.eu.org>
	<20070407013857S.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <46168B4A.6080007@linux.vnet.ibm.com>

FUJITA Tomonori wrote:
> From: Bastian Blank <waldi at berlios.de>
> Subject: Re: [Stgt-devel] ibmvio - rdma error
> Date: Fri, 6 Apr 2007 18:13:05 +0200
> 
>> On Sat, Apr 07, 2007 at 12:36:04AM +0900, FUJITA Tomonori wrote:
>>> diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
>>> index a7fbd10..46f9ca1 100644
>>> --- a/drivers/scsi/ibmvscsi/ibmvstgt.c
>>> +++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
>>> @@ -35,7 +35,7 @@
>>>  #include "ibmvscsi.h"
>>>  
>>>  #define	INITIAL_SRP_LIMIT	16
>>> -#define	DEFAULT_MAX_SECTORS	512
>>> +#define	DEFAULT_MAX_SECTORS	128
>> 256, not 128.
> 
> Are you sure 256 should work though it seems to work? We know 128
> works. If you definitely sure (e.g. you read the IBM document), I'm
> happy to use 256.

128k is the max rdma transfer size according to the spec,
so 256 should work fine.

Brian

-- 
Brian King
eServer Storage I/O
IBM Linux Technology Center


From fujita.tomonori at lab.ntt.co.jp  Sat Apr  7 10:26:56 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 7 Apr 2007 17:26:56 +0900 (JST)
Subject: [Stgt-devel] ibmvio - rdma error
In-Reply-To: <46168B4A.6080007@linux.vnet.ibm.com>
References: <20070406161305.GA22606@wavehammer.waldi.eu.org>
	<20070407013857S.fujita.tomonori@lab.ntt.co.jp>
	<46168B4A.6080007@linux.vnet.ibm.com>
Message-ID: <20070407164238A.fujita.tomonori@lab.ntt.co.jp>

From: Brian King <brking at linux.vnet.ibm.com>
Subject: Re: [Stgt-devel] ibmvio - rdma error
Date: Fri, 06 Apr 2007 13:02:50 -0500

> FUJITA Tomonori wrote:
> > From: Bastian Blank <waldi at berlios.de>
> > Subject: Re: [Stgt-devel] ibmvio - rdma error
> > Date: Fri, 6 Apr 2007 18:13:05 +0200
> > 
> >> On Sat, Apr 07, 2007 at 12:36:04AM +0900, FUJITA Tomonori wrote:
> >>> diff --git a/drivers/scsi/ibmvscsi/ibmvstgt.c b/drivers/scsi/ibmvscsi/ibmvstgt.c
> >>> index a7fbd10..46f9ca1 100644
> >>> --- a/drivers/scsi/ibmvscsi/ibmvstgt.c
> >>> +++ b/drivers/scsi/ibmvscsi/ibmvstgt.c
> >>> @@ -35,7 +35,7 @@
> >>>  #include "ibmvscsi.h"
> >>>  
> >>>  #define	INITIAL_SRP_LIMIT	16
> >>> -#define	DEFAULT_MAX_SECTORS	512
> >>> +#define	DEFAULT_MAX_SECTORS	128
> >> 256, not 128.
> > 
> > Are you sure 256 should work though it seems to work? We know 128
> > works. If you definitely sure (e.g. you read the IBM document), I'm
> > happy to use 256.
> 
> 128k is the max rdma transfer size according to the spec,
> so 256 should work fine.

Thanks a lot. That's what I want to know.


From waldi at berlios.de  Sun Apr  8 22:08:50 2007
From: waldi at berlios.de (Bastian Blank)
Date: Sun, 8 Apr 2007 22:08:50 +0200
Subject: [Stgt-devel] ibmvio - performance
Message-ID: <20070408200850.GA19258@wavehammer.waldi.eu.org>

Hi folks

I did some performance checks with bonnie and it seems that iscsi is faster
than ibmvscsi.

Target:
Version  1.03       ------Sequential Output------ --Sequential Input- --Random-
                    -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
Machine        Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
waldi.track.rz.u 2G           32124  17 18063   6           45815   4 324.6   0

Initiator, iSCSI:
Version  1.03       ------Sequential Output------ --Sequential Input- --Random-
                    -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
Machine        Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
kernel1          2G           31631  14 12809   4           39241   5 306.3   1

Initiator, ibmvio:
Version  1.03       ------Sequential Output------ --Sequential Input- --Random-
                    -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
Machine        Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
kernel1          2G           18513   9 16208   5           34003   3 221.4   0

Bastian

-- 
He's dead, Jim.
		-- McCoy, "The Devil in the Dark", stardate 3196.1
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070408/3f310ce7/attachment.pgp>

From waldi at berlios.de  Sun Apr  8 22:33:34 2007
From: waldi at berlios.de (Bastian Blank)
Date: Sun, 8 Apr 2007 22:33:34 +0200
Subject: [Stgt-devel] ibmvio - performance
In-Reply-To: <20070408200850.GA19258@wavehammer.waldi.eu.org>
References: <20070408200850.GA19258@wavehammer.waldi.eu.org>
Message-ID: <20070408203334.GA20785@wavehammer.waldi.eu.org>

On Sun, Apr 08, 2007 at 10:08:50PM +0200, Bastian Blank wrote:
> Target:
> Version  1.03       ------Sequential Output------ --Sequential Input- --Random-
>                     -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
> Machine        Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
> waldi.track.rz.u 2G           32124  17 18063   6           45815   4 324.6   0

To be correct, this is already an initiator which uses an old ibmvscsis. The
target gives the following:

Version  1.03       ------Sequential Output------ --Sequential Input- --Random-
                    -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
Machine        Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
vioserver.trac 472M           41362  23 19839   6           65798   8 462.4   0

Bastian

-- 
One does not thank logic.
		-- Sarek, "Journey to Babel", stardate 3842.4
-------------- next part --------------
A non-text attachment was scrubbed...
Name: signature.asc
Type: application/pgp-signature
Size: 197 bytes
Desc: Digital signature
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070408/bcdcc434/attachment.pgp>

From fujita.tomonori at lab.ntt.co.jp  Tue Apr 10 12:43:02 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 10 Apr 2007 19:43:02 +0900 (JST)
Subject: [Stgt-devel] ibmvio - broken after tgtd restart
In-Reply-To: <20070405153445.GA25132@wavehammer.waldi.eu.org>
References: <20070405153445.GA25132@wavehammer.waldi.eu.org>
Message-ID: <20070410173156J.fujita.tomonori@lab.ntt.co.jp>

From: Bastian Blank <waldi at berlios.de>
Subject: [Stgt-devel] ibmvio - broken after tgtd restart
Date: Thu, 5 Apr 2007 17:34:45 +0200

> Hi folks
> 
> Active ibmvio targets are broken after I restart tgtd.

You can't do that. tgtd is essential for ibmvio targets. It must run
while ibmvio targets are active.


> After an unload-load cycle of ibmvstgt it seems to works again and the client
> reports correctly:
> | ibmvscsi: partner initialized
> | ibmvscsic: sent SRP login
> | ibmvscsi: SRP_LOGIN succeeded
> | ibmvscsi: host srp version: 16.a, host partition XXX (YY), OS 2, max io 131072
> 
> But at least sometimes the client seems to hang.

If you see a client to hang when you don't try to restart tgtd, there
should be bugs.


From fujita.tomonori at lab.ntt.co.jp  Tue Apr 10 16:06:39 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 10 Apr 2007 23:06:39 +0900 (JST)
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
References: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
Message-ID: <20070410211856V.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] vtl patch.
Date: Thu, 5 Apr 2007 09:56:10 +1000

> Apologies for this being an attachment. It is rather large to include
> inline (57k).
> 
> Follow up to feedback from earlier postings, I have implemented the following:
> 
> 
> This patch includes the following changes.
> 
> - Patch to tgtadm so multiple '--name, --value' arguments can be passed.

Why do we need multiple arguments?

I prefer to keep the current semantics:

$ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
         -n VendorIdent -v QUANTUM
$ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
         -n ProductIdent -v SDLT600
$ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
         -n ProductRev -v 0001
$ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
         -n SerialNumber -v XYZZY10

rather than:

tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
	-n VendorIdent -v QUANTUM	\
	-n ProductIdent -v SDLT600	\
	-n ProductRev -v 0001		\
	-n SerialNumber -v XYZZY10


The rest looks ok.


From markh794 at gmail.com  Wed Apr 11 04:06:18 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 11 Apr 2007 12:06:18 +1000
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <20070410211856V.fujita.tomonori@lab.ntt.co.jp>
References: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
	<20070410211856V.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80704101906l4eb12375nfe687f184ce82fdf@mail.gmail.com>

On 4/11/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: [Stgt-devel] vtl patch.
> Date: Thu, 5 Apr 2007 09:56:10 +1000
>
> > Apologies for this being an attachment. It is rather large to include
> > inline (57k).
> >
> > Follow up to feedback from earlier postings, I have implemented the following:
> >
> >
> > This patch includes the following changes.
> >
> > - Patch to tgtadm so multiple '--name, --value' arguments can be passed.
>
> Why do we need multiple arguments?
>
> I prefer to keep the current semantics:
>
> $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
>          -n VendorIdent -v QUANTUM
> $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
>          -n ProductIdent -v SDLT600
> $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
>          -n ProductRev -v 0001
> $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
>          -n SerialNumber -v XYZZY10
>
> rather than:
>
> tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
>         -n VendorIdent -v QUANTUM       \
>         -n ProductIdent -v SDLT600      \
>         -n ProductRev -v 0001           \
>         -n SerialNumber -v XYZZY10
>
>
> The rest looks ok.
>

Thanks for the feedback.

While setting the Vendor Ident etc can be easly acheived one field at
a time, configuring the parameters for the SMC device requires
multiple parameters at the same time.


e.g.
> (Reserve address space for storage slots)
> --name=ElementType --value=[1|2|3]
> --name=StartAddress --value=number
> --name=Quanity --value=number
> --name=Sides --value=[1|2]          (Single/double sided)

I need to get the element type, starting address and number of slots
and if media is single/double sided (or at minimum, the element type
and the element address - if configuring a slot per instance of
tgtcmd)

> (To reserve address space for 'drives')
> --name=ElementType --value=4
> --name=StartAddress --value=number
> --name=Quanity --value=number
> --name=Type --value="ssc|mmc|sbc"

Again for slots which contain Data Transfer Elements, the element
type, slot number, type of 'data transfer element' needs to be passed
in 'one go'


Same basic argument for the two other configuration options below..

> (To 'tie' a previously known TID/LUN to a slot Address..)
> --name=ElementType --value=4
> --name=Address --value=<Within Range from above>
> --name=tid --value=<tid>
> --name=lun --value=<lun>
> --name=SerialNumber --value-<Device S/No>

> To 'populate' slots with 'media'
> --name=ElementType --value=[2|3]
> --name=Address --value=<slot number>
> --name=BarCode --value="string"


The only other way I can see to acheive this would be to create unique
options within tgtadm. The number of unique options within tgtadm is
already quite long, hence I followed the '--name=<> --value=<>'
option.

Cheers
Mark


From albert.pauw at gmail.com  Wed Apr 11 10:46:52 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Wed, 11 Apr 2007 10:46:52 +0200
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <f29db9a80704101906l4eb12375nfe687f184ce82fdf@mail.gmail.com>
References: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
	<20070410211856V.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80704101906l4eb12375nfe687f184ce82fdf@mail.gmail.com>
Message-ID: <b2919bc20704110146p4cd5670dka54abc20de8de1b0@mail.gmail.com>

Hi Mark,

it would be more readable if the value for ElementType is not a number,
but more symbolic:

MT or picker (Media Transport element)
ST or slot (Storage element)
IE or portal (Import/Export element)
DT or drive (Data Transfer element)

Using enumeration this can easily be converted internally.

Just my 2 cents.

Albert


On 4/11/07, Mark Harvey <markh794 at gmail.com> wrote:
>
> On 4/11/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > From: "Mark Harvey" <markh794 at gmail.com>
> > Subject: [Stgt-devel] vtl patch.
> > Date: Thu, 5 Apr 2007 09:56:10 +1000
> >
> > > Apologies for this being an attachment. It is rather large to include
> > > inline (57k).
> > >
> > > Follow up to feedback from earlier postings, I have implemented the
> following:
> > >
> > >
> > > This patch includes the following changes.
> > >
> > > - Patch to tgtadm so multiple '--name, --value' arguments can be
> passed.
> >
> > Why do we need multiple arguments?
> >
> > I prefer to keep the current semantics:
> >
> > $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> >          -n VendorIdent -v QUANTUM
> > $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> >          -n ProductIdent -v SDLT600
> > $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> >          -n ProductRev -v 0001
> > $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> >          -n SerialNumber -v XYZZY10
> >
> > rather than:
> >
> > tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> >         -n VendorIdent -v QUANTUM       \
> >         -n ProductIdent -v SDLT600      \
> >         -n ProductRev -v 0001           \
> >         -n SerialNumber -v XYZZY10
> >
> >
> > The rest looks ok.
> >
>
> Thanks for the feedback.
>
> While setting the Vendor Ident etc can be easly acheived one field at
> a time, configuring the parameters for the SMC device requires
> multiple parameters at the same time.
>
>
> e.g.
> > (Reserve address space for storage slots)
> > --name=ElementType --value=[1|2|3]
> > --name=StartAddress --value=number
> > --name=Quanity --value=number
> > --name=Sides --value=[1|2]          (Single/double sided)
>
> I need to get the element type, starting address and number of slots
> and if media is single/double sided (or at minimum, the element type
> and the element address - if configuring a slot per instance of
> tgtcmd)
>
> > (To reserve address space for 'drives')
> > --name=ElementType --value=4
> > --name=StartAddress --value=number
> > --name=Quanity --value=number
> > --name=Type --value="ssc|mmc|sbc"
>
> Again for slots which contain Data Transfer Elements, the element
> type, slot number, type of 'data transfer element' needs to be passed
> in 'one go'
>
>
> Same basic argument for the two other configuration options below..
>
> > (To 'tie' a previously known TID/LUN to a slot Address..)
> > --name=ElementType --value=4
> > --name=Address --value=<Within Range from above>
> > --name=tid --value=<tid>
> > --name=lun --value=<lun>
> > --name=SerialNumber --value-<Device S/No>
>
> > To 'populate' slots with 'media'
> > --name=ElementType --value=[2|3]
> > --name=Address --value=<slot number>
> > --name=BarCode --value="string"
>
>
> The only other way I can see to acheive this would be to create unique
> options within tgtadm. The number of unique options within tgtadm is
> already quite long, hence I followed the '--name=<> --value=<>'
> option.
>
> Cheers
> Mark
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070411/c79a7da8/attachment.html>

From fujita.tomonori at lab.ntt.co.jp  Wed Apr 11 13:18:37 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 11 Apr 2007 20:18:37 +0900 (JST)
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <f29db9a80704101906l4eb12375nfe687f184ce82fdf@mail.gmail.com>
References: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
	<20070410211856V.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80704101906l4eb12375nfe687f184ce82fdf@mail.gmail.com>
Message-ID: <20070411135308G.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] vtl patch.
Date: Wed, 11 Apr 2007 12:06:18 +1000

> On 4/11/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > From: "Mark Harvey" <markh794 at gmail.com>
> > Subject: [Stgt-devel] vtl patch.
> > Date: Thu, 5 Apr 2007 09:56:10 +1000
> >
> > > Apologies for this being an attachment. It is rather large to include
> > > inline (57k).
> > >
> > > Follow up to feedback from earlier postings, I have implemented the following:
> > >
> > >
> > > This patch includes the following changes.
> > >
> > > - Patch to tgtadm so multiple '--name, --value' arguments can be passed.
> >
> > Why do we need multiple arguments?
> >
> > I prefer to keep the current semantics:
> >
> > $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> >          -n VendorIdent -v QUANTUM
> > $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> >          -n ProductIdent -v SDLT600
> > $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> >          -n ProductRev -v 0001
> > $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> >          -n SerialNumber -v XYZZY10
> >
> > rather than:
> >
> > tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> >         -n VendorIdent -v QUANTUM       \
> >         -n ProductIdent -v SDLT600      \
> >         -n ProductRev -v 0001           \
> >         -n SerialNumber -v XYZZY10
> >
> >
> > The rest looks ok.
> >
> 
> Thanks for the feedback.
> 
> While setting the Vendor Ident etc can be easly acheived one field at
> a time, configuring the parameters for the SMC device requires
> multiple parameters at the same time.
> 
> 
> e.g.
> > (Reserve address space for storage slots)
> > --name=ElementType --value=[1|2|3]
> > --name=StartAddress --value=number
> > --name=Quanity --value=number
> > --name=Sides --value=[1|2]          (Single/double sided)
> 
> I need to get the element type, starting address and number of slots
> and if media is single/double sided (or at minimum, the element type
> and the element address - if configuring a slot per instance of
> tgtcmd)

I can't find "ElementType" in ssc3_config or smc_config. Will you
implement it later?

Do you need a configuration like 'only when X is true, Y is
necessary'?  I think that you can still do that with the current
semantics, 'one field at a time'. You just need to check whether the
configuration is valid when a user tries to start a target. Though
with a 'multiple fields at a time' scheme, the checking would be
a bit easier.

I don't like '--name a --value b --name b --value c ...' because it
doesn't look like the standard (GNU) option way.


From markh794 at gmail.com  Thu Apr 12 07:07:31 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 12 Apr 2007 15:07:31 +1000
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <20070411135308G.fujita.tomonori@lab.ntt.co.jp>
References: <f29db9a80704041656y106cff54y2d67b69527df22a@mail.gmail.com>
	<20070410211856V.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80704101906l4eb12375nfe687f184ce82fdf@mail.gmail.com>
	<20070411135308G.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80704112207w5c88236cg6b76e91b919cc3e8@mail.gmail.com>

On 4/11/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: Re: [Stgt-devel] vtl patch.
> Date: Wed, 11 Apr 2007 12:06:18 +1000
>
> > On 4/11/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > > From: "Mark Harvey" <markh794 at gmail.com>
> > > Subject: [Stgt-devel] vtl patch.
> > > Date: Thu, 5 Apr 2007 09:56:10 +1000
> > >
> > > > Apologies for this being an attachment. It is rather large to include
> > > > inline (57k).
> > > >
> > > > Follow up to feedback from earlier postings, I have implemented the following:
> > > >
> > > >
> > > > This patch includes the following changes.
> > > >
> > > > - Patch to tgtadm so multiple '--name, --value' arguments can be passed.
> > >
> > > Why do we need multiple arguments?
> > >
> > > I prefer to keep the current semantics:
> > >
> > > $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> > >          -n VendorIdent -v QUANTUM
> > > $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> > >          -n ProductIdent -v SDLT600
> > > $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> > >          -n ProductRev -v 0001
> > > $ tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> > >          -n SerialNumber -v XYZZY10
> > >
> > > rather than:
> > >
> > > tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
> > >         -n VendorIdent -v QUANTUM       \
> > >         -n ProductIdent -v SDLT600      \
> > >         -n ProductRev -v 0001           \
> > >         -n SerialNumber -v XYZZY10
> > >
> > >
> > > The rest looks ok.
> > >
> >
> > Thanks for the feedback.
> >
> > While setting the Vendor Ident etc can be easly acheived one field at
> > a time, configuring the parameters for the SMC device requires
> > multiple parameters at the same time.
> >
> >
> > e.g.
> > > (Reserve address space for storage slots)
> > > --name=ElementType --value=[1|2|3]
> > > --name=StartAddress --value=number
> > > --name=Quanity --value=number
> > > --name=Sides --value=[1|2]          (Single/double sided)
> >
> > I need to get the element type, starting address and number of slots
> > and if media is single/double sided (or at minimum, the element type
> > and the element address - if configuring a slot per instance of
> > tgtcmd)
>
> I can't find "ElementType" in ssc3_config or smc_config. Will you
> implement it later?

Yes. I am in the process of implementing the this now. Nothing that
actually compiles, let alone run.

I am working on implementing the MODE SENSE/MODE LOG command, with
initial config of page 0x1d (Element Address Assignment).

I hope to post something new tomorrow so what was previously
'theoretical' will have some code example with what I'm trying to
achieve.

> Do you need a configuration like 'only when X is true, Y is
> necessary'?  I think that you can still do that with the current
> semantics, 'one field at a time'. You just need to check whether the
> configuration is valid when a user tries to start a target. Though
> with a 'multiple fields at a time' scheme, the checking would be
> a bit easier.
>
> I don't like '--name a --value b --name b --value c ...' because it
> doesn't look like the standard (GNU) option way.

I can't say I like it either, however it does seem to be the cleanest
way.. I'm open to suggestions.


Only other idea I had was to group up all non-processed arguments from
the getopt_long(), re-format into a argc/argv[] type and pass this
thru to the SMC/SSC module for additional processing. This would allow
the SMC/SSC module to perform their own getopt_long()

Regards
Mark


From fujita.tomonori at lab.ntt.co.jp  Thu Apr 12 07:37:00 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 12 Apr 2007 14:37:00 +0900
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <f29db9a80704112207w5c88236cg6b76e91b919cc3e8@mail.gmail.com>
References: <f29db9a80704101906l4eb12375nfe687f184ce82fdf@mail.gmail.com>
	<20070411135308G.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80704112207w5c88236cg6b76e91b919cc3e8@mail.gmail.com>
Message-ID: <20070412143700B.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] vtl patch.
Date: Thu, 12 Apr 2007 15:07:31 +1000

> > I can't find "ElementType" in ssc3_config or smc_config. Will you
> > implement it later?
> 
> Yes. I am in the process of implementing the this now. Nothing that
> actually compiles, let alone run.
> 
> I am working on implementing the MODE SENSE/MODE LOG command, with
> initial config of page 0x1d (Element Address Assignment).
> 
> I hope to post something new tomorrow so what was previously
> 'theoretical' will have some code example with what I'm trying to
> achieve.

I see. Thanks.


> > Do you need a configuration like 'only when X is true, Y is
> > necessary'?  I think that you can still do that with the current
> > semantics, 'one field at a time'. You just need to check whether the
> > configuration is valid when a user tries to start a target. Though
> > with a 'multiple fields at a time' scheme, the checking would be
> > a bit easier.
> >
> > I don't like '--name a --value b --name b --value c ...' because it
> > doesn't look like the standard (GNU) option way.
> 
> I can't say I like it either, however it does seem to be the cleanest
> way.. I'm open to suggestions.
> 
> 
> Only other idea I had was to group up all non-processed arguments from
> the getopt_long(), re-format into a argc/argv[] type and pass this
> thru to the SMC/SSC module for additional processing. This would allow
> the SMC/SSC module to perform their own getopt_long()

How about somthing like this?

tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
        --params VendorIdent=QUANTUM,ProductIdent=SDLT600,ProductRev=0001


We can steal a parser for this from Linux kernel.


From blackmagic02881 at gmail.com  Thu Apr 12 15:00:17 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 12 Apr 2007 09:00:17 -0400
Subject: [Stgt-devel] vtl patch.
In-Reply-To: <20070412143700B.fujita.tomonori@lab.ntt.co.jp>
References: <f29db9a80704101906l4eb12375nfe687f184ce82fdf@mail.gmail.com>
	<20070411135308G.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80704112207w5c88236cg6b76e91b919cc3e8@mail.gmail.com>
	<20070412143700B.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <1176382817.3465.5.camel@fs0004.ibrix.com>

On Thu, 2007-04-12 at 14:37 +0900, FUJITA Tomonori wrote:
> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: Re: [Stgt-devel] vtl patch.
> Date: Thu, 12 Apr 2007 15:07:31 +1000
> 
> > > I can't find "ElementType" in ssc3_config or smc_config. Will you
> > > implement it later?
> > 
> > Yes. I am in the process of implementing the this now. Nothing that
> > actually compiles, let alone run.
> > 
> > I am working on implementing the MODE SENSE/MODE LOG command, with
> > initial config of page 0x1d (Element Address Assignment).
> > 
> > I hope to post something new tomorrow so what was previously
> > 'theoretical' will have some code example with what I'm trying to
> > achieve.
> 
> I see. Thanks.
> 
> 
> > > Do you need a configuration like 'only when X is true, Y is
> > > necessary'?  I think that you can still do that with the current
> > > semantics, 'one field at a time'. You just need to check whether the
> > > configuration is valid when a user tries to start a target. Though
> > > with a 'multiple fields at a time' scheme, the checking would be
> > > a bit easier.
> > >
> > > I don't like '--name a --value b --name b --value c ...' because it
> > > doesn't look like the standard (GNU) option way.
> > 
> > I can't say I like it either, however it does seem to be the cleanest
> > way.. I'm open to suggestions.
> > 
> > 
> > Only other idea I had was to group up all non-processed arguments from
> > the getopt_long(), re-format into a argc/argv[] type and pass this
> > thru to the SMC/SSC module for additional processing. This would allow
> > the SMC/SSC module to perform their own getopt_long()
> 
> How about somthing like this?
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
>         --params VendorIdent=QUANTUM,ProductIdent=SDLT600,ProductRev=0001
> 

this looks much better.

> 
> We can steal a parser for this from Linux kernel.
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From dougg at torque.net  Thu Apr 12 22:11:28 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Thu, 12 Apr 2007 16:11:28 -0400
Subject: [Stgt-devel] tgtif.c doesn't compile
Message-ID: <461E9270.7050703@torque.net>

cc -DIBMVIO -DUSE_KERNEL -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE -I../include -I/usr/src/linux/include -I.   -c -o tgtif.o tgtif.c
tgtif.c: In function ?kspace_send_cmd_res?:
tgtif.c:116: error: ?struct <anonymous>? has no member named ?sense_len?
tgtif.c:117: error: ?struct <anonymous>? has no member named ?sense_uaddr?
tgtif.c: In function ?kern_queue_cmd?:
tgtif.c:137: warning: pointer targets in assignment differ in signedness

The sense_len, sense_uaddr fields are not in scsi/scsi_tgt_if.h
in Linus, linux-2.6-block.git,bsg, or linux-2.6-target kernels.
Where else should I be looking?

Doug Gilbert


From markh794 at gmail.com  Thu Apr 12 23:28:04 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 13 Apr 2007 07:28:04 +1000
Subject: [Stgt-devel] VTL patch, take 2
Message-ID: <f29db9a80704121428m1ccf2dc1x49485fc77772c128@mail.gmail.com>

SSC / SMC patches to SCSI Tgt code.

It is based from git commit :
   ================================
commit 47e15c234ca298d31b1709db592eef9db4bce0ca
Author: Albert Pauw <albert.pauw at gmail.com>
Date:   Sat Apr 7 17:31:54 2007 +0900

    some shortcut options missing from tgtadm

    Signed-off-by: Albert Pauw <albert.pauw at gmail.com>
   ================================


Additions from last patch include :
 - Updated syntax to add/configure limited set of SMC / SSC parameters
 - Start implementing structures for MODE SELECT / MODE SENSE op codes
 - Start implementing structures for LOG SELECT / LOG SENSE op codes

 - SMC module includes:
   Allocation of MODE pages and initialization to default values.
   Ability to change Element Address Assignment



This is a work-in-progress and is being posted as an example of
where/how I'm attempting to implement a VTL.

I need to update command parameter passing to recommended use of
"--params ....."

Next step is to implement the SCSI MODE SENSE op code so I can
actually test what is being set is correct..

Note: in root of src is a 'tgt-setup' script which will (should)
correctly configure the SSC & SMC modules

As always, feedback welcome.

Regards
Mark
-------------- next part --------------
A non-text attachment was scrubbed...
Name: tgt-vtl.diff
Type: text/x-patch
Size: 71673 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070413/4fa66760/attachment.bin>

From dougg at torque.net  Fri Apr 13 00:14:27 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Thu, 12 Apr 2007 18:14:27 -0400
Subject: [Stgt-devel] VTL patch, take 2
In-Reply-To: <f29db9a80704121428m1ccf2dc1x49485fc77772c128@mail.gmail.com>
References: <f29db9a80704121428m1ccf2dc1x49485fc77772c128@mail.gmail.com>
Message-ID: <461EAF43.4090005@torque.net>

Mark Harvey wrote:
> SSC / SMC patches to SCSI Tgt code.
> 
> It is based from git commit :
>   ================================
> commit 47e15c234ca298d31b1709db592eef9db4bce0ca
> Author: Albert Pauw <albert.pauw at gmail.com>
> Date:   Sat Apr 7 17:31:54 2007 +0900
> 
>    some shortcut options missing from tgtadm
> 
>    Signed-off-by: Albert Pauw <albert.pauw at gmail.com>
>   ================================
> 
> 
> Additions from last patch include :
> - Updated syntax to add/configure limited set of SMC / SSC parameters
> - Start implementing structures for MODE SELECT / MODE SENSE op codes
> - Start implementing structures for LOG SELECT / LOG SENSE op codes

It will be interesting to see how you go with MODE SELECT
and LOG SELECT. As far as I can see it requires the SCSI
parser to:
  a) decode the "parameter list length" field in the
     cdb
  b) go away and fetch that much data from the data_out
  c) return to parser and process the parameter list
     together with other fields in the cdb

In the case of the SAS and FCP transports, step b)
probably means going all the way back to the
initiator (low level details: the target sends a XFER_RDY
frame to entice the initiator to send the data_out buffer).
There may be less work involved with iSCSI and SRP.

Folks who want persistent reservations will also want
this problem solved as PERSISTENT RESERVE OUT has the
same structure as MODE SELECT.

Doug Gilbert


From markh794 at gmail.com  Fri Apr 13 00:20:40 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 13 Apr 2007 08:20:40 +1000
Subject: [Stgt-devel] VTL patch, take 2
In-Reply-To: <461EAF43.4090005@torque.net>
References: <f29db9a80704121428m1ccf2dc1x49485fc77772c128@mail.gmail.com>
	<461EAF43.4090005@torque.net>
Message-ID: <f29db9a80704121520p29f6bec7p8895205a51369c8d@mail.gmail.com>

On 4/13/07, Douglas Gilbert <dougg at torque.net> wrote:
> Mark Harvey wrote:
> > SSC / SMC patches to SCSI Tgt code.
> >
> > It is based from git commit :
> >   ================================
> > commit 47e15c234ca298d31b1709db592eef9db4bce0ca
> > Author: Albert Pauw <albert.pauw at gmail.com>
> > Date:   Sat Apr 7 17:31:54 2007 +0900
> >
> >    some shortcut options missing from tgtadm
> >
> >    Signed-off-by: Albert Pauw <albert.pauw at gmail.com>
> >   ================================
> >
> >
> > Additions from last patch include :
> > - Updated syntax to add/configure limited set of SMC / SSC parameters
> > - Start implementing structures for MODE SELECT / MODE SENSE op codes
> > - Start implementing structures for LOG SELECT / LOG SENSE op codes
>
> It will be interesting to see how you go with MODE SELECT
> and LOG SELECT. As far as I can see it requires the SCSI
> parser to:
>   a) decode the "parameter list length" field in the
>      cdb
>   b) go away and fetch that much data from the data_out
>   c) return to parser and process the parameter list
>      together with other fields in the cdb
>
> In the case of the SAS and FCP transports, step b)
> probably means going all the way back to the
> initiator (low level details: the target sends a XFER_RDY
> frame to entice the initiator to send the data_out buffer).
> There may be less work involved with iSCSI and SRP.
>
> Folks who want persistent reservations will also want
> this problem solved as PERSISTENT RESERVE OUT has the
> same structure as MODE SELECT.
>
> Doug Gilbert
>

I'll let you know how I go..

It will either be tomorrow, or a little over a week. (Taking a weeks
break from computers, and taking the family on holidays :)

I managed to get this working without too much problems with the Intel
iSCSI reference code.. So the iSCSI initiator is doing the 'right
thing'

Cheers
Mark


From fujita.tomonori at lab.ntt.co.jp  Fri Apr 13 16:57:55 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 13 Apr 2007 23:57:55 +0900 (JST)
Subject: [Stgt-devel] tgtif.c doesn't compile
In-Reply-To: <461E9270.7050703@torque.net>
References: <461E9270.7050703@torque.net>
Message-ID: <20070413234547V.fujita.tomonori@lab.ntt.co.jp>

From: Douglas Gilbert <dougg at torque.net>
Subject: [Stgt-devel] tgtif.c doesn't compile
Date: Thu, 12 Apr 2007 16:11:28 -0400

> The sense_len, sense_uaddr fields are not in scsi/scsi_tgt_if.h
> in Linus, linux-2.6-block.git,bsg, or linux-2.6-target kernels.
> Where else should I be looking?

Please use James' scsi-misc master branch or linux-2.6-target tgt
branch.


From dougg at torque.net  Fri Apr 13 17:48:50 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Fri, 13 Apr 2007 11:48:50 -0400
Subject: [Stgt-devel] tgtif.c doesn't compile
In-Reply-To: <20070413234547V.fujita.tomonori@lab.ntt.co.jp>
References: <461E9270.7050703@torque.net>
	<20070413234547V.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <461FA662.8040507@torque.net>

FUJITA Tomonori wrote:
> From: Douglas Gilbert <dougg at torque.net>
> Subject: [Stgt-devel] tgtif.c doesn't compile
> Date: Thu, 12 Apr 2007 16:11:28 -0400
> 
>> The sense_len, sense_uaddr fields are not in scsi/scsi_tgt_if.h
>> in Linus, linux-2.6-block.git,bsg, or linux-2.6-target kernels.
>> Where else should I be looking?
> 
> Please use James' scsi-misc master branch or linux-2.6-target tgt
> branch.

Tomo,
Following a link from stgt.berlios.de I went here:
http://git.kernel.org/?p=linux/kernel/git/tomo/linux-2.6-target.git;a=summary

which shows this information:

description	scsi-target tree
owner	FUJITA Tomonori
last change	Thu, 22 Mar 2007 02:45:50 +0000
URL	git://git.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git
	http://www.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git


So I cloned that repository and it has only one branch: "main"

Doug Gilbert




From fujita.tomonori at lab.ntt.co.jp  Sat Apr 14 03:23:17 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 14 Apr 2007 10:23:17 +0900 (JST)
Subject: [Stgt-devel] tgtif.c doesn't compile
In-Reply-To: <461FA662.8040507@torque.net>
References: <461E9270.7050703@torque.net>
	<20070413234547V.fujita.tomonori@lab.ntt.co.jp>
	<461FA662.8040507@torque.net>
Message-ID: <20070414102144F.fujita.tomonori@lab.ntt.co.jp>

From: Douglas Gilbert <dougg at torque.net>
Subject: Re: [Stgt-devel] tgtif.c doesn't compile
Date: Fri, 13 Apr 2007 11:48:50 -0400

> FUJITA Tomonori wrote:
> > From: Douglas Gilbert <dougg at torque.net>
> > Subject: [Stgt-devel] tgtif.c doesn't compile
> > Date: Thu, 12 Apr 2007 16:11:28 -0400
> > 
> >> The sense_len, sense_uaddr fields are not in scsi/scsi_tgt_if.h
> >> in Linus, linux-2.6-block.git,bsg, or linux-2.6-target kernels.
> >> Where else should I be looking?
> > 
> > Please use James' scsi-misc master branch or linux-2.6-target tgt
> > branch.
> 
> Tomo,
> Following a link from stgt.berlios.de I went here:
> http://git.kernel.org/?p=linux/kernel/git/tomo/linux-2.6-target.git;a=summary
> 
> which shows this information:
> 
> description	scsi-target tree
> owner	FUJITA Tomonori
> last change	Thu, 22 Mar 2007 02:45:50 +0000
> URL	git://git.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git
> 	http://www.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git
> 
> 
> So I cloned that repository and it has only one branch: "main"

Strange. I just tried and it looks fine.

fujita at iris:/tmp$ git-clone git://git.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git
remote: Generating pack...
remote: Done counting 442181 objects.
remote: Deltifying 442181 objects.
remote:  100% (442181/442181) done
remote: Total 442181 (delta 353734), reused 424382 (delta 335945)
Checking files out...
 100% (21617/21617) done
fujita at iris:/tmp$ cd linux-2.6-target/
fujita at iris:/tmp/linux-2.6-target$ git-branch
* master
  origin
  sgv3
  tgt
fujita at iris:/tmp/linux-2.6-target$ git-checkout tgt
fujita at iris:/tmp/linux-2.6-target$ grep sense_len include/scsi/scsi_tgt_if.h
                        uint32_t sense_len;



From dougg at torque.net  Sat Apr 14 06:07:44 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Sat, 14 Apr 2007 00:07:44 -0400
Subject: [Stgt-devel] tgtif.c doesn't compile
In-Reply-To: <20070414102144F.fujita.tomonori@lab.ntt.co.jp>
References: <461E9270.7050703@torque.net>	<20070413234547V.fujita.tomonori@lab.ntt.co.jp>	<461FA662.8040507@torque.net>
	<20070414102144F.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <46205390.3070109@torque.net>

FUJITA Tomonori wrote:
> From: Douglas Gilbert <dougg at torque.net>
> Subject: Re: [Stgt-devel] tgtif.c doesn't compile
> Date: Fri, 13 Apr 2007 11:48:50 -0400
> 
>> FUJITA Tomonori wrote:
>>> From: Douglas Gilbert <dougg at torque.net>
>>> Subject: [Stgt-devel] tgtif.c doesn't compile
>>> Date: Thu, 12 Apr 2007 16:11:28 -0400
>>>
>>>> The sense_len, sense_uaddr fields are not in scsi/scsi_tgt_if.h
>>>> in Linus, linux-2.6-block.git,bsg, or linux-2.6-target kernels.
>>>> Where else should I be looking?
>>> Please use James' scsi-misc master branch or linux-2.6-target tgt
>>> branch.
>> Tomo,
>> Following a link from stgt.berlios.de I went here:
>> http://git.kernel.org/?p=linux/kernel/git/tomo/linux-2.6-target.git;a=summary
>>
>> which shows this information:
>>
>> description	scsi-target tree
>> owner	FUJITA Tomonori
>> last change	Thu, 22 Mar 2007 02:45:50 +0000
>> URL	git://git.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git
>> 	http://www.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git
>>
>>
>> So I cloned that repository and it has only one branch: "main"
> 
> Strange. I just tried and it looks fine.
> 
> fujita at iris:/tmp$ git-clone git://git.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git
> remote: Generating pack...
> remote: Done counting 442181 objects.
> remote: Deltifying 442181 objects.
> remote:  100% (442181/442181) done
> remote: Total 442181 (delta 353734), reused 424382 (delta 335945)
> Checking files out...
>  100% (21617/21617) done
> fujita at iris:/tmp$ cd linux-2.6-target/
> fujita at iris:/tmp/linux-2.6-target$ git-branch
> * master
>   origin
>   sgv3
>   tgt
> fujita at iris:/tmp/linux-2.6-target$ git-checkout tgt
> fujita at iris:/tmp/linux-2.6-target$ grep sense_len include/scsi/scsi_tgt_if.h
>                         uint32_t sense_len;

Tomo,
And I just tried it again:

[root at target git]# git clone git://git.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git linux-2.6-target
Initialized empty Git repository in /usr/src/git/linux-2.6-target/.git/
remote: Generating pack...
remote: Done counting 442181 objects.
remote: Deltifying 442181 objects.
remote:  100% (442181/442181) done
Indexing 442181 objects.
remote: Total 442181 (delta 353734), reused 424382 (delta 335945)
 100% (442181/442181) done
Resolving 353734 deltas.
 100% (353734/353734) done
Checking files out...
 100% (21617/21617) done

[root at target git]# cd linux-2.6-target
[root at target linux-2.6-target]# git branch
* master
[root at target linux-2.6-target]# git --version
git version 1.5.0.6


Doug Gilbert



From fujita.tomonori at lab.ntt.co.jp  Sun Apr 15 06:12:55 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 15 Apr 2007 13:12:55 +0900
Subject: [Stgt-devel] tgtif.c doesn't compile
In-Reply-To: <46205390.3070109@torque.net>
References: <461FA662.8040507@torque.net>
	<20070414102144F.fujita.tomonori@lab.ntt.co.jp>
	<46205390.3070109@torque.net>
Message-ID: <200704150412.l3F4CxVK023061@r-dd.iij4u.or.jp>

From: Douglas Gilbert <dougg at torque.net>
Subject: Re: [Stgt-devel] tgtif.c doesn't compile
Date: Sat, 14 Apr 2007 00:07:44 -0400

> FUJITA Tomonori wrote:
> > From: Douglas Gilbert <dougg at torque.net>
> > Subject: Re: [Stgt-devel] tgtif.c doesn't compile
> > Date: Fri, 13 Apr 2007 11:48:50 -0400
> > 
> >> FUJITA Tomonori wrote:
> >>> From: Douglas Gilbert <dougg at torque.net>
> >>> Subject: [Stgt-devel] tgtif.c doesn't compile
> >>> Date: Thu, 12 Apr 2007 16:11:28 -0400
> >>>
> >>>> The sense_len, sense_uaddr fields are not in scsi/scsi_tgt_if.h
> >>>> in Linus, linux-2.6-block.git,bsg, or linux-2.6-target kernels.
> >>>> Where else should I be looking?
> >>> Please use James' scsi-misc master branch or linux-2.6-target tgt
> >>> branch.
> >> Tomo,
> >> Following a link from stgt.berlios.de I went here:
> >> http://git.kernel.org/?p=linux/kernel/git/tomo/linux-2.6-target.git;a=summary
> >>
> >> which shows this information:
> >>
> >> description	scsi-target tree
> >> owner	FUJITA Tomonori
> >> last change	Thu, 22 Mar 2007 02:45:50 +0000
> >> URL	git://git.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git
> >> 	http://www.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git
> >>
> >>
> >> So I cloned that repository and it has only one branch: "main"
> > 
> > Strange. I just tried and it looks fine.
> > 
> > fujita at iris:/tmp$ git-clone git://git.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git
> > remote: Generating pack...
> > remote: Done counting 442181 objects.
> > remote: Deltifying 442181 objects.
> > remote:  100% (442181/442181) done
> > remote: Total 442181 (delta 353734), reused 424382 (delta 335945)
> > Checking files out...
> >  100% (21617/21617) done
> > fujita at iris:/tmp$ cd linux-2.6-target/
> > fujita at iris:/tmp/linux-2.6-target$ git-branch
> > * master
> >   origin
> >   sgv3
> >   tgt
> > fujita at iris:/tmp/linux-2.6-target$ git-checkout tgt
> > fujita at iris:/tmp/linux-2.6-target$ grep sense_len include/scsi/scsi_tgt_if.h
> >                         uint32_t sense_len;
> 
> Tomo,
> And I just tried it again:
> 
> [root at target git]# git clone git://git.kernel.org/pub/scm/linux/kernel/git/tomo/linux-2.6-target.git linux-2.6-target
> Initialized empty Git repository in /usr/src/git/linux-2.6-target/.git/
> remote: Generating pack...
> remote: Done counting 442181 objects.
> remote: Deltifying 442181 objects.
> remote:  100% (442181/442181) done
> Indexing 442181 objects.
> remote: Total 442181 (delta 353734), reused 424382 (delta 335945)
>  100% (442181/442181) done
> Resolving 353734 deltas.
>  100% (353734/353734) done
> Checking files out...
>  100% (21617/21617) done
> 
> [root at target git]# cd linux-2.6-target
> [root at target linux-2.6-target]# git branch
> * master

Sorry, I have no idea why it doesn't work for you.

Anyway, you can use James' scsi-misc tree. BTW, I rebased my tree so
it might work for you this time.


From fujita.tomonori at lab.ntt.co.jp  Sun Apr 15 06:37:07 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 15 Apr 2007 13:37:07 +0900
Subject: [Stgt-devel] AIO code is removed
Message-ID: <200704150437.l3F4bBuL024038@r-dd.iij4u.or.jp>

The iSCSI driver used AIO, however it has been painful:

- not rock solid
- no unified event notification
- no page-cache AIO support
- no AIO FSYNC support

The first issue is critical and the third and forth issues hurt
scalability and performance, though we can live with the third one.

I added new backing store code, bs_sync, which uses pthread and
synchronous I/Os though I don't like to play with pthread.

Now the iSCSI driver uses bs_sync code by default. Please test it.


From fujita.tomonori at lab.ntt.co.jp  Sun Apr 15 06:51:22 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 15 Apr 2007 13:51:22 +0900
Subject: [Stgt-devel] add it_nexus support
Message-ID: <200704150451.l3F4pPTo024457@r-dd.iij4u.or.jp>

tgt uses scsi host_no as it_nexus. This works for ibmvstgt because it
creates one scsi host for one it_nexus. However, this doesn't work for
some target drivers.

I added it_nexus support and modified ibmvstgt to use it. It needs to
be polished before it goes to scsi-ml. But I applied this to my trees
since this has been long overdue and some people want to try it, I
guess.

The user/kernel interface was changed so get and compile the latest
user-space and kernel-space code.


From albert.pauw at gmail.com  Sun Apr 15 11:33:27 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Sun, 15 Apr 2007 11:33:27 +0200
Subject: [Stgt-devel] FirstBurstLenght > MaxBurstLength --> error
Message-ID: <4621F167.3070504@gmail.com>

Running the test regression script of open-iscsi on stgt I found an 
error, which I did not encounter with other targets.

It is test #17 with the following parameters:

================== TEST #17 BEGIN ====================
ImmediateData = No
InitialR2T = No
HeaderDigest = None
DataDigest = None
FirstBurstLength = 8192
MaxBurstLength = 4096
MaxRecvDataSegmentLength = 4096
MaxOutstandingR2T = 1

I get the error "Invalid burst lengths first_burst 8192 max_burst 4096" 
in /var/log/messages and the login breaks of.
According to the RFC 3720 "FirstBurstLength MUST NOT exceed 
MaxBurstLength" (chap 12.14), which means that the target
should answer back with a FirstBurstLenght parameters equal to 
MaxBurstLenght.

I investigated with wireshark and found that this is exactly the 
behaviour of the Wasabi Storagebuilder target,
iscsi-target silently accepts FirstBurstLength > MaxBurstLength, and 
stgt only gives an error.

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070415/0487a12e/attachment.html>

From fujita.tomonori at lab.ntt.co.jp  Sun Apr 15 15:42:02 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 15 Apr 2007 22:42:02 +0900
Subject: [Stgt-devel] [PATCH] iSNS support
Message-ID: <200704151342.l3FDg6Bd011205@r-dd.iij4u.or.jp>

Somehow I need iSNS in tgt now.

I know that IET iSNS code has some problems (e.g. can't handle errors
properly), however, I just modified it for tgt. It needs to be fixed
later on.

Before I apply this, I need to find how tgt supports iSNS
configurations; tgtd boot options or via tgt.

Note that this patch requires you to modify the code to configure the
iSNS server address (see usr/iscsi/transport.c).



From fujita.tomonori at lab.ntt.co.jp  Sun Apr 15 15:24:43 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 15 Apr 2007 22:24:43 +0900
Subject: [PATCH] add iSNS support
Message-ID: <mailman.5.1331738469.12506.stgt-devel@lists.berlios.de>

Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
---
 usr/Makefile           |    2 +-
 usr/iscsi/iscsid.h     |   10 +
 usr/iscsi/isns.c       |  958 ++++++++++++++++++++++++++++++++++++++++++++++++
 usr/iscsi/isns_proto.h |  200 ++++++++++
 usr/iscsi/target.c     |   15 +-
 usr/iscsi/transport.c  |    6 +
 6 files changed, 1185 insertions(+), 6 deletions(-)

diff --git a/usr/Makefile b/usr/Makefile
index 96535f9..2685cb4 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -35,7 +35,7 @@ endif
 ifneq ($(ISCSI),)
 CFLAGS += -DISCSI
 TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o iscsid.o target.o \
-	chap.o transport.o iscsi_tcp.o)
+	chap.o transport.o iscsi_tcp.o isns.o)
 TGTD_OBJS += bs_sync.o
 LIBS += -lcrypto -lpthread
 endif
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 65e8710..b61b6b2 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -238,6 +238,8 @@ struct iscsi_target {
 
 	int max_nr_sessions;
 	int nr_sessions;
+
+	struct list_head isns_list;
 };
 
 enum task_flags {
@@ -249,6 +251,7 @@ enum task_flags {
 #define task_pending(t)		((t)->flags & (1 << TASK_pending))
 
 extern int lld_index;
+extern struct list_head iscsi_targets_list;
 
 /* chap.c */
 extern int cmnd_exec_auth_chap(struct iscsi_connection *conn);
@@ -295,6 +298,13 @@ int param_index_by_name(char *name, struct iscsi_key *keys);
 /* transport.c */
 extern int iscsi_init(int);
 
+/* isns.c */
+extern int isns_init(char *addr, int isns_ac);
+extern int isns_scn_access(int tid, int fd, char *name);
+extern int isns_target_register(char *name);
+extern int isns_target_deregister(char *name);
+extern void isns_exit(void);
+
 #define buffer_check(buf, total, len, rest)	\
 ({						\
 	buf += len;				\
diff --git a/usr/iscsi/isns.c b/usr/iscsi/isns.c
new file mode 100644
index 0000000..8e21813
--- /dev/null
+++ b/usr/iscsi/isns.c
@@ -0,0 +1,958 @@
+/*
+ * iSNS functions
+ *
+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <errno.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <sys/socket.h>
+#include <sys/epoll.h>
+#include <sys/types.h>
+
+#include "iscsid.h"
+#include "tgtd.h"
+#include "work.h"
+#include "list.h"
+#include "isns_proto.h"
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#define BUFSIZE (1 << 18)
+
+struct isns_io {
+	char *buf;
+	int offset;
+};
+
+struct isns_qry_mgmt {
+	char name[ISCSI_NAME_LEN];
+	uint16_t transaction;
+	struct list_head qlist;
+};
+
+struct isns_initiator {
+	char name[ISCSI_NAME_LEN];
+	struct list_head ilist;
+};
+
+struct tgt_work timeout_work;
+
+static LIST_HEAD(qry_list);
+static uint16_t scn_listen_port;
+static int use_isns, use_isns_ac, isns_fd, scn_listen_fd, scn_fd;
+static struct isns_io isns_rx, scn_rx;
+static char *rxbuf;
+static uint16_t transaction;
+static uint32_t isns_timeout = 30; /* seconds */
+static char eid[ISCSI_NAME_LEN];
+static uint8_t ip[16]; /* IET supoprts only one portal */
+static struct sockaddr_storage ss;
+
+int isns_scn_access(int tid, int fd, char *name)
+{
+	struct isns_initiator *ini;
+	struct iscsi_target *target = target_find_by_id(tid);
+
+	if (!use_isns || !use_isns_ac)
+		return 0;
+
+	if (!target)
+		return -EPERM;
+
+	list_for_each_entry(ini, &target->isns_list, ilist) {
+		if (!strcmp(ini->name, name))
+			return 0;
+	}
+	return -EPERM;
+}
+
+static int isns_get_ip(int fd)
+{
+	int err, i;
+	uint32_t addr;
+	struct sockaddr_storage lss;
+	socklen_t slen = sizeof(lss);
+
+	err = getsockname(fd, (struct sockaddr *) &lss, &slen);
+	if (err) {
+		eprintf("getsockname error %s!\n", gai_strerror(err));
+		return err;
+	}
+
+	err = getnameinfo((struct sockaddr *) &lss, sizeof(lss),
+			  eid, sizeof(eid), NULL, 0, 0);
+	if (err) {
+		eprintf("getaddrinfo error %s!\n", gai_strerror(err));
+		return err;
+	}
+
+	switch (lss.ss_family) {
+	case AF_INET:
+		addr = (((struct sockaddr_in *) &lss)->sin_addr.s_addr);
+
+		ip[10] = ip[11] = 0xff;
+		ip[15] = 0xff & (addr >> 24);
+		ip[14] = 0xff & (addr >> 16);
+		ip[13] = 0xff & (addr >> 8);
+		ip[12] = 0xff & addr;
+		break;
+	case AF_INET6:
+		for (i = 0; i < ARRAY_SIZE(ip); i++)
+			ip[i] = ((struct sockaddr_in6 *) &lss)->sin6_addr.s6_addr[i];
+		break;
+	}
+
+	return 0;
+}
+
+static void isns_handle(int fd, int events, void *data);
+
+static int isns_connect(void)
+{
+	int fd, err;
+
+	fd = socket(ss.ss_family, SOCK_STREAM, IPPROTO_TCP);
+	if (fd < 0) {
+		eprintf("unable to create (%s) %d!\n", strerror(errno),
+			ss.ss_family);
+		return -1;
+	}
+
+	err = connect(fd, (struct sockaddr *) &ss, sizeof(ss));
+	if (err < 0) {
+		eprintf("unable to connect (%s) %d!\n", strerror(errno),
+			ss.ss_family);
+		close(fd);
+		return -1;
+	}
+
+	eprintf("new connection %d\n", fd);
+
+	if (!strlen(eid)) {
+		err = isns_get_ip(fd);
+		if (err) {
+			close(fd);
+			return -1;
+		}
+	}
+
+	isns_fd = fd;
+	tgt_event_add(fd, EPOLLIN, isns_handle, NULL);
+
+	return fd;
+}
+
+static void isns_hdr_init(struct isns_hdr *hdr, uint16_t function,
+			  uint16_t length, uint16_t flags,
+			  uint16_t trans, uint16_t sequence)
+{
+	hdr->version = htons(0x0001);
+	hdr->function = htons(function);
+	hdr->length = htons(length);
+	hdr->flags = htons(flags);
+	hdr->transaction = htons(trans);
+	hdr->sequence = htons(sequence);
+}
+
+static int isns_tlv_set(struct isns_tlv **tlv, uint32_t tag, uint32_t length,
+			void *value)
+{
+	if (length)
+		memcpy((*tlv)->value, value, length);
+	if (length % ISNS_ALIGN)
+		length += (ISNS_ALIGN - (length % ISNS_ALIGN));
+
+	(*tlv)->tag = htonl(tag);
+	(*tlv)->length = htonl(length);
+
+	length += sizeof(struct isns_tlv);
+	*tlv = (struct isns_tlv *) ((char *) *tlv + length);
+
+	return length;
+}
+
+static int isns_scn_deregister(char *name)
+{
+	int err;
+	uint16_t flags, length = 0;
+	char buf[2048];
+	struct isns_hdr *hdr = (struct isns_hdr *) buf;
+	struct isns_tlv *tlv;
+
+	if (!isns_fd)
+		if (isns_connect() < 0)
+			return 0;
+
+	memset(buf, 0, sizeof(buf));
+	tlv = (struct isns_tlv *) hdr->pdu;
+
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME, strlen(name), name);
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME, strlen(name), name);
+
+	flags = ISNS_FLAG_CLIENT | ISNS_FLAG_LAST_PDU | ISNS_FLAG_FIRST_PDU;
+	isns_hdr_init(hdr, ISNS_FUNC_SCN_DEREG, length, flags,
+		      ++transaction, 0);
+
+	err = write(isns_fd, buf, length + sizeof(struct isns_hdr));
+	if (err < 0)
+		eprintf("%d %m\n", length);
+
+	return 0;
+}
+
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define set_scn_flag(x)						\
+{								\
+	x = (x & 0x55555555) << 1 | (x & 0xaaaaaaaa) >> 1;	\
+	x = (x & 0x33333333) << 2 | (x & 0xcccccccc) >> 2;	\
+	x = (x & 0x0f0f0f0f) << 4 | (x & 0xf0f0f0f0) >> 4;	\
+	x = (x & 0x00ff00ff) << 8 | (x & 0xff00ff00) >> 8;	\
+	x = (x & 0x0000ffff) << 16 | (x & 0xffff0000) >> 16;	\
+}
+#else
+#define set_scn_flag(x) (x)
+#endif
+
+static int isns_scn_register(void)
+{
+	int err;
+	uint16_t flags, length = 0;
+	uint32_t scn_flags;
+	char buf[4096], *name;
+	struct isns_hdr *hdr = (struct isns_hdr *) buf;
+	struct isns_tlv *tlv;
+	struct iscsi_target *target;
+
+	if (list_empty(&iscsi_targets_list))
+		return 0;
+
+	if (!isns_fd)
+		if (isns_connect() < 0)
+			return 0;
+
+	memset(buf, 0, sizeof(buf));
+	tlv = (struct isns_tlv *) hdr->pdu;
+
+	target = list_entry(iscsi_targets_list.next, struct iscsi_target, tlist);
+	name = tgt_targetname(target->tid);
+
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME, strlen(name), name);
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME, strlen(name), name);
+	length += isns_tlv_set(&tlv, 0, 0, 0);
+
+	scn_flags = ISNS_SCN_FLAG_INITIATOR | ISNS_SCN_FLAG_OBJECT_REMOVE |
+		ISNS_SCN_FLAG_OBJECT_ADDED | ISNS_SCN_FLAG_OBJECT_UPDATED;
+	scn_flags = htonl(set_scn_flag(scn_flags));
+
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_SCN_BITMAP,
+			       sizeof(scn_flags), &scn_flags);
+
+	flags = ISNS_FLAG_CLIENT | ISNS_FLAG_LAST_PDU | ISNS_FLAG_FIRST_PDU;
+	isns_hdr_init(hdr, ISNS_FUNC_SCN_REG, length, flags, ++transaction, 0);
+
+	err = write(isns_fd, buf, length + sizeof(struct isns_hdr));
+	if (err < 0)
+		eprintf("%d %m\n", length);
+
+	return 0;
+}
+
+static int isns_attr_query(char *name)
+{
+	int err;
+	uint16_t flags, length = 0;
+	char buf[4096];
+	struct isns_hdr *hdr = (struct isns_hdr *) buf;
+	struct isns_tlv *tlv;
+	struct iscsi_target *target;
+	uint32_t node = htonl(ISNS_NODE_INITIATOR);
+	struct isns_qry_mgmt *mgmt;
+
+	if (list_empty(&iscsi_targets_list))
+		return 0;
+
+	if (!isns_fd)
+		if (isns_connect() < 0)
+			return 0;
+
+	mgmt = malloc(sizeof(*mgmt));
+	if (!mgmt)
+		return 0;
+	list_add(&mgmt->qlist, &qry_list);
+
+	memset(buf, 0, sizeof(buf));
+	tlv = (struct isns_tlv *) hdr->pdu;
+
+	if (name)
+		snprintf(mgmt->name, sizeof(mgmt->name), name);
+	else {
+		mgmt->name[0] = '\0';
+		target = list_entry(iscsi_targets_list.next, struct iscsi_target, tlist);
+		name = tgt_targetname(target->tid);
+	}
+
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME, strlen(name), name);
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NODE_TYPE,
+			       sizeof(node), &node);
+	length += isns_tlv_set(&tlv, 0, 0, 0);
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME, 0, 0);
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NODE_TYPE, 0, 0);
+	length += isns_tlv_set(&tlv, ISNS_ATTR_PORTAL_IP_ADDRESS, 0, 0);
+
+	flags = ISNS_FLAG_CLIENT | ISNS_FLAG_LAST_PDU | ISNS_FLAG_FIRST_PDU;
+	isns_hdr_init(hdr, ISNS_FUNC_DEV_ATTR_QRY, length, flags,
+		      ++transaction, 0);
+	mgmt->transaction = transaction;
+
+	err = write(isns_fd, buf, length + sizeof(struct isns_hdr));
+	if (err < 0)
+		eprintf("%d %m\n", length);
+
+	return 0;
+}
+
+static int isns_deregister(void)
+{
+	int err;
+	uint16_t flags, length = 0;
+	char buf[4096], *name;
+	struct isns_hdr *hdr = (struct isns_hdr *) buf;
+	struct isns_tlv *tlv;
+	struct iscsi_target *target;
+
+	if (list_empty(&iscsi_targets_list))
+		return 0;
+
+	if (!isns_fd)
+		if (isns_connect() < 0)
+			return 0;
+
+	memset(buf, 0, sizeof(buf));
+	tlv = (struct isns_tlv *) hdr->pdu;
+
+	target = list_entry(iscsi_targets_list.next, struct iscsi_target, tlist);
+	name = tgt_targetname(target->tid);
+
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME, strlen(name), name);
+	length += isns_tlv_set(&tlv, 0, 0, 0);
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ENTITY_IDENTIFIER,
+			       strlen(eid), eid);
+
+	flags = ISNS_FLAG_CLIENT | ISNS_FLAG_LAST_PDU | ISNS_FLAG_FIRST_PDU;
+	isns_hdr_init(hdr, ISNS_FUNC_DEV_DEREG, length, flags,
+		      ++transaction, 0);
+
+	err = write(isns_fd, buf, length + sizeof(struct isns_hdr));
+	if (err < 0)
+		eprintf("%d %m\n", length);
+	return 0;
+}
+
+static inline int list_length_is_one(const struct list_head *head)
+{
+        return head->next == head->prev;
+}
+
+int isns_target_register(char *name)
+{
+	char buf[4096];
+	uint16_t flags = 0, length = 0;
+	struct isns_hdr *hdr = (struct isns_hdr *) buf;
+	struct isns_tlv *tlv;
+	uint32_t port = htonl(ISCSI_LISTEN_PORT);
+	uint32_t node = htonl(ISNS_NODE_TARGET);
+	uint32_t type = htonl(2);
+	struct iscsi_target *target;
+	int err, initial = list_length_is_one(&iscsi_targets_list);
+
+	if (!use_isns)
+		return 0;
+
+	if (!isns_fd)
+		if (isns_connect() < 0)
+			return 0;
+
+	memset(buf, 0, sizeof(buf));
+	tlv = (struct isns_tlv *) hdr->pdu;
+
+        target = list_entry(iscsi_targets_list.next, struct iscsi_target, tlist);
+        length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME,
+			       strlen(tgt_targetname(target->tid)),
+			       tgt_targetname(target->tid));
+
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ENTITY_IDENTIFIER,
+			       strlen(eid), eid);
+
+	length += isns_tlv_set(&tlv, 0, 0, 0);
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ENTITY_IDENTIFIER,
+			       strlen(eid), eid);
+	if (initial) {
+		length += isns_tlv_set(&tlv, ISNS_ATTR_ENTITY_PROTOCOL,
+				       sizeof(type), &type);
+		length += isns_tlv_set(&tlv, ISNS_ATTR_PORTAL_IP_ADDRESS,
+				       sizeof(ip), &ip);
+		length += isns_tlv_set(&tlv, ISNS_ATTR_PORTAL_PORT,
+				       sizeof(port), &port);
+		flags = ISNS_FLAG_REPLACE;
+
+		if (scn_listen_port) {
+			uint32_t sport = htonl(scn_listen_port);
+			length += isns_tlv_set(&tlv, ISNS_ATTR_SCN_PORT,
+					       sizeof(sport), &sport);
+		}
+	}
+
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME, strlen(name), name);
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NODE_TYPE,
+			       sizeof(node), &node);
+
+	flags |= ISNS_FLAG_CLIENT | ISNS_FLAG_LAST_PDU | ISNS_FLAG_FIRST_PDU;
+	isns_hdr_init(hdr, ISNS_FUNC_DEV_ATTR_REG, length, flags,
+		      ++transaction, 0);
+
+	err = write(isns_fd, buf, length + sizeof(struct isns_hdr));
+	if (err < 0)
+		eprintf("%d %m\n", length);
+
+	if (scn_listen_port)
+		isns_scn_register();
+
+	isns_attr_query(name);
+
+	return 0;
+}
+
+static void free_all_acl(struct iscsi_target *target)
+{
+	struct isns_initiator *ini;
+
+	while (!list_empty(&target->isns_list)) {
+		ini = list_entry(target->isns_list.next, typeof(*ini), ilist);
+		list_del(&ini->ilist);
+	}
+}
+
+int isns_target_deregister(char *name)
+{
+	char buf[4096];
+	uint16_t flags, length = 0;
+	struct isns_hdr *hdr = (struct isns_hdr *) buf;
+	struct isns_tlv *tlv;
+	int err, last = list_empty(&iscsi_targets_list);
+	struct iscsi_target *target;
+
+	target = target_find_by_name(name);
+	if (target)
+		free_all_acl(target);
+
+	if (!use_isns)
+		return 0;
+
+	if (!isns_fd)
+		if (isns_connect() < 0)
+			return 0;
+
+	isns_scn_deregister(name);
+
+	memset(buf, 0, sizeof(buf));
+	tlv = (struct isns_tlv *) hdr->pdu;
+
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME, strlen(name), name);
+	length += isns_tlv_set(&tlv, 0, 0, 0);
+	if (last)
+		length += isns_tlv_set(&tlv, ISNS_ATTR_ENTITY_IDENTIFIER,
+				       strlen(eid), eid);
+	else
+		length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME,
+				       strlen(name), name);
+
+	flags = ISNS_FLAG_CLIENT | ISNS_FLAG_LAST_PDU | ISNS_FLAG_FIRST_PDU;
+	isns_hdr_init(hdr, ISNS_FUNC_DEV_DEREG, length, flags,
+		      ++transaction, 0);
+
+	err = write(isns_fd, buf, length + sizeof(struct isns_hdr));
+	if (err < 0)
+		eprintf("%d %m\n", length);
+
+	return 0;
+}
+
+static int recv_hdr(int fd, struct isns_io *rx, struct isns_hdr *hdr)
+{
+	int err;
+
+	if (rx->offset < sizeof(*hdr)) {
+		err = read(fd, rx->buf + rx->offset,
+			   sizeof(*hdr) - rx->offset);
+		if (err < 0) {
+			if (errno == EAGAIN || errno == EINTR)
+				return -EAGAIN;
+			eprintf("header read error %d %d %d %d\n",
+				fd, err, errno, rx->offset);
+			return -1;
+		} else if (err == 0)
+			return -1;
+
+		dprintf("header %d %d bytes!\n", fd, err);
+		rx->offset += err;
+
+		if (rx->offset < sizeof(*hdr)) {
+			dprintf("header wait %d %d\n", rx->offset, err);
+			return -EAGAIN;
+		}
+	}
+
+	return 0;
+}
+
+#define get_hdr_param(hdr, function, length, flags, transaction, sequence)	\
+{										\
+	function = ntohs(hdr->function);					\
+	length = ntohs(hdr->length);						\
+	flags = ntohs(hdr->flags);						\
+	transaction = ntohs(hdr->transaction);					\
+	sequence = ntohs(hdr->sequence);					\
+}
+
+static int recv_pdu(int fd, struct isns_io *rx, struct isns_hdr *hdr)
+{
+	uint16_t function, length, flags, transaction, sequence;
+	int err;
+
+	err = recv_hdr(fd, rx, hdr);
+	if (err)
+		return err;
+
+	/* Now we got a complete header */
+	get_hdr_param(hdr, function, length, flags, transaction, sequence);
+	dprintf("got a header %x %u %x %u %u\n", function, length, flags,
+		transaction, sequence);
+
+	if (length + sizeof(*hdr) > BUFSIZE) {
+		eprintf("FIXME we cannot handle this yet %u!\n", length);
+		return -1;
+	}
+
+	if (rx->offset < length + sizeof(*hdr)) {
+		err = read(fd, rx->buf + rx->offset,
+			   length + sizeof(*hdr) - rx->offset);
+		if (err < 0) {
+			if (errno == EAGAIN || errno == EINTR)
+				return -EAGAIN;
+			eprintf("pdu read error %d %d %d %d\n",
+				fd, err, errno, rx->offset);
+			return -1;
+		} else if (err == 0)
+			return -1;
+
+		dprintf("pdu %u %u\n", fd, err);
+		rx->offset += err;
+
+		if (rx->offset < length + sizeof(*hdr)) {
+			eprintf("pdu wait %d %d\n", rx->offset, err);
+			return -EAGAIN;
+		}
+	}
+
+	/* Now we got everything. */
+	rx->offset = 0;
+
+	return 0;
+}
+
+#define print_unknown_pdu(hdr)						\
+{									\
+	uint16_t function, length, flags, transaction, sequence;	\
+	get_hdr_param(hdr, function, length, flags, transaction,	\
+		      sequence)						\
+	eprintf("unknown function %x %u %x %u %u\n",			\
+		function, length, flags, transaction, sequence);	\
+}
+
+static char *print_scn_pdu(struct isns_hdr *hdr)
+{
+	struct isns_tlv *tlv = (struct isns_tlv *) hdr->pdu;
+	uint16_t function, length, flags, transaction, sequence;
+	char *name = NULL;
+
+	get_hdr_param(hdr, function, length, flags, transaction, sequence);
+
+	while (length) {
+		uint32_t vlen = ntohl(tlv->length);
+
+		switch (ntohl(tlv->tag)) {
+		case ISNS_ATTR_ISCSI_NAME:
+			eprintf("scn name: %u, %s\n", vlen, (char *) tlv->value);
+			if (!name)
+				name = (char *) tlv->value;
+			break;
+		case ISNS_ATTR_TIMESTAMP:
+/* 			log_error("%u : %u : %" PRIx64, ntohl(tlv->tag), vlen, */
+/* 				  *((uint64_t *) tlv->value)); */
+			break;
+		case ISNS_ATTR_ISCSI_SCN_BITMAP:
+			eprintf("scn bitmap : %x\n", *((uint32_t *) tlv->value));
+			break;
+		}
+
+		length -= (sizeof(*tlv) + vlen);
+		tlv = (struct isns_tlv *) ((char *) tlv->value + vlen);
+	}
+
+	return name;
+}
+
+static void qry_rsp_handle(struct isns_hdr *hdr)
+{
+	struct isns_tlv *tlv;
+	uint16_t function, length, flags, transaction, sequence;
+	uint32_t status = (uint32_t) (*hdr->pdu);
+	struct isns_qry_mgmt *mgmt, *n;
+	struct iscsi_target *target;
+	struct isns_initiator *ini;
+	char *name = NULL;
+
+	get_hdr_param(hdr, function, length, flags, transaction, sequence);
+
+	list_for_each_entry_safe(mgmt, n, &qry_list, qlist) {
+		if (mgmt->transaction == transaction) {
+			list_del(&mgmt->qlist);
+			goto found;
+		}
+	}
+
+	eprintf("transaction not found %u\n", transaction);
+	return;
+found:
+
+	if (status) {
+		eprintf("error response %u\n", status);
+		goto free_qry_mgmt;
+	}
+
+	if (!strlen(mgmt->name)) {
+		dprintf("skip %u\n", transaction);
+		goto free_qry_mgmt;
+	}
+
+	target = target_find_by_name(mgmt->name);
+	if (!target) {
+		eprintf("invalid tid %s\n", mgmt->name);
+		goto free_qry_mgmt;
+	}
+
+	free_all_acl(target);
+
+	/* skip status */
+	tlv = (struct isns_tlv *) ((char *) hdr->pdu + 4);
+	length -= 4;
+
+	while (length) {
+		uint32_t vlen = ntohl(tlv->length);
+
+		switch (ntohl(tlv->tag)) {
+		case ISNS_ATTR_ISCSI_NAME:
+			name = (char *) tlv->value;
+			break;
+		case ISNS_ATTR_ISCSI_NODE_TYPE:
+			if (ntohl(*(tlv->value)) == ISNS_NODE_INITIATOR && name) {
+				eprintf("%s\n", (char *) name);
+				ini = malloc(sizeof(*ini));
+				if (!ini)
+					goto free_qry_mgmt;
+				snprintf(ini->name, sizeof(ini->name), name);
+				list_add(&ini->ilist, &target->isns_list);
+			} else
+				name = NULL;
+			break;
+		default:
+			name = NULL;
+			break;
+		}
+
+		length -= (sizeof(*tlv) + vlen);
+		tlv = (struct isns_tlv *) ((char *) tlv->value + vlen);
+	}
+
+free_qry_mgmt:
+	free(mgmt);
+}
+
+static void isns_handle(int fd, int events, void *data)
+{
+	int err;
+	struct isns_io *rx = &isns_rx;
+	struct isns_hdr *hdr = (struct isns_hdr *) rx->buf;
+	uint32_t result;
+	uint16_t function, length, flags, transaction, sequence;
+	char *name = NULL;
+
+	err = recv_pdu(isns_fd, rx, hdr);
+	if (err) {
+		if (err == -EAGAIN)
+			return;
+		dprintf("close connection %d\n", isns_fd);
+		tgt_event_del(isns_fd);
+		close(isns_fd);
+		isns_fd = 0;
+		return;
+	}
+
+	get_hdr_param(hdr, function, length, flags, transaction, sequence);
+	result = ntohl((uint32_t) hdr->pdu[0]);
+
+	switch (function) {
+	case ISNS_FUNC_DEV_ATTR_REG_RSP:
+		break;
+	case ISNS_FUNC_DEV_ATTR_QRY_RSP:
+		qry_rsp_handle(hdr);
+		break;
+	case ISNS_FUNC_DEV_DEREG_RSP:
+	case ISNS_FUNC_SCN_REG_RSP:
+		break;
+	case ISNS_FUNC_SCN:
+		name = print_scn_pdu(hdr);
+		if (name) {
+			eprintf("%s\n", name);
+			isns_attr_query(name);
+		}
+		break;
+	default:
+		print_unknown_pdu(hdr);
+	}
+
+	return;
+}
+
+static void send_scn_rsp(char *name, uint16_t transaction)
+{
+	char buf[1024];
+	struct isns_hdr *hdr = (struct isns_hdr *) buf;
+	struct isns_tlv *tlv;
+	uint16_t flags, length = 0;
+	int err;
+
+	memset(buf, 0, sizeof(buf));
+	*((uint32_t *) hdr->pdu) = 0;
+	tlv = (struct isns_tlv *) ((char *) hdr->pdu + 4);
+	length +=4;
+
+	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME, strlen(name), name);
+
+	flags = ISNS_FLAG_CLIENT | ISNS_FLAG_LAST_PDU | ISNS_FLAG_FIRST_PDU;
+	isns_hdr_init(hdr, ISNS_FUNC_SCN_RSP, length, flags, transaction, 0);
+
+	err = write(scn_fd, buf, length + sizeof(struct isns_hdr));
+	if (err < 0)
+		eprintf("%d %m\n", length);
+}
+
+static void isns_scn_handle(int fd, int events, void *data)
+{
+	int err;
+	struct isns_io *rx = &scn_rx;
+	struct isns_hdr *hdr = (struct isns_hdr *) rx->buf;
+	uint16_t function, length, flags, transaction, sequence;
+	char *name = NULL;
+
+	err = recv_pdu(scn_fd, rx, hdr);
+	if (err) {
+		if (err == -EAGAIN)
+			return;
+		dprintf("close connection %d\n", scn_fd);
+		tgt_event_del(scn_fd);
+		close(scn_fd);
+		scn_fd = 0;
+		return;
+	}
+
+	get_hdr_param(hdr, function, length, flags, transaction, sequence);
+
+	switch (function) {
+	case ISNS_FUNC_SCN:
+		name = print_scn_pdu(hdr);
+		break;
+	default:
+		print_unknown_pdu(hdr);
+	}
+
+	if (name) {
+		send_scn_rsp(name, transaction);
+		isns_attr_query(name);
+	}
+
+	return;
+}
+
+static void scn_accept_connection(int dummy, int events, void *data)
+{
+	struct sockaddr_storage from;
+	socklen_t slen;
+	int fd, err, opt = 1;
+
+	slen = sizeof(from);
+	fd = accept(scn_listen_fd, (struct sockaddr *) &from, &slen);
+	if (fd < 0) {
+		eprintf("accept error %m\n");
+		return;
+	}
+	eprintf("Accept scn connection %d\n", fd);
+
+	err = setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));
+	if (err)
+		eprintf("%m\n");
+	/* not critical, so ignore. */
+
+	scn_fd = fd;
+	tgt_event_add(scn_fd, EPOLLIN, isns_scn_handle, NULL);
+
+	return;
+}
+
+static int scn_init(char *addr)
+{
+	int fd, opt, err;
+	struct sockaddr_storage lss;
+	socklen_t slen;
+
+	fd = socket(ss.ss_family, SOCK_STREAM, IPPROTO_TCP);
+	if (fd < 0) {
+		eprintf("%m\n");
+		return -errno;
+	}
+
+	opt = 1;
+	if (ss.ss_family == AF_INET6) {
+		err = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &opt, sizeof(opt));
+		if (err)
+			eprintf("%m\n");
+		goto out;
+	}
+
+	err = listen(fd, 5);
+	if (err) {
+		eprintf("%m\n");
+		goto out;
+	}
+
+	slen = sizeof(lss);
+	err = getsockname(fd, (struct sockaddr *) &lss, &slen);
+	if (err) {
+		eprintf("%m\n");
+		goto out;
+	}
+
+	/* protocol independent way ? */
+	if (lss.ss_family == AF_INET6)
+		scn_listen_port = ntohs(((struct sockaddr_in6 *) &lss)->sin6_port);
+	else
+		scn_listen_port = ntohs(((struct sockaddr_in *) &lss)->sin_port);
+
+	eprintf("scn listen port %u %d %d\n", scn_listen_port, fd, err);
+out:
+	if (err)
+		close(fd);
+	else {
+		scn_listen_fd = fd;
+		tgt_event_add(fd, EPOLLIN, scn_accept_connection, NULL);
+	}
+
+	return err;
+}
+
+static void isns_timeout_fn(void *data)
+{
+	struct tgt_work *w = data;
+
+	isns_attr_query(NULL);
+	add_work(w, isns_timeout);
+}
+
+int isns_init(char *addr, int isns_ac)
+{
+	int err;
+	char port[8];
+	struct addrinfo hints, *res;
+
+	snprintf(port, sizeof(port), "%d", ISNS_PORT);
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_socktype = SOCK_STREAM;
+	err = getaddrinfo(addr, (char *) &port, &hints, &res);
+	if (err) {
+		eprintf("getaddrinfo error %s\n", addr);
+		return -1;
+	}
+	memcpy(&ss, res->ai_addr, sizeof(ss));
+	freeaddrinfo(res);
+
+	rxbuf = calloc(2, BUFSIZE);
+	if (!rxbuf) {
+		eprintf("oom\n");
+		return -1;
+	}
+
+	scn_init(addr);
+
+	isns_rx.buf = rxbuf;
+	isns_rx.offset = 0;
+	scn_rx.buf = rxbuf + BUFSIZE;
+	scn_rx.offset = 0;
+
+	use_isns = 1;
+	use_isns_ac = isns_ac;
+
+	timeout_work.func = isns_timeout_fn;
+	timeout_work.data = &timeout_work;
+	add_work(&timeout_work, isns_timeout);
+
+	return 0;
+}
+
+void isns_exit(void)
+{
+	struct iscsi_target *target;
+
+	if (!use_isns)
+		return;
+
+	list_for_each_entry(target, &iscsi_targets_list, tlist)
+		isns_scn_deregister(tgt_targetname(target->tid));
+
+	isns_deregister();
+
+	if (isns_fd) {
+		tgt_event_del(isns_fd);
+		close(isns_fd);
+	}
+	if (scn_listen_fd) {
+		tgt_event_del(scn_listen_fd);
+		close(scn_listen_fd);
+	}
+	if (scn_fd) {
+		tgt_event_del(scn_fd);
+		close(scn_fd);
+	}
+
+	free(rxbuf);
+}
diff --git a/usr/iscsi/isns_proto.h b/usr/iscsi/isns_proto.h
new file mode 100644
index 0000000..a070d03
--- /dev/null
+++ b/usr/iscsi/isns_proto.h
@@ -0,0 +1,200 @@
+/*
+ * iSNS protocol data types
+ *
+ * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#ifndef ISNS_PROTO_H
+#define ISNS_PROTO_H
+
+#define ISNS_PORT	3205
+#define ISNS_ALIGN	4
+
+struct isns_hdr {
+	uint16_t version;
+	uint16_t function;
+	uint16_t length;
+	uint16_t flags;
+	uint16_t transaction;
+	uint16_t sequence;
+	uint32_t pdu[0];
+} __attribute__ ((packed));
+
+struct isns_tlv {
+	uint32_t tag;
+	uint32_t length;
+	uint32_t value[0];
+} __attribute__ ((packed));
+
+/* Commands and responses (4.1.3) */
+#define ISNS_FUNC_DEV_ATTR_REG			0x0001
+#define ISNS_FUNC_DEV_ATTR_QRY			0x0002
+#define ISNS_FUNC_DEV_GET_NEXT			0x0003
+#define ISNS_FUNC_DEV_DEREG			0x0004
+#define ISNS_FUNC_SCN_REG			0x0005
+#define ISNS_FUNC_SCN_DEREG			0x0006
+#define ISNS_FUNC_SCN_EVENT			0x0007
+#define ISNS_FUNC_SCN				0x0008
+#define ISNS_FUNC_DD_REG			0x0009
+#define ISNS_FUNC_DD_DEREG			0x000a
+#define ISNS_FUNC_DDS_REG			0x000b
+#define ISNS_FUNC_DDS_DEREG			0x000c
+#define ISNS_FUNC_ESI				0x000d
+#define ISNS_FUNC_HEARTBEAT			0x000e
+
+#define ISNS_FUNC_DEV_ATTR_REG_RSP		0x8001
+#define ISNS_FUNC_DEV_ATTR_QRY_RSP		0x8002
+#define ISNS_FUNC_DEV_GET_NEXT_RSP		0x8003
+#define ISNS_FUNC_DEV_DEREG_RSP			0x8004
+#define ISNS_FUNC_SCN_REG_RSP			0x8005
+#define ISNS_FUNC_SCN_DEREG_RSP			0x8006
+#define ISNS_FUNC_SCN_EVENT_RSP			0x8007
+#define ISNS_FUNC_SCN_RSP			0x8008
+#define ISNS_FUNC_DD_REG_RSP			0x8009
+#define ISNS_FUNC_DD_DEREG_RSP			0x800a
+#define ISNS_FUNC_DDS_REG_RSP			0x800b
+#define ISNS_FUNC_DDS_DEREG_RSP			0x800c
+#define ISNS_FUNC_ESI_RSP			0x800d
+
+/* iSNSP flags (5.1.4) */
+#define ISNS_FLAG_CLIENT			(1U << 15)
+#define ISNS_FLAG_SERVER			(1U << 14)
+#define ISNS_FLAG_AUTH				(1U << 13)
+#define ISNS_FLAG_REPLACE			(1U << 12)
+#define ISNS_FLAG_LAST_PDU			(1U << 11)
+#define ISNS_FLAG_FIRST_PDU			(1U << 10)
+
+/* Response Status Codes (5.4) */
+#define ISNS_STATUS_SUCCESS			0
+#define ISNS_STATUS_UNKNOWN_ERROR		1
+#define ISNS_STATUS_FORMAT_ERROR		2
+#define ISNS_STATUS_INVALID_REGISTRATION	3
+#define ISNS_STATUS_RESERVED			4
+#define ISNS_STATUS_INVALID_QUERY		5
+#define ISNS_STATUS_SOURCE_UNKNOWN		6
+#define ISNS_STATUS_SOURCE_ABSENT		7
+#define ISNS_STATUS_SOURCE_UNAUTHORIZED		8
+#define ISNS_STATUS_NO_SUCH_ENTRY		9
+#define ISNS_STATUS_VERSION_NOT_SUPPORTED	10
+#define ISNS_STATUS_INTERNAL_ERROR		11
+#define ISNS_STATUS_BUSY			12
+#define ISNS_STATUS_OPTION_NOT_UNDERSTOOD	13
+#define ISNS_STATUS_INVALID_UPDATE		14
+#define ISNS_STATUS_MESSAGE_NOT_SUPPORTED	15
+#define ISNS_STATUS_SCN_EVENT_REJECTED		16
+#define ISNS_STATUS_SCN_REGISTRATION_REJECTED	17
+#define ISNS_STATUS_ATTRIBUTE_NOT_IMPLEMENTED	18
+#define ISNS_STATUS_FC_DOMAIN_ID_NOT_AVAILABLE	19
+#define ISNS_STATUS_FC_DOMAIN_ID_NOT_ALLOCATED	20
+#define ISNS_STATUS_ESI_NOT_AVAILABLE		21
+#define ISNS_STATUS_INVALIDE_DEREGISTRATION	22
+#define ISNS_STATUS_REGISTRATION_NOT_SUPPORTED	23
+
+/* Node type (5.4.2) */
+#define ISNS_NODE_CONTROL			(1U << 2)
+#define ISNS_NODE_INITIATOR			(1U << 1)
+#define ISNS_NODE_TARGET			(1U << 0)
+
+/* Attributes (6.1) */
+#define ISNS_ATTR_DELIMITER			0
+#define ISNS_ATTR_ENTITY_IDENTIFIER		1
+#define ISNS_ATTR_ENTITY_PROTOCOL		2
+#define ISNS_ATTR_MANAGEMENT_IP_ADDRESS		3
+#define ISNS_ATTR_TIMESTAMP			4
+#define ISNS_ATTR_PROTOCOL_VERSION_RANGE	5
+#define ISNS_ATTR_REGISTRATION_PERIOD		6
+#define ISNS_ATTR_ENTITY_INDEX			7
+#define ISNS_ATTR_ENTITY_NEXT_INDEX		8
+#define ISNS_ATTR_ISAKMP_PHASE1			11
+#define ISNS_ATTR_CERTIFICATE			12
+#define ISNS_ATTR_PORTAL_IP_ADDRESS		16
+#define ISNS_ATTR_PORTAL_PORT			17
+#define ISNS_ATTR_PORTAL_SYMBOLIC_NAME		18
+#define ISNS_ATTR_ESI_INTERVAL			19
+#define ISNS_ATTR_ESI_PORT			20
+#define ISNS_ATTR_PORTAL_INDEX			22
+#define ISNS_ATTR_SCN_PORT			23
+#define ISNS_ATTR_PORTAL_NEXT_INDEX		24
+#define ISNS_ATTR_PORTAL_SECURITY_BITMAP	27
+#define ISNS_ATTR_PORTAL_ISAKMP_PHASE1		28
+#define ISNS_ATTR_PORTAL_ISAKMP_PHASE2		29
+#define ISNS_ATTR_PORTAL_CERTIFICATE		31
+#define ISNS_ATTR_ISCSI_NAME			32
+#define ISNS_ATTR_ISCSI_NODE_TYPE		33
+#define ISNS_ATTR_ISCSI_ALIAS			34
+#define ISNS_ATTR_ISCSI_SCN_BITMAP		35
+#define ISNS_ATTR_ISCSI_NODE_INDEX		36
+#define ISNS_ATTR_WWNN_TOKEN			37
+#define ISNS_ATTR_ISCSI_NODE_NEXT_INDEX		38
+#define ISNS_ATTR_ISCSI_AUTHMETHOD		42
+#define ISNS_ATTR_PG_ISCSI_NAME			48
+#define ISNS_ATTR_PG_PORTAL_IP_ADDRESS		49
+#define ISNS_ATTR_PG_PORTAL_PORT		50
+#define ISNS_ATTR_PG_TAG			51
+#define ISNS_ATTR_PG_INDEX			52
+#define ISNS_ATTR_PG_NEXT_INDEX			53
+#define ISNS_ATTR_FC_PORT_NAME_WWPN		64
+#define ISNS_ATTR_PORT_ID			65
+#define ISNS_ATTR_PORT_TYPE			66
+#define ISNS_ATTR_SYMBOLIC_PORT_NAME		67
+#define ISNS_ATTR_FABRIC_PORT_NAME		68
+#define ISNS_ATTR_HARD_ADDRESS			69
+#define ISNS_ATTR_PORT_IP_ADDRESS		70
+#define ISNS_ATTR_CLASS_OF_SERVICE		71
+#define ISNS_ATTR_FC4_TYPES			72
+#define ISNS_ATTR_FC4_DESCRIPOTR		73
+#define ISNS_ATTR_FC4_FEATURES			74
+#define ISNS_ATTR_IFCP_SCN_BITMAP		75
+#define ISNS_ATTR_PORT_ROLE			76
+#define ISNS_ATTR_PERMANENT_PORT_NAME		77
+#define ISNS_ATTR_FC4_TYPE_CODE			95
+#define ISNS_ATTR_FC_NODE_NAME_WWNN		96
+#define ISNS_ATTR_SYMBOLIC_NODE_NAME		97
+#define ISNS_ATTR_NODE_IP_ADDRESS		98
+#define ISNS_ATTR_NODE_IPA			99
+#define ISNS_ATTR_PORXY_ISCSI_NAME		101
+#define ISNS_ATTR_SWITCH_NAME			128
+#define ISNS_ATTR_PREFERRED_ID			129
+#define ISNS_ATTR_ASSIGNED_ID			130
+#define ISNS_ATTR_VIRTUAL_FABRIC_ID		131
+#define ISNS_ATTR_ISNS_SERVER_VENDOR_OUI	256
+#define ISNS_ATTR_DD_SET_ID			2049
+#define ISNS_ATTR_DD_SET_SYM_NAME		2050
+#define ISNS_ATTR_DD_SET_STATUS			2051
+#define ISNS_ATTR_DD_SET_NEXT_ID		2052
+#define ISNS_ATTR_DD_ID				2065
+#define ISNS_ATTR_DD_SYMBOLIC_NAME		2066
+#define ISNS_ATTR_DD_MEMBER_ISCSI_INDEX		2067
+#define ISNS_ATTR_DD_MEMBER_ISCSI_NAME		2068
+#define ISNS_ATTR_DD_MEMBER_FC_PORT_NAME	2069
+#define ISNS_ATTR_DD_MEMBER_PORTAL_INDEX	2070
+#define ISNS_ATTR_DD_MEMBER_IP_ADDR		2071
+#define ISNS_ATTR_DD_MEMBER_TCP_UDP		2072
+#define ISNS_ATTR_DD_FEATURES			2078
+#define ISNS_ATTR_DD_ID_NEXT_ID			2079
+
+/* SCN flags (6.4.4) */
+#define ISNS_SCN_FLAG_INITIATOR			(1U << 24)
+#define ISNS_SCN_FLAG_TARGET			(1U << 25)
+#define ISNS_SCN_FLAG_MANAGEMENT		(1U << 26)
+#define ISNS_SCN_FLAG_OBJECT_REMOVE		(1U << 27)
+#define ISNS_SCN_FLAG_OBJECT_ADDED		(1U << 28)
+#define ISNS_SCN_FLAG_OBJECT_UPDATED		(1U << 29)
+#define ISNS_SCN_FLAG_DD_REMOVED		(1U << 30)
+#define ISNS_SCN_FLAG_DD_ADDED			(1U << 31)
+#endif
diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
index 531367d..3fe86a8 100644
--- a/usr/iscsi/target.c
+++ b/usr/iscsi/target.c
@@ -38,7 +38,7 @@
 #include "tgtd.h"
 #include "target.h"
 
-static LIST_HEAD(targets_list);
+LIST_HEAD(iscsi_targets_list);
 
 static int netmask_match_v6(struct sockaddr *sa1, struct sockaddr *sa2, uint32_t mbit)
 {
@@ -195,7 +195,7 @@ void target_list_build(struct iscsi_connection *conn, char *addr, char *name)
 {
 	struct iscsi_target *target;
 
-	list_for_each_entry(target, &targets_list, tlist) {
+	list_for_each_entry(target, &iscsi_targets_list, tlist) {
 		if (name && strcmp(tgt_targetname(target->tid), name))
 			continue;
 
@@ -211,7 +211,7 @@ struct iscsi_target *target_find_by_name(const char *name)
 {
 	struct iscsi_target *target;
 
-	list_for_each_entry(target, &targets_list, tlist) {
+	list_for_each_entry(target, &iscsi_targets_list, tlist) {
 		if (!strcmp(tgt_targetname(target->tid), name))
 			return target;
 	}
@@ -223,7 +223,7 @@ struct iscsi_target* target_find_by_id(int tid)
 {
 	struct iscsi_target *target;
 
-	list_for_each_entry(target, &targets_list, tlist) {
+	list_for_each_entry(target, &iscsi_targets_list, tlist) {
 		if (target->tid == tid)
 			return target;
 	}
@@ -250,6 +250,9 @@ int iscsi_target_destroy(int tid)
 
 	free(target);
 
+	/* FIXME: the target is already removed */
+/* 	isns_target_deregister(tgt_targetname(tid)); */
+
 	return 0;
 }
 
@@ -290,9 +293,11 @@ int iscsi_target_create(struct target *t)
 
 	INIT_LIST_HEAD(&target->tlist);
 	INIT_LIST_HEAD(&target->sessions_list);
+	INIT_LIST_HEAD(&target->isns_list);
 	target->tid = tid;
-	list_add(&target->tlist, &targets_list);
+	list_add(&target->tlist, &iscsi_targets_list);
 
+	isns_target_register(tgt_targetname(tid));
 	return 0;
 }
 
diff --git a/usr/iscsi/transport.c b/usr/iscsi/transport.c
index 51dfeb2..1f1a512 100644
--- a/usr/iscsi/transport.c
+++ b/usr/iscsi/transport.c
@@ -24,6 +24,7 @@
 #include <inttypes.h>
 #include <sys/types.h>
 
+#include "iscsid.h"
 #include "transport.h"
 
 struct iscsi_transport *iscsi_transports[] = {
@@ -33,6 +34,8 @@ struct iscsi_transport *iscsi_transports[] = {
 
 int lld_index;
 
+static char isns_ip[] = "192.168.11.133";
+
 int iscsi_init(int index)
 {
 	int i, err, nr = 0;
@@ -44,5 +47,8 @@ int iscsi_init(int index)
 		if (!err)
 			nr++;
 	}
+
+	isns_init(isns_ip, 0);
+
 	return !nr;
 }
-- 
1.4.4.3



From hugang at soulinfo.com  Mon Apr 16 12:28:26 2007
From: hugang at soulinfo.com (Hu Gang)
Date: Mon, 16 Apr 2007 18:28:26 +0800
Subject: [Stgt-devel] [patch] support different type in one target, V2.
Message-ID: <20070416182826.286600e8@hugang-laptop>

support different type in one target.

all of the logical units at same target must same type. this patch extend current tgt to support different type in one target.
 
./tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
./tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 -b /p/ref/ubuntu-7.04-beta-alternate-i386.iso --target-type cd
./tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 -b /tmp/100M --target-type disk
./tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL
./tgtadm --lld iscsi --op show --mode target

From: <hugang at soulinfo.com>
---

 usr/mgmt.c   |    5 ++--
 usr/mmc.c    |    2 +-
 usr/osd.c    |    2 +-
 usr/sbc.c    |    4 ++-
 usr/scsi.c   |    2 +-
 usr/spc.c    |    4 ++-
 usr/spt.c    |    2 +-
 usr/target.c |   70 ++++++++++++++++++++++++++++++----------------------------
 usr/target.h |    5 ----
 usr/tgtd.h   |   38 +++++++++++++++++++------------
 10 files changed, 69 insertions(+), 65 deletions(-)

diff --git a/usr/mgmt.c b/usr/mgmt.c
index c2dfa98..7725896 100644
--- a/usr/mgmt.c
+++ b/usr/mgmt.c
@@ -77,8 +77,7 @@ static int target_mgmt(int lld_no, struc
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_target_create(lld_no, req->tid, mtask->buf,
-					req->target_type);
+		err = tgt_target_create(lld_no, req->tid, mtask->buf);
 		break;
 	case OP_DELETE:
 		err = tgt_target_destroy(req->tid);
@@ -169,7 +168,7 @@ static int device_mgmt(int lld_no, struc
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_device_create(req->tid, req->lun, params);
+		err = tgt_device_create(req->tid, req->lun, req->target_type, params);
 		break;
 	case OP_DELETE:
 		err = tgt_device_destroy(req->tid, req->lun);
diff --git a/usr/mmc.c b/usr/mmc.c
index e9cc479..ba3a395 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -49,7 +49,7 @@ static int mmc_rw(int host_no, struct sc
 	int ret;
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << MMC_BLK_SHIFT);
-	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
+	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		cmd->offset = 0;
 		cmd->len = 0;
diff --git a/usr/osd.c b/usr/osd.c
index 46bf0a0..894d4b4 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -142,7 +142,7 @@ static int osd_varlen_cdb(int host_no, s
 	}
 
 /* 	return SAM_STAT_GOOD; */
-	return cmd->c_target->bst->bs_cmd_submit(cmd);
+	return cmd->dev->bst->bs_cmd_submit(cmd);
 }
 
 static void device_osd_init(struct scsi_lu *lu)
diff --git a/usr/sbc.c b/usr/sbc.c
index a22d3b0..abcc8e6 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -67,7 +67,7 @@ static int sbc_rw(int host_no, struct sc
 	}
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << BLK_SHIFT);
-	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
+	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		key = HARDWARE_ERROR;
 		asc = 0;
@@ -173,7 +173,7 @@ static int sbc_sync_cache(int host_no, s
 		goto sense;
 	}
 
-	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
+	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	switch (ret) {
 	case EROFS:
 	case EINVAL:
diff --git a/usr/scsi.c b/usr/scsi.c
index 1a6929f..4ec7a1a 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -119,5 +119,5 @@ uint64_t scsi_rw_offset(uint8_t *scb)
 int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd)
 {
 	unsigned char op = cmd->scb[0];
-	return cmd->c_target->dev_type_template.ops[op].cmd_perform(host_no, cmd);
+	return cmd->dev->dev_type_template.ops[op].cmd_perform(host_no, cmd);
 }
diff --git a/usr/spc.c b/usr/spc.c
index b922a45..09b8bf1 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -39,8 +39,8 @@ int spc_inquiry(int host_no, struct scsi
 	int len, ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data;
 	uint8_t *scb = cmd->scb;
-	unsigned char device_type = cmd->c_target->dev_type_template.type;
-	char *product_id = cmd->c_target->dev_type_template.pid;
+	unsigned char device_type = cmd->dev->dev_type_template.type;
+	char *product_id = cmd->dev->dev_type_template.pid;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
diff --git a/usr/spt.c b/usr/spt.c
index fe2a848..3d1413f 100644
--- a/usr/spt.c
+++ b/usr/spt.c
@@ -67,7 +67,7 @@ static int spt_cmd_perform(int host_no, 
 	struct device_type_operations *ops;
 
 	if (!cmd->dev) {
-		ops = cmd->c_target->dev_type_template.ops;
+		ops = cmd->dev->dev_type_template.ops;
 		return ops[cmd->scb[0]].cmd_perform(host_no, cmd);
 	}
 
diff --git a/usr/target.c b/usr/target.c
index 1a9fe68..a9da5e0 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -174,7 +174,7 @@ static int tgt_device_path_update(struct
 	if (!path)
 		return TGTADM_NOMEM;
 
-	err = target->bst->bs_open(lu, path, &dev_fd, &size);
+	err = lu->bst->bs_open(lu, path, &dev_fd, &size);
 	if (err) {
 		free(path);
 		return TGTADM_INVALID_REQUEST;
@@ -206,12 +206,13 @@ __device_lookup(int tid, uint64_t lun, s
 	return lu;
 }
 
-int tgt_device_create(int tid, uint64_t lun, char *args)
+int tgt_device_create(int tid, uint64_t lun, uint32_t t_type, char *args)
 {
 	char *p;
 	int err;
 	struct target *target;
 	struct scsi_lu *lu, *pos;
+    struct backingstore_template *bst;
 
 	dprintf("%d %" PRIu64 "\n", tid, lun);
 
@@ -233,9 +234,34 @@ int tgt_device_create(int tid, uint64_t 
 		return TGTADM_INVALID_REQUEST;
 	p++;
 
-	lu = zalloc(sizeof(*lu) + target->bst->bs_datasize);
+    /* FIXME */
+	if (t_type == TYPE_SPT)
+		bst = &sg_bst;
+	else
+		bst = tgt_drivers[target->lid]->default_bst;
+
+	lu = zalloc(sizeof(*lu) + bst->bs_datasize);
 	if (!lu)
 		return TGTADM_NOMEM;
+    lu->bst = bst;
+
+	switch (t_type) {
+	case TYPE_DISK:
+		lu->dev_type_template = sbc_template;
+		break;
+	case TYPE_ROM:
+		lu->dev_type_template = mmc_template;
+		break;
+	case TYPE_OSD:
+		lu->dev_type_template = osd_template;
+		break;
+	case TYPE_SPT:
+		lu->dev_type_template = spt_template;
+		break;
+	default:
+		free(lu);
+		return TGTADM_INVALID_REQUEST;
+	}
 
 	err = tgt_device_path_update(target, lu, p);
 	if (err) {
@@ -251,8 +277,8 @@ int tgt_device_create(int tid, uint64_t 
 
 	tgt_cmd_queue_init(&lu->cmd_queue);
 
-	if (target->dev_type_template.device_init)
-		target->dev_type_template.device_init(lu);
+	if (lu->dev_type_template.device_init)
+		lu->dev_type_template.device_init(lu);
 
 	list_for_each_entry(pos, &target->device_list, device_siblings) {
 		if (lu->lun < pos->lun)
@@ -283,7 +309,7 @@ int tgt_device_destroy(int tid, uint64_t
 	free(lu->path);
 	list_del(&lu->device_siblings);
 
-	target->bst->bs_close(lu);
+	lu->bst->bs_close(lu);
 	free(lu);
 	return 0;
 }
@@ -508,7 +534,7 @@ static void __cmd_done(struct target *ta
 
 	cmd_hlist_remove(cmd);
 
-	err = target->bst->bs_cmd_done(cmd);
+	err = cmd->dev->bst->bs_cmd_done(cmd);
 
 	dprintf("%d %" PRIx64 " %u %d\n", cmd->mmapped, cmd->uaddr, cmd->len, err);
 
@@ -1095,12 +1121,10 @@ int tgt_target_show_all(char *buf, int r
 		shprintf(total, buf, rest,
 			 "Target %d: %s\n"
 			 _TAB1 "System information:\n"
-			 _TAB2 "Type: %s\n"
 			 _TAB2 "Driver: %s\n"
 			 _TAB2 "Status: %s\n",
 			 target->tid,
 			 target->name,
-			 target->dev_type_template.name,
 			 tgt_drivers[target->lid]->name,
 			 target_state_name(target->target_state));
 
@@ -1117,11 +1141,13 @@ int tgt_target_show_all(char *buf, int r
 		list_for_each_entry(lu, &target->device_list, device_siblings)
 			shprintf(total, buf, rest,
 				 _TAB2 "LUN: %" PRIu64 "\n"
+                 _TAB3 "Dev Type: %d\n"
 				 _TAB3 "SCSI ID: %s\n"
 				 _TAB3 "SCSI SN: %s\n"
 				 _TAB3 "Size: %s\n"
 				 _TAB3 "Backing store: %s\n",
 				 lu->lun,
+                 lu->dev_type_template.type,
 				 lu->scsi_id,
 				 lu->scsi_sn,
 				 print_disksize(lu->size),
@@ -1167,7 +1193,7 @@ char *tgt_targetname(int tid)
 
 #define DEFAULT_NR_ACCOUNT 16
 
-int tgt_target_create(int lld, int tid, char *args, int t_type)
+int tgt_target_create(int lld, int tid, char *args)
 {
 	struct target *target, *pos;
 	char *p, *q, *targetname = NULL;
@@ -1200,24 +1226,6 @@ int tgt_target_create(int lld, int tid, 
 	if (!target)
 		return TGTADM_NOMEM;
 
-	switch (t_type) {
-	case TYPE_DISK:
-		target->dev_type_template = sbc_template;
-		break;
-	case TYPE_ROM:
-		target->dev_type_template = mmc_template;
-		break;
-	case TYPE_OSD:
-		target->dev_type_template = osd_template;
-		break;
-	case TYPE_SPT:
-		target->dev_type_template = spt_template;
-		break;
-	default:
-		free(target);
-		return TGTADM_INVALID_REQUEST;
-	}
-
 	target->name = strdup(targetname);
 	if (!target->name) {
 		free(target);
@@ -1236,12 +1244,6 @@ int tgt_target_create(int lld, int tid, 
 
 	INIT_LIST_HEAD(&target->device_list);
 
-	/* FIXME */
-	if (t_type == TYPE_SPT)
-		target->bst = &sg_bst;
-	else
-		target->bst = tgt_drivers[lld]->default_bst;
-
 	target->target_state = SCSI_TARGET_RUNNING;
 	target->lid = lld;
 
diff --git a/usr/target.h b/usr/target.h
index a5f1faa..481769d 100644
--- a/usr/target.h
+++ b/usr/target.h
@@ -36,14 +36,9 @@ struct target {
 
 	struct tgt_cmd_queue cmd_queue;
 
-	struct backingstore_template *bst;
-
 	struct list_head acl_list;
 
 	struct tgt_account account;
-
-	/* we don't use a pointer because a lld could change this. */
-	struct device_type_template dev_type_template;
 };
 
 struct it_nexus {
diff --git a/usr/tgtd.h b/usr/tgtd.h
index e0ead9b..e0bebaa 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -29,6 +29,23 @@ struct tgt_cmd_queue {
 	struct list_head queue;
 };
 
+struct scsi_lu;
+struct scsi_cmd;
+
+struct device_type_operations {
+	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
+};
+
+struct device_type_template {
+	unsigned char type;
+	char *name;
+	char *pid;
+
+	void (*device_init)(struct scsi_lu *dev);
+
+	struct device_type_operations ops[256];
+};
+
 struct scsi_lu {
 	int fd;
 	uint64_t addr; /* persistent mapped address */
@@ -49,6 +66,10 @@ struct scsi_lu {
 
 	/* TODO: needs a structure for lots of device parameters */
 	uint8_t d_sense;
+
+    struct device_type_template dev_type_template;
+    struct backingstore_template *bst;
+    void *private;
 };
 
 struct scsi_cmd {
@@ -112,32 +133,19 @@ static inline int kreq_init(void)	\
 }
 #endif
 
-struct device_type_operations {
-	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
-};
-
-struct device_type_template {
-	unsigned char type;
-	char *name;
-	char *pid;
-
-	void (*device_init)(struct scsi_lu *dev);
-
-	struct device_type_operations ops[256];
-};
 
 extern int kspace_send_tsk_mgmt_res(struct mgmt_req *mreq);
 extern int kspace_send_cmd_res(uint64_t nid, int result, struct scsi_cmd *);
 
 extern int ipc_init(void);
-extern int tgt_device_create(int tid, uint64_t lun, char *args);
+extern int tgt_device_create(int tid, uint64_t lun, uint32_t type, char *args);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_device_update(int tid, uint64_t dev_id, char *name);
 extern int device_reserve(struct scsi_cmd *cmd);
 extern int device_release(int tid, uint64_t itn_id, uint64_t lun, int force);
 extern int device_reserved(struct scsi_cmd *cmd);
 
-extern int tgt_target_create(int lld, int tid, char *args, int t_type);
+extern int tgt_target_create(int lld, int tid, char *args);
 extern int tgt_target_destroy(int tid);
 extern char *tgt_targetname(int tid);
 extern int tgt_target_show_all(char *buf, int rest);


From hugang at soulinfo.com  Mon Apr 16 12:29:06 2007
From: hugang at soulinfo.com (Hu Gang)
Date: Mon, 16 Apr 2007 18:29:06 +0800
Subject: [Stgt-devel] [patch] modularization target types. V2.
Message-ID: <20070416182906.1b29452a@hugang-laptop>

this patch adding support mutiple scsi type as a modules.

---

 usr/mmc.c    |    7 ++++++-
 usr/osd.c    |    7 ++++++-
 usr/sbc.c    |    7 ++++++-
 usr/spt.c    |    8 +++++++-
 usr/target.c |   61 +++++++++++++++++++++++++++++++++++++++++++---------------
 usr/tgtd.h   |    4 ++++
 6 files changed, 74 insertions(+), 20 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index ba3a395..49103a5 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -121,7 +121,7 @@ static int mmc_read_capacity(int host_no
 	return SAM_STAT_GOOD;
 }
 
-struct device_type_template mmc_template = {
+static struct device_type_template mmc_template = {
 	.type	= TYPE_ROM,
 	.name	= "cdrom/dvd",
 	.pid	= "VIRTUAL-CDROM",
@@ -227,3 +227,8 @@ struct device_type_template mmc_template
 		[0xb0 ... 0xff] = {spc_illegal_op},
 	}
 };
+
+__attribute__((constructor)) static void mmc_init(void)
+{
+    device_type_register(&mmc_template);
+}
diff --git a/usr/osd.c b/usr/osd.c
index 894d4b4..91286f6 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -150,7 +150,7 @@ static void device_osd_init(struct scsi_
 	lu->d_sense = 1;
 }
 
-struct device_type_template osd_template = {
+static struct device_type_template osd_template = {
 	.type		= TYPE_OSD,
 	.name		= "osd",
 	.device_init	= device_osd_init,
@@ -221,3 +221,8 @@ struct device_type_template osd_template
 		[0xb0 ... 0xff] = {spc_illegal_op},
 	}
 };
+
+__attribute__((constructor)) static void osd_init(void)
+{
+        device_type_register(&osd_template);
+}
diff --git a/usr/sbc.c b/usr/sbc.c
index 4ac6833..2cd8b23 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -337,7 +337,7 @@ sense:
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-struct device_type_template sbc_template = {
+static struct device_type_template sbc_template = {
 	.type	= TYPE_DISK,
 	.name	= "disk",
 	.pid	= "VIRTUAL-DISK",
@@ -479,3 +479,8 @@ struct device_type_template sbc_template
 		[0xb0 ... 0xff] = {spc_illegal_op},
 	}
 };
+
+__attribute__((constructor)) static void sbc_init(void)
+{
+        device_type_register(&sbc_template);
+}
diff --git a/usr/spt.c b/usr/spt.c
index 3d1413f..4f9d9ae 100644
--- a/usr/spt.c
+++ b/usr/spt.c
@@ -80,7 +80,8 @@ static int spt_cmd_perform(int host_no, 
 		return SAM_STAT_GOOD;
 }
 
-struct device_type_template spt_template = {
+static struct device_type_template spt_template = {
+    .type   = TYPE_SPT,
 	.name	= "passthrough",
 	.ops	= {
 		[0x00 ... 0x9f] = {spt_cmd_perform,},
@@ -107,3 +108,8 @@ struct device_type_template spt_template
 		[0xb0 ... 0xff] = {spt_cmd_perform},
 	}
 };
+
+__attribute__((constructor)) static void spt_init(void)
+{
+    device_type_register(&spt_template);
+}
diff --git a/usr/target.c b/usr/target.c
index dadb6f4..5c7ea6f 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -36,8 +36,37 @@ #include "target.h"
 #include "scsi.h"
 #include "tgtadm.h"
 
-extern struct device_type_template sbc_template, mmc_template, osd_template,
-	spt_template;
+static LIST_HEAD(type_list);
+
+int device_type_register(struct device_type_template *t)
+{
+    list_add_tail(&t->list_entry, &type_list);
+    return 0;
+}
+
+static struct device_type_template *device_type_find_name(const char *name)
+{
+    struct device_type_template *t;
+    
+    list_for_each_entry(t, &type_list, list_entry) {
+        if (strcmp(name, t->name) == 0)
+            return t;
+    }
+
+    return NULL;
+}
+
+static struct device_type_template *device_type_find_type(unsigned char type)
+{
+    struct device_type_template *t;
+    
+    list_for_each_entry(t, &type_list, list_entry) {
+        if (t->type == type)
+            return t;
+    }
+
+    return NULL;
+}
 
 static LIST_HEAD(target_list);
 
@@ -213,6 +242,7 @@ int tgt_device_create(int tid, uint64_t 
 	struct target *target;
 	struct scsi_lu *lu, *pos;
     struct backingstore_template *bst;
+    struct device_type_template *tt;
 
 	dprintf("%d %" PRIu64 "\n", tid, lun);
 
@@ -245,23 +275,12 @@ int tgt_device_create(int tid, uint64_t 
 		return TGTADM_NOMEM;
     lu->bst = bst;
 
-	switch (t_type) {
-	case TYPE_DISK:
-		lu->dev_type_template = sbc_template;
-		break;
-	case TYPE_ROM:
-		lu->dev_type_template = mmc_template;
-		break;
-	case TYPE_OSD:
-		lu->dev_type_template = osd_template;
-		break;
-	case TYPE_SPT:
-		lu->dev_type_template = spt_template;
-		break;
-	default:
+    tt = device_type_find_type(t_type);
+    if (tt == NULL) {
 		free(lu);
 		return TGTADM_INVALID_REQUEST;
 	}
+    lu->dev_type_template = *tt;
 
 	err = tgt_device_path_update(target, lu, p);
 	if (err) {
@@ -1116,6 +1135,7 @@ int tgt_target_show_all(char *buf, int r
 	struct scsi_lu *lu;
 	struct acl_entry *acl;
 	struct it_nexus *nexus;
+    struct device_type_template *dtt;
 
 	list_for_each_entry(target, &target_list, target_siblings) {
 		shprintf(total, buf, rest,
@@ -1175,6 +1195,15 @@ int tgt_target_show_all(char *buf, int r
 		list_for_each_entry(acl, &target->acl_list, aclent_list)
 			shprintf(total, buf, rest, _TAB2 "%s\n", acl->address);
 	}
+
+    shprintf(total, buf, rest, "Device type:\n");
+    list_for_each_entry(dtt, &type_list, list_entry) {
+        shprintf(total, buf, rest, 
+                _TAB1 "Device Type: %d\n"
+                _TAB2 "Device Name: %s\n"
+                _TAB2 "Device Pid : %s\n",
+                dtt->type, dtt->name, dtt->pid ? dtt->pid : "");
+    }
 	return total;
 overflow:
 	return max;
diff --git a/usr/tgtd.h b/usr/tgtd.h
index e0bebaa..2eacaba 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -44,8 +44,12 @@ struct device_type_template {
 	void (*device_init)(struct scsi_lu *dev);
 
 	struct device_type_operations ops[256];
+
+    struct list_head list_entry;
 };
 
+extern int device_type_register(struct device_type_template *);
+
 struct scsi_lu {
 	int fd;
 	uint64_t addr; /* persistent mapped address */


From hare at suse.de  Tue Apr 17 08:31:00 2007
From: hare at suse.de (Hannes Reinecke)
Date: Tue, 17 Apr 2007 08:31:00 +0200
Subject: [Stgt-devel] [patch] support different type in one target, V2.
In-Reply-To: <20070416182826.286600e8@hugang-laptop>
References: <20070416182826.286600e8@hugang-laptop>
Message-ID: <462469A4.903@suse.de>

Hu Gang wrote:
> support different type in one target.
> 
> all of the logical units at same target must same type.
> this patch extend current tgt to support different type in one target.
>  
[ .. ]
> 
> From: <hugang at soulinfo.com>

Hmpf. You beat me to it.
I had just finished my patch and was about to send it :-)
Oh well.

We definitely should associate the SCSI type with the LUN, not the
target. Otherwise we just impose some artificial restrictions not
mandated by the spec.

Signed-off-by: Hannes Reinecke <hare at suse.de>

Cheers,

Hannes
-- 
Dr. Hannes Reinecke		      zSeries & Storage
hare at suse.de			      +49 911 74053 688
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
GF: Markus Rex, HRB 16746 (AG N?rnberg)


From fujita.tomonori at lab.ntt.co.jp  Tue Apr 17 09:40:52 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 17 Apr 2007 16:40:52 +0900
Subject: [Stgt-devel] [patch] modularization target types. V2.
In-Reply-To: <20070416182906.1b29452a@hugang-laptop>
References: <20070416182906.1b29452a@hugang-laptop>
Message-ID: <20070417164052Q.fujita.tomonori@lab.ntt.co.jp>

From: Hu Gang <hugang at soulinfo.com>
Subject: [Stgt-devel] [patch] modularization target types. V2.
Date: Mon, 16 Apr 2007 18:29:06 +0800

> this patch adding support mutiple scsi type as a modules.
> 
> ---
> 
>  usr/mmc.c    |    7 ++++++-
>  usr/osd.c    |    7 ++++++-
>  usr/sbc.c    |    7 ++++++-
>  usr/spt.c    |    8 +++++++-
>  usr/target.c |   61 +++++++++++++++++++++++++++++++++++++++++++---------------
>  usr/tgtd.h   |    4 ++++
>  6 files changed, 74 insertions(+), 20 deletions(-)

Thanks, but:

rouen:~/git/tgt/usr$ git-apply --whitespace=error < ~/Mail/inbox/8
Adds trailing whitespace.
<stdin>:203:
Adds trailing whitespace.
<stdin>:215:
Adds trailing whitespace.
<stdin>:276:        shprintf(total, buf, rest,
fatal: 3 lines add trailing whitespaces.




From fujita.tomonori at lab.ntt.co.jp  Tue Apr 17 09:40:50 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 17 Apr 2007 16:40:50 +0900
Subject: [Stgt-devel] [patch] support different type in one target, V2.
In-Reply-To: <462469A4.903@suse.de>
References: <20070416182826.286600e8@hugang-laptop>
	<462469A4.903@suse.de>
Message-ID: <20070417164050A.fujita.tomonori@lab.ntt.co.jp>

From: Hannes Reinecke <hare at suse.de>
Subject: Re: [Stgt-devel] [patch] support different type in one target, V2.
Date: Tue, 17 Apr 2007 08:31:00 +0200

> Hu Gang wrote:
> > support different type in one target.
> > 
> > all of the logical units at same target must same type.
> > this patch extend current tgt to support different type in one target.
> >  
> [ .. ]
> > 
> > From: <hugang at soulinfo.com>
> 
> Hmpf. You beat me to it.
> I had just finished my patch and was about to send it :-)
> Oh well.
> 
> We definitely should associate the SCSI type with the LUN, not the
> target. Otherwise we just impose some artificial restrictions not
> mandated by the spec.

I chose it for simplicity (I think that I said this before). I'll
merge this patch sometime.

We can have artificial restrictions. For example, EqualLogic has a
huge artificial restriction (one lu per target), but seems that their
products are very popular.


From fujita.tomonori at lab.ntt.co.jp  Tue Apr 17 16:14:27 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 17 Apr 2007 23:14:27 +0900
Subject: [Stgt-devel] FirstBurstLenght > MaxBurstLength --> error
In-Reply-To: <4621F167.3070504@gmail.com>
References: <4621F167.3070504@gmail.com>
Message-ID: <20070417231427U.fujita.tomonori@lab.ntt.co.jp>

From: Albert Pauw <albert.pauw at gmail.com>
Subject: [Stgt-devel] FirstBurstLenght > MaxBurstLength --> error
Date: Sun, 15 Apr 2007 11:33:27 +0200

> Running the test regression script of open-iscsi on stgt I found an 
> error, which I did not encounter with other targets.
> 
> It is test #17 with the following parameters:
> 
> ================== TEST #17 BEGIN ====================
> ImmediateData = No
> InitialR2T = No
> HeaderDigest = None
> DataDigest = None
> FirstBurstLength = 8192
> MaxBurstLength = 4096
> MaxRecvDataSegmentLength = 4096
> MaxOutstandingR2T = 1
> 
> I get the error "Invalid burst lengths first_burst 8192 max_burst 4096" 
> in /var/log/messages and the login breaks of.
> According to the RFC 3720 "FirstBurstLength MUST NOT exceed 
> MaxBurstLength" (chap 12.14), which means that the target
> should answer back with a FirstBurstLenght parameters equal to 
> MaxBurstLenght.
> 
> I investigated with wireshark and found that this is exactly the 
> behaviour of the Wasabi Storagebuilder target,
> iscsi-target silently accepts FirstBurstLength > MaxBurstLength, and 
> stgt only gives an error.

Thanks a lot.

I put it on my to do list since it's a bit tricky to handle this.

BTW, would it better for open-iscsi not to send invalid parameters?


From michaelc at cs.wisc.edu  Tue Apr 17 18:11:25 2007
From: michaelc at cs.wisc.edu (Mike Christie)
Date: Tue, 17 Apr 2007 11:11:25 -0500
Subject: [Stgt-devel] FirstBurstLenght > MaxBurstLength --> error
In-Reply-To: <20070417231427U.fujita.tomonori@lab.ntt.co.jp>
References: <4621F167.3070504@gmail.com>
	<20070417231427U.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <4624F1AD.2090705@cs.wisc.edu>

FUJITA Tomonori wrote:
> From: Albert Pauw <albert.pauw at gmail.com>
> Subject: [Stgt-devel] FirstBurstLenght > MaxBurstLength --> error
> Date: Sun, 15 Apr 2007 11:33:27 +0200
> 
>> Running the test regression script of open-iscsi on stgt I found an 
>> error, which I did not encounter with other targets.
>>
>> It is test #17 with the following parameters:
>>
>> ================== TEST #17 BEGIN ====================
>> ImmediateData = No
>> InitialR2T = No
>> HeaderDigest = None
>> DataDigest = None
>> FirstBurstLength = 8192
>> MaxBurstLength = 4096
>> MaxRecvDataSegmentLength = 4096
>> MaxOutstandingR2T = 1
>>
>> I get the error "Invalid burst lengths first_burst 8192 max_burst 4096" 
>> in /var/log/messages and the login breaks of.
>> According to the RFC 3720 "FirstBurstLength MUST NOT exceed 
>> MaxBurstLength" (chap 12.14), which means that the target
>> should answer back with a FirstBurstLenght parameters equal to 
>> MaxBurstLenght.
>>
>> I investigated with wireshark and found that this is exactly the 
>> behaviour of the Wasabi Storagebuilder target,
>> iscsi-target silently accepts FirstBurstLength > MaxBurstLength, and 
>> stgt only gives an error.
> 
> Thanks a lot.
> 
> I put it on my to do list since it's a bit tricky to handle this.
> 
> BTW, would it better for open-iscsi not to send invalid parameters?

I will fix that on my side.


From hugang at soulinfo.com  Wed Apr 18 03:59:29 2007
From: hugang at soulinfo.com (Hu Gang)
Date: Wed, 18 Apr 2007 09:59:29 +0800
Subject: [Stgt-devel] [patch] modularization target types. V2.
In-Reply-To: <20070417164052Q.fujita.tomonori@lab.ntt.co.jp>
References: <20070416182906.1b29452a@hugang-laptop>
	<20070417164052Q.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070418095929.4bfd5cec@hugang-laptop>

On Tue, 17 Apr 2007 16:40:52 +0900
FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:

> From: Hu Gang <hugang at soulinfo.com>
> Subject: [Stgt-devel] [patch] modularization target types. V2.
> Date: Mon, 16 Apr 2007 18:29:06 +0800
> 
> > this patch adding support mutiple scsi type as a modules.
> > 
> > ---
> > 
> >  usr/mmc.c    |    7 ++++++-
> >  usr/osd.c    |    7 ++++++-
> >  usr/sbc.c    |    7 ++++++-
> >  usr/spt.c    |    8 +++++++-
> >  usr/target.c |   61 +++++++++++++++++++++++++++++++++++++++++++---------------
> >  usr/tgtd.h   |    4 ++++
> >  6 files changed, 74 insertions(+), 20 deletions(-)
> 
> Thanks, but:
> 
> rouen:~/git/tgt/usr$ git-apply --whitespace=error < ~/Mail/inbox/8
> Adds trailing whitespace.
> <stdin>:203:
> Adds trailing whitespace.
> <stdin>:215:
> Adds trailing whitespace.
> <stdin>:276:        shprintf(total, buf, rest,
> fatal: 3 lines add trailing whitespaces.
> 

I attached the patch into the email, hope it can clean to apply.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: 02_type_per_lu.diff
Type: text/x-patch
Size: 11269 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070418/d87c0218/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: tgt_temp_module.diff
Type: text/x-patch
Size: 5793 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070418/d87c0218/attachment-0001.bin>

From fujita.tomonori at lab.ntt.co.jp  Thu Apr 19 01:02:07 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 19 Apr 2007 08:02:07 +0900
Subject: [Stgt-devel] [patch] modularization target types. V2.
In-Reply-To: <20070418095929.4bfd5cec@hugang-laptop>
References: <20070416182906.1b29452a@hugang-laptop>
	<20070417164052Q.fujita.tomonori@lab.ntt.co.jp>
	<20070418095929.4bfd5cec@hugang-laptop>
Message-ID: <20070419080207V.fujita.tomonori@lab.ntt.co.jp>

From: Hu Gang <hugang at soulinfo.com>
Subject: Re: [Stgt-devel] [patch] modularization target types. V2.
Date: Wed, 18 Apr 2007 09:59:29 +0800

> On Tue, 17 Apr 2007 16:40:52 +0900
> FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> 
> > From: Hu Gang <hugang at soulinfo.com>
> > Subject: [Stgt-devel] [patch] modularization target types. V2.
> > Date: Mon, 16 Apr 2007 18:29:06 +0800
> > 
> > > this patch adding support mutiple scsi type as a modules.
> > > 
> > > ---
> > > 
> > >  usr/mmc.c    |    7 ++++++-
> > >  usr/osd.c    |    7 ++++++-
> > >  usr/sbc.c    |    7 ++++++-
> > >  usr/spt.c    |    8 +++++++-
> > >  usr/target.c |   61 +++++++++++++++++++++++++++++++++++++++++++---------------
> > >  usr/tgtd.h   |    4 ++++
> > >  6 files changed, 74 insertions(+), 20 deletions(-)
> > 
> > Thanks, but:
> > 
> > rouen:~/git/tgt/usr$ git-apply --whitespace=error < ~/Mail/inbox/8
> > Adds trailing whitespace.
> > <stdin>:203:
> > Adds trailing whitespace.
> > <stdin>:215:
> > Adds trailing whitespace.
> > <stdin>:276:        shprintf(total, buf, rest,
> > fatal: 3 lines add trailing whitespaces.
> > 
> 
> I attached the patch into the email, hope it can clean to apply.

Nope.

rouen:~/git/tgt$ git-apply --whitespace=error < ~/tgt_temp_module.diff
Adds trailing whitespace.
<stdin>:126:
Adds trailing whitespace.
<stdin>:138:
Adds trailing whitespace.
<stdin>:199:        shprintf(total, buf, rest,
fatal: 3 lines add trailing whitespaces.


Please make sure your mailer works properly before posting to the
mailing list.


From hugang at soulinfo.com  Fri Apr 20 02:55:33 2007
From: hugang at soulinfo.com (Hu Gang)
Date: Fri, 20 Apr 2007 08:55:33 +0800
Subject: [Stgt-devel] [patch] modularization target types. V2.
In-Reply-To: <20070419080207V.fujita.tomonori@lab.ntt.co.jp>
References: <20070416182906.1b29452a@hugang-laptop>
	<20070417164052Q.fujita.tomonori@lab.ntt.co.jp>
	<20070418095929.4bfd5cec@hugang-laptop>
	<20070419080207V.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070420085533.41f413f5@hugang-laptop>

On Thu, 19 Apr 2007 08:02:07 +0900
FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:

> From: Hu Gang <hugang at soulinfo.com>
> Subject: Re: [Stgt-devel] [patch] modularization target types. V2.
> Date: Wed, 18 Apr 2007 09:59:29 +0800
> 
> > On Tue, 17 Apr 2007 16:40:52 +0900
> > FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > 
> > > From: Hu Gang <hugang at soulinfo.com>
> > > Subject: [Stgt-devel] [patch] modularization target types. V2.
> > > Date: Mon, 16 Apr 2007 18:29:06 +0800
> > > 
> > > > this patch adding support mutiple scsi type as a modules.
> > > > 
> > > > ---
> > > > 
> > > >  usr/mmc.c    |    7 ++++++-
> > > >  usr/osd.c    |    7 ++++++-
> > > >  usr/sbc.c    |    7 ++++++-
> > > >  usr/spt.c    |    8 +++++++-
> > > >  usr/target.c |   61 +++++++++++++++++++++++++++++++++++++++++++---------------
> > > >  usr/tgtd.h   |    4 ++++
> > > >  6 files changed, 74 insertions(+), 20 deletions(-)
> > > 
> > > Thanks, but:
> > > 
> > > rouen:~/git/tgt/usr$ git-apply --whitespace=error < ~/Mail/inbox/8
> > > Adds trailing whitespace.
> > > <stdin>:203:
> > > Adds trailing whitespace.
> > > <stdin>:215:
> > > Adds trailing whitespace.
> > > <stdin>:276:        shprintf(total, buf, rest,
> > > fatal: 3 lines add trailing whitespaces.
> > > 
> > 
> > I attached the patch into the email, hope it can clean to apply.
> 
> Nope.
> 
> rouen:~/git/tgt$ git-apply --whitespace=error < ~/tgt_temp_module.diff
> Adds trailing whitespace.
> <stdin>:126:
> Adds trailing whitespace.
> <stdin>:138:
> Adds trailing whitespace.
> <stdin>:199:        shprintf(total, buf, rest,
> fatal: 3 lines add trailing whitespaces.
> 
> 
> Please make sure your mailer works properly before posting to the
> mailing list.
> 
OK, here is the clean patch.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 02_type_per_lu.diff
Type: text/x-patch
Size: 11269 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070420/592cff8b/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 03_tgt_temp_module.diff
Type: text/x-patch
Size: 5959 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070420/592cff8b/attachment-0001.bin>

From fujita.tomonori at lab.ntt.co.jp  Fri Apr 20 07:43:41 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 20 Apr 2007 14:43:41 +0900
Subject: [Stgt-devel] VTL patch, take 2
In-Reply-To: <f29db9a80704121428m1ccf2dc1x49485fc77772c128@mail.gmail.com>
References: <f29db9a80704121428m1ccf2dc1x49485fc77772c128@mail.gmail.com>
Message-ID: <20070420144341W.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] VTL patch, take 2
Date: Fri, 13 Apr 2007 07:28:04 +1000

> SSC / SMC patches to SCSI Tgt code.
> 
> It is based from git commit :
>    ================================
> commit 47e15c234ca298d31b1709db592eef9db4bce0ca
> Author: Albert Pauw <albert.pauw at gmail.com>
> Date:   Sat Apr 7 17:31:54 2007 +0900
> 
>     some shortcut options missing from tgtadm
> 
>     Signed-off-by: Albert Pauw <albert.pauw at gmail.com>
>    ================================
> 
> 
> Additions from last patch include :
>  - Updated syntax to add/configure limited set of SMC / SSC parameters
>  - Start implementing structures for MODE SELECT / MODE SENSE op codes
>  - Start implementing structures for LOG SELECT / LOG SENSE op codes
> 
>  - SMC module includes:
>    Allocation of MODE pages and initialization to default values.
>    Ability to change Element Address Assignment
> 
> 
> 
> This is a work-in-progress and is being posted as an example of
> where/how I'm attempting to implement a VTL.
> 
> I need to update command parameter passing to recommended use of
> "--params ....."

I've attached a parser patch (taken from Linux kernel). See
tgt_device_update() about how it works if you are not familiar with
the Linux parser. I think that it works for you. And if so, I'll merge
this patch shortly (though I need to change it slightly).


> Next step is to implement the SCSI MODE SENSE op code so I can
> actually test what is being set is correct..
> 
> Note: in root of src is a 'tgt-setup' script which will (should)
> correctly configure the SSC & SMC modules

I think that it would be better to create a new directory for example
scripts.


diff --git a/usr/Makefile b/usr/Makefile
index 96535f9..2e299dc 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -45,7 +45,7 @@ CFLAGS += -Wall -g -O2 -Wstrict-prototyp
 
 PROGRAMS += tgtd tgtadm
 TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o osd.o spt.o scsi.o log.o \
-	driver.o util.o work.o
+	driver.o util.o work.o parser.o
 
 all: $(PROGRAMS)
 
diff --git a/usr/parser.c b/usr/parser.c
new file mode 100644
index 0000000..75fe12c
--- /dev/null
+++ b/usr/parser.c
@@ -0,0 +1,216 @@
+/*
+ * lib/parser.c - simple parser for mount, etc. options.
+ *
+ * This source code is licensed under the GNU General Public License,
+ * Version 2.  See the file COPYING for more details.
+ */
+
+#include <ctype.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "parser.h"
+
+/**
+ * match_one: - Determines if a string matches a simple pattern
+ * @s: the string to examine for presense of the pattern
+ * @p: the string containing the pattern
+ * @args: array of %MAX_OPT_ARGS &substring_t elements. Used to return match
+ * locations.
+ *
+ * Description: Determines if the pattern @p is present in string @s. Can only
+ * match extremely simple token=arg style patterns. If the pattern is found,
+ * the location(s) of the arguments will be returned in the @args array.
+ */
+static int match_one(char *s, char *p, substring_t args[])
+{
+	char *meta;
+	int argc = 0;
+
+	if (!p)
+		return 1;
+
+	while(1) {
+		int len = -1;
+		meta = strchr(p, '%');
+		if (!meta)
+			return strcmp(p, s) == 0;
+
+		if (strncmp(p, s, meta-p))
+			return 0;
+
+		s += meta - p;
+		p = meta + 1;
+
+		if (isdigit(*p))
+			len = strtoul(p, &p, 10);
+		else if (*p == '%') {
+			if (*s++ != '%')
+				return 0;
+			p++;
+			continue;
+		}
+
+		if (argc >= MAX_OPT_ARGS)
+			return 0;
+
+		args[argc].from = s;
+		switch (*p++) {
+		case 's':
+			if (strlen(s) == 0)
+				return 0;
+			else if (len == -1 || len > strlen(s))
+				len = strlen(s);
+			args[argc].to = s + len;
+			break;
+		case 'd':
+			strtol(s, &args[argc].to, 0);
+			goto num;
+		case 'u':
+			strtoul(s, &args[argc].to, 0);
+			goto num;
+		case 'o':
+			strtoul(s, &args[argc].to, 8);
+			goto num;
+		case 'x':
+			strtoul(s, &args[argc].to, 16);
+		num:
+			if (args[argc].to == args[argc].from)
+				return 0;
+			break;
+		default:
+			return 0;
+		}
+		s = args[argc].to;
+		argc++;
+	}
+}
+
+/**
+ * match_token: - Find a token (and optional args) in a string
+ * @s: the string to examine for token/argument pairs
+ * @table: match_table_t describing the set of allowed option tokens and the
+ * arguments that may be associated with them. Must be terminated with a
+ * &struct match_token whose pattern is set to the NULL pointer.
+ * @args: array of %MAX_OPT_ARGS &substring_t elements. Used to return match
+ * locations.
+ *
+ * Description: Detects which if any of a set of token strings has been passed
+ * to it. Tokens can include up to MAX_OPT_ARGS instances of basic c-style
+ * format identifiers which will be taken into account when matching the
+ * tokens, and whose locations will be returned in the @args array.
+ */
+int match_token(char *s, match_table_t table, substring_t args[])
+{
+	struct match_token *p;
+
+	for (p = table; !match_one(s, p->pattern, args) ; p++)
+		;
+
+	return p->token;
+}
+
+/**
+ * match_number: scan a number in the given base from a substring_t
+ * @s: substring to be scanned
+ * @result: resulting integer on success
+ * @base: base to use when converting string
+ *
+ * Description: Given a &substring_t and a base, attempts to parse the substring
+ * as a number in that base. On success, sets @result to the integer represented
+ * by the string and returns 0. Returns either -ENOMEM or -EINVAL on failure.
+ */
+static int match_number(substring_t *s, int *result, int base)
+{
+	char *endp;
+	char *buf;
+	int ret;
+
+	buf = malloc(s->to - s->from + 1);
+	if (!buf)
+		return -ENOMEM;
+	memcpy(buf, s->from, s->to - s->from);
+	buf[s->to - s->from] = '\0';
+	*result = strtol(buf, &endp, base);
+	ret = 0;
+	if (endp == buf)
+		ret = -EINVAL;
+	free(buf);
+	return ret;
+}
+
+/**
+ * match_int: - scan a decimal representation of an integer from a substring_t
+ * @s: substring_t to be scanned
+ * @result: resulting integer on success
+ *
+ * Description: Attempts to parse the &substring_t @s as a decimal integer. On
+ * success, sets @result to the integer represented by the string and returns 0.
+ * Returns either -ENOMEM or -EINVAL on failure.
+ */
+int match_int(substring_t *s, int *result)
+{
+	return match_number(s, result, 0);
+}
+
+/**
+ * match_octal: - scan an octal representation of an integer from a substring_t
+ * @s: substring_t to be scanned
+ * @result: resulting integer on success
+ *
+ * Description: Attempts to parse the &substring_t @s as an octal integer. On
+ * success, sets @result to the integer represented by the string and returns
+ * 0. Returns either -ENOMEM or -EINVAL on failure.
+ */
+int match_octal(substring_t *s, int *result)
+{
+	return match_number(s, result, 8);
+}
+
+/**
+ * match_hex: - scan a hex representation of an integer from a substring_t
+ * @s: substring_t to be scanned
+ * @result: resulting integer on success
+ *
+ * Description: Attempts to parse the &substring_t @s as a hexadecimal integer.
+ * On success, sets @result to the integer represented by the string and
+ * returns 0. Returns either -ENOMEM or -EINVAL on failure.
+ */
+int match_hex(substring_t *s, int *result)
+{
+	return match_number(s, result, 16);
+}
+
+/**
+ * match_strcpy: - copies the characters from a substring_t to a string
+ * @to: string to copy characters to.
+ * @s: &substring_t to copy
+ *
+ * Description: Copies the set of characters represented by the given
+ * &substring_t @s to the c-style string @to. Caller guarantees that @to is
+ * large enough to hold the characters of @s.
+ */
+void match_strcpy(char *to, substring_t *s)
+{
+	memcpy(to, s->from, s->to - s->from);
+	to[s->to - s->from] = '\0';
+}
+
+/**
+ * match_strdup: - allocate a new string with the contents of a substring_t
+ * @s: &substring_t to copy
+ *
+ * Description: Allocates and returns a string filled with the contents of
+ * the &substring_t @s. The caller is responsible for freeing the returned
+ * string with kfree().
+ */
+char *match_strdup(substring_t *s)
+{
+	char *p = malloc(s->to - s->from + 1);
+	if (p)
+		match_strcpy(p, s);
+	return p;
+}
diff --git a/usr/parser.h b/usr/parser.h
new file mode 100644
index 0000000..fa33328
--- /dev/null
+++ b/usr/parser.h
@@ -0,0 +1,33 @@
+/*
+ * linux/include/linux/parser.h
+ *
+ * Header for lib/parser.c
+ * Intended use of these functions is parsing filesystem argument lists,
+ * but could potentially be used anywhere else that simple option=arg
+ * parsing is required.
+ */
+
+
+/* associates an integer enumerator with a pattern string. */
+struct match_token {
+	int token;
+	char *pattern;
+};
+
+typedef struct match_token match_table_t[];
+
+/* Maximum number of arguments that match_token will find in a pattern */
+enum {MAX_OPT_ARGS = 3};
+
+/* Describe the location within a string of a substring */
+typedef struct {
+	char *from;
+	char *to;
+} substring_t;
+
+int match_token(char *, match_table_t table, substring_t args[]);
+int match_int(substring_t *, int *result);
+int match_octal(substring_t *, int *result);
+int match_hex(substring_t *, int *result);
+void match_strcpy(char *, substring_t *);
+char *match_strdup(substring_t *);
diff --git a/usr/target.c b/usr/target.c
index 1a9fe68..1510078 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -29,6 +29,7 @@ #include <unistd.h>
 #include <sys/socket.h>
 
 #include "list.h"
+#include "parser.h"
 #include "util.h"
 #include "tgtd.h"
 #include "driver.h"
@@ -338,9 +339,20 @@ int device_reserved(struct scsi_cmd *cmd
 	return -EBUSY;
 }
 
-int tgt_device_update(int tid, uint64_t dev_id, char *name)
+enum {
+	Opt_scsiid, Opt_scsisn, Opt_err,
+};
+
+static match_table_t tokens = {
+	{Opt_scsiid, "Scsi_id=%s"},
+	{Opt_scsisn, "Scsi_sn=%s"},
+	{Opt_err, NULL},
+};
+
+int tgt_device_update(int tid, uint64_t dev_id, char *params)
 {
 	int err = 0;
+	char *p;
 	struct target *target;
 	struct scsi_lu *lu;
 
@@ -354,12 +366,24 @@ int tgt_device_update(int tid, uint64_t
 		return TGTADM_NO_LUN;
 	}
 
-	if (!strncmp(name, "scsi_id=", 8))
-		memcpy(lu->scsi_id, name + 8, sizeof(lu->scsi_id) - 1);
-	else if (!strncmp(name, "scsi_sn=", 8))
-		memcpy(lu->scsi_sn, name + 8, sizeof(lu->scsi_sn) - 1);
-	else
-		err = TGTADM_INVALID_REQUEST;
+	while ((p = strsep(&params, ",")) != NULL) {
+		substring_t args[MAX_OPT_ARGS];
+		int token;
+		if (!*p)
+			continue;
+		token = match_token(p, tokens, args);
+
+		switch (token) {
+		case Opt_scsiid:
+			match_strcpy(lu->scsi_id, &args[0]);
+			break;
+		case Opt_scsisn:
+			match_strcpy(lu->scsi_sn, &args[0]);
+			break;
+		default:
+			err = TGTADM_INVALID_REQUEST;
+		}
+	}
 
 	return err;
 }


From albert.pauw at gmail.com  Fri Apr 20 19:11:29 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Fri, 20 Apr 2007 19:11:29 +0200
Subject: [Stgt-devel] [patch] modularization target types. V2.
In-Reply-To: <20070420085533.41f413f5@hugang-laptop>
References: <20070416182906.1b29452a@hugang-laptop>	<20070417164052Q.fujita.tomonori@lab.ntt.co.jp>	<20070418095929.4bfd5cec@hugang-laptop>	<20070419080207V.fujita.tomonori@lab.ntt.co.jp>
	<20070420085533.41f413f5@hugang-laptop>
Message-ID: <4628F441.5000603@gmail.com>

I applied these patches and tried my setup script below,
but got a segmentation fault at the marked point. Without the patch (the 
original git version)
it works fine. I get the error for type disk as well as cd.

Albert



tgtadm -L iscsi -m account     -o new    -u iscsi -p myuser
tgtadm -L iscsi -m account     -o new    -u iscsi_in -p mypassword
tgtadm -L iscsi -m target      -o new    -t 1 -T 
iqn.2007-03.com.example:stgt.disk -Y disk

 >> the following line generates a segmentation fault:
tgtadm -L iscsi -m logicalunit -o new    -t 1 -l 0 -b /tmp/disk.bin

 >> from now on I get the messages:
 >> tgtadm: can't connect to the tgt daemon, Connection refused
 >> tgtadm: can't send the request to the tgt daemon, Transport endpoint 
is not connected

tgtadm -L iscsi -m logicalunit -o update -t 1 -l 0 -n scsi_id -v "HARDDISK"

tgtadm -L iscsi -m logicalunit -o update -t 1 -l 0 -n scsi_sn -v "001"

tgtadm -L iscsi -m target      -o bind   -t 1 -I 127.0.0.1
#
# Set iSCSI parameters
#
... etc ...


From fujita.tomonori at lab.ntt.co.jp  Sat Apr 21 12:35:55 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 21 Apr 2007 19:35:55 +0900 (JST)
Subject: [Stgt-devel] [PATCH] iSNS support
In-Reply-To: <200704151342.l3FDg6Bd011205@r-dd.iij4u.or.jp>
References: <200704151342.l3FDg6Bd011205@r-dd.iij4u.or.jp>
Message-ID: <20070421193537Q.fujita.tomonori@lab.ntt.co.jp>

From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
Subject: [Stgt-devel] [PATCH] iSNS support
Date: Sun, 15 Apr 2007 22:42:02 +0900

> Somehow I need iSNS in tgt now.
> 
> I know that IET iSNS code has some problems (e.g. can't handle errors
> properly), however, I just modified it for tgt. It needs to be fixed
> later on.
> 
> Before I apply this, I need to find how tgt supports iSNS
> configurations; tgtd boot options or via tgt.
> 
> Note that this patch requires you to modify the code to configure the
> iSNS server address (see usr/iscsi/transport.c).

Merged.

Here are some examples:

root at lilac:~# ./tgt/usr/tgtadm --lld iscsi --op show --mode sys
iSNS:
    iSNS=Off
    iSNSServerIP=
    iSNSServerPort=3205
    iSNSAccessControl=Off

root at lilac:~# ./tgt/usr/tgtadm --op update --mode sys --name iSNSServerIP -v 192.168.11.133

root at lilac:~# ./tgt/usr/tgtadm --op update --mode sys --name iSNS -v On

root at lilac:~# ./tgt/usr/tgtadm --lld iscsi --op show --mode sys
iSNS:
    iSNS=On
    iSNSServerIP=192.168.11.133
    iSNSServerPort=3205
    iSNSAccessControl=Off

Now you are ready to add targets.

TODO:
- once you enable iSNS, you can't disable it.
- you need to enable iSNS before adding targets.
- stop reading from sockets synchronously


From fujita.tomonori at lab.ntt.co.jp  Sat Apr 21 12:35:56 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 21 Apr 2007 19:35:56 +0900 (JST)
Subject: [Stgt-devel] VTL patch, take 2
In-Reply-To: <20070420144341W.fujita.tomonori@lab.ntt.co.jp>
References: <f29db9a80704121428m1ccf2dc1x49485fc77772c128@mail.gmail.com>
	<20070420144341W.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070421193634A.fujita.tomonori@lab.ntt.co.jp>

From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
Subject: Re: [Stgt-devel] VTL patch, take 2
Date: Fri, 20 Apr 2007 14:43:41 +0900

> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: [Stgt-devel] VTL patch, take 2
> Date: Fri, 13 Apr 2007 07:28:04 +1000
> 
> > SSC / SMC patches to SCSI Tgt code.
> > 
> > It is based from git commit :
> >    ================================
> > commit 47e15c234ca298d31b1709db592eef9db4bce0ca
> > Author: Albert Pauw <albert.pauw at gmail.com>
> > Date:   Sat Apr 7 17:31:54 2007 +0900
> > 
> >     some shortcut options missing from tgtadm
> > 
> >     Signed-off-by: Albert Pauw <albert.pauw at gmail.com>
> >    ================================
> > 
> > 
> > Additions from last patch include :
> >  - Updated syntax to add/configure limited set of SMC / SSC parameters
> >  - Start implementing structures for MODE SELECT / MODE SENSE op codes
> >  - Start implementing structures for LOG SELECT / LOG SENSE op codes
> > 
> >  - SMC module includes:
> >    Allocation of MODE pages and initialization to default values.
> >    Ability to change Element Address Assignment
> > 
> > 
> > 
> > This is a work-in-progress and is being posted as an example of
> > where/how I'm attempting to implement a VTL.
> > 
> > I need to update command parameter passing to recommended use of
> > "--params ....."
> 
> I've attached a parser patch (taken from Linux kernel). See
> tgt_device_update() about how it works if you are not familiar with
> the Linux parser. I think that it works for you. And if so, I'll merge
> this patch shortly (though I need to change it slightly).

Merged.


From albert.pauw at gmail.com  Sat Apr 21 13:55:34 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Sat, 21 Apr 2007 13:55:34 +0200
Subject: [Stgt-devel] scsi_id and scsi_sn not able to set
Message-ID: <4629FBB6.4020105@gmail.com>

Up until the last patches the following worked fine:

tgtadm -L iscsi -m logicalunit -o update -t 2 -l 1 -n scsi_id -v "CDROM ISO"
tgtadm -L iscsi -m logicalunit -o update -t 2 -l 1 -n scsi_sn -v "001"

But that doesn't seem to work anymore. Now I get 'invalid request'.
How can I set these parameters?

Thanks,

Albert

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070421/615fb9aa/attachment.html>

From fujita.tomonori at lab.ntt.co.jp  Sat Apr 21 14:44:47 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 21 Apr 2007 21:44:47 +0900
Subject: [Stgt-devel] scsi_id and scsi_sn not able to set
In-Reply-To: <4629FBB6.4020105@gmail.com>
References: <4629FBB6.4020105@gmail.com>
Message-ID: <20070421214447A.fujita.tomonori@lab.ntt.co.jp>

From: Albert Pauw <albert.pauw at gmail.com>
Subject: [Stgt-devel] scsi_id and scsi_sn not able to set
Date: Sat, 21 Apr 2007 13:55:34 +0200

> Up until the last patches the following worked fine:
> 
> tgtadm -L iscsi -m logicalunit -o update -t 2 -l 1 -n scsi_id -v "CDROM ISO"
> tgtadm -L iscsi -m logicalunit -o update -t 2 -l 1 -n scsi_sn -v "001"
> 
> But that doesn't seem to work anymore. Now I get 'invalid request'.
> How can I set these parameters?

Oops, here's a fix.

BTW, please use a plain-text mail.

diff --git a/usr/target.c b/usr/target.c
index 156b8e6..118e7ad 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -344,8 +344,8 @@ enum {
 };
 
 static match_table_t tokens = {
-	{Opt_scsiid, "Scsi_id=%s"},
-	{Opt_scsisn, "Scsi_sn=%s"},
+	{Opt_scsiid, "scsi_id=%s"},
+	{Opt_scsisn, "scsi_sn=%s"},
 	{Opt_err, NULL},
 };
 


From fujita.tomonori at lab.ntt.co.jp  Sat Apr 21 18:07:43 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 22 Apr 2007 01:07:43 +0900
Subject: [Stgt-devel] FirstBurstLenght > MaxBurstLength --> error
In-Reply-To: <4621F167.3070504@gmail.com>
References: <4621F167.3070504@gmail.com>
Message-ID: <20070422010743I.fujita.tomonori@lab.ntt.co.jp>

From: Albert Pauw <albert.pauw at gmail.com>
Subject: [Stgt-devel] FirstBurstLenght > MaxBurstLength --> error
Date: Sun, 15 Apr 2007 11:33:27 +0200

> Running the test regression script of open-iscsi on stgt I found an 
> error, which I did not encounter with other targets.
> 
> It is test #17 with the following parameters:
> 
> ================== TEST #17 BEGIN ====================
> ImmediateData = No
> InitialR2T = No
> HeaderDigest = None
> DataDigest = None
> FirstBurstLength = 8192
> MaxBurstLength = 4096
> MaxRecvDataSegmentLength = 4096
> MaxOutstandingR2T = 1
> 
> I get the error "Invalid burst lengths first_burst 8192 max_burst 4096" 
> in /var/log/messages and the login breaks of.
> According to the RFC 3720 "FirstBurstLength MUST NOT exceed 
> MaxBurstLength" (chap 12.14), which means that the target
> should answer back with a FirstBurstLenght parameters equal to 
> MaxBurstLenght.
> 
> I investigated with wireshark and found that this is exactly the 
> behaviour of the Wasabi Storagebuilder target,
> iscsi-target silently accepts FirstBurstLength > MaxBurstLength, and 
> stgt only gives an error.

I've attached a patch. It's not pretty but I don't have a better idea.


diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 2377952..d973409 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -226,8 +226,10 @@ static void login_security_done(struct i
 static void text_scan_login(struct iscsi_connection *conn)
 {
 	char *key, *value, *data;
-	int datasize, idx;
+	int datasize, idx, first_burst = 0;
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
+	struct param *p = conn->session_param;
+	char buf[32];
 
 	data = conn->req.data;
 	datasize = conn->req.datasize;
@@ -240,14 +242,12 @@ static void text_scan_login(struct iscsi
 		else if (!((idx = param_index_by_name(key, session_keys)) < 0)) {
 			int err;
 			unsigned int val;
-			char buf[32];
 
 			if (idx == ISCSI_PARAM_MAX_RECV_DLENGTH)
 				idx = ISCSI_PARAM_MAX_XMIT_DLENGTH;
 
 			if (param_str_to_val(session_keys, idx, value, &val) < 0) {
-				if (conn->session_param[idx].state
-				    == KEY_STATE_START) {
+				if (p[idx].state == KEY_STATE_START) {
 					text_key_add_reject(conn, key);
 					continue;
 				} else {
@@ -261,9 +261,14 @@ static void text_scan_login(struct iscsi
 			}
 
 			err = param_check_val(session_keys, idx, &val);
-			err = param_set_val(session_keys, conn->session_param, idx, &val);
+			if (idx == ISCSI_PARAM_FIRST_BURST &&
+			    p[idx].state == KEY_STATE_START) {
+				first_burst = val;
+				continue;
+			}
+			err = param_set_val(session_keys, p, idx, &val);
 
-			switch (conn->session_param[idx].state) {
+			switch (p[idx].state) {
 			case KEY_STATE_START:
 				if (idx == ISCSI_PARAM_MAX_XMIT_DLENGTH)
 					break;
@@ -272,25 +277,35 @@ static void text_scan_login(struct iscsi
 				text_key_add(conn, key, buf);
 				break;
 			case KEY_STATE_REQUEST:
-				if (val != conn->session_param[idx].val) {
+				if (val != p[idx].val) {
 					rsp->status_class =
 						ISCSI_STATUS_CLS_INITIATOR_ERR;
 					rsp->status_detail =
 						ISCSI_LOGIN_STATUS_INIT_ERR;
 					conn->state = STATE_EXIT;
-					log_warning("%s %u %u\n", key,
-					val, conn->session_param[idx].val);
+					eprintf("invalid response %s %u %u\n",
+						key, val, p[idx].val);
 					goto out;
 				}
 				break;
 			case KEY_STATE_DONE:
 				break;
 			}
-			conn->session_param[idx].state = KEY_STATE_DONE;
+			p[idx].state = KEY_STATE_DONE;
 		} else
 			text_key_add(conn, key, "NotUnderstood");
 	}
 
+	if (first_burst) {
+		idx = ISCSI_PARAM_MAX_BURST;
+		if (first_burst > p[idx].val)
+			first_burst = p[idx].val;
+		idx = ISCSI_PARAM_FIRST_BURST;
+		p[idx].state = KEY_STATE_DONE;
+		param_set_val(session_keys, p, idx, &first_burst);
+		param_val_to_str(session_keys, idx, first_burst, buf);
+		text_key_add(conn, "FirstBurstLength", buf);
+	}
 out:
 	return;
 }



From albert.pauw at gmail.com  Sat Apr 21 18:41:13 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Sat, 21 Apr 2007 18:41:13 +0200
Subject: [Stgt-devel] FirstBurstLenght > MaxBurstLength --> error
In-Reply-To: <20070422010743I.fujita.tomonori@lab.ntt.co.jp>
References: <4621F167.3070504@gmail.com>
	<20070422010743I.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <462A3EA9.2000605@gmail.com>

Thanks,

first tests seem to work fine.

Albert

FUJITA Tomonori wrote:
> From: Albert Pauw <albert.pauw at gmail.com>
> Subject: [Stgt-devel] FirstBurstLenght > MaxBurstLength --> error
> Date: Sun, 15 Apr 2007 11:33:27 +0200
> 
>> Running the test regression script of open-iscsi on stgt I found an 
>> error, which I did not encounter with other targets.
>>
>> It is test #17 with the following parameters:
>>
>> ================== TEST #17 BEGIN ====================
>> ImmediateData = No
>> InitialR2T = No
>> HeaderDigest = None
>> DataDigest = None
>> FirstBurstLength = 8192
>> MaxBurstLength = 4096
>> MaxRecvDataSegmentLength = 4096
>> MaxOutstandingR2T = 1
>>
>> I get the error "Invalid burst lengths first_burst 8192 max_burst 4096" 
>> in /var/log/messages and the login breaks of.
>> According to the RFC 3720 "FirstBurstLength MUST NOT exceed 
>> MaxBurstLength" (chap 12.14), which means that the target
>> should answer back with a FirstBurstLenght parameters equal to 
>> MaxBurstLenght.
>>
>> I investigated with wireshark and found that this is exactly the 
>> behaviour of the Wasabi Storagebuilder target,
>> iscsi-target silently accepts FirstBurstLength > MaxBurstLength, and 
>> stgt only gives an error.
> 
> I've attached a patch. It's not pretty but I don't have a better idea.
> 
> 
> diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> index 2377952..d973409 100644
> --- a/usr/iscsi/iscsid.c
> +++ b/usr/iscsi/iscsid.c
> @@ -226,8 +226,10 @@ static void login_security_done(struct i
>  static void text_scan_login(struct iscsi_connection *conn)
>  {
>  	char *key, *value, *data;
> -	int datasize, idx;
> +	int datasize, idx, first_burst = 0;
>  	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
> +	struct param *p = conn->session_param;
> +	char buf[32];
>  
>  	data = conn->req.data;
>  	datasize = conn->req.datasize;
> @@ -240,14 +242,12 @@ static void text_scan_login(struct iscsi
>  		else if (!((idx = param_index_by_name(key, session_keys)) < 0)) {
>  			int err;
>  			unsigned int val;
> -			char buf[32];
>  
>  			if (idx == ISCSI_PARAM_MAX_RECV_DLENGTH)
>  				idx = ISCSI_PARAM_MAX_XMIT_DLENGTH;
>  
>  			if (param_str_to_val(session_keys, idx, value, &val) < 0) {
> -				if (conn->session_param[idx].state
> -				    == KEY_STATE_START) {
> +				if (p[idx].state == KEY_STATE_START) {
>  					text_key_add_reject(conn, key);
>  					continue;
>  				} else {
> @@ -261,9 +261,14 @@ static void text_scan_login(struct iscsi
>  			}
>  
>  			err = param_check_val(session_keys, idx, &val);
> -			err = param_set_val(session_keys, conn->session_param, idx, &val);
> +			if (idx == ISCSI_PARAM_FIRST_BURST &&
> +			    p[idx].state == KEY_STATE_START) {
> +				first_burst = val;
> +				continue;
> +			}
> +			err = param_set_val(session_keys, p, idx, &val);
>  
> -			switch (conn->session_param[idx].state) {
> +			switch (p[idx].state) {
>  			case KEY_STATE_START:
>  				if (idx == ISCSI_PARAM_MAX_XMIT_DLENGTH)
>  					break;
> @@ -272,25 +277,35 @@ static void text_scan_login(struct iscsi
>  				text_key_add(conn, key, buf);
>  				break;
>  			case KEY_STATE_REQUEST:
> -				if (val != conn->session_param[idx].val) {
> +				if (val != p[idx].val) {
>  					rsp->status_class =
>  						ISCSI_STATUS_CLS_INITIATOR_ERR;
>  					rsp->status_detail =
>  						ISCSI_LOGIN_STATUS_INIT_ERR;
>  					conn->state = STATE_EXIT;
> -					log_warning("%s %u %u\n", key,
> -					val, conn->session_param[idx].val);
> +					eprintf("invalid response %s %u %u\n",
> +						key, val, p[idx].val);
>  					goto out;
>  				}
>  				break;
>  			case KEY_STATE_DONE:
>  				break;
>  			}
> -			conn->session_param[idx].state = KEY_STATE_DONE;
> +			p[idx].state = KEY_STATE_DONE;
>  		} else
>  			text_key_add(conn, key, "NotUnderstood");
>  	}
>  
> +	if (first_burst) {
> +		idx = ISCSI_PARAM_MAX_BURST;
> +		if (first_burst > p[idx].val)
> +			first_burst = p[idx].val;
> +		idx = ISCSI_PARAM_FIRST_BURST;
> +		p[idx].state = KEY_STATE_DONE;
> +		param_set_val(session_keys, p, idx, &first_burst);
> +		param_val_to_str(session_keys, idx, first_burst, buf);
> +		text_key_add(conn, "FirstBurstLength", buf);
> +	}
>  out:
>  	return;
>  }
> 
> 



From fujita.tomonori at lab.ntt.co.jp  Sun Apr 22 16:16:42 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 22 Apr 2007 23:16:42 +0900 (JST)
Subject: [Stgt-devel] [PATCH] head and data digest
Message-ID: <20070422160651E.fujita.tomonori@lab.ntt.co.jp>

This patch adds head and data digest features (not heavily
tested). It's against the latest git tree.

Please test this and let me know the results.

Do we provide all features of iscsitarget?

diff --git a/usr/iscsi/conn.c b/usr/iscsi/conn.c
index e4e36aa..fcd2385 100644
--- a/usr/iscsi/conn.c
+++ b/usr/iscsi/conn.c
@@ -176,18 +176,3 @@ int conn_take_fd(struct iscsi_connection
 
 	return 0;
 }
-
-void conn_read_pdu(struct iscsi_connection *conn)
-{
-	conn->rx_iostate = IOSTATE_READ_BHS;
-	conn->rx_buffer = (void *)&conn->req.bhs;
-	conn->rx_size = BHS_SIZE;
-}
-
-void conn_write_pdu(struct iscsi_connection *conn)
-{
-	conn->tx_iostate = IOSTATE_WRITE_BHS;
-	memset(&conn->rsp, 0, sizeof(conn->rsp));
-	conn->tx_buffer = (void *)&conn->rsp.bhs;
-	conn->tx_size = BHS_SIZE;
-}
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 2377952..fbde08c 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -38,9 +38,53 @@ #include "iscsid.h"
 #include "tgtd.h"
 #include "util.h"
 #include "driver.h"
+#include "crc32c.h"
 
 #define MAX_QUEUE_CMD	32
 
+enum {
+	IOSTATE_FREE,
+
+	IOSTATE_RX_BHS,
+	IOSTATE_RX_INIT_AHS,
+	IOSTATE_RX_AHS,
+	IOSTATE_RX_INIT_HDIGEST,
+	IOSTATE_RX_HDIGEST,
+	IOSTATE_RX_CHECK_HDIGEST,
+	IOSTATE_RX_INIT_DATA,
+	IOSTATE_RX_DATA,
+	IOSTATE_RX_INIT_DDIGEST,
+	IOSTATE_RX_DDIGEST,
+	IOSTATE_RX_CHECK_DDIGEST,
+	IOSTATE_RX_END,
+
+	IOSTATE_TX_BHS,
+	IOSTATE_TX_INIT_AHS,
+	IOSTATE_TX_AHS,
+	IOSTATE_TX_INIT_HDIGEST,
+	IOSTATE_TX_HDIGEST,
+	IOSTATE_TX_INIT_DATA,
+	IOSTATE_TX_DATA,
+	IOSTATE_TX_INIT_DDIGEST,
+	IOSTATE_TX_DDIGEST,
+	IOSTATE_TX_END,
+};
+
+void conn_read_pdu(struct iscsi_connection *conn)
+{
+	conn->rx_iostate = IOSTATE_RX_BHS;
+	conn->rx_buffer = (void *)&conn->req.bhs;
+	conn->rx_size = BHS_SIZE;
+}
+
+static void conn_write_pdu(struct iscsi_connection *conn)
+{
+	conn->tx_iostate = IOSTATE_TX_BHS;
+	memset(&conn->rsp, 0, sizeof(conn->rsp));
+	conn->tx_buffer = (void *)&conn->rsp.bhs;
+	conn->tx_size = BHS_SIZE;
+}
+
 static struct iscsi_key login_keys[] = {
 	{"InitiatorName",},
 	{"InitiatorAlias",},
@@ -1492,6 +1536,11 @@ static int iscsi_task_rx_start(struct is
 		break;
 	}
 
+	if (conn->rx_task) {
+		conn->req.ahs = conn->rx_task->ahs;
+		conn->req.data = conn->rx_task->data;
+	}
+
 	return err;
 }
 
@@ -1662,167 +1711,314 @@ nodata:
 	return -EAGAIN;
 }
 
+static int do_recv(int fd, struct iscsi_connection *conn, int next_state)
+{
+	int ret;
+
+	ret = conn->tp->ep_read(fd, conn->rx_buffer, conn->rx_size);
+	if (!ret) {
+		conn->state = STATE_CLOSE;
+		return 0;
+	} else if (ret < 0) {
+		if (errno == EINTR || errno == EAGAIN)
+			return 0;
+		else
+			return -EIO;
+	}
+
+	conn->rx_size -= ret;
+	conn->rx_buffer += ret;
+	if (!conn->rx_size)
+		conn->rx_iostate = next_state;
+
+	return ret;
+}
+
 static void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
 {
-	int res;
+	int ret = 0, hdigest, ddigest;
+	uint32_t crc;
 
+	if (conn->state == STATE_SCSI) {
+		struct param *p = conn->session_param;
+		hdigest = p[ISCSI_PARAM_HDRDGST_EN].val & DIGEST_CRC32C;
+		ddigest = p[ISCSI_PARAM_DATADGST_EN].val & DIGEST_CRC32C;
+	} else
+		hdigest = ddigest = 0;
+again:
 	switch (conn->rx_iostate) {
-	case IOSTATE_READ_BHS:
-	case IOSTATE_READ_AHS_DATA:
-	read_again:
-		res = conn->tp->ep_read(fd, conn->rx_buffer, conn->rx_size);
-		if (!res) {
-			conn->state = STATE_CLOSE;
+	case IOSTATE_RX_BHS:
+		ret = do_recv(fd, conn, IOSTATE_RX_INIT_AHS);
+		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_AHS)
 			break;
-		} else if (res < 0) {
-			if (errno == EINTR)
-				goto read_again;
-			else if (errno == EAGAIN)
-				break;
-			else {
+	case IOSTATE_RX_INIT_AHS:
+		if (conn->state == STATE_SCSI) {
+			ret = iscsi_task_rx_start(conn);
+			if (ret) {
 				conn->state = STATE_CLOSE;
-				dprintf("%d %d, %m\n", res, errno);
+				break;
 			}
+		} else {
+			conn->rx_buffer = conn->req_buffer;
+			conn->req.ahs = conn->rx_buffer;
+			conn->req.data = conn->rx_buffer + conn->rx_size;
+		}
+		conn->req.ahssize = conn->req.bhs.hlength * 4;
+		conn->req.datasize = ntoh24(conn->req.bhs.dlength);
+		conn->rx_size = roundup(conn->req.ahssize, 4);
+		if (conn->rx_size) {
+			ret = do_recv(fd, conn, IOSTATE_RX_AHS);
+			if (ret <= 0)
+				break;
+		} else
+			conn->rx_iostate = hdigest ?
+				IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA;
+
+		if (conn->rx_iostate == IOSTATE_RX_INIT_DATA)
+			goto again;
+		else if (conn->rx_iostate != IOSTATE_RX_AHS)
+			break;
+	case IOSTATE_RX_AHS:
+		ret = do_recv(fd, conn, hdigest ?
+			      IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA);
+		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_HDIGEST)
 			break;
+	case IOSTATE_RX_INIT_HDIGEST:
+		conn->rx_buffer = conn->rx_digest;
+		conn->rx_size = sizeof(conn->rx_digest);
+		conn->rx_iostate = IOSTATE_RX_HDIGEST;
+	case IOSTATE_RX_HDIGEST:
+		ret = do_recv(fd, conn, IOSTATE_RX_CHECK_HDIGEST);
+		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_CHECK_HDIGEST)
+			break;
+	case IOSTATE_RX_CHECK_HDIGEST:
+		crc = ~0;
+		crc = crc32c(crc, &conn->req.bhs, BHS_SIZE);
+		if (conn->req.ahssize)
+			crc = crc32c(crc, conn->req.ahs,
+				     roundup(conn->req.ahssize, 4));
+		crc = ~__cpu_to_le32(crc);
+		if (*((uint32_t *)conn->rx_digest) != crc) {
+			eprintf("rx hdr digest error 0x%x calc 0x%x\n",
+				*((uint32_t *)conn->rx_digest), crc);
+			conn->state = STATE_CLOSE;
 		}
-		conn->rx_size -= res;
-		conn->rx_buffer += res;
-		if (conn->rx_size)
+		conn->rx_iostate = IOSTATE_RX_INIT_DATA;
+	case IOSTATE_RX_INIT_DATA:
+		conn->rx_size = roundup(conn->req.datasize, 4);
+		if (conn->rx_size) {
+			conn->rx_iostate = IOSTATE_RX_DATA;
+			conn->rx_buffer = conn->req.data;
+		} else {
+			conn->rx_iostate = IOSTATE_RX_END;
 			break;
+		}
+	case IOSTATE_RX_DATA:
+		ret = do_recv(fd, conn, ddigest ?
+			      IOSTATE_RX_INIT_DDIGEST : IOSTATE_RX_END);
+		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_DDIGEST)
+			break;
+	case IOSTATE_RX_INIT_DDIGEST:
+		conn->rx_buffer = conn->rx_digest;
+		conn->rx_size = sizeof(conn->rx_digest);
+		conn->rx_iostate = IOSTATE_RX_DDIGEST;
+	case IOSTATE_RX_DDIGEST:
+		ret = do_recv(fd, conn, IOSTATE_RX_CHECK_DDIGEST);
+		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_CHECK_DDIGEST)
+			break;
+	case IOSTATE_RX_CHECK_DDIGEST:
+		crc = ~0;
+		crc = crc32c(crc, conn->req.data, roundup(conn->req.datasize, 4));
+		crc = ~__cpu_to_le32(crc);
+		conn->rx_iostate = IOSTATE_RX_END;
+		if (*((uint32_t *)conn->rx_digest) != crc) {
+			eprintf("rx hdr digest error 0x%x calc 0x%x\n",
+				*((uint32_t *)conn->rx_digest), crc);
+			conn->state = STATE_CLOSE;
+		}
+		break;
+	default:
+		eprintf("error %d %d\n", conn->state, conn->rx_iostate);
+		exit(1);
+	}
 
-		switch (conn->rx_iostate) {
-		case IOSTATE_READ_BHS:
-			conn->req.ahssize = conn->req.bhs.hlength * 4;
-			conn->req.datasize = ntoh24(conn->req.bhs.dlength);
+	if (ret < 0 ||
+	    conn->rx_iostate != IOSTATE_RX_END ||
+	    conn->state == STATE_CLOSE)
+		return;
 
-			if (conn->state == STATE_SCSI) {
-				res = iscsi_task_rx_start(conn);
-				if (res) {
-					conn->state = STATE_CLOSE;
-					break;
-				}
-			} else {
-				conn->rx_buffer = conn->req_buffer;
-				conn->req.ahs = conn->rx_buffer;
-				conn->rx_size = roundup(conn->req.ahssize, 4);
-				conn->req.data = conn->rx_buffer + conn->rx_size;
-				conn->rx_size += roundup(conn->req.datasize, 4);
-			}
+	if (conn->rx_size) {
+		eprintf("error %d %d %d\n", conn->state, conn->rx_iostate,
+			conn->rx_size);
+		exit(1);
+	}
 
-			if (conn->rx_size) {
-				conn->rx_iostate = IOSTATE_READ_AHS_DATA;
-				goto read_again;
-			}
+	if (conn->state == STATE_SCSI) {
+		ret = iscsi_task_rx_done(conn);
+		if (ret)
+			conn->state = STATE_CLOSE;
+		else
+			conn_read_pdu(conn);
+	} else {
+		conn_write_pdu(conn);
+		tgt_event_modify(fd, EPOLLOUT);
+		ret = cmnd_execute(conn);
+		if (ret)
+			conn->state = STATE_CLOSE;
+	}
+}
 
-		case IOSTATE_READ_AHS_DATA:
-			if (conn->state == STATE_SCSI) {
-				res = iscsi_task_rx_done(conn);
-				if (!res)
-					conn_read_pdu(conn);
-			} else {
-				conn_write_pdu(conn);
-				tgt_event_modify(fd, EPOLLOUT);
-				res = cmnd_execute(conn);
-			}
+static int do_send(int fd, struct iscsi_connection *conn, int next_state)
+{
+	int ret;
+again:
+	ret = conn->tp->ep_write_begin(fd, conn->tx_buffer, conn->tx_size);
+	if (ret < 0) {
+		if (errno != EINTR && errno != EAGAIN)
+			conn->state = STATE_CLOSE;
+		else if (errno == EINTR || errno == EAGAIN)
+			goto again;
 
-			if (res)
-				conn->state = STATE_CLOSE;
-			break;
-		}
-		break;
+		return -EIO;
 	}
+
+	conn->tx_size -= ret;
+	conn->tx_buffer += ret;
+	if (conn->tx_size)
+		goto again;
+	conn->tx_iostate = next_state;
+
+	return 0;
 }
 
 static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 {
-	int res;
+	int ret = 0, hdigest, ddigest;
+	uint32_t crc;
+
+	if (conn->state == STATE_SCSI) {
+		struct param *p = conn->session_param;
+		hdigest = p[ISCSI_PARAM_HDRDGST_EN].val & DIGEST_CRC32C;
+		ddigest = p[ISCSI_PARAM_DATADGST_EN].val & DIGEST_CRC32C;
+	} else
+		hdigest = ddigest = 0;
 
 	if (conn->state == STATE_SCSI && !conn->tx_task) {
-		res = iscsi_task_tx_start(conn);
-		if (res)
+		ret = iscsi_task_tx_start(conn);
+		if (ret)
 			return;
 	}
 
 	switch (conn->tx_iostate) {
-	case IOSTATE_WRITE_BHS:
-	case IOSTATE_WRITE_AHS:
-	case IOSTATE_WRITE_DATA:
-	write_again:
-		res = conn->tp->ep_write_begin(fd, conn->tx_buffer,
-					       conn->tx_size);
-		if (res < 0) {
-			if (errno != EINTR && errno != EAGAIN)
-				conn->state = STATE_CLOSE;
-			else if (errno == EINTR)
-				goto write_again;
+	case IOSTATE_TX_BHS:
+		ret = do_send(fd, conn, IOSTATE_TX_INIT_AHS);
+		if (ret < 0)
 			break;
-		}
+	case IOSTATE_TX_INIT_AHS:
+		if (conn->rsp.ahssize) {
+			conn->tx_iostate = IOSTATE_TX_AHS;
+			conn->tx_buffer = conn->rsp.ahs;
+			conn->tx_size = conn->rsp.ahssize;
 
-		conn->tx_size -= res;
-		conn->tx_buffer += res;
-		if (conn->tx_size)
-			goto write_again;
-
-		switch (conn->tx_iostate) {
-		case IOSTATE_WRITE_BHS:
-			if (conn->rsp.ahssize) {
-				conn->tx_iostate = IOSTATE_WRITE_AHS;
-				conn->tx_buffer = conn->rsp.ahs;
-				conn->tx_size = conn->rsp.ahssize;
-				goto write_again;
-			}
-		case IOSTATE_WRITE_AHS:
-			if (conn->rsp.datasize) {
-				int pad;
-
-				conn->tx_iostate = IOSTATE_WRITE_DATA;
-				conn->tx_buffer = conn->rsp.data;
-				conn->tx_size = conn->rsp.datasize;
-				pad = conn->tx_size & (PAD_WORD_LEN - 1);
-				if (pad) {
-					pad = PAD_WORD_LEN - pad;
-					memset(conn->tx_buffer + conn->tx_size,
-					       0, pad);
-					conn->tx_size += pad;
-				}
-				goto write_again;
-			}
-		case IOSTATE_WRITE_DATA:
-			conn->tp->ep_write_end(fd);
-			cmnd_finish(conn);
+			conn->tx_iostate = IOSTATE_TX_AHS;
+		} else
+			conn->tx_iostate = hdigest ?
+				IOSTATE_TX_INIT_HDIGEST : IOSTATE_TX_INIT_DATA;
 
-			switch (conn->state) {
-			case STATE_KERNEL:
-				res = conn_take_fd(conn, fd);
-				if (res)
-					conn->state = STATE_CLOSE;
-				else {
-					conn->state = STATE_SCSI;
-					conn_read_pdu(conn);
-					tgt_event_modify(fd, EPOLLIN);
-				}
-				break;
-			case STATE_EXIT:
-			case STATE_CLOSE:
-				break;
-			case STATE_SCSI:
-				iscsi_task_tx_done(conn);
-				break;
-			default:
-				conn_read_pdu(conn);
-				tgt_event_modify(fd, EPOLLIN);
-				break;
+		if (conn->tx_iostate != IOSTATE_TX_AHS)
+			break;
+	case IOSTATE_TX_AHS:
+		conn->tx_iostate = hdigest ?
+			IOSTATE_TX_INIT_HDIGEST : IOSTATE_TX_INIT_DATA;
+		if (conn->tx_iostate != IOSTATE_TX_INIT_HDIGEST)
+			break;
+	case IOSTATE_TX_INIT_HDIGEST:
+		crc = ~0;
+		crc = crc32c(crc, &conn->rsp.bhs, BHS_SIZE);
+		*(uint32_t *)conn->tx_digest = ~__cpu_to_le32(crc);
+		conn->tx_iostate = IOSTATE_TX_HDIGEST;
+		conn->tx_buffer = conn->tx_digest;
+		conn->tx_size = sizeof(conn->tx_digest);
+	case IOSTATE_TX_HDIGEST:
+		ret = do_send(fd, conn, IOSTATE_TX_INIT_DATA);
+		if (ret < 0)
+			break;
+	case IOSTATE_TX_INIT_DATA:
+		if (conn->rsp.datasize) {
+			int pad;
+
+			conn->tx_iostate = IOSTATE_TX_DATA;
+			conn->tx_buffer = conn->rsp.data;
+			conn->tx_size = conn->rsp.datasize;
+			pad = conn->tx_size & (PAD_WORD_LEN - 1);
+			if (pad) {
+				pad = PAD_WORD_LEN - pad;
+				memset(conn->tx_buffer + conn->tx_size, 0, pad);
+				conn->tx_size += pad;
 			}
+		} else
+			conn->tx_iostate = IOSTATE_TX_END;
+		if (conn->tx_iostate != IOSTATE_TX_DATA)
 			break;
-		}
-
+	case IOSTATE_TX_DATA:
+		ret = do_send(fd, conn, ddigest ?
+			      IOSTATE_TX_INIT_DDIGEST : IOSTATE_TX_END);
+		if (ret < 0)
+			return;
+		if (conn->tx_iostate != IOSTATE_TX_INIT_DDIGEST)
+			break;
+	case IOSTATE_TX_INIT_DDIGEST:
+		crc = ~0;
+		crc = crc32c(crc, conn->rsp.data,
+			     roundup(conn->rsp.datasize, 4));
+		*(uint32_t *)conn->tx_digest = ~__cpu_to_le32(crc);
+		conn->tx_iostate = IOSTATE_TX_DDIGEST;
+		conn->tx_buffer = conn->tx_digest;
+		conn->tx_size = sizeof(conn->tx_digest);
+	case IOSTATE_TX_DDIGEST:
+		ret = do_send(fd, conn, IOSTATE_TX_END);
 		break;
 	default:
-		eprintf("illegal iostate %d %d\n", conn->tx_iostate,
-			conn->tx_iostate);
-		conn->state = STATE_CLOSE;
+		eprintf("error %d %d\n", conn->state, conn->tx_iostate);
+		exit(1);
+	}
+
+	if (ret < 0 ||
+	    conn->tx_iostate != IOSTATE_TX_END ||
+	    conn->state == STATE_CLOSE)
+		return;
+
+	if (conn->tx_size) {
+		eprintf("error %d %d %d\n", conn->state, conn->tx_iostate,
+			conn->tx_size);
+		exit(1);
 	}
 
+	conn->tp->ep_write_end(fd);
+	cmnd_finish(conn);
+
+	switch (conn->state) {
+	case STATE_KERNEL:
+		ret = conn_take_fd(conn, fd);
+		if (ret)
+			conn->state = STATE_CLOSE;
+		else {
+			conn->state = STATE_SCSI;
+			conn_read_pdu(conn);
+			tgt_event_modify(fd, EPOLLIN);
+		}
+		break;
+	case STATE_EXIT:
+	case STATE_CLOSE:
+		break;
+	case STATE_SCSI:
+		iscsi_task_tx_done(conn);
+		break;
+	default:
+		conn_read_pdu(conn);
+		tgt_event_modify(fd, EPOLLIN);
+		break;
+	}
 }
 
 void iscsi_event_handler(int fd, int events, void *data)
@@ -1838,8 +2034,10 @@ void iscsi_event_handler(int fd, int eve
 	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
 		iscsi_tx_handler(fd, conn);
 
-	if (conn->state == STATE_CLOSE)
+	if (conn->state == STATE_CLOSE) {
 		conn_close(conn, fd);
+		dprintf("connection closed\n");
+	}
 }
 
 struct tgt_driver iscsi = {
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 84d74f3..29abc5d 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -174,6 +174,9 @@ struct iscsi_connection {
 
 	struct list_head tx_clist;
 
+	unsigned char rx_digest[4];
+	unsigned char tx_digest[4];
+
 	int auth_state;
 	union {
 		struct {
@@ -187,13 +190,6 @@ struct iscsi_connection {
 	struct iscsi_transport *tp;
 };
 
-#define IOSTATE_FREE		0
-#define IOSTATE_READ_BHS	1
-#define IOSTATE_READ_AHS_DATA	2
-#define IOSTATE_WRITE_BHS	3
-#define IOSTATE_WRITE_AHS	4
-#define IOSTATE_WRITE_DATA	5
-
 #define STATE_FREE		0
 #define STATE_SECURITY		1
 #define STATE_SECURITY_AUTH	2
@@ -263,14 +259,13 @@ extern void conn_put(struct iscsi_connec
 extern int conn_get(struct iscsi_connection *conn);
 extern struct iscsi_connection * conn_find(struct iscsi_session *session, uint32_t cid);
 extern int conn_take_fd(struct iscsi_connection *conn, int fd);
-extern void conn_read_pdu(struct iscsi_connection *conn);
-extern void conn_write_pdu(struct iscsi_connection *conn);
 extern void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_session *session);
 
 /* iscsid.c */
 extern void iscsi_event_handler(int fd, int events, void *data);
 extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
 extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
+extern void conn_read_pdu(struct iscsi_connection *conn);
 
 /* iscsid.c iscsi_task */
 extern void iscsi_free_task(struct iscsi_task *task);


From albert.pauw at gmail.com  Sun Apr 22 17:39:26 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Sun, 22 Apr 2007 17:39:26 +0200
Subject: [Stgt-devel] [PATCH] head and data digest
In-Reply-To: <20070422160651E.fujita.tomonori@lab.ntt.co.jp>
References: <20070422160651E.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <462B81AE.7040003@gmail.com>

I set HeaderDigest to CRC32C on the disk target:
[root at orange sbin]# iscsiadm -m node -T iqn.2007-03.com.example:stgt.disk
node.name = iqn.2007-03.com.example:stgt.disk
node.transport_name = tcp
node.tpgt = 1
node.startup = manual
iface.name = default
node.discovery_address = <empty>
node.discovery_port = 0
node.discovery_type = static
node.session.initial_cmdsn = 0
node.session.cmds_max = 128
node.session.queue_depth = 32
node.session.auth.authmethod = None
node.session.auth.username = <empty>
node.session.auth.password = <empty>
node.session.auth.username_in = <empty>
node.session.auth.password_in = <empty>
node.session.timeo.replacement_timeout = 120
node.session.err_timeo.abort_timeout = 10
node.session.err_timeo.reset_timeout = 30
node.session.iscsi.InitialR2T = No
node.session.iscsi.ImmediateData = Yes
node.session.iscsi.FirstBurstLength = 262144
node.session.iscsi.MaxBurstLength = 16776192
node.session.iscsi.DefaultTime2Retain = 0
node.session.iscsi.DefaultTime2Wait = 0
node.session.iscsi.MaxConnections = 1
node.session.iscsi.MaxOutstandingR2T = 1
node.session.iscsi.ERL = 0
node.conn[0].address = 127.0.0.1
node.conn[0].port = 3260
node.conn[0].startup = manual
node.conn[0].tcp.window_size = 524288
node.conn[0].tcp.type_of_service = 0
node.conn[0].timeo.logout_timeout = 15
node.conn[0].timeo.login_timeout = 15
node.conn[0].timeo.auth_timeout = 45
node.conn[0].timeo.active_timeout = 5
node.conn[0].timeo.idle_timeout = 60
node.conn[0].timeo.ping_timeout = 5
node.conn[0].timeo.noop_out_interval = 10
node.conn[0].timeo.noop_out_timeout = 15
node.conn[0].iscsi.MaxRecvDataSegmentLength = 131072
node.conn[0].iscsi.HeaderDigest = CRC32C
node.conn[0].iscsi.DataDigest = None,CRC32C
node.conn[0].iscsi.IFMarker = No
node.conn[0].iscsi.OFMarker = No

I only get:

iscsiadm: Could not login session (err 5).
iscsiadm: initiator reported error (5 - encountered iSCSI login failure)


FUJITA Tomonori wrote:
> This patch adds head and data digest features (not heavily
> tested). It's against the latest git tree.
> 
> Please test this and let me know the results.
> 
> Do we provide all features of iscsitarget?
> 
> diff --git a/usr/iscsi/conn.c b/usr/iscsi/conn.c
> index e4e36aa..fcd2385 100644
> --- a/usr/iscsi/conn.c
> +++ b/usr/iscsi/conn.c
> @@ -176,18 +176,3 @@ int conn_take_fd(struct iscsi_connection
>  
>  	return 0;
>  }
> -
> -void conn_read_pdu(struct iscsi_connection *conn)
> -{
> -	conn->rx_iostate = IOSTATE_READ_BHS;
> -	conn->rx_buffer = (void *)&conn->req.bhs;
> -	conn->rx_size = BHS_SIZE;
> -}
> -
> -void conn_write_pdu(struct iscsi_connection *conn)
> -{
> -	conn->tx_iostate = IOSTATE_WRITE_BHS;
> -	memset(&conn->rsp, 0, sizeof(conn->rsp));
> -	conn->tx_buffer = (void *)&conn->rsp.bhs;
> -	conn->tx_size = BHS_SIZE;
> -}
> diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> index 2377952..fbde08c 100644
> --- a/usr/iscsi/iscsid.c
> +++ b/usr/iscsi/iscsid.c
> @@ -38,9 +38,53 @@ #include "iscsid.h"
>  #include "tgtd.h"
>  #include "util.h"
>  #include "driver.h"
> +#include "crc32c.h"
>  
>  #define MAX_QUEUE_CMD	32
>  
> +enum {
> +	IOSTATE_FREE,
> +
> +	IOSTATE_RX_BHS,
> +	IOSTATE_RX_INIT_AHS,
> +	IOSTATE_RX_AHS,
> +	IOSTATE_RX_INIT_HDIGEST,
> +	IOSTATE_RX_HDIGEST,
> +	IOSTATE_RX_CHECK_HDIGEST,
> +	IOSTATE_RX_INIT_DATA,
> +	IOSTATE_RX_DATA,
> +	IOSTATE_RX_INIT_DDIGEST,
> +	IOSTATE_RX_DDIGEST,
> +	IOSTATE_RX_CHECK_DDIGEST,
> +	IOSTATE_RX_END,
> +
> +	IOSTATE_TX_BHS,
> +	IOSTATE_TX_INIT_AHS,
> +	IOSTATE_TX_AHS,
> +	IOSTATE_TX_INIT_HDIGEST,
> +	IOSTATE_TX_HDIGEST,
> +	IOSTATE_TX_INIT_DATA,
> +	IOSTATE_TX_DATA,
> +	IOSTATE_TX_INIT_DDIGEST,
> +	IOSTATE_TX_DDIGEST,
> +	IOSTATE_TX_END,
> +};
> +
> +void conn_read_pdu(struct iscsi_connection *conn)
> +{
> +	conn->rx_iostate = IOSTATE_RX_BHS;
> +	conn->rx_buffer = (void *)&conn->req.bhs;
> +	conn->rx_size = BHS_SIZE;
> +}
> +
> +static void conn_write_pdu(struct iscsi_connection *conn)
> +{
> +	conn->tx_iostate = IOSTATE_TX_BHS;
> +	memset(&conn->rsp, 0, sizeof(conn->rsp));
> +	conn->tx_buffer = (void *)&conn->rsp.bhs;
> +	conn->tx_size = BHS_SIZE;
> +}
> +
>  static struct iscsi_key login_keys[] = {
>  	{"InitiatorName",},
>  	{"InitiatorAlias",},
> @@ -1492,6 +1536,11 @@ static int iscsi_task_rx_start(struct is
>  		break;
>  	}
>  
> +	if (conn->rx_task) {
> +		conn->req.ahs = conn->rx_task->ahs;
> +		conn->req.data = conn->rx_task->data;
> +	}
> +
>  	return err;
>  }
>  
> @@ -1662,167 +1711,314 @@ nodata:
>  	return -EAGAIN;
>  }
>  
> +static int do_recv(int fd, struct iscsi_connection *conn, int next_state)
> +{
> +	int ret;
> +
> +	ret = conn->tp->ep_read(fd, conn->rx_buffer, conn->rx_size);
> +	if (!ret) {
> +		conn->state = STATE_CLOSE;
> +		return 0;
> +	} else if (ret < 0) {
> +		if (errno == EINTR || errno == EAGAIN)
> +			return 0;
> +		else
> +			return -EIO;
> +	}
> +
> +	conn->rx_size -= ret;
> +	conn->rx_buffer += ret;
> +	if (!conn->rx_size)
> +		conn->rx_iostate = next_state;
> +
> +	return ret;
> +}
> +
>  static void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
>  {
> -	int res;
> +	int ret = 0, hdigest, ddigest;
> +	uint32_t crc;
>  
> +	if (conn->state == STATE_SCSI) {
> +		struct param *p = conn->session_param;
> +		hdigest = p[ISCSI_PARAM_HDRDGST_EN].val & DIGEST_CRC32C;
> +		ddigest = p[ISCSI_PARAM_DATADGST_EN].val & DIGEST_CRC32C;
> +	} else
> +		hdigest = ddigest = 0;
> +again:
>  	switch (conn->rx_iostate) {
> -	case IOSTATE_READ_BHS:
> -	case IOSTATE_READ_AHS_DATA:
> -	read_again:
> -		res = conn->tp->ep_read(fd, conn->rx_buffer, conn->rx_size);
> -		if (!res) {
> -			conn->state = STATE_CLOSE;
> +	case IOSTATE_RX_BHS:
> +		ret = do_recv(fd, conn, IOSTATE_RX_INIT_AHS);
> +		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_AHS)
>  			break;
> -		} else if (res < 0) {
> -			if (errno == EINTR)
> -				goto read_again;
> -			else if (errno == EAGAIN)
> -				break;
> -			else {
> +	case IOSTATE_RX_INIT_AHS:
> +		if (conn->state == STATE_SCSI) {
> +			ret = iscsi_task_rx_start(conn);
> +			if (ret) {
>  				conn->state = STATE_CLOSE;
> -				dprintf("%d %d, %m\n", res, errno);
> +				break;
>  			}
> +		} else {
> +			conn->rx_buffer = conn->req_buffer;
> +			conn->req.ahs = conn->rx_buffer;
> +			conn->req.data = conn->rx_buffer + conn->rx_size;
> +		}
> +		conn->req.ahssize = conn->req.bhs.hlength * 4;
> +		conn->req.datasize = ntoh24(conn->req.bhs.dlength);
> +		conn->rx_size = roundup(conn->req.ahssize, 4);
> +		if (conn->rx_size) {
> +			ret = do_recv(fd, conn, IOSTATE_RX_AHS);
> +			if (ret <= 0)
> +				break;
> +		} else
> +			conn->rx_iostate = hdigest ?
> +				IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA;
> +
> +		if (conn->rx_iostate == IOSTATE_RX_INIT_DATA)
> +			goto again;
> +		else if (conn->rx_iostate != IOSTATE_RX_AHS)
> +			break;
> +	case IOSTATE_RX_AHS:
> +		ret = do_recv(fd, conn, hdigest ?
> +			      IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA);
> +		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_HDIGEST)
>  			break;
> +	case IOSTATE_RX_INIT_HDIGEST:
> +		conn->rx_buffer = conn->rx_digest;
> +		conn->rx_size = sizeof(conn->rx_digest);
> +		conn->rx_iostate = IOSTATE_RX_HDIGEST;
> +	case IOSTATE_RX_HDIGEST:
> +		ret = do_recv(fd, conn, IOSTATE_RX_CHECK_HDIGEST);
> +		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_CHECK_HDIGEST)
> +			break;
> +	case IOSTATE_RX_CHECK_HDIGEST:
> +		crc = ~0;
> +		crc = crc32c(crc, &conn->req.bhs, BHS_SIZE);
> +		if (conn->req.ahssize)
> +			crc = crc32c(crc, conn->req.ahs,
> +				     roundup(conn->req.ahssize, 4));
> +		crc = ~__cpu_to_le32(crc);
> +		if (*((uint32_t *)conn->rx_digest) != crc) {
> +			eprintf("rx hdr digest error 0x%x calc 0x%x\n",
> +				*((uint32_t *)conn->rx_digest), crc);
> +			conn->state = STATE_CLOSE;
>  		}
> -		conn->rx_size -= res;
> -		conn->rx_buffer += res;
> -		if (conn->rx_size)
> +		conn->rx_iostate = IOSTATE_RX_INIT_DATA;
> +	case IOSTATE_RX_INIT_DATA:
> +		conn->rx_size = roundup(conn->req.datasize, 4);
> +		if (conn->rx_size) {
> +			conn->rx_iostate = IOSTATE_RX_DATA;
> +			conn->rx_buffer = conn->req.data;
> +		} else {
> +			conn->rx_iostate = IOSTATE_RX_END;
>  			break;
> +		}
> +	case IOSTATE_RX_DATA:
> +		ret = do_recv(fd, conn, ddigest ?
> +			      IOSTATE_RX_INIT_DDIGEST : IOSTATE_RX_END);
> +		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_DDIGEST)
> +			break;
> +	case IOSTATE_RX_INIT_DDIGEST:
> +		conn->rx_buffer = conn->rx_digest;
> +		conn->rx_size = sizeof(conn->rx_digest);
> +		conn->rx_iostate = IOSTATE_RX_DDIGEST;
> +	case IOSTATE_RX_DDIGEST:
> +		ret = do_recv(fd, conn, IOSTATE_RX_CHECK_DDIGEST);
> +		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_CHECK_DDIGEST)
> +			break;
> +	case IOSTATE_RX_CHECK_DDIGEST:
> +		crc = ~0;
> +		crc = crc32c(crc, conn->req.data, roundup(conn->req.datasize, 4));
> +		crc = ~__cpu_to_le32(crc);
> +		conn->rx_iostate = IOSTATE_RX_END;
> +		if (*((uint32_t *)conn->rx_digest) != crc) {
> +			eprintf("rx hdr digest error 0x%x calc 0x%x\n",
> +				*((uint32_t *)conn->rx_digest), crc);
> +			conn->state = STATE_CLOSE;
> +		}
> +		break;
> +	default:
> +		eprintf("error %d %d\n", conn->state, conn->rx_iostate);
> +		exit(1);
> +	}
>  
> -		switch (conn->rx_iostate) {
> -		case IOSTATE_READ_BHS:
> -			conn->req.ahssize = conn->req.bhs.hlength * 4;
> -			conn->req.datasize = ntoh24(conn->req.bhs.dlength);
> +	if (ret < 0 ||
> +	    conn->rx_iostate != IOSTATE_RX_END ||
> +	    conn->state == STATE_CLOSE)
> +		return;
>  
> -			if (conn->state == STATE_SCSI) {
> -				res = iscsi_task_rx_start(conn);
> -				if (res) {
> -					conn->state = STATE_CLOSE;
> -					break;
> -				}
> -			} else {
> -				conn->rx_buffer = conn->req_buffer;
> -				conn->req.ahs = conn->rx_buffer;
> -				conn->rx_size = roundup(conn->req.ahssize, 4);
> -				conn->req.data = conn->rx_buffer + conn->rx_size;
> -				conn->rx_size += roundup(conn->req.datasize, 4);
> -			}
> +	if (conn->rx_size) {
> +		eprintf("error %d %d %d\n", conn->state, conn->rx_iostate,
> +			conn->rx_size);
> +		exit(1);
> +	}
>  
> -			if (conn->rx_size) {
> -				conn->rx_iostate = IOSTATE_READ_AHS_DATA;
> -				goto read_again;
> -			}
> +	if (conn->state == STATE_SCSI) {
> +		ret = iscsi_task_rx_done(conn);
> +		if (ret)
> +			conn->state = STATE_CLOSE;
> +		else
> +			conn_read_pdu(conn);
> +	} else {
> +		conn_write_pdu(conn);
> +		tgt_event_modify(fd, EPOLLOUT);
> +		ret = cmnd_execute(conn);
> +		if (ret)
> +			conn->state = STATE_CLOSE;
> +	}
> +}
>  
> -		case IOSTATE_READ_AHS_DATA:
> -			if (conn->state == STATE_SCSI) {
> -				res = iscsi_task_rx_done(conn);
> -				if (!res)
> -					conn_read_pdu(conn);
> -			} else {
> -				conn_write_pdu(conn);
> -				tgt_event_modify(fd, EPOLLOUT);
> -				res = cmnd_execute(conn);
> -			}
> +static int do_send(int fd, struct iscsi_connection *conn, int next_state)
> +{
> +	int ret;
> +again:
> +	ret = conn->tp->ep_write_begin(fd, conn->tx_buffer, conn->tx_size);
> +	if (ret < 0) {
> +		if (errno != EINTR && errno != EAGAIN)
> +			conn->state = STATE_CLOSE;
> +		else if (errno == EINTR || errno == EAGAIN)
> +			goto again;
>  
> -			if (res)
> -				conn->state = STATE_CLOSE;
> -			break;
> -		}
> -		break;
> +		return -EIO;
>  	}
> +
> +	conn->tx_size -= ret;
> +	conn->tx_buffer += ret;
> +	if (conn->tx_size)
> +		goto again;
> +	conn->tx_iostate = next_state;
> +
> +	return 0;
>  }
>  
>  static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
>  {
> -	int res;
> +	int ret = 0, hdigest, ddigest;
> +	uint32_t crc;
> +
> +	if (conn->state == STATE_SCSI) {
> +		struct param *p = conn->session_param;
> +		hdigest = p[ISCSI_PARAM_HDRDGST_EN].val & DIGEST_CRC32C;
> +		ddigest = p[ISCSI_PARAM_DATADGST_EN].val & DIGEST_CRC32C;
> +	} else
> +		hdigest = ddigest = 0;
>  
>  	if (conn->state == STATE_SCSI && !conn->tx_task) {
> -		res = iscsi_task_tx_start(conn);
> -		if (res)
> +		ret = iscsi_task_tx_start(conn);
> +		if (ret)
>  			return;
>  	}
>  
>  	switch (conn->tx_iostate) {
> -	case IOSTATE_WRITE_BHS:
> -	case IOSTATE_WRITE_AHS:
> -	case IOSTATE_WRITE_DATA:
> -	write_again:
> -		res = conn->tp->ep_write_begin(fd, conn->tx_buffer,
> -					       conn->tx_size);
> -		if (res < 0) {
> -			if (errno != EINTR && errno != EAGAIN)
> -				conn->state = STATE_CLOSE;
> -			else if (errno == EINTR)
> -				goto write_again;
> +	case IOSTATE_TX_BHS:
> +		ret = do_send(fd, conn, IOSTATE_TX_INIT_AHS);
> +		if (ret < 0)
>  			break;
> -		}
> +	case IOSTATE_TX_INIT_AHS:
> +		if (conn->rsp.ahssize) {
> +			conn->tx_iostate = IOSTATE_TX_AHS;
> +			conn->tx_buffer = conn->rsp.ahs;
> +			conn->tx_size = conn->rsp.ahssize;
>  
> -		conn->tx_size -= res;
> -		conn->tx_buffer += res;
> -		if (conn->tx_size)
> -			goto write_again;
> -
> -		switch (conn->tx_iostate) {
> -		case IOSTATE_WRITE_BHS:
> -			if (conn->rsp.ahssize) {
> -				conn->tx_iostate = IOSTATE_WRITE_AHS;
> -				conn->tx_buffer = conn->rsp.ahs;
> -				conn->tx_size = conn->rsp.ahssize;
> -				goto write_again;
> -			}
> -		case IOSTATE_WRITE_AHS:
> -			if (conn->rsp.datasize) {
> -				int pad;
> -
> -				conn->tx_iostate = IOSTATE_WRITE_DATA;
> -				conn->tx_buffer = conn->rsp.data;
> -				conn->tx_size = conn->rsp.datasize;
> -				pad = conn->tx_size & (PAD_WORD_LEN - 1);
> -				if (pad) {
> -					pad = PAD_WORD_LEN - pad;
> -					memset(conn->tx_buffer + conn->tx_size,
> -					       0, pad);
> -					conn->tx_size += pad;
> -				}
> -				goto write_again;
> -			}
> -		case IOSTATE_WRITE_DATA:
> -			conn->tp->ep_write_end(fd);
> -			cmnd_finish(conn);
> +			conn->tx_iostate = IOSTATE_TX_AHS;
> +		} else
> +			conn->tx_iostate = hdigest ?
> +				IOSTATE_TX_INIT_HDIGEST : IOSTATE_TX_INIT_DATA;
>  
> -			switch (conn->state) {
> -			case STATE_KERNEL:
> -				res = conn_take_fd(conn, fd);
> -				if (res)
> -					conn->state = STATE_CLOSE;
> -				else {
> -					conn->state = STATE_SCSI;
> -					conn_read_pdu(conn);
> -					tgt_event_modify(fd, EPOLLIN);
> -				}
> -				break;
> -			case STATE_EXIT:
> -			case STATE_CLOSE:
> -				break;
> -			case STATE_SCSI:
> -				iscsi_task_tx_done(conn);
> -				break;
> -			default:
> -				conn_read_pdu(conn);
> -				tgt_event_modify(fd, EPOLLIN);
> -				break;
> +		if (conn->tx_iostate != IOSTATE_TX_AHS)
> +			break;
> +	case IOSTATE_TX_AHS:
> +		conn->tx_iostate = hdigest ?
> +			IOSTATE_TX_INIT_HDIGEST : IOSTATE_TX_INIT_DATA;
> +		if (conn->tx_iostate != IOSTATE_TX_INIT_HDIGEST)
> +			break;
> +	case IOSTATE_TX_INIT_HDIGEST:
> +		crc = ~0;
> +		crc = crc32c(crc, &conn->rsp.bhs, BHS_SIZE);
> +		*(uint32_t *)conn->tx_digest = ~__cpu_to_le32(crc);
> +		conn->tx_iostate = IOSTATE_TX_HDIGEST;
> +		conn->tx_buffer = conn->tx_digest;
> +		conn->tx_size = sizeof(conn->tx_digest);
> +	case IOSTATE_TX_HDIGEST:
> +		ret = do_send(fd, conn, IOSTATE_TX_INIT_DATA);
> +		if (ret < 0)
> +			break;
> +	case IOSTATE_TX_INIT_DATA:
> +		if (conn->rsp.datasize) {
> +			int pad;
> +
> +			conn->tx_iostate = IOSTATE_TX_DATA;
> +			conn->tx_buffer = conn->rsp.data;
> +			conn->tx_size = conn->rsp.datasize;
> +			pad = conn->tx_size & (PAD_WORD_LEN - 1);
> +			if (pad) {
> +				pad = PAD_WORD_LEN - pad;
> +				memset(conn->tx_buffer + conn->tx_size, 0, pad);
> +				conn->tx_size += pad;
>  			}
> +		} else
> +			conn->tx_iostate = IOSTATE_TX_END;
> +		if (conn->tx_iostate != IOSTATE_TX_DATA)
>  			break;
> -		}
> -
> +	case IOSTATE_TX_DATA:
> +		ret = do_send(fd, conn, ddigest ?
> +			      IOSTATE_TX_INIT_DDIGEST : IOSTATE_TX_END);
> +		if (ret < 0)
> +			return;
> +		if (conn->tx_iostate != IOSTATE_TX_INIT_DDIGEST)
> +			break;
> +	case IOSTATE_TX_INIT_DDIGEST:
> +		crc = ~0;
> +		crc = crc32c(crc, conn->rsp.data,
> +			     roundup(conn->rsp.datasize, 4));
> +		*(uint32_t *)conn->tx_digest = ~__cpu_to_le32(crc);
> +		conn->tx_iostate = IOSTATE_TX_DDIGEST;
> +		conn->tx_buffer = conn->tx_digest;
> +		conn->tx_size = sizeof(conn->tx_digest);
> +	case IOSTATE_TX_DDIGEST:
> +		ret = do_send(fd, conn, IOSTATE_TX_END);
>  		break;
>  	default:
> -		eprintf("illegal iostate %d %d\n", conn->tx_iostate,
> -			conn->tx_iostate);
> -		conn->state = STATE_CLOSE;
> +		eprintf("error %d %d\n", conn->state, conn->tx_iostate);
> +		exit(1);
> +	}
> +
> +	if (ret < 0 ||
> +	    conn->tx_iostate != IOSTATE_TX_END ||
> +	    conn->state == STATE_CLOSE)
> +		return;
> +
> +	if (conn->tx_size) {
> +		eprintf("error %d %d %d\n", conn->state, conn->tx_iostate,
> +			conn->tx_size);
> +		exit(1);
>  	}
>  
> +	conn->tp->ep_write_end(fd);
> +	cmnd_finish(conn);
> +
> +	switch (conn->state) {
> +	case STATE_KERNEL:
> +		ret = conn_take_fd(conn, fd);
> +		if (ret)
> +			conn->state = STATE_CLOSE;
> +		else {
> +			conn->state = STATE_SCSI;
> +			conn_read_pdu(conn);
> +			tgt_event_modify(fd, EPOLLIN);
> +		}
> +		break;
> +	case STATE_EXIT:
> +	case STATE_CLOSE:
> +		break;
> +	case STATE_SCSI:
> +		iscsi_task_tx_done(conn);
> +		break;
> +	default:
> +		conn_read_pdu(conn);
> +		tgt_event_modify(fd, EPOLLIN);
> +		break;
> +	}
>  }
>  
>  void iscsi_event_handler(int fd, int events, void *data)
> @@ -1838,8 +2034,10 @@ void iscsi_event_handler(int fd, int eve
>  	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
>  		iscsi_tx_handler(fd, conn);
>  
> -	if (conn->state == STATE_CLOSE)
> +	if (conn->state == STATE_CLOSE) {
>  		conn_close(conn, fd);
> +		dprintf("connection closed\n");
> +	}
>  }
>  
>  struct tgt_driver iscsi = {
> diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
> index 84d74f3..29abc5d 100644
> --- a/usr/iscsi/iscsid.h
> +++ b/usr/iscsi/iscsid.h
> @@ -174,6 +174,9 @@ struct iscsi_connection {
>  
>  	struct list_head tx_clist;
>  
> +	unsigned char rx_digest[4];
> +	unsigned char tx_digest[4];
> +
>  	int auth_state;
>  	union {
>  		struct {
> @@ -187,13 +190,6 @@ struct iscsi_connection {
>  	struct iscsi_transport *tp;
>  };
>  
> -#define IOSTATE_FREE		0
> -#define IOSTATE_READ_BHS	1
> -#define IOSTATE_READ_AHS_DATA	2
> -#define IOSTATE_WRITE_BHS	3
> -#define IOSTATE_WRITE_AHS	4
> -#define IOSTATE_WRITE_DATA	5
> -
>  #define STATE_FREE		0
>  #define STATE_SECURITY		1
>  #define STATE_SECURITY_AUTH	2
> @@ -263,14 +259,13 @@ extern void conn_put(struct iscsi_connec
>  extern int conn_get(struct iscsi_connection *conn);
>  extern struct iscsi_connection * conn_find(struct iscsi_session *session, uint32_t cid);
>  extern int conn_take_fd(struct iscsi_connection *conn, int fd);
> -extern void conn_read_pdu(struct iscsi_connection *conn);
> -extern void conn_write_pdu(struct iscsi_connection *conn);
>  extern void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_session *session);
>  
>  /* iscsid.c */
>  extern void iscsi_event_handler(int fd, int events, void *data);
>  extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
>  extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
> +extern void conn_read_pdu(struct iscsi_connection *conn);
>  
>  /* iscsid.c iscsi_task */
>  extern void iscsi_free_task(struct iscsi_task *task);
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
> 



From fujita.tomonori at lab.ntt.co.jp  Mon Apr 23 00:21:27 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 23 Apr 2007 07:21:27 +0900
Subject: [Stgt-devel] [PATCH] head and data digest
In-Reply-To: <462B81AE.7040003@gmail.com>
References: <20070422160651E.fujita.tomonori@lab.ntt.co.jp>
	<462B81AE.7040003@gmail.com>
Message-ID: <20070423072127S.fujita.tomonori@lab.ntt.co.jp>

From: Albert Pauw <albert.pauw at gmail.com>
Subject: Re: [Stgt-devel] [PATCH] head and data digest
Date: Sun, 22 Apr 2007 17:39:26 +0200

> I set HeaderDigest to CRC32C on the disk target:

Do you enable the features? Here's an example:

root at ac:~/git# ./tgt/usr/tgtadm --op show --mode target --tid 1
MaxRecvDataSegmentLength=8192
MaxXmitDataSegmentLength=8192
HeaderDigest=None
DataDigest=None
InitialR2T=Yes
MaxOutstandingR2T=1
ImmediateData=Yes
FirstBurstLength=65536
MaxBurstLength=262144
DataPDUInOrder=Yes
DataSequenceInOrder=Yes
ErrorRecoveryLevel=0
IFMarker=No
OFMarker=No
DefaultTime2Wait=2
DefaultTime2Retain=20
OFMarkInt=Reject
IFMarkInt=Reject
MaxConnections=1

root at ac:~/git# ./tgt/usr/tgtadm --op update --mode target --tid 1 -n HeaderDigest -v CRC32C
root at ac:~/git# ./tgt/usr/tgtadm --op update --mode target --tid 1 -n DataDigest -v CRC32C

root at ac:~/git# ./tgt/usr/tgtadm --op show --mode target --tid 1
MaxRecvDataSegmentLength=8192
MaxXmitDataSegmentLength=8192
HeaderDigest=CRC32C
DataDigest=CRC32C
InitialR2T=Yes
MaxOutstandingR2T=1
ImmediateData=Yes
FirstBurstLength=65536
MaxBurstLength=262144
DataPDUInOrder=Yes
DataSequenceInOrder=Yes
ErrorRecoveryLevel=0
IFMarker=No
OFMarker=No
DefaultTime2Wait=2
DefaultTime2Retain=20
OFMarkInt=Reject
IFMarkInt=Reject
MaxConnections=1

With this configuration, the target accepts CRC32C and
None. Currently, there is no way to configure a target to accept only
CRC32C.

If it still doesn't work for you, please send the tcpdump log during a
login process.


From albert.pauw at gmail.com  Mon Apr 23 05:22:06 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Mon, 23 Apr 2007 05:22:06 +0200
Subject: [Stgt-devel] [PATCH] head and data digest
In-Reply-To: <20070423072127S.fujita.tomonori@lab.ntt.co.jp>
References: <20070422160651E.fujita.tomonori@lab.ntt.co.jp>	<462B81AE.7040003@gmail.com>
	<20070423072127S.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <462C265E.1090305@gmail.com>

FUJITA Tomonori wrote:
> From: Albert Pauw <albert.pauw at gmail.com>
> Subject: Re: [Stgt-devel] [PATCH] head and data digest
> Date: Sun, 22 Apr 2007 17:39:26 +0200
> 
>> I set HeaderDigest to CRC32C on the disk target:
> 
> Do you enable the features? Here's an example:
> 
> root at ac:~/git# ./tgt/usr/tgtadm --op show --mode target --tid 1
> MaxRecvDataSegmentLength=8192
> MaxXmitDataSegmentLength=8192
> HeaderDigest=None
> DataDigest=None
> InitialR2T=Yes
> MaxOutstandingR2T=1
> ImmediateData=Yes
> FirstBurstLength=65536
> MaxBurstLength=262144
> DataPDUInOrder=Yes
> DataSequenceInOrder=Yes
> ErrorRecoveryLevel=0
> IFMarker=No
> OFMarker=No
> DefaultTime2Wait=2
> DefaultTime2Retain=20
> OFMarkInt=Reject
> IFMarkInt=Reject
> MaxConnections=1
> 
> root at ac:~/git# ./tgt/usr/tgtadm --op update --mode target --tid 1 -n HeaderDigest -v CRC32C
> root at ac:~/git# ./tgt/usr/tgtadm --op update --mode target --tid 1 -n DataDigest -v CRC32C
> 
> root at ac:~/git# ./tgt/usr/tgtadm --op show --mode target --tid 1
> MaxRecvDataSegmentLength=8192
> MaxXmitDataSegmentLength=8192
> HeaderDigest=CRC32C
> DataDigest=CRC32C
> InitialR2T=Yes
> MaxOutstandingR2T=1
> ImmediateData=Yes
> FirstBurstLength=65536
> MaxBurstLength=262144
> DataPDUInOrder=Yes
> DataSequenceInOrder=Yes
> ErrorRecoveryLevel=0
> IFMarker=No
> OFMarker=No
> DefaultTime2Wait=2
> DefaultTime2Retain=20
> OFMarkInt=Reject
> IFMarkInt=Reject
> MaxConnections=1
> 
> With this configuration, the target accepts CRC32C and
> None. Currently, there is no way to configure a target to accept only
> CRC32C.
> 
> If it still doesn't work for you, please send the tcpdump log during a
> login process.
> 
Oops, good point, forgot that.

I'll let you know.

Thanks,

Albert


From albert.pauw at gmail.com  Mon Apr 23 19:21:56 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Mon, 23 Apr 2007 19:21:56 +0200
Subject: [Stgt-devel] [PATCH] head and data digest
In-Reply-To: <20070423072127S.fujita.tomonori@lab.ntt.co.jp>
References: <20070422160651E.fujita.tomonori@lab.ntt.co.jp>	<462B81AE.7040003@gmail.com>
	<20070423072127S.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <462CEB34.90803@gmail.com>

FUJITA Tomonori wrote:
> From: Albert Pauw <albert.pauw at gmail.com>
> Subject: Re: [Stgt-devel] [PATCH] head and data digest
> Date: Sun, 22 Apr 2007 17:39:26 +0200
>
>   
>> I set HeaderDigest to CRC32C on the disk target:
>>     
>
> Do you enable the features? Here's an example:
>
> root at ac:~/git# ./tgt/usr/tgtadm --op show --mode target --tid 1
> MaxRecvDataSegmentLength=8192
> MaxXmitDataSegmentLength=8192
> HeaderDigest=None
> DataDigest=None
> InitialR2T=Yes
> MaxOutstandingR2T=1
> ImmediateData=Yes
> FirstBurstLength=65536
> MaxBurstLength=262144
> DataPDUInOrder=Yes
> DataSequenceInOrder=Yes
> ErrorRecoveryLevel=0
> IFMarker=No
> OFMarker=No
> DefaultTime2Wait=2
> DefaultTime2Retain=20
> OFMarkInt=Reject
> IFMarkInt=Reject
> MaxConnections=1
>
> root at ac:~/git# ./tgt/usr/tgtadm --op update --mode target --tid 1 -n HeaderDigest -v CRC32C
> root at ac:~/git# ./tgt/usr/tgtadm --op update --mode target --tid 1 -n DataDigest -v CRC32C
>
> root at ac:~/git# ./tgt/usr/tgtadm --op show --mode target --tid 1
> MaxRecvDataSegmentLength=8192
> MaxXmitDataSegmentLength=8192
> HeaderDigest=CRC32C
> DataDigest=CRC32C
> InitialR2T=Yes
> MaxOutstandingR2T=1
> ImmediateData=Yes
> FirstBurstLength=65536
> MaxBurstLength=262144
> DataPDUInOrder=Yes
> DataSequenceInOrder=Yes
> ErrorRecoveryLevel=0
> IFMarker=No
> OFMarker=No
> DefaultTime2Wait=2
> DefaultTime2Retain=20
> OFMarkInt=Reject
> IFMarkInt=Reject
> MaxConnections=1
>
> With this configuration, the target accepts CRC32C and
> None. Currently, there is no way to configure a target to accept only
> CRC32C.
>
> If it still doesn't work for you, please send the tcpdump log during a
> login process.
>
>   
Ok, login works fine, if I look with wireshark I can see that the digest
is ok.
However, I seem to be having another problem now, with or without digest.

When I login, it works fine. When I partition the disk and create a
filesystem
on the partition it seems to be fine as well. However, when I try to
mount that
filesystem I get an error:

[root at orange ~]# fdisk /dev/sdb

Command (m for help): p

Disk /dev/sdb: 104 MB, 104857600 bytes
4 heads, 50 sectors/track, 1024 cylinders
Units = cylinders of 200 * 512 = 102400 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1        1024      102375   83  Linux

Command (m for help): d
Selected partition 1

Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-1024, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-1024, default 1024):
Using default value 1024

Command (m for help): p

Disk /dev/sdb: 104 MB, 104857600 bytes
4 heads, 50 sectors/track, 1024 cylinders
Units = cylinders of 200 * 512 = 102400 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1        1024      102375   83  Linux

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
[root at orange ~]# mkfs -t ext3 /dev/sdb1
mke2fs 1.39 (29-May-2006)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
25688 inodes, 102372 blocks
5118 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=67371008
13 block groups
8192 blocks per group, 8192 fragments per group
1976 inodes per group
Superblock backups stored on blocks:
        8193, 24577, 40961, 57345, 73729

Writing inode tables: done
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 35 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
[root at orange ~]# mount /dev/sdb1 /mnt/disk1
mount: wrong fs type, bad option, bad superblock on /dev/sdb1,
       missing codepage or other error
       In some cases useful info is found in syslog - try
       dmesg | tail  or so






From apauw at inter.nl.net  Mon Apr 23 19:10:15 2007
From: apauw at inter.nl.net (Albert Pauw)
Date: Mon, 23 Apr 2007 19:10:15 +0200
Subject: [Stgt-devel] [PATCH] head and data digest
In-Reply-To: <20070423072127S.fujita.tomonori@lab.ntt.co.jp>
References: <20070422160651E.fujita.tomonori@lab.ntt.co.jp>	<462B81AE.7040003@gmail.com>
	<20070423072127S.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <462CE877.6070207@inter.nl.net>

FUJITA Tomonori wrote:
> From: Albert Pauw <albert.pauw at gmail.com>
> Subject: Re: [Stgt-devel] [PATCH] head and data digest
> Date: Sun, 22 Apr 2007 17:39:26 +0200
>
>   
>> I set HeaderDigest to CRC32C on the disk target:
>>     
>
> Do you enable the features? Here's an example:
>
> root at ac:~/git# ./tgt/usr/tgtadm --op show --mode target --tid 1
> MaxRecvDataSegmentLength=8192
> MaxXmitDataSegmentLength=8192
> HeaderDigest=None
> DataDigest=None
> InitialR2T=Yes
> MaxOutstandingR2T=1
> ImmediateData=Yes
> FirstBurstLength=65536
> MaxBurstLength=262144
> DataPDUInOrder=Yes
> DataSequenceInOrder=Yes
> ErrorRecoveryLevel=0
> IFMarker=No
> OFMarker=No
> DefaultTime2Wait=2
> DefaultTime2Retain=20
> OFMarkInt=Reject
> IFMarkInt=Reject
> MaxConnections=1
>
> root at ac:~/git# ./tgt/usr/tgtadm --op update --mode target --tid 1 -n HeaderDigest -v CRC32C
> root at ac:~/git# ./tgt/usr/tgtadm --op update --mode target --tid 1 -n DataDigest -v CRC32C
>
> root at ac:~/git# ./tgt/usr/tgtadm --op show --mode target --tid 1
> MaxRecvDataSegmentLength=8192
> MaxXmitDataSegmentLength=8192
> HeaderDigest=CRC32C
> DataDigest=CRC32C
> InitialR2T=Yes
> MaxOutstandingR2T=1
> ImmediateData=Yes
> FirstBurstLength=65536
> MaxBurstLength=262144
> DataPDUInOrder=Yes
> DataSequenceInOrder=Yes
> ErrorRecoveryLevel=0
> IFMarker=No
> OFMarker=No
> DefaultTime2Wait=2
> DefaultTime2Retain=20
> OFMarkInt=Reject
> IFMarkInt=Reject
> MaxConnections=1
>
> With this configuration, the target accepts CRC32C and
> None. Currently, there is no way to configure a target to accept only
> CRC32C.
>
> If it still doesn't work for you, please send the tcpdump log during a
> login process.
>
>   
Ok, login works fine, if I look with wireshark I can see that the digest 
is ok.
However, I seem to be having another problem now, with or without digest.

When I login, it works fine. When I partition the disk and create a 
filesystem
on the partition it seems to be fine as well. However, when I try to 
mount that
filesystem I get an error:

[root at orange ~]# fdisk /dev/sdb

Command (m for help): p

Disk /dev/sdb: 104 MB, 104857600 bytes
4 heads, 50 sectors/track, 1024 cylinders
Units = cylinders of 200 * 512 = 102400 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1        1024      102375   83  Linux

Command (m for help): d
Selected partition 1

Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-1024, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-1024, default 1024):
Using default value 1024

Command (m for help): p

Disk /dev/sdb: 104 MB, 104857600 bytes
4 heads, 50 sectors/track, 1024 cylinders
Units = cylinders of 200 * 512 = 102400 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1        1024      102375   83  Linux

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
[root at orange ~]# mkfs -t ext3 /dev/sdb1
mke2fs 1.39 (29-May-2006)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
25688 inodes, 102372 blocks
5118 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=67371008
13 block groups
8192 blocks per group, 8192 fragments per group
1976 inodes per group
Superblock backups stored on blocks:
        8193, 24577, 40961, 57345, 73729

Writing inode tables: done                           
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 35 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
[root at orange ~]# mount /dev/sdb1 /mnt/disk1
mount: wrong fs type, bad option, bad superblock on /dev/sdb1,
       missing codepage or other error
       In some cases useful info is found in syslog - try
       dmesg | tail  or so





From fujita.tomonori at lab.ntt.co.jp  Tue Apr 24 01:39:30 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 24 Apr 2007 08:39:30 +0900
Subject: [Stgt-devel] [PATCH] head and data digest
In-Reply-To: <462CEB34.90803@gmail.com>
References: <462B81AE.7040003@gmail.com>
	<20070423072127S.fujita.tomonori@lab.ntt.co.jp>
	<462CEB34.90803@gmail.com>
Message-ID: <20070424083930S.fujita.tomonori@lab.ntt.co.jp>

From: Albert Pauw <albert.pauw at gmail.com>
Subject: Re: [Stgt-devel] [PATCH] head and data digest
Date: Mon, 23 Apr 2007 19:21:56 +0200

> FUJITA Tomonori wrote:
> > From: Albert Pauw <albert.pauw at gmail.com>
> > Subject: Re: [Stgt-devel] [PATCH] head and data digest
> > Date: Sun, 22 Apr 2007 17:39:26 +0200
> >
> >   
> >> I set HeaderDigest to CRC32C on the disk target:
> >>     
> >
> > Do you enable the features? Here's an example:
> >
> > root at ac:~/git# ./tgt/usr/tgtadm --op show --mode target --tid 1
> > MaxRecvDataSegmentLength=8192
> > MaxXmitDataSegmentLength=8192
> > HeaderDigest=None
> > DataDigest=None
> > InitialR2T=Yes
> > MaxOutstandingR2T=1
> > ImmediateData=Yes
> > FirstBurstLength=65536
> > MaxBurstLength=262144
> > DataPDUInOrder=Yes
> > DataSequenceInOrder=Yes
> > ErrorRecoveryLevel=0
> > IFMarker=No
> > OFMarker=No
> > DefaultTime2Wait=2
> > DefaultTime2Retain=20
> > OFMarkInt=Reject
> > IFMarkInt=Reject
> > MaxConnections=1
> >
> > root at ac:~/git# ./tgt/usr/tgtadm --op update --mode target --tid 1 -n HeaderDigest -v CRC32C
> > root at ac:~/git# ./tgt/usr/tgtadm --op update --mode target --tid 1 -n DataDigest -v CRC32C
> >
> > root at ac:~/git# ./tgt/usr/tgtadm --op show --mode target --tid 1
> > MaxRecvDataSegmentLength=8192
> > MaxXmitDataSegmentLength=8192
> > HeaderDigest=CRC32C
> > DataDigest=CRC32C
> > InitialR2T=Yes
> > MaxOutstandingR2T=1
> > ImmediateData=Yes
> > FirstBurstLength=65536
> > MaxBurstLength=262144
> > DataPDUInOrder=Yes
> > DataSequenceInOrder=Yes
> > ErrorRecoveryLevel=0
> > IFMarker=No
> > OFMarker=No
> > DefaultTime2Wait=2
> > DefaultTime2Retain=20
> > OFMarkInt=Reject
> > IFMarkInt=Reject
> > MaxConnections=1
> >
> > With this configuration, the target accepts CRC32C and
> > None. Currently, there is no way to configure a target to accept only
> > CRC32C.
> >
> > If it still doesn't work for you, please send the tcpdump log during a
> > login process.
> >
> >   
> Ok, login works fine, if I look with wireshark I can see that the digest
> is ok.

Sorry, I put a silly bug in the patch. Here's a new one.


diff --git a/usr/iscsi/conn.c b/usr/iscsi/conn.c
index e4e36aa..fcd2385 100644
--- a/usr/iscsi/conn.c
+++ b/usr/iscsi/conn.c
@@ -176,18 +176,3 @@ int conn_take_fd(struct iscsi_connection
 
 	return 0;
 }
-
-void conn_read_pdu(struct iscsi_connection *conn)
-{
-	conn->rx_iostate = IOSTATE_READ_BHS;
-	conn->rx_buffer = (void *)&conn->req.bhs;
-	conn->rx_size = BHS_SIZE;
-}
-
-void conn_write_pdu(struct iscsi_connection *conn)
-{
-	conn->tx_iostate = IOSTATE_WRITE_BHS;
-	memset(&conn->rsp, 0, sizeof(conn->rsp));
-	conn->tx_buffer = (void *)&conn->rsp.bhs;
-	conn->tx_size = BHS_SIZE;
-}
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 2377952..3d38ccc 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -38,9 +38,53 @@ #include "iscsid.h"
 #include "tgtd.h"
 #include "util.h"
 #include "driver.h"
+#include "crc32c.h"
 
 #define MAX_QUEUE_CMD	32
 
+enum {
+	IOSTATE_FREE,
+
+	IOSTATE_RX_BHS,
+	IOSTATE_RX_INIT_AHS,
+	IOSTATE_RX_AHS,
+	IOSTATE_RX_INIT_HDIGEST,
+	IOSTATE_RX_HDIGEST,
+	IOSTATE_RX_CHECK_HDIGEST,
+	IOSTATE_RX_INIT_DATA,
+	IOSTATE_RX_DATA,
+	IOSTATE_RX_INIT_DDIGEST,
+	IOSTATE_RX_DDIGEST,
+	IOSTATE_RX_CHECK_DDIGEST,
+	IOSTATE_RX_END,
+
+	IOSTATE_TX_BHS,
+	IOSTATE_TX_INIT_AHS,
+	IOSTATE_TX_AHS,
+	IOSTATE_TX_INIT_HDIGEST,
+	IOSTATE_TX_HDIGEST,
+	IOSTATE_TX_INIT_DATA,
+	IOSTATE_TX_DATA,
+	IOSTATE_TX_INIT_DDIGEST,
+	IOSTATE_TX_DDIGEST,
+	IOSTATE_TX_END,
+};
+
+void conn_read_pdu(struct iscsi_connection *conn)
+{
+	conn->rx_iostate = IOSTATE_RX_BHS;
+	conn->rx_buffer = (void *)&conn->req.bhs;
+	conn->rx_size = BHS_SIZE;
+}
+
+static void conn_write_pdu(struct iscsi_connection *conn)
+{
+	conn->tx_iostate = IOSTATE_TX_BHS;
+	memset(&conn->rsp, 0, sizeof(conn->rsp));
+	conn->tx_buffer = (void *)&conn->rsp.bhs;
+	conn->tx_size = BHS_SIZE;
+}
+
 static struct iscsi_key login_keys[] = {
 	{"InitiatorName",},
 	{"InitiatorAlias",},
@@ -1265,9 +1309,7 @@ found:
 		task->r2t_count,
 		ntoh24(req->dlength), be32_to_cpu(req->offset));
 
-	conn->rx_buffer = task->data;
-	conn->rx_buffer += be32_to_cpu(req->offset);
-	conn->rx_size = roundup(ntoh24(req->dlength), 4);
+	conn->req.data = task->data + be32_to_cpu(req->offset);
 
 	task->offset += ntoh24(req->dlength);
 	task->r2t_count -= ntoh24(req->dlength);
@@ -1357,12 +1399,10 @@ static int iscsi_scsi_cmd_rx_start(struc
 	if (ahs_len) {
 		task->ahs = task->data + sizeof(req->cdb);
 		task->data = task->ahs + ahs_len;
-		conn->rx_buffer = task->ahs;
- 		conn->rx_size = ahs_len + imm_len;
-	} else if (data_len) {
- 		conn->rx_buffer = task->data;
-		conn->rx_size = imm_len;
- 	}
+		conn->req.ahs = task->ahs;
+		conn->req.data = task->data;
+	} else if (data_len)
+		conn->req.data = task->data;
 
 	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
 		task->offset = ntoh24(req->dlength);
@@ -1414,9 +1454,8 @@ static int iscsi_noop_out_rx_start(struc
 	}
 
 	if (len) {
-		conn->rx_size = len;
 		task->len = len;
-		conn->rx_buffer = task->data;
+		conn->req.data = task->data;
 	}
 out:
 	return err;
@@ -1662,167 +1701,314 @@ nodata:
 	return -EAGAIN;
 }
 
+static int do_recv(int fd, struct iscsi_connection *conn, int next_state)
+{
+	int ret;
+
+	ret = conn->tp->ep_read(fd, conn->rx_buffer, conn->rx_size);
+	if (!ret) {
+		conn->state = STATE_CLOSE;
+		return 0;
+	} else if (ret < 0) {
+		if (errno == EINTR || errno == EAGAIN)
+			return 0;
+		else
+			return -EIO;
+	}
+
+	conn->rx_size -= ret;
+	conn->rx_buffer += ret;
+	if (!conn->rx_size)
+		conn->rx_iostate = next_state;
+
+	return ret;
+}
+
 static void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
 {
-	int res;
+	int ret = 0, hdigest, ddigest;
+	uint32_t crc;
 
+	if (conn->state == STATE_SCSI) {
+		struct param *p = conn->session_param;
+		hdigest = p[ISCSI_PARAM_HDRDGST_EN].val & DIGEST_CRC32C;
+		ddigest = p[ISCSI_PARAM_DATADGST_EN].val & DIGEST_CRC32C;
+	} else
+		hdigest = ddigest = 0;
+again:
 	switch (conn->rx_iostate) {
-	case IOSTATE_READ_BHS:
-	case IOSTATE_READ_AHS_DATA:
-	read_again:
-		res = conn->tp->ep_read(fd, conn->rx_buffer, conn->rx_size);
-		if (!res) {
-			conn->state = STATE_CLOSE;
+	case IOSTATE_RX_BHS:
+		ret = do_recv(fd, conn, IOSTATE_RX_INIT_AHS);
+		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_AHS)
 			break;
-		} else if (res < 0) {
-			if (errno == EINTR)
-				goto read_again;
-			else if (errno == EAGAIN)
-				break;
-			else {
+	case IOSTATE_RX_INIT_AHS:
+		if (conn->state == STATE_SCSI) {
+			ret = iscsi_task_rx_start(conn);
+			if (ret) {
 				conn->state = STATE_CLOSE;
-				dprintf("%d %d, %m\n", res, errno);
+				break;
 			}
+		} else {
+			conn->rx_buffer = conn->req_buffer;
+			conn->req.ahs = conn->rx_buffer;
+			conn->req.data = conn->rx_buffer + conn->rx_size;
+		}
+		conn->req.ahssize = conn->req.bhs.hlength * 4;
+		conn->req.datasize = ntoh24(conn->req.bhs.dlength);
+		conn->rx_size = roundup(conn->req.ahssize, 4);
+		if (conn->rx_size) {
+			ret = do_recv(fd, conn, IOSTATE_RX_AHS);
+			if (ret <= 0)
+				break;
+		} else
+			conn->rx_iostate = hdigest ?
+				IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA;
+
+		if (conn->rx_iostate == IOSTATE_RX_INIT_DATA)
+			goto again;
+		else if (conn->rx_iostate != IOSTATE_RX_AHS)
+			break;
+	case IOSTATE_RX_AHS:
+		ret = do_recv(fd, conn, hdigest ?
+			      IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA);
+		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_HDIGEST)
 			break;
+	case IOSTATE_RX_INIT_HDIGEST:
+		conn->rx_buffer = conn->rx_digest;
+		conn->rx_size = sizeof(conn->rx_digest);
+		conn->rx_iostate = IOSTATE_RX_HDIGEST;
+	case IOSTATE_RX_HDIGEST:
+		ret = do_recv(fd, conn, IOSTATE_RX_CHECK_HDIGEST);
+		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_CHECK_HDIGEST)
+			break;
+	case IOSTATE_RX_CHECK_HDIGEST:
+		crc = ~0;
+		crc = crc32c(crc, &conn->req.bhs, BHS_SIZE);
+		if (conn->req.ahssize)
+			crc = crc32c(crc, conn->req.ahs,
+				     roundup(conn->req.ahssize, 4));
+		crc = ~__cpu_to_le32(crc);
+		if (*((uint32_t *)conn->rx_digest) != crc) {
+			eprintf("rx hdr digest error 0x%x calc 0x%x\n",
+				*((uint32_t *)conn->rx_digest), crc);
+			conn->state = STATE_CLOSE;
 		}
-		conn->rx_size -= res;
-		conn->rx_buffer += res;
-		if (conn->rx_size)
+		conn->rx_iostate = IOSTATE_RX_INIT_DATA;
+	case IOSTATE_RX_INIT_DATA:
+		conn->rx_size = roundup(conn->req.datasize, 4);
+		if (conn->rx_size) {
+			conn->rx_iostate = IOSTATE_RX_DATA;
+			conn->rx_buffer = conn->req.data;
+		} else {
+			conn->rx_iostate = IOSTATE_RX_END;
+			break;
+		}
+	case IOSTATE_RX_DATA:
+		ret = do_recv(fd, conn, ddigest ?
+			      IOSTATE_RX_INIT_DDIGEST : IOSTATE_RX_END);
+		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_DDIGEST)
+			break;
+	case IOSTATE_RX_INIT_DDIGEST:
+		conn->rx_buffer = conn->rx_digest;
+		conn->rx_size = sizeof(conn->rx_digest);
+		conn->rx_iostate = IOSTATE_RX_DDIGEST;
+	case IOSTATE_RX_DDIGEST:
+		ret = do_recv(fd, conn, IOSTATE_RX_CHECK_DDIGEST);
+		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_CHECK_DDIGEST)
 			break;
+	case IOSTATE_RX_CHECK_DDIGEST:
+		crc = ~0;
+		crc = crc32c(crc, conn->req.data, roundup(conn->req.datasize, 4));
+		crc = ~__cpu_to_le32(crc);
+		conn->rx_iostate = IOSTATE_RX_END;
+		if (*((uint32_t *)conn->rx_digest) != crc) {
+			eprintf("rx hdr digest error 0x%x calc 0x%x\n",
+				*((uint32_t *)conn->rx_digest), crc);
+			conn->state = STATE_CLOSE;
+		}
+		break;
+	default:
+		eprintf("error %d %d\n", conn->state, conn->rx_iostate);
+		exit(1);
+	}
 
-		switch (conn->rx_iostate) {
-		case IOSTATE_READ_BHS:
-			conn->req.ahssize = conn->req.bhs.hlength * 4;
-			conn->req.datasize = ntoh24(conn->req.bhs.dlength);
+	if (ret < 0 ||
+	    conn->rx_iostate != IOSTATE_RX_END ||
+	    conn->state == STATE_CLOSE)
+		return;
 
-			if (conn->state == STATE_SCSI) {
-				res = iscsi_task_rx_start(conn);
-				if (res) {
-					conn->state = STATE_CLOSE;
-					break;
-				}
-			} else {
-				conn->rx_buffer = conn->req_buffer;
-				conn->req.ahs = conn->rx_buffer;
-				conn->rx_size = roundup(conn->req.ahssize, 4);
-				conn->req.data = conn->rx_buffer + conn->rx_size;
-				conn->rx_size += roundup(conn->req.datasize, 4);
-			}
+	if (conn->rx_size) {
+		eprintf("error %d %d %d\n", conn->state, conn->rx_iostate,
+			conn->rx_size);
+		exit(1);
+	}
 
-			if (conn->rx_size) {
-				conn->rx_iostate = IOSTATE_READ_AHS_DATA;
-				goto read_again;
-			}
+	if (conn->state == STATE_SCSI) {
+		ret = iscsi_task_rx_done(conn);
+		if (ret)
+			conn->state = STATE_CLOSE;
+		else
+			conn_read_pdu(conn);
+	} else {
+		conn_write_pdu(conn);
+		tgt_event_modify(fd, EPOLLOUT);
+		ret = cmnd_execute(conn);
+		if (ret)
+			conn->state = STATE_CLOSE;
+	}
+}
 
-		case IOSTATE_READ_AHS_DATA:
-			if (conn->state == STATE_SCSI) {
-				res = iscsi_task_rx_done(conn);
-				if (!res)
-					conn_read_pdu(conn);
-			} else {
-				conn_write_pdu(conn);
-				tgt_event_modify(fd, EPOLLOUT);
-				res = cmnd_execute(conn);
-			}
+static int do_send(int fd, struct iscsi_connection *conn, int next_state)
+{
+	int ret;
+again:
+	ret = conn->tp->ep_write_begin(fd, conn->tx_buffer, conn->tx_size);
+	if (ret < 0) {
+		if (errno != EINTR && errno != EAGAIN)
+			conn->state = STATE_CLOSE;
+		else if (errno == EINTR || errno == EAGAIN)
+			goto again;
 
-			if (res)
-				conn->state = STATE_CLOSE;
-			break;
-		}
-		break;
+		return -EIO;
 	}
+
+	conn->tx_size -= ret;
+	conn->tx_buffer += ret;
+	if (conn->tx_size)
+		goto again;
+	conn->tx_iostate = next_state;
+
+	return 0;
 }
 
 static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 {
-	int res;
+	int ret = 0, hdigest, ddigest;
+	uint32_t crc;
+
+	if (conn->state == STATE_SCSI) {
+		struct param *p = conn->session_param;
+		hdigest = p[ISCSI_PARAM_HDRDGST_EN].val & DIGEST_CRC32C;
+		ddigest = p[ISCSI_PARAM_DATADGST_EN].val & DIGEST_CRC32C;
+	} else
+		hdigest = ddigest = 0;
 
 	if (conn->state == STATE_SCSI && !conn->tx_task) {
-		res = iscsi_task_tx_start(conn);
-		if (res)
+		ret = iscsi_task_tx_start(conn);
+		if (ret)
 			return;
 	}
 
 	switch (conn->tx_iostate) {
-	case IOSTATE_WRITE_BHS:
-	case IOSTATE_WRITE_AHS:
-	case IOSTATE_WRITE_DATA:
-	write_again:
-		res = conn->tp->ep_write_begin(fd, conn->tx_buffer,
-					       conn->tx_size);
-		if (res < 0) {
-			if (errno != EINTR && errno != EAGAIN)
-				conn->state = STATE_CLOSE;
-			else if (errno == EINTR)
-				goto write_again;
+	case IOSTATE_TX_BHS:
+		ret = do_send(fd, conn, IOSTATE_TX_INIT_AHS);
+		if (ret < 0)
 			break;
-		}
+	case IOSTATE_TX_INIT_AHS:
+		if (conn->rsp.ahssize) {
+			conn->tx_iostate = IOSTATE_TX_AHS;
+			conn->tx_buffer = conn->rsp.ahs;
+			conn->tx_size = conn->rsp.ahssize;
 
-		conn->tx_size -= res;
-		conn->tx_buffer += res;
-		if (conn->tx_size)
-			goto write_again;
-
-		switch (conn->tx_iostate) {
-		case IOSTATE_WRITE_BHS:
-			if (conn->rsp.ahssize) {
-				conn->tx_iostate = IOSTATE_WRITE_AHS;
-				conn->tx_buffer = conn->rsp.ahs;
-				conn->tx_size = conn->rsp.ahssize;
-				goto write_again;
-			}
-		case IOSTATE_WRITE_AHS:
-			if (conn->rsp.datasize) {
-				int pad;
-
-				conn->tx_iostate = IOSTATE_WRITE_DATA;
-				conn->tx_buffer = conn->rsp.data;
-				conn->tx_size = conn->rsp.datasize;
-				pad = conn->tx_size & (PAD_WORD_LEN - 1);
-				if (pad) {
-					pad = PAD_WORD_LEN - pad;
-					memset(conn->tx_buffer + conn->tx_size,
-					       0, pad);
-					conn->tx_size += pad;
-				}
-				goto write_again;
-			}
-		case IOSTATE_WRITE_DATA:
-			conn->tp->ep_write_end(fd);
-			cmnd_finish(conn);
+			conn->tx_iostate = IOSTATE_TX_AHS;
+		} else
+			conn->tx_iostate = hdigest ?
+				IOSTATE_TX_INIT_HDIGEST : IOSTATE_TX_INIT_DATA;
 
-			switch (conn->state) {
-			case STATE_KERNEL:
-				res = conn_take_fd(conn, fd);
-				if (res)
-					conn->state = STATE_CLOSE;
-				else {
-					conn->state = STATE_SCSI;
-					conn_read_pdu(conn);
-					tgt_event_modify(fd, EPOLLIN);
-				}
-				break;
-			case STATE_EXIT:
-			case STATE_CLOSE:
-				break;
-			case STATE_SCSI:
-				iscsi_task_tx_done(conn);
-				break;
-			default:
-				conn_read_pdu(conn);
-				tgt_event_modify(fd, EPOLLIN);
-				break;
+		if (conn->tx_iostate != IOSTATE_TX_AHS)
+			break;
+	case IOSTATE_TX_AHS:
+		conn->tx_iostate = hdigest ?
+			IOSTATE_TX_INIT_HDIGEST : IOSTATE_TX_INIT_DATA;
+		if (conn->tx_iostate != IOSTATE_TX_INIT_HDIGEST)
+			break;
+	case IOSTATE_TX_INIT_HDIGEST:
+		crc = ~0;
+		crc = crc32c(crc, &conn->rsp.bhs, BHS_SIZE);
+		*(uint32_t *)conn->tx_digest = ~__cpu_to_le32(crc);
+		conn->tx_iostate = IOSTATE_TX_HDIGEST;
+		conn->tx_buffer = conn->tx_digest;
+		conn->tx_size = sizeof(conn->tx_digest);
+	case IOSTATE_TX_HDIGEST:
+		ret = do_send(fd, conn, IOSTATE_TX_INIT_DATA);
+		if (ret < 0)
+			break;
+	case IOSTATE_TX_INIT_DATA:
+		if (conn->rsp.datasize) {
+			int pad;
+
+			conn->tx_iostate = IOSTATE_TX_DATA;
+			conn->tx_buffer = conn->rsp.data;
+			conn->tx_size = conn->rsp.datasize;
+			pad = conn->tx_size & (PAD_WORD_LEN - 1);
+			if (pad) {
+				pad = PAD_WORD_LEN - pad;
+				memset(conn->tx_buffer + conn->tx_size, 0, pad);
+				conn->tx_size += pad;
 			}
+		} else
+			conn->tx_iostate = IOSTATE_TX_END;
+		if (conn->tx_iostate != IOSTATE_TX_DATA)
 			break;
-		}
-
+	case IOSTATE_TX_DATA:
+		ret = do_send(fd, conn, ddigest ?
+			      IOSTATE_TX_INIT_DDIGEST : IOSTATE_TX_END);
+		if (ret < 0)
+			return;
+		if (conn->tx_iostate != IOSTATE_TX_INIT_DDIGEST)
+			break;
+	case IOSTATE_TX_INIT_DDIGEST:
+		crc = ~0;
+		crc = crc32c(crc, conn->rsp.data,
+			     roundup(conn->rsp.datasize, 4));
+		*(uint32_t *)conn->tx_digest = ~__cpu_to_le32(crc);
+		conn->tx_iostate = IOSTATE_TX_DDIGEST;
+		conn->tx_buffer = conn->tx_digest;
+		conn->tx_size = sizeof(conn->tx_digest);
+	case IOSTATE_TX_DDIGEST:
+		ret = do_send(fd, conn, IOSTATE_TX_END);
 		break;
 	default:
-		eprintf("illegal iostate %d %d\n", conn->tx_iostate,
-			conn->tx_iostate);
-		conn->state = STATE_CLOSE;
+		eprintf("error %d %d\n", conn->state, conn->tx_iostate);
+		exit(1);
 	}
 
+	if (ret < 0 ||
+	    conn->tx_iostate != IOSTATE_TX_END ||
+	    conn->state == STATE_CLOSE)
+		return;
+
+	if (conn->tx_size) {
+		eprintf("error %d %d %d\n", conn->state, conn->tx_iostate,
+			conn->tx_size);
+		exit(1);
+	}
+
+	conn->tp->ep_write_end(fd);
+	cmnd_finish(conn);
+
+	switch (conn->state) {
+	case STATE_KERNEL:
+		ret = conn_take_fd(conn, fd);
+		if (ret)
+			conn->state = STATE_CLOSE;
+		else {
+			conn->state = STATE_SCSI;
+			conn_read_pdu(conn);
+			tgt_event_modify(fd, EPOLLIN);
+		}
+		break;
+	case STATE_EXIT:
+	case STATE_CLOSE:
+		break;
+	case STATE_SCSI:
+		iscsi_task_tx_done(conn);
+		break;
+	default:
+		conn_read_pdu(conn);
+		tgt_event_modify(fd, EPOLLIN);
+		break;
+	}
 }
 
 void iscsi_event_handler(int fd, int events, void *data)
@@ -1838,8 +2024,10 @@ void iscsi_event_handler(int fd, int eve
 	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
 		iscsi_tx_handler(fd, conn);
 
-	if (conn->state == STATE_CLOSE)
+	if (conn->state == STATE_CLOSE) {
 		conn_close(conn, fd);
+		dprintf("connection closed\n");
+	}
 }
 
 struct tgt_driver iscsi = {
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 84d74f3..29abc5d 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -174,6 +174,9 @@ struct iscsi_connection {
 
 	struct list_head tx_clist;
 
+	unsigned char rx_digest[4];
+	unsigned char tx_digest[4];
+
 	int auth_state;
 	union {
 		struct {
@@ -187,13 +190,6 @@ struct iscsi_connection {
 	struct iscsi_transport *tp;
 };
 
-#define IOSTATE_FREE		0
-#define IOSTATE_READ_BHS	1
-#define IOSTATE_READ_AHS_DATA	2
-#define IOSTATE_WRITE_BHS	3
-#define IOSTATE_WRITE_AHS	4
-#define IOSTATE_WRITE_DATA	5
-
 #define STATE_FREE		0
 #define STATE_SECURITY		1
 #define STATE_SECURITY_AUTH	2
@@ -263,14 +259,13 @@ extern void conn_put(struct iscsi_connec
 extern int conn_get(struct iscsi_connection *conn);
 extern struct iscsi_connection * conn_find(struct iscsi_session *session, uint32_t cid);
 extern int conn_take_fd(struct iscsi_connection *conn, int fd);
-extern void conn_read_pdu(struct iscsi_connection *conn);
-extern void conn_write_pdu(struct iscsi_connection *conn);
 extern void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_session *session);
 
 /* iscsid.c */
 extern void iscsi_event_handler(int fd, int events, void *data);
 extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
 extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
+extern void conn_read_pdu(struct iscsi_connection *conn);
 
 /* iscsid.c iscsi_task */
 extern void iscsi_free_task(struct iscsi_task *task);


From albert.pauw at gmail.com  Tue Apr 24 16:05:25 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Tue, 24 Apr 2007 16:05:25 +0200
Subject: [Stgt-devel] [PATCH] head and data digest
In-Reply-To: <20070424083930S.fujita.tomonori@lab.ntt.co.jp>
References: <462B81AE.7040003@gmail.com>	<20070423072127S.fujita.tomonori@lab.ntt.co.jp>	<462CEB34.90803@gmail.com>
	<20070424083930S.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <462E0EA5.4060600@gmail.com>

Checked this patch (together with the FirstBurstLength patch)
and it seems to work fine again. But now with both digests.

Thanks,

Albert

FUJITA Tomonori wrote:
> From: Albert Pauw <albert.pauw at gmail.com>
> Subject: Re: [Stgt-devel] [PATCH] head and data digest
> Date: Mon, 23 Apr 2007 19:21:56 +0200
> 
>> FUJITA Tomonori wrote:
>>> From: Albert Pauw <albert.pauw at gmail.com>
>>> Subject: Re: [Stgt-devel] [PATCH] head and data digest
>>> Date: Sun, 22 Apr 2007 17:39:26 +0200
>>>
>>>   
>>>> I set HeaderDigest to CRC32C on the disk target:
>>>>     
>>> Do you enable the features? Here's an example:
>>>
>>> root at ac:~/git# ./tgt/usr/tgtadm --op show --mode target --tid 1
>>> MaxRecvDataSegmentLength=8192
>>> MaxXmitDataSegmentLength=8192
>>> HeaderDigest=None
>>> DataDigest=None
>>> InitialR2T=Yes
>>> MaxOutstandingR2T=1
>>> ImmediateData=Yes
>>> FirstBurstLength=65536
>>> MaxBurstLength=262144
>>> DataPDUInOrder=Yes
>>> DataSequenceInOrder=Yes
>>> ErrorRecoveryLevel=0
>>> IFMarker=No
>>> OFMarker=No
>>> DefaultTime2Wait=2
>>> DefaultTime2Retain=20
>>> OFMarkInt=Reject
>>> IFMarkInt=Reject
>>> MaxConnections=1
>>>
>>> root at ac:~/git# ./tgt/usr/tgtadm --op update --mode target --tid 1 -n HeaderDigest -v CRC32C
>>> root at ac:~/git# ./tgt/usr/tgtadm --op update --mode target --tid 1 -n DataDigest -v CRC32C
>>>
>>> root at ac:~/git# ./tgt/usr/tgtadm --op show --mode target --tid 1
>>> MaxRecvDataSegmentLength=8192
>>> MaxXmitDataSegmentLength=8192
>>> HeaderDigest=CRC32C
>>> DataDigest=CRC32C
>>> InitialR2T=Yes
>>> MaxOutstandingR2T=1
>>> ImmediateData=Yes
>>> FirstBurstLength=65536
>>> MaxBurstLength=262144
>>> DataPDUInOrder=Yes
>>> DataSequenceInOrder=Yes
>>> ErrorRecoveryLevel=0
>>> IFMarker=No
>>> OFMarker=No
>>> DefaultTime2Wait=2
>>> DefaultTime2Retain=20
>>> OFMarkInt=Reject
>>> IFMarkInt=Reject
>>> MaxConnections=1
>>>
>>> With this configuration, the target accepts CRC32C and
>>> None. Currently, there is no way to configure a target to accept only
>>> CRC32C.
>>>
>>> If it still doesn't work for you, please send the tcpdump log during a
>>> login process.
>>>
>>>   
>> Ok, login works fine, if I look with wireshark I can see that the digest
>> is ok.
> 
> Sorry, I put a silly bug in the patch. Here's a new one.
> 
> 
> diff --git a/usr/iscsi/conn.c b/usr/iscsi/conn.c
> index e4e36aa..fcd2385 100644
> --- a/usr/iscsi/conn.c
> +++ b/usr/iscsi/conn.c
> @@ -176,18 +176,3 @@ int conn_take_fd(struct iscsi_connection
>  
>  	return 0;
>  }
> -
> -void conn_read_pdu(struct iscsi_connection *conn)
> -{
> -	conn->rx_iostate = IOSTATE_READ_BHS;
> -	conn->rx_buffer = (void *)&conn->req.bhs;
> -	conn->rx_size = BHS_SIZE;
> -}
> -
> -void conn_write_pdu(struct iscsi_connection *conn)
> -{
> -	conn->tx_iostate = IOSTATE_WRITE_BHS;
> -	memset(&conn->rsp, 0, sizeof(conn->rsp));
> -	conn->tx_buffer = (void *)&conn->rsp.bhs;
> -	conn->tx_size = BHS_SIZE;
> -}
> diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> index 2377952..3d38ccc 100644
> --- a/usr/iscsi/iscsid.c
> +++ b/usr/iscsi/iscsid.c
> @@ -38,9 +38,53 @@ #include "iscsid.h"
>  #include "tgtd.h"
>  #include "util.h"
>  #include "driver.h"
> +#include "crc32c.h"
>  
>  #define MAX_QUEUE_CMD	32
>  
> +enum {
> +	IOSTATE_FREE,
> +
> +	IOSTATE_RX_BHS,
> +	IOSTATE_RX_INIT_AHS,
> +	IOSTATE_RX_AHS,
> +	IOSTATE_RX_INIT_HDIGEST,
> +	IOSTATE_RX_HDIGEST,
> +	IOSTATE_RX_CHECK_HDIGEST,
> +	IOSTATE_RX_INIT_DATA,
> +	IOSTATE_RX_DATA,
> +	IOSTATE_RX_INIT_DDIGEST,
> +	IOSTATE_RX_DDIGEST,
> +	IOSTATE_RX_CHECK_DDIGEST,
> +	IOSTATE_RX_END,
> +
> +	IOSTATE_TX_BHS,
> +	IOSTATE_TX_INIT_AHS,
> +	IOSTATE_TX_AHS,
> +	IOSTATE_TX_INIT_HDIGEST,
> +	IOSTATE_TX_HDIGEST,
> +	IOSTATE_TX_INIT_DATA,
> +	IOSTATE_TX_DATA,
> +	IOSTATE_TX_INIT_DDIGEST,
> +	IOSTATE_TX_DDIGEST,
> +	IOSTATE_TX_END,
> +};
> +
> +void conn_read_pdu(struct iscsi_connection *conn)
> +{
> +	conn->rx_iostate = IOSTATE_RX_BHS;
> +	conn->rx_buffer = (void *)&conn->req.bhs;
> +	conn->rx_size = BHS_SIZE;
> +}
> +
> +static void conn_write_pdu(struct iscsi_connection *conn)
> +{
> +	conn->tx_iostate = IOSTATE_TX_BHS;
> +	memset(&conn->rsp, 0, sizeof(conn->rsp));
> +	conn->tx_buffer = (void *)&conn->rsp.bhs;
> +	conn->tx_size = BHS_SIZE;
> +}
> +
>  static struct iscsi_key login_keys[] = {
>  	{"InitiatorName",},
>  	{"InitiatorAlias",},
> @@ -1265,9 +1309,7 @@ found:
>  		task->r2t_count,
>  		ntoh24(req->dlength), be32_to_cpu(req->offset));
>  
> -	conn->rx_buffer = task->data;
> -	conn->rx_buffer += be32_to_cpu(req->offset);
> -	conn->rx_size = roundup(ntoh24(req->dlength), 4);
> +	conn->req.data = task->data + be32_to_cpu(req->offset);
>  
>  	task->offset += ntoh24(req->dlength);
>  	task->r2t_count -= ntoh24(req->dlength);
> @@ -1357,12 +1399,10 @@ static int iscsi_scsi_cmd_rx_start(struc
>  	if (ahs_len) {
>  		task->ahs = task->data + sizeof(req->cdb);
>  		task->data = task->ahs + ahs_len;
> -		conn->rx_buffer = task->ahs;
> - 		conn->rx_size = ahs_len + imm_len;
> -	} else if (data_len) {
> - 		conn->rx_buffer = task->data;
> -		conn->rx_size = imm_len;
> - 	}
> +		conn->req.ahs = task->ahs;
> +		conn->req.data = task->data;
> +	} else if (data_len)
> +		conn->req.data = task->data;
>  
>  	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
>  		task->offset = ntoh24(req->dlength);
> @@ -1414,9 +1454,8 @@ static int iscsi_noop_out_rx_start(struc
>  	}
>  
>  	if (len) {
> -		conn->rx_size = len;
>  		task->len = len;
> -		conn->rx_buffer = task->data;
> +		conn->req.data = task->data;
>  	}
>  out:
>  	return err;
> @@ -1662,167 +1701,314 @@ nodata:
>  	return -EAGAIN;
>  }
>  
> +static int do_recv(int fd, struct iscsi_connection *conn, int next_state)
> +{
> +	int ret;
> +
> +	ret = conn->tp->ep_read(fd, conn->rx_buffer, conn->rx_size);
> +	if (!ret) {
> +		conn->state = STATE_CLOSE;
> +		return 0;
> +	} else if (ret < 0) {
> +		if (errno == EINTR || errno == EAGAIN)
> +			return 0;
> +		else
> +			return -EIO;
> +	}
> +
> +	conn->rx_size -= ret;
> +	conn->rx_buffer += ret;
> +	if (!conn->rx_size)
> +		conn->rx_iostate = next_state;
> +
> +	return ret;
> +}
> +
>  static void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
>  {
> -	int res;
> +	int ret = 0, hdigest, ddigest;
> +	uint32_t crc;
>  
> +	if (conn->state == STATE_SCSI) {
> +		struct param *p = conn->session_param;
> +		hdigest = p[ISCSI_PARAM_HDRDGST_EN].val & DIGEST_CRC32C;
> +		ddigest = p[ISCSI_PARAM_DATADGST_EN].val & DIGEST_CRC32C;
> +	} else
> +		hdigest = ddigest = 0;
> +again:
>  	switch (conn->rx_iostate) {
> -	case IOSTATE_READ_BHS:
> -	case IOSTATE_READ_AHS_DATA:
> -	read_again:
> -		res = conn->tp->ep_read(fd, conn->rx_buffer, conn->rx_size);
> -		if (!res) {
> -			conn->state = STATE_CLOSE;
> +	case IOSTATE_RX_BHS:
> +		ret = do_recv(fd, conn, IOSTATE_RX_INIT_AHS);
> +		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_AHS)
>  			break;
> -		} else if (res < 0) {
> -			if (errno == EINTR)
> -				goto read_again;
> -			else if (errno == EAGAIN)
> -				break;
> -			else {
> +	case IOSTATE_RX_INIT_AHS:
> +		if (conn->state == STATE_SCSI) {
> +			ret = iscsi_task_rx_start(conn);
> +			if (ret) {
>  				conn->state = STATE_CLOSE;
> -				dprintf("%d %d, %m\n", res, errno);
> +				break;
>  			}
> +		} else {
> +			conn->rx_buffer = conn->req_buffer;
> +			conn->req.ahs = conn->rx_buffer;
> +			conn->req.data = conn->rx_buffer + conn->rx_size;
> +		}
> +		conn->req.ahssize = conn->req.bhs.hlength * 4;
> +		conn->req.datasize = ntoh24(conn->req.bhs.dlength);
> +		conn->rx_size = roundup(conn->req.ahssize, 4);
> +		if (conn->rx_size) {
> +			ret = do_recv(fd, conn, IOSTATE_RX_AHS);
> +			if (ret <= 0)
> +				break;
> +		} else
> +			conn->rx_iostate = hdigest ?
> +				IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA;
> +
> +		if (conn->rx_iostate == IOSTATE_RX_INIT_DATA)
> +			goto again;
> +		else if (conn->rx_iostate != IOSTATE_RX_AHS)
> +			break;
> +	case IOSTATE_RX_AHS:
> +		ret = do_recv(fd, conn, hdigest ?
> +			      IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA);
> +		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_HDIGEST)
>  			break;
> +	case IOSTATE_RX_INIT_HDIGEST:
> +		conn->rx_buffer = conn->rx_digest;
> +		conn->rx_size = sizeof(conn->rx_digest);
> +		conn->rx_iostate = IOSTATE_RX_HDIGEST;
> +	case IOSTATE_RX_HDIGEST:
> +		ret = do_recv(fd, conn, IOSTATE_RX_CHECK_HDIGEST);
> +		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_CHECK_HDIGEST)
> +			break;
> +	case IOSTATE_RX_CHECK_HDIGEST:
> +		crc = ~0;
> +		crc = crc32c(crc, &conn->req.bhs, BHS_SIZE);
> +		if (conn->req.ahssize)
> +			crc = crc32c(crc, conn->req.ahs,
> +				     roundup(conn->req.ahssize, 4));
> +		crc = ~__cpu_to_le32(crc);
> +		if (*((uint32_t *)conn->rx_digest) != crc) {
> +			eprintf("rx hdr digest error 0x%x calc 0x%x\n",
> +				*((uint32_t *)conn->rx_digest), crc);
> +			conn->state = STATE_CLOSE;
>  		}
> -		conn->rx_size -= res;
> -		conn->rx_buffer += res;
> -		if (conn->rx_size)
> +		conn->rx_iostate = IOSTATE_RX_INIT_DATA;
> +	case IOSTATE_RX_INIT_DATA:
> +		conn->rx_size = roundup(conn->req.datasize, 4);
> +		if (conn->rx_size) {
> +			conn->rx_iostate = IOSTATE_RX_DATA;
> +			conn->rx_buffer = conn->req.data;
> +		} else {
> +			conn->rx_iostate = IOSTATE_RX_END;
> +			break;
> +		}
> +	case IOSTATE_RX_DATA:
> +		ret = do_recv(fd, conn, ddigest ?
> +			      IOSTATE_RX_INIT_DDIGEST : IOSTATE_RX_END);
> +		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_DDIGEST)
> +			break;
> +	case IOSTATE_RX_INIT_DDIGEST:
> +		conn->rx_buffer = conn->rx_digest;
> +		conn->rx_size = sizeof(conn->rx_digest);
> +		conn->rx_iostate = IOSTATE_RX_DDIGEST;
> +	case IOSTATE_RX_DDIGEST:
> +		ret = do_recv(fd, conn, IOSTATE_RX_CHECK_DDIGEST);
> +		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_CHECK_DDIGEST)
>  			break;
> +	case IOSTATE_RX_CHECK_DDIGEST:
> +		crc = ~0;
> +		crc = crc32c(crc, conn->req.data, roundup(conn->req.datasize, 4));
> +		crc = ~__cpu_to_le32(crc);
> +		conn->rx_iostate = IOSTATE_RX_END;
> +		if (*((uint32_t *)conn->rx_digest) != crc) {
> +			eprintf("rx hdr digest error 0x%x calc 0x%x\n",
> +				*((uint32_t *)conn->rx_digest), crc);
> +			conn->state = STATE_CLOSE;
> +		}
> +		break;
> +	default:
> +		eprintf("error %d %d\n", conn->state, conn->rx_iostate);
> +		exit(1);
> +	}
>  
> -		switch (conn->rx_iostate) {
> -		case IOSTATE_READ_BHS:
> -			conn->req.ahssize = conn->req.bhs.hlength * 4;
> -			conn->req.datasize = ntoh24(conn->req.bhs.dlength);
> +	if (ret < 0 ||
> +	    conn->rx_iostate != IOSTATE_RX_END ||
> +	    conn->state == STATE_CLOSE)
> +		return;
>  
> -			if (conn->state == STATE_SCSI) {
> -				res = iscsi_task_rx_start(conn);
> -				if (res) {
> -					conn->state = STATE_CLOSE;
> -					break;
> -				}
> -			} else {
> -				conn->rx_buffer = conn->req_buffer;
> -				conn->req.ahs = conn->rx_buffer;
> -				conn->rx_size = roundup(conn->req.ahssize, 4);
> -				conn->req.data = conn->rx_buffer + conn->rx_size;
> -				conn->rx_size += roundup(conn->req.datasize, 4);
> -			}
> +	if (conn->rx_size) {
> +		eprintf("error %d %d %d\n", conn->state, conn->rx_iostate,
> +			conn->rx_size);
> +		exit(1);
> +	}
>  
> -			if (conn->rx_size) {
> -				conn->rx_iostate = IOSTATE_READ_AHS_DATA;
> -				goto read_again;
> -			}
> +	if (conn->state == STATE_SCSI) {
> +		ret = iscsi_task_rx_done(conn);
> +		if (ret)
> +			conn->state = STATE_CLOSE;
> +		else
> +			conn_read_pdu(conn);
> +	} else {
> +		conn_write_pdu(conn);
> +		tgt_event_modify(fd, EPOLLOUT);
> +		ret = cmnd_execute(conn);
> +		if (ret)
> +			conn->state = STATE_CLOSE;
> +	}
> +}
>  
> -		case IOSTATE_READ_AHS_DATA:
> -			if (conn->state == STATE_SCSI) {
> -				res = iscsi_task_rx_done(conn);
> -				if (!res)
> -					conn_read_pdu(conn);
> -			} else {
> -				conn_write_pdu(conn);
> -				tgt_event_modify(fd, EPOLLOUT);
> -				res = cmnd_execute(conn);
> -			}
> +static int do_send(int fd, struct iscsi_connection *conn, int next_state)
> +{
> +	int ret;
> +again:
> +	ret = conn->tp->ep_write_begin(fd, conn->tx_buffer, conn->tx_size);
> +	if (ret < 0) {
> +		if (errno != EINTR && errno != EAGAIN)
> +			conn->state = STATE_CLOSE;
> +		else if (errno == EINTR || errno == EAGAIN)
> +			goto again;
>  
> -			if (res)
> -				conn->state = STATE_CLOSE;
> -			break;
> -		}
> -		break;
> +		return -EIO;
>  	}
> +
> +	conn->tx_size -= ret;
> +	conn->tx_buffer += ret;
> +	if (conn->tx_size)
> +		goto again;
> +	conn->tx_iostate = next_state;
> +
> +	return 0;
>  }
>  
>  static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
>  {
> -	int res;
> +	int ret = 0, hdigest, ddigest;
> +	uint32_t crc;
> +
> +	if (conn->state == STATE_SCSI) {
> +		struct param *p = conn->session_param;
> +		hdigest = p[ISCSI_PARAM_HDRDGST_EN].val & DIGEST_CRC32C;
> +		ddigest = p[ISCSI_PARAM_DATADGST_EN].val & DIGEST_CRC32C;
> +	} else
> +		hdigest = ddigest = 0;
>  
>  	if (conn->state == STATE_SCSI && !conn->tx_task) {
> -		res = iscsi_task_tx_start(conn);
> -		if (res)
> +		ret = iscsi_task_tx_start(conn);
> +		if (ret)
>  			return;
>  	}
>  
>  	switch (conn->tx_iostate) {
> -	case IOSTATE_WRITE_BHS:
> -	case IOSTATE_WRITE_AHS:
> -	case IOSTATE_WRITE_DATA:
> -	write_again:
> -		res = conn->tp->ep_write_begin(fd, conn->tx_buffer,
> -					       conn->tx_size);
> -		if (res < 0) {
> -			if (errno != EINTR && errno != EAGAIN)
> -				conn->state = STATE_CLOSE;
> -			else if (errno == EINTR)
> -				goto write_again;
> +	case IOSTATE_TX_BHS:
> +		ret = do_send(fd, conn, IOSTATE_TX_INIT_AHS);
> +		if (ret < 0)
>  			break;
> -		}
> +	case IOSTATE_TX_INIT_AHS:
> +		if (conn->rsp.ahssize) {
> +			conn->tx_iostate = IOSTATE_TX_AHS;
> +			conn->tx_buffer = conn->rsp.ahs;
> +			conn->tx_size = conn->rsp.ahssize;
>  
> -		conn->tx_size -= res;
> -		conn->tx_buffer += res;
> -		if (conn->tx_size)
> -			goto write_again;
> -
> -		switch (conn->tx_iostate) {
> -		case IOSTATE_WRITE_BHS:
> -			if (conn->rsp.ahssize) {
> -				conn->tx_iostate = IOSTATE_WRITE_AHS;
> -				conn->tx_buffer = conn->rsp.ahs;
> -				conn->tx_size = conn->rsp.ahssize;
> -				goto write_again;
> -			}
> -		case IOSTATE_WRITE_AHS:
> -			if (conn->rsp.datasize) {
> -				int pad;
> -
> -				conn->tx_iostate = IOSTATE_WRITE_DATA;
> -				conn->tx_buffer = conn->rsp.data;
> -				conn->tx_size = conn->rsp.datasize;
> -				pad = conn->tx_size & (PAD_WORD_LEN - 1);
> -				if (pad) {
> -					pad = PAD_WORD_LEN - pad;
> -					memset(conn->tx_buffer + conn->tx_size,
> -					       0, pad);
> -					conn->tx_size += pad;
> -				}
> -				goto write_again;
> -			}
> -		case IOSTATE_WRITE_DATA:
> -			conn->tp->ep_write_end(fd);
> -			cmnd_finish(conn);
> +			conn->tx_iostate = IOSTATE_TX_AHS;
> +		} else
> +			conn->tx_iostate = hdigest ?
> +				IOSTATE_TX_INIT_HDIGEST : IOSTATE_TX_INIT_DATA;
>  
> -			switch (conn->state) {
> -			case STATE_KERNEL:
> -				res = conn_take_fd(conn, fd);
> -				if (res)
> -					conn->state = STATE_CLOSE;
> -				else {
> -					conn->state = STATE_SCSI;
> -					conn_read_pdu(conn);
> -					tgt_event_modify(fd, EPOLLIN);
> -				}
> -				break;
> -			case STATE_EXIT:
> -			case STATE_CLOSE:
> -				break;
> -			case STATE_SCSI:
> -				iscsi_task_tx_done(conn);
> -				break;
> -			default:
> -				conn_read_pdu(conn);
> -				tgt_event_modify(fd, EPOLLIN);
> -				break;
> +		if (conn->tx_iostate != IOSTATE_TX_AHS)
> +			break;
> +	case IOSTATE_TX_AHS:
> +		conn->tx_iostate = hdigest ?
> +			IOSTATE_TX_INIT_HDIGEST : IOSTATE_TX_INIT_DATA;
> +		if (conn->tx_iostate != IOSTATE_TX_INIT_HDIGEST)
> +			break;
> +	case IOSTATE_TX_INIT_HDIGEST:
> +		crc = ~0;
> +		crc = crc32c(crc, &conn->rsp.bhs, BHS_SIZE);
> +		*(uint32_t *)conn->tx_digest = ~__cpu_to_le32(crc);
> +		conn->tx_iostate = IOSTATE_TX_HDIGEST;
> +		conn->tx_buffer = conn->tx_digest;
> +		conn->tx_size = sizeof(conn->tx_digest);
> +	case IOSTATE_TX_HDIGEST:
> +		ret = do_send(fd, conn, IOSTATE_TX_INIT_DATA);
> +		if (ret < 0)
> +			break;
> +	case IOSTATE_TX_INIT_DATA:
> +		if (conn->rsp.datasize) {
> +			int pad;
> +
> +			conn->tx_iostate = IOSTATE_TX_DATA;
> +			conn->tx_buffer = conn->rsp.data;
> +			conn->tx_size = conn->rsp.datasize;
> +			pad = conn->tx_size & (PAD_WORD_LEN - 1);
> +			if (pad) {
> +				pad = PAD_WORD_LEN - pad;
> +				memset(conn->tx_buffer + conn->tx_size, 0, pad);
> +				conn->tx_size += pad;
>  			}
> +		} else
> +			conn->tx_iostate = IOSTATE_TX_END;
> +		if (conn->tx_iostate != IOSTATE_TX_DATA)
>  			break;
> -		}
> -
> +	case IOSTATE_TX_DATA:
> +		ret = do_send(fd, conn, ddigest ?
> +			      IOSTATE_TX_INIT_DDIGEST : IOSTATE_TX_END);
> +		if (ret < 0)
> +			return;
> +		if (conn->tx_iostate != IOSTATE_TX_INIT_DDIGEST)
> +			break;
> +	case IOSTATE_TX_INIT_DDIGEST:
> +		crc = ~0;
> +		crc = crc32c(crc, conn->rsp.data,
> +			     roundup(conn->rsp.datasize, 4));
> +		*(uint32_t *)conn->tx_digest = ~__cpu_to_le32(crc);
> +		conn->tx_iostate = IOSTATE_TX_DDIGEST;
> +		conn->tx_buffer = conn->tx_digest;
> +		conn->tx_size = sizeof(conn->tx_digest);
> +	case IOSTATE_TX_DDIGEST:
> +		ret = do_send(fd, conn, IOSTATE_TX_END);
>  		break;
>  	default:
> -		eprintf("illegal iostate %d %d\n", conn->tx_iostate,
> -			conn->tx_iostate);
> -		conn->state = STATE_CLOSE;
> +		eprintf("error %d %d\n", conn->state, conn->tx_iostate);
> +		exit(1);
>  	}
>  
> +	if (ret < 0 ||
> +	    conn->tx_iostate != IOSTATE_TX_END ||
> +	    conn->state == STATE_CLOSE)
> +		return;
> +
> +	if (conn->tx_size) {
> +		eprintf("error %d %d %d\n", conn->state, conn->tx_iostate,
> +			conn->tx_size);
> +		exit(1);
> +	}
> +
> +	conn->tp->ep_write_end(fd);
> +	cmnd_finish(conn);
> +
> +	switch (conn->state) {
> +	case STATE_KERNEL:
> +		ret = conn_take_fd(conn, fd);
> +		if (ret)
> +			conn->state = STATE_CLOSE;
> +		else {
> +			conn->state = STATE_SCSI;
> +			conn_read_pdu(conn);
> +			tgt_event_modify(fd, EPOLLIN);
> +		}
> +		break;
> +	case STATE_EXIT:
> +	case STATE_CLOSE:
> +		break;
> +	case STATE_SCSI:
> +		iscsi_task_tx_done(conn);
> +		break;
> +	default:
> +		conn_read_pdu(conn);
> +		tgt_event_modify(fd, EPOLLIN);
> +		break;
> +	}
>  }
>  
>  void iscsi_event_handler(int fd, int events, void *data)
> @@ -1838,8 +2024,10 @@ void iscsi_event_handler(int fd, int eve
>  	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
>  		iscsi_tx_handler(fd, conn);
>  
> -	if (conn->state == STATE_CLOSE)
> +	if (conn->state == STATE_CLOSE) {
>  		conn_close(conn, fd);
> +		dprintf("connection closed\n");
> +	}
>  }
>  
>  struct tgt_driver iscsi = {
> diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
> index 84d74f3..29abc5d 100644
> --- a/usr/iscsi/iscsid.h
> +++ b/usr/iscsi/iscsid.h
> @@ -174,6 +174,9 @@ struct iscsi_connection {
>  
>  	struct list_head tx_clist;
>  
> +	unsigned char rx_digest[4];
> +	unsigned char tx_digest[4];
> +
>  	int auth_state;
>  	union {
>  		struct {
> @@ -187,13 +190,6 @@ struct iscsi_connection {
>  	struct iscsi_transport *tp;
>  };
>  
> -#define IOSTATE_FREE		0
> -#define IOSTATE_READ_BHS	1
> -#define IOSTATE_READ_AHS_DATA	2
> -#define IOSTATE_WRITE_BHS	3
> -#define IOSTATE_WRITE_AHS	4
> -#define IOSTATE_WRITE_DATA	5
> -
>  #define STATE_FREE		0
>  #define STATE_SECURITY		1
>  #define STATE_SECURITY_AUTH	2
> @@ -263,14 +259,13 @@ extern void conn_put(struct iscsi_connec
>  extern int conn_get(struct iscsi_connection *conn);
>  extern struct iscsi_connection * conn_find(struct iscsi_session *session, uint32_t cid);
>  extern int conn_take_fd(struct iscsi_connection *conn, int fd);
> -extern void conn_read_pdu(struct iscsi_connection *conn);
> -extern void conn_write_pdu(struct iscsi_connection *conn);
>  extern void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_session *session);
>  
>  /* iscsid.c */
>  extern void iscsi_event_handler(int fd, int events, void *data);
>  extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
>  extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
> +extern void conn_read_pdu(struct iscsi_connection *conn);
>  
>  /* iscsid.c iscsi_task */
>  extern void iscsi_free_task(struct iscsi_task *task);
> 
> 



From markh794 at gmail.com  Fri Apr 27 03:10:15 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 27 Apr 2007 11:10:15 +1000
Subject: [Stgt-devel] vtl take 3
Message-ID: <f29db9a80704261810m7fd81f9ct25748bbe6503c3fe@mail.gmail.com>

Post #3 of vtl patch against current scsi target git head..
 - Sorry - it is an attachment due to patch size (80k)

Updated smc module to use 'kernel style param parser' parser.c
 - ssc module is still to be updated.

Moved common 'scsi_sn' & 'scsi_id' from target.c to spc.c
 - To me, the processing of module 'params' should be handled in each module.
 - sbc / mmc both call the common (original code in target.c) routine
in spc.c. While this is not a 'SCSI Primary Command', I chose this as
the 'best fit' place for the common routine.


smc improvements since last post:
 - Configure slots & ability to add 'media' (or at least assign a
barcode to the slot location)
 - mode sense pages.

tgt-setup in the / directory is my 'pre-canned' script to test.

What next:
- Over the next few days I should have enough of the smc coded which
will allow utility 'mtx' to move media between slots / drives.
- Then it will be onto the ssc module.

Log sense pages still to be implemented. Current code in this patch
for LOG SENSE/SELECT is just a place holder.

Cheers
Mark
-------------- next part --------------
A non-text attachment was scrubbed...
Name: vtl.diff
Type: application/octet-stream
Size: 80151 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070427/a3eb7c8a/attachment.obj>

