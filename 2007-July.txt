From fujita.tomonori at lab.ntt.co.jp  Tue Jul  3 01:57:28 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 03 Jul 2007 08:57:28 +0900
Subject: [Stgt-devel] iSCSI digest offload
In-Reply-To: <4685093C.1040008@solarflare.com>
References: <4685093C.1040008@solarflare.com>
Message-ID: <20070703085728Q.fujita.tomonori@lab.ntt.co.jp>

From: Greg Law <glaw at solarflare.com>
Subject: [Stgt-devel] iSCSI digest offload
Date: Fri, 29 Jun 2007 14:29:32 +0100

> My company, Solarflare, makes 10gig NICs.  We don't do full TCP offload, 
> but we do have support on the card for iSCSI digest offload. Essentially 
> this means that if your packets are conveniently formatted, you can have 
> iSCSI digests with a very small performance penalty (in terms of both 
> throughput and CPU hit).  I say "if your packets are conveniently 
> formatted" because the NIC can only offload the digest if an Ethernet 
> frame contains exactly one iSCSI PDU in exactly one TCP segment. 
> However, providing you use a MaxRecvDataSegmentLength of <= MSS (less 
> headers) our experiments show this is almost always the case.
> 
> We've implemented our own iSCSI initiator stack on Linux as a 
> proof-of-concept, and it gives the performance wins we'd hoped for.  Now 
> we want to patch the open-source stacks (target and initiator) to take 
> advantage of this feature.  We will also need to patch the Linux TCP 
> stack so that (a) we can pass meta data down (to tell the NIC to compute 
> and insert digests on tx) and pass meta data back up (to tell the iSCSI 
> stack whether the digests computed ok on rx); and (b) to make sure we 
> can handle edge-cases such as routing changes etc.
> 
> We expect the patch to be quite small - both the TCP and iSCSI parts. We 
> plan to do the target first, and follow up with the initiator.
> 
> I'd be really interested to hear the list's views on this.  Have you 
> heard of anything similar before?  Does it sound like a patch that you 
> might be interested in merging (of course, I'm not looking for a 
> definitive answer here, just a "could be interesting, providing ....".)
> 
> Also, do the tgt and open-iscsi share any code for the iSCSI protocol 
> processing?  If not, are there any plans to do so?

tgt's iscsi code runs in user space unlike IET.

I tried to convert open-iscsi code (libiscsi and the transport class)
to work for the target mode (you can find the patchset in linux-scsi
mailing list) and wrote the target mode code for it. But the mainline
people don't want iSCSI target code in kernel space.

We can put some iSCSI target code for some iSCSI hardware like qla4xxx
(which can process iSCSI protocol fully or partially). But if your
hardware can offload only iSCSI digests only when packets are
conveniently formatted, we must put full-iscsi-target processing code
in kernel. I tried it twice with IET and tgt, and both failed.


From markh794 at gmail.com  Wed Jul  4 09:39:24 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 04 Jul 2007 17:39:24 +1000
Subject: [Stgt-devel] [Patch 1/1] Merge sense_codes.h into scsi.h
Message-ID: <468B4EAC.6010306@gmail.com>

>From a63a1fbcaa2b183a539fc50037d0bdea80f49c02 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Wed, 4 Jul 2007 17:32:42 +1000
Subject: Merge sense_codes.h into scsi.h

Realised many of the defines are duplicated between the two files anyway.

Corrected aggressive global search/replace
s/E_/ASC_/g which also changed entries like
DRIVE_REQUIRES => DRIVASC_REQUIRES

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/bs_sync.c       |    1 -
 usr/ibmvio/ibmvio.c |    2 +-
 usr/mmc.c           |    1 -
 usr/osd.c           |    1 -
 usr/sbc.c           |    1 -
 usr/scsi.h          |   72 +++++++++++++++++++++++++++++++++++
 usr/sense_codes.h   |  103 ---------------------------------------------------
 usr/spc.c           |    1 -
 usr/spt.c           |    1 -
 9 files changed, 73 insertions(+), 110 deletions(-)

diff --git a/usr/bs_sync.c b/usr/bs_sync.c
index 4986c59..e0c77cb 100644
--- a/usr/bs_sync.c
+++ b/usr/bs_sync.c
@@ -37,7 +37,6 @@
 #include "util.h"
 #include "tgtd.h"
 #include "scsi.h"
-#include "sense_codes.h"
 
 #define NR_WORKER_THREADS	4
 
diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index 8cfc8d6..cdd3782 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -44,7 +44,7 @@
 #include "target.h"
 #include "driver.h"
 #include "spc.h"
-#include "sense_codes.h"
+#include "scsi.h"
 
 #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
 #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
diff --git a/usr/mmc.c b/usr/mmc.c
index defe60b..9f8559f 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -41,7 +41,6 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
-#include "sense_codes.h"
 
 #define MMC_BLK_SHIFT 11
 
diff --git a/usr/osd.c b/usr/osd.c
index 048d0c8..ff138aa 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -33,7 +33,6 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
-#include "sense_codes.h"
 
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 {
diff --git a/usr/sbc.c b/usr/sbc.c
index a62e6d8..51c48da 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -38,7 +38,6 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
-#include "sense_codes.h"
 
 #define BLK_SHIFT	9
 
diff --git a/usr/scsi.h b/usr/scsi.h
index 9ef4a0c..425fcff 100644
--- a/usr/scsi.h
+++ b/usr/scsi.h
@@ -146,4 +146,76 @@
 #define TASK_ABORTED         0x20
 #define SAM_STAT_TASK_ABORTED    0x40
 
+/* Key 0: No Sense Errors */
+#define NO_ADDITIONAL_SENSE			0x0000
+#define ASC_MARK				0x0001
+#define ASC_EOM					0x0002
+#define ASC_BOM					0x0004
+#define ASC_END_OF_DATA				0x0005
+#define ASC_OP_IN_PROGRESS			0x0016
+#define ASC_DRIVE_REQUIRES_CLEANING		0x8282
+
+/* Key 1: Recovered Errors */
+#define ASC_WRITE_ERROR				0x0c00
+#define ASC_READ_ERROR				0x1100
+#define ASC_RECOVERED_WITH_RETRYS		0x1701
+#define ASC_MEDIA_LOAD_EJECT_ERROR		0x5300
+#define ASC_FAILURE_PREDICTION			0x5d00
+
+/* Key 2: Not ready */
+#define ASC_CAUSE_NOT_REPORTABLE		0x0400
+#define ASC_BECOMING_READY			0x0401
+#define ASC_INITIALIZING_REQUIRED		0x0402
+#define ASC_CLEANING_CART_INSTALLED		0x3003
+#define ASC_CLEANING_FAILURE			0x3007
+#define ASC_MEDIUM_NOT_PRESENT			0x3a00
+#define ASC_LOGICAL_UNIT_NOT_CONFIG		0x3e00
+
+/* Key 3: Medium Errors */
+#define ASC_WRITE_ERROR				0x0c00
+#define ASC_UNRECOVERED_READ			0x1100
+#define ASC_RECORDED_ENTITY_NOT_FOUND		0x1400
+#define ASC_UNKNOWN_FORMAT			0x3001
+#define ASC_IMCOMPATIBLE_FORMAT			0x3002
+#define ASC_MEDIUM_FORMAT_CORRUPT		0x3100
+#define ASC_SEQUENTIAL_POSITION_ERR		0x3b00
+#define ASC_WRITE_APPEND_ERR			0x5000
+#define ASC_CARTRIDGE_FAULT			0x5200
+#define ASC_MEDIA_LOAD_OR_EJECT_FAILED		0x5300
+
+/* Key 4: Hardware Failure */
+#define ASC_COMPRESSION_CHECK			0x0c04
+#define ASC_DECOMPRESSION_CRC			0x110d
+#define ASC_MECHANICAL_POSITIONING_ERROR	0x1501
+#define ASC_MANUAL_INTERVENTION_REQ		0x0403
+#define ASC_HARDWARE_FAILURE			0x4000
+#define ASC_INTERNAL_TGT_FAILURE		0x4400
+#define ASC_ERASE_FAILURE			0x5100
+
+/* Key 5: Illegal Request */
+#define ASC_PARAMETER_LIST_LENGTH_ERR		0x1a00
+#define ASC_INVALID_OP_CODE			0x2000
+#define ASC_INVALID_FIELD_IN_CDB		0x2400
+#define ASC_LUN_NOT_SUPPORTED			0x2500
+#define ASC_INVALID_FIELD_IN_PARMS		0x2600
+#define ASC_SAVING_PARMS_UNSUP			0x3900
+#define ASC_MEDIUM_DEST_FULL			0x3b0d
+#define ASC_MEDIUM_SRC_EMPTY			0x3b0e
+#define ASC_POSITION_PAST_BOM			0x3b0c
+#define ASC_MEDIUM_REMOVAL_PREVENTED		0x5302
+#define ASC_BAD_MICROCODE_DETECTED		0x8283
+
+/* Key 6: Unit Attention */
+#define ASC_NOT_READY_TO_TRANSITION		0x2800
+#define ASC_POWERON_RESET			0x2900
+#define ASC_MODE_PARAMETERS_CHANGED		0x2a01
+#define ASC_INSUFFICIENT_TIME_FOR_OPERATION	0x2e00
+#define ASC_MICROCODE_DOWNLOADED		0x3f01
+#define ASC_FAILURE_PREDICTION_FALSE		0x5dff
+#define ASC_INQUIRY_DATA_HAS_CHANGED		0x3f03
+
+/* Data Protect */
+#define ASC_WRITE_PROTECT			0x2700
+#define ASC_MEDIUM_OVERWRITE_ATTEMPTED		0x300c
+
 #endif
diff --git a/usr/sense_codes.h b/usr/sense_codes.h
deleted file mode 100644
index 60a877c..0000000
--- a/usr/sense_codes.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * The SCSI sense key Additional Sense Code / Additional Sense Code Qualifier
- *
- * Copyright (C) 2007 Mark Harvey <markh794 at gmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/*
- * SENSE keys
- */
-#define NO_SENSE			0x00
-#define	RECOVERED_ERROR			0x01
-#define NOT_READY			0x02
-#define MEDIUM_ERROR			0x03
-#define	HARDWARE_ERROR			0x04
-#define ILLEGAL_REQUEST			0x05
-#define UNIT_ATTENTION			0x06
-#define DATA_PROTECT			0x07
-#define	BLANK_CHECK			0x08
-
-/* Key 0: No Sense Errors */
-#define NO_ADDITIONAL_SENSE			0x0000
-#define ASC_MARK				0x0001
-#define ASC_EOM					0x0002
-#define ASC_BOM					0x0004
-#define ASC_END_OF_DATA				0x0005
-#define ASC_OP_IN_PROGRESS			0x0016
-#define ASC_DRIVASC_REQUIRES_CLEANING		0x8282
-
-/* Key 1: Recovered Errors */
-#define ASC_WRITASC_ERROR			0x0c00
-#define ASC_READ_ERROR				0x1100
-#define ASC_RECOVERED_WITH_RETRYS		0x1701
-#define ASC_MEDIA_LOAD_EJECT_ERROR		0x5300
-#define ASC_FAILURASC_PREDICTION		0x5d00
-
-/* Key 2: Not ready */
-#define ASC_CAUSASC_NOT_REPORTABLE		0x0400
-#define ASC_BECOMING_READY			0x0401
-#define ASC_INITIALIZING_REQUIRED		0x0402
-#define ASC_CLEANING_CART_INSTALLED		0x3003
-#define ASC_CLEANING_FAILURE			0x3007
-#define ASC_MEDIUM_NOT_PRESENT			0x3a00
-#define ASC_LOGICAL_UNIT_NOT_CONFIG		0x3e00
-
-/* Key 3: Medium Errors */
-#define ASC_WRITE_ERROR			0x0c00
-#define ASC_UNRECOVERED_READ			0x1100
-#define ASC_RECORDED_ENTITY_NOT_FOUND		0x1400
-#define ASC_UNKNOWN_FORMAT			0x3001
-#define ASC_IMCOMPATIBLE_FORMAT		0x3002
-#define ASC_MEDIUM_FORMAT_CORRUPT		0x3100
-#define ASC_SEQUENTIAL_POSITION_ERR		0x3b00
-#define ASC_WRITE_APPEND_ERR			0x5000
-#define ASC_CARTRIDGE_FAULT			0x5200
-#define ASC_MEDIA_LOAD_OR_EJECT_FAILED		0x5300
-
-/* Key 4: Hardware Failure */
-#define ASC_COMPRESSION_CHECK			0x0c04
-#define ASC_DECOMPRESSION_CRC			0x110d
-#define ASC_MECHANICAL_POSITIONING_ERROR	0x1501
-#define ASC_MANUAL_INTERVENTION_REQ		0x0403
-#define ASC_HARDWARE_FAILURE			0x4000
-#define ASC_INTERNAL_TGT_FAILURE		0x4400
-#define ASC_ERASE_FAILURE			0x5100
-
-/* Key 5: Illegal Request */
-#define ASC_PARAMETER_LIST_LENGTH_ERR		0x1a00
-#define ASC_INVALID_OP_CODE			0x2000
-#define ASC_INVALID_FIELD_IN_CDB		0x2400
-#define ASC_LUN_NOT_SUPPORTED			0x2500
-#define ASC_INVALID_FIELD_IN_PARMS		0x2600
-#define ASC_SAVING_PARMS_UNSUP			0x3900
-#define ASC_MEDIUM_DEST_FULL			0x3b0d
-#define ASC_MEDIUM_SRC_EMPTY			0x3b0e
-#define ASC_POSITION_PAST_BOM			0x3b0c
-#define ASC_MEDIUM_REMOVAL_PREVENTED		0x5302
-#define ASC_BAD_MICROCODE_DETECTED		0x8283
-
-/* Key 6: Unit Attention */
-#define ASC_NOT_READY_TO_TRANSITION		0x2800
-#define ASC_POWERON_RESET			0x2900
-#define ASC_MODE_PARAMETERS_CHANGED		0x2a01
-#define ASC_INSUFFICIENT_TIME_FOR_OPERATION	0x2e00
-#define ASC_MICROCODE_DOWNLOADED		0x3f01
-#define ASC_FAILURE_PREDICTION_FALSE		0x5dff
-#define ASC_INQUIRY_DATA_HAS_CHANGED		0x3f03
-
-/* Data Protect */
-#define ASC_WRITE_PROTECT			0x2700
-#define ASC_MEDIUM_OVERWRITE_ATTEMPTED		0x300c
diff --git a/usr/spc.c b/usr/spc.c
index 6560e98..1997329 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -34,7 +34,6 @@
 #include "tgtadm_error.h"
 #include "scsi.h"
 #include "spc.h"
-#include "sense_codes.h"
 
 #define PRODUCT_REV	"0"
 #define BLK_SHIFT	9
diff --git a/usr/spt.c b/usr/spt.c
index 9115d7f..6ad36f8 100644
--- a/usr/spt.c
+++ b/usr/spt.c
@@ -40,7 +40,6 @@
 #include "target.h"
 #include "scsi.h"
 #include "spc.h"
-#include "sense_codes.h"
 
 extern int spt_sg_open(struct scsi_lu *lu, char *path, int *fd, uint64_t *size);
 extern int spt_sg_perform(struct scsi_cmd *cmd);
-- 
1.5.2.1








From markh794 at gmail.com  Wed Jul  4 10:15:23 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 04 Jul 2007 18:15:23 +1000
Subject: [Stgt-devel] [Patch 1/1] Merge sense_codes.h into scsi.h
Message-ID: <468B571B.2080903@gmail.com>

Forgot to add:

This is based on latest git commit 035bbdf457a4201355466a90d00968113ad961a5.

   ========================================
commit 035bbdf457a4201355466a90d00968113ad961a5
Author: Mark Harvey <markh794 at gmail.com>
Date:   Fri Jun 29 09:32:51 2007 +0900

    use nmemonic representation for ASC/ASCQ as a 16bit value
   
    - Values defined in sense_codes.h
    - Updated sense_data_build() to accept a single 16bit combined
    asc/ascq value.
   
    Signed-off-by: Mark Harvey <markh794 at gmail.com>
    Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>

   ========================================


I will need to re-do the previous two patches submitted last week 
against this patch.

I'll hold off until this is applied.


Cheers
Mark



From fujita.tomonori at lab.ntt.co.jp  Wed Jul  4 11:52:42 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 04 Jul 2007 18:52:42 +0900
Subject: [Stgt-devel] [Patch 1/1] Merge sense_codes.h into scsi.h
In-Reply-To: <468B4EAC.6010306@gmail.com>
References: <468B4EAC.6010306@gmail.com>
Message-ID: <20070704185242B.fujita.tomonori@lab.ntt.co.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 1/1] Merge sense_codes.h into scsi.h
Date: Wed, 04 Jul 2007 17:39:24 +1000

> >From a63a1fbcaa2b183a539fc50037d0bdea80f49c02 Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Wed, 4 Jul 2007 17:32:42 +1000
> Subject: Merge sense_codes.h into scsi.h
> 
> Realised many of the defines are duplicated between the two files anyway.
> 
> Corrected aggressive global search/replace
> s/E_/ASC_/g which also changed entries like
> DRIVE_REQUIRES => DRIVASC_REQUIRES
> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Thu Jul  5 14:59:17 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 05 Jul 2007 21:59:17 +0900
Subject: [Stgt-devel] [Patch 1/2] Add MODE SENSE (6) & MODE SENSE
	(10)	support
In-Reply-To: <46860A7E.8040800@gmail.com>
References: <46860A7E.8040800@gmail.com>
Message-ID: <200707051259.l65CxHhw025562@mbox.iij4u.or.jp>

Thanks a lot and sorry for the delay.

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 1/2] Add MODE SENSE (6) & MODE SENSE (10)	support
Date: Sat, 30 Jun 2007 17:47:10 +1000

> >From 4afa975c190c87fab099f52bcd95cafa608fcf96 Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Sat, 30 Jun 2007 16:56:19 +1000
> Subject: Initial commit of Dynamic MODE SENSE support
> 
> Add support for:
>  - MODE SENSE (6)
>  - MODE SENSE (10)
> 
> Add ability to add mode pages 'on the fly'. i.e. At setup time.
> 
> Configuration/creation of mode pages via the 'tgtadm --params mode_page'
> 
> Page data information is seperated by ':'
> e.g.
>  --params mode_page=10:1:11:2:0:0:0:0:0:0:0:2:0:0
> Where '10' is mode page 10
>       '1'  is the subpage
>       '11' is the length of the page data (11 bytes of information follow)

I keep this format but is the length necessary?


> SBC & MMC devices set up some default pages at lu creation time.
> 
> The example script 'scripts/tgt-core-test' contains an executable example.
> 
> The 'doc/README.lu_configuration' updated for mode page informaiton.
> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>

I simplified the code slightly. I'll apply this if it works for you.


diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
index 1244bc0..d63668a 100644
--- a/doc/README.lu_configuration
+++ b/doc/README.lu_configuration
@@ -65,5 +65,25 @@ standard INQUIRY:
 As can be seen from above 'sg_inq' output, the RMB (removable) bit is set to 1.
 The Unit serial number page updated with 'FRED00'
 
+Mode Page Creation
+------------------
+Create mode page '2', subpage 0 and 14 bytes of data.
+tgtadm --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+
+Create mode page '3', subpage 0 and 22 bytes of data.
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
+
+Create mode page '10', subpage 0 and 10 bytes of data.
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
+
+Create mode page '0x1c', subpage 0 and 10 bytes of data.
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+
+
+
 Please refer to scripts/tgt-core-test for a working example.
 
diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
index a90fc9d..a31be1b 100755
--- a/scripts/tgt-core-test
+++ b/scripts/tgt-core-test
@@ -3,6 +3,7 @@ #!/bin/bash
 # Parent directory for data files..
 HOME=/d/01
 
+# Start tgtd if not running..
 P=`ps -ef|grep -v grep|grep tgtd|wc -l`
 if [ "X"$P == "X0" ]; then
 	tgtd -d 1
@@ -35,7 +36,7 @@ TID=1
 
 # Create Target ID 1..
 tgtadm --lld iscsi --mode target --op new --tid $TID \
-		-T iqn.2007-03:marks-vtl_sbc:`hostname`
+		-T iqn.2007-03:marks-vtl_tgt:`hostname`
 sleep 1
 
 # Create first LUN - Disk
@@ -48,23 +49,58 @@ tgtadm --lld iscsi --mode logicalunit --
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 	--params vendor_id=QUANTUM,product_id=HD100,product_rev=0010,removable=1,sense_format=0
 
-# Create 2nd LUN - CD/ROM
-LUN=2
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
+#### Set up mode pages ####
+# First try a couple of attempts with incorrect data..
+# i.e. Expect the first two to fail!
+# - Length too long & Incorrect value (300) as one if the params...
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY11,removable=1
-
-# Create 3rd LUN - CD/ROM
-LUN=3
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:300:0:0:0:0:0:0:0:0:3
+# - Length too short...
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY12,removable=1
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0
+#
+# From here on - should work OK..
+#
 
-# Create 4th LUN - CD/ROM
-LUN=4
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
+# Vendor Uniq - Mode page 0..
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0:0:0
+# Disconnect page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+# Format mode page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
+# Geo mode page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=4:0:22:0:0:0:0x40:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0x3a:0x98:0:0
+# Caching Page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=8:0:18:0x14:0:0xff:0xff:0:0:0xff:0xff:0xff:0xff:0x80:0x14:0:0:0:0:0:0
+# ctrl mode page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
+# Informational Exceptions Control Mode Page
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY13,removable=1
+	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+
+
+
+for LUN in 2 3 4; do
+	# Create LUN - CD/ROM
+	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY1$LUN,removable=1
+	# Vendor Uniq - Mode page 0..
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params mode_page=0:0:0
+	# ctrl mode page
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
+	# Informational Exceptions Control Mode Page
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+done
 
 # Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
diff --git a/usr/mmc.c b/usr/mmc.c
index 9f8559f..0390bdb 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -41,6 +41,7 @@ #include "target.h"
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "tgtadm_error.h"
 
 #define MMC_BLK_SHIFT 11
 
@@ -121,10 +122,19 @@ static int mmc_read_capacity(int host_no
 	return SAM_STAT_GOOD;
 }
 
+static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)
+{
+	uint8_t *scb = cmd->scb;
+
+	/* MMC devices always return descriptor block */
+	scb[1] |= 8;
+	return spc_mode_sense(host_no, cmd);
+}
+
 static int mmc_lu_init(struct scsi_lu *lu)
 {
 	if (spc_lu_init(lu))
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "VIRTUAL-CDROM", sizeof(lu->attrs.product_id));
 	lu->attrs.sense_format = 0;
@@ -132,6 +142,33 @@ static int mmc_lu_init(struct scsi_lu *l
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
 	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
+	/*
+	 * Set up default mode pages
+	 * Ref: mmc6r00.pdf 7.2.2 (Table 649)
+	 */
+
+	/* Vendor uniq - However most apps seem to call for mode page 0*/
+	add_mode_page(lu, "0:0:0");
+	/* Read/Write Error Recovery */
+	add_mode_page(lu, "1:0:10:0:8:0:0:0:0:8:0:0:0");
+	/* MRW */
+	add_mode_page(lu, "3:0:6:0:0:0:0:0:0");
+	/* Write Parameter
+	 * Somebody who knows more about this mode page should be setting
+	 * defaults.
+	add_mode_page(lu, "5:0:0");
+	 */
+	/* Caching Page */
+	add_mode_page(lu, "8:0:10:0:0:0:0:0:0:0:0:0:0");
+	/* Control page */
+	add_mode_page(lu, "10:0:10:2:0:0:0:0:0:0:0:2:0");
+	/* Power Condition */
+	add_mode_page(lu, "0x1a:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Informational Exceptions Control page */
+	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Timeout & Protect */
+	add_mode_page(lu, "0x1d:0:10:0:0:7:0:0:2:0:2:0:20");
+
 	return 0;
 }
 
@@ -217,7 +254,26 @@ static struct device_type_template mmc_t
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 
-		[0x50 ... 0x9f] = {spc_illegal_op,},
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{mmc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x9f] = {spc_illegal_op,},
 
 		/* 0xA0 */
 		{spc_report_luns,},
diff --git a/usr/osd.c b/usr/osd.c
index ff138aa..2bd33e6 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -33,6 +33,7 @@ #include "target.h"
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "tgtadm_error.h"
 
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 {
@@ -52,7 +53,7 @@ static int osd_varlen_cdb(int host_no, s
 static int osd_lu_init(struct scsi_lu *lu)
 {
 	if (spc_lu_init(lu))
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "OSD", sizeof(lu->attrs.product_id));
 	lu->attrs.sense_format = 1;
diff --git a/usr/sbc.c b/usr/sbc.c
index 51c48da..d285207 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -38,6 +38,7 @@ #include "target.h"
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "tgtadm_error.h"
 
 #define BLK_SHIFT	9
 
@@ -168,154 +169,43 @@ sense:
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int insert_disconnect_pg(uint8_t *ptr)
-{
-	unsigned char disconnect_pg[] = {0x02, 0x0e, 0x80, 0x80, 0x00, 0x0a, 0x00, 0x00,
-                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, disconnect_pg, sizeof(disconnect_pg));
-	return sizeof(disconnect_pg);
-}
-
-static int insert_caching_pg(uint8_t *ptr)
-{
-	unsigned char caching_pg[] = {0x08, 0x12, 0x14, 0x00, 0xff, 0xff, 0x00, 0x00,
-				      0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0x00, 0x00,
-				      0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, caching_pg, sizeof(caching_pg));
-	return sizeof(caching_pg);
-}
-
-static int insert_ctrl_m_pg(uint8_t *ptr)
-{
-	unsigned char ctrl_m_pg[] = {0x0a, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
-				     0x00, 0x00, 0x02, 0x4b};
-
-	memcpy(ptr, ctrl_m_pg, sizeof(ctrl_m_pg));
-	return sizeof(ctrl_m_pg);
-}
-
-static int insert_iec_m_pg(uint8_t *ptr)
-{
-	unsigned char iec_m_pg[] = {0x1c, 0xa, 0x08, 0x00, 0x00, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, iec_m_pg, sizeof(iec_m_pg));
-	return sizeof(iec_m_pg);
-}
-
-static int insert_format_m_pg(uint8_t *ptr)
-{
-	unsigned char format_m_pg[] = {0x03, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-				       0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
-				       0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00};
-	memcpy(ptr, format_m_pg, sizeof(format_m_pg));
-	return sizeof(format_m_pg);
-}
-
-static int insert_geo_m_pg(uint8_t *ptr, uint64_t sec)
-{
-	unsigned char geo_m_pg[] = {0x04, 0x16, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x3a, 0x98, 0x00, 0x00};
-	uint32_t ncyl, *p;
-
-	/* assume 0xff heads, 15krpm. */
-	memcpy(ptr, geo_m_pg, sizeof(geo_m_pg));
-	ncyl = sec >> 14; /* 256 * 64 */
-	p = (uint32_t *)(ptr + 1);
-	*p = *p | __cpu_to_be32(ncyl);
-	return sizeof(geo_m_pg);
-}
-
-static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
+static int sbc_lu_init(struct scsi_lu *lu)
 {
-	int ret = SAM_STAT_GOOD, len;
-	uint8_t pcode = cmd->scb[2] & 0x3f;
 	uint64_t size;
-	uint8_t *data = NULL;
-	unsigned char key = ILLEGAL_REQUEST;
-	uint16_t asc = ASC_LUN_NOT_SUPPORTED;
+	uint8_t *data;
 
-	if (device_reserved(cmd))
-		return SAM_STAT_RESERVATION_CONFLICT;
-
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = ASC_INTERNAL_TGT_FAILURE;
-		goto sense;
-	}
-	memset(data, 0, pagesize);
-
-	len = 4;
-	size = cmd->dev->size >> BLK_SHIFT;
-
-	if ((cmd->scb[1] & 0x8))
-		data[3] = 0;
-	else {
-		data[3] = 8;
-		len += 8;
-		*(uint32_t *)(data + 4) = (size >> 32) ?
-			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
-		*(uint32_t *)(data + 8) = __cpu_to_be32(1 << BLK_SHIFT);
-	}
-
-	switch (pcode) {
-	case 0x0:
-		break;
-	case 0x2:
-		len += insert_disconnect_pg(data + len);
-		break;
-	case 0x3:
-		len += insert_format_m_pg(data + len);
-		break;
-	case 0x4:
-		len += insert_geo_m_pg(data + len, size);
-		break;
-	case 0x8:
-		len += insert_caching_pg(data + len);
-		break;
-	case 0xa:
-		len += insert_ctrl_m_pg(data + len);
-		break;
-	case 0x1c:
-		len += insert_iec_m_pg(data + len);
-		break;
-	case 0x3f:
-		len += insert_disconnect_pg(data + len);
-		len += insert_format_m_pg(data + len);
-		len += insert_geo_m_pg(data + len, size);
-		len += insert_caching_pg(data + len);
-		len += insert_ctrl_m_pg(data + len);
-		len += insert_iec_m_pg(data + len);
-		break;
-	default:
-		asc = ASC_INVALID_FIELD_IN_CDB;
-		goto sense;
-	}
-
-	data[0] = len - 1;
-	cmd->len = len;
-	cmd->uaddr = (unsigned long) data;
-	return ret;
-sense:
-	cmd->len = 0;
-	sense_data_build(cmd, key, asc);
-	return SAM_STAT_CHECK_CONDITION;
-}
-
-static int sbc_lu_init(struct scsi_lu *lu)
-{
 	if (spc_lu_init(lu))
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "VIRTUAL-DISK", sizeof(lu->attrs.product_id));
 	lu->attrs.version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
 	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
+	data = lu->mode_block_descriptor;
+	size = lu->size >> BLK_SHIFT;
+
+	*(uint32_t *)(data) = (size >> 32) ?
+			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
+	*(uint32_t *)(data + 4) = __cpu_to_be32(1 << BLK_SHIFT);
+
+	/* Vendor uniq - However most apps seem to call for mode page 0*/
+	add_mode_page(lu, "0:0:0");
+	/* Disconnect page */
+	add_mode_page(lu, "2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0");
+	/* Format page */
+	add_mode_page(lu, "3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0");
+	/* GEO page */
+	add_mode_page(lu, "4:0:22:0:0:0:0x40:0:0:0:0:0:"
+		      "0:0:0:0:0:0:0:0:0:0x3a:0x98:0:0");
+	/* Caching Page */
+	add_mode_page(lu, "8:0:18:0x14:0:0xff:0xff:0:0:"
+		      "0xff:0xff:0xff:0xff:0x80:0x14:0:0:0:0:0:0");
+	/* Control page */
+	add_mode_page(lu, "10:0:10:2:0:0:0:0:0:0:0:2:0");
+	/* Informational Exceptions Control page */
+	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
+
 	return 0;
 }
 
@@ -354,7 +244,7 @@ static struct device_type_template sbc_t
 
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_mode_sense,},
+		{spc_mode_sense,},
 		{spc_start_stop,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -399,7 +289,28 @@ static struct device_type_template sbc_t
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 
-		[0x40 ... 0x7f] = {spc_illegal_op,},
+		[0x40 ... 0x4f] = {spc_illegal_op,},
+
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x7f] = {spc_illegal_op,},
 
 		/* 0x80 */
 		{spc_illegal_op,},
diff --git a/usr/scc.c b/usr/scc.c
index 3b26a57..0a154a5 100644
--- a/usr/scc.c
+++ b/usr/scc.c
@@ -33,12 +33,13 @@ #include "tgtd.h"
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
+#include "tgtadm_error.h"
 #include "spc.h"
 
 static int scc_lu_init(struct scsi_lu *lu)
 {
 	if (spc_lu_init(lu))
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "Controller",
 		sizeof(lu->attrs.product_id));
diff --git a/usr/spc.c b/usr/spc.c
index 1997329..7711078 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -230,6 +230,112 @@ int spc_test_unit(int host_no, struct sc
 		return SAM_STAT_GOOD;
 }
 
+/*
+ * Copy mode page data from list into SCSI data so it can be returned
+ * to the initiator
+ *
+ * *data -> target address (destination)
+ * pg -> Pointer to mode page information (source)
+ *
+ * Returns number of bytes copied.
+ */
+static int build_mode_page(uint8_t *data, struct mode_pg *pg)
+{
+	uint8_t *p;
+	int len;
+
+	data[0] = pg->pcode;
+	len = pg->pcode_size;
+	data[1] = len;
+	p = &data[2];
+	len += 2;
+	memcpy(p, pg->mode_data, pg->pcode_size);
+
+	return len;
+}
+
+int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
+{
+	int len = 0;
+	uint8_t *data, *scb, mode6, dbd, pcode, subpcode;
+	uint16_t alloc_len;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+	struct mode_pg *pg;
+
+	/*
+	 * Reference : SPC4r11
+	 * 6.11 - MODE SENSE(6)
+	 * 6.12 - MODE SENSE(10)
+	 */
+
+	scb = cmd->scb;
+	mode6 = (scb[0] == 0x1a);
+	dbd = scb[1] & 0x8; /* Disable Block Descriptors */
+	pcode = scb[2] & 0x3f;
+	subpcode = scb[3];
+
+	/* Currently not implemented */
+	if (subpcode)
+		goto sense;
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	if (mode6) {
+		alloc_len = scb[4];
+		len = 4;
+	} else {
+		alloc_len = (scb[7] << 8) + scb[8];
+		len = 8;
+	}
+
+	if (alloc_len > pagesize)
+		goto sense;
+
+	if (!dbd) {
+		memcpy(data + len, cmd->dev->mode_block_descriptor,
+				BLOCK_DESCRIPTOR_LEN);
+		len += 8;
+	}
+
+	if (pcode == 0x3f) {
+		int i;
+		for (i = 0; i < ARRAY_SIZE(cmd->dev->mode_pgs); i++) {
+			pg = cmd->dev->mode_pgs[i];
+			if (pg)
+				len += build_mode_page(data + len, pg);
+		}
+	} else {
+		pg = cmd->dev->mode_pgs[pcode];
+		if (!pg)
+			goto sense;
+		len += build_mode_page(data + len, pg);
+	}
+
+	if (mode6) {
+		data[0] = len - 1;
+		data[3] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
+	} else {
+		*(uint16_t *)(data) = __cpu_to_be16(len - 3);
+		data[7] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
+	}
+
+	cmd->len = len;
+	cmd->uaddr = (unsigned long)data;
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
 int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
 	cmd->len = 0;
@@ -237,6 +343,81 @@ int spc_request_sense(int host_no, struc
 	return SAM_STAT_GOOD;
 }
 
+static struct mode_pg *alloc_mode_pg(uint8_t pcode, uint8_t subpcode,
+				     uint16_t size)
+{
+	struct mode_pg *pg;
+
+	pg = zalloc(sizeof(*pg) + size);
+	if (!pg)
+		return NULL;
+
+	pg->pcode = pcode;
+	pg->subpcode = subpcode;
+	pg->pcode_size = size;
+
+	return pg;
+}
+
+int add_mode_page(struct scsi_lu *lu, char *p)
+{
+	int i, tmp, ret = TGTADM_SUCCESS;
+	uint8_t pcode, subpcode, *data;
+	uint16_t size;
+	struct mode_pg *pg;
+
+	pcode = subpcode = i = size = 0;
+	data = NULL;
+
+	for (i = 0; p; i++) {
+		switch (i) {
+		case 0:
+			pcode = strtol(p, NULL, 0);
+			break;
+		case 1:
+			subpcode = strtol(p, NULL, 0);
+			break;
+		case 2:
+			size = strtol(p, NULL, 0);
+
+			if (lu->mode_pgs[pcode])
+				free(lu->mode_pgs[pcode]);
+
+			pg = alloc_mode_pg(pcode, subpcode, size);
+			if (!pg) {
+				ret = TGTADM_NOMEM;
+				goto exit;
+			}
+
+			lu->mode_pgs[pcode] = pg;
+			data = pg->mode_data;
+			break;
+		default:
+			if (i < (size + 3)) {
+				tmp = strtol(p, NULL, 0);
+				if (tmp > UINT8_MAX)
+					eprintf("Incorrect value %d "
+						"Mode page %d (0x%02x), index: %d\n",
+						tmp, pcode, subpcode, i - 3);
+				data[i - 3] = (uint8_t)tmp;
+			}
+			break;
+		}
+
+		p = strchr(p, ':');
+		if (p)
+			p++;
+	}
+
+	if (i != size + 3) {
+		ret = TGTADM_INVALID_REQUEST;
+		eprintf("Mode Page %d (0x%02x): param_count %d != "
+			"MODE PAGE size : %d\n", pcode, subpcode, i, size + 3);
+	}
+exit:
+	return ret;
+}
+
 void dump_cdb(struct scsi_cmd *cmd)
 {
 	uint8_t *cdb = cmd->scb;
@@ -282,6 +463,7 @@ enum {
 	Opt_vendor_id, Opt_product_id,
 	Opt_product_rev, Opt_sense_format,
 	Opt_removable, Opt_online,
+	Opt_mode_page,
 	Opt_err,
 };
 
@@ -294,13 +476,14 @@ static match_table_t tokens = {
 	{Opt_sense_format, "sense_format=%s"},
 	{Opt_removable, "removable=%s"},
 	{Opt_online, "online=%s"},
+	{Opt_mode_page, "mode_page=%s"},
 	{Opt_err, NULL},
 };
 
 int spc_lu_config(struct scsi_lu *lu, char *params) {
 	int err = 0;
 	char *p;
-	char buf[20];
+	char buf[256];
 
 	if (!strncmp("targetOps", params, 9))
 		params = params + 10;
@@ -344,6 +527,10 @@ int spc_lu_config(struct scsi_lu *lu, ch
 			match_strncpy(buf, &args[0],  sizeof(buf));
 			lu->attrs.online = atoi(buf);
 			break;
+		case Opt_mode_page:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			err = add_mode_page(lu, buf);
+			break;
 		default:
 			err = TGTADM_INVALID_REQUEST;
 		}
@@ -351,6 +538,11 @@ int spc_lu_config(struct scsi_lu *lu, ch
 	return err;
 }
 
+/*
+ * Set initial power-on defaults for lu
+ *
+ * Currently always return '0'
+ */
 int spc_lu_init(struct scsi_lu *lu)
 {
 	strncpy(lu->attrs.vendor_id, VENDOR_ID, sizeof(lu->attrs.vendor_id));
diff --git a/usr/spc.h b/usr/spc.h
index 1036b70..4b99268 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -10,5 +10,7 @@ extern int spc_illegal_op(int host_no, s
 extern int spc_lu_init(struct scsi_lu *lu);
 extern int spc_lu_config(struct scsi_lu *lu, char * params);
 extern void dump_cdb(struct scsi_cmd *cmd);
+extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
+extern int add_mode_page(struct scsi_lu *lu, char *params);
 
 #endif
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 8e66d60..1c1e3e2 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -5,6 +5,7 @@ #include "log.h"
 
 #define SCSI_ID_LEN	24
 #define SCSI_SN_LEN	8
+#define BLOCK_DESCRIPTOR_LEN 8
 #define VERSION_DESCRIPTOR_LEN 8
 
 #define VENDOR_ID	"IET"
@@ -75,6 +76,13 @@ struct backingstore_template {
 	int (*bs_cmd_done) (struct scsi_cmd *cmd);
 };
 
+struct mode_pg {
+	uint8_t pcode;		/* Page code */
+	uint8_t subpcode;	/* Sub page code */
+	int16_t pcode_size;	/* Size of page code data. */
+	uint8_t mode_data[0];	/* Rest of mode page info */
+};
+
 struct scsi_lu {
 	int fd;
 	uint64_t addr; /* persistent mapped address */
@@ -96,6 +104,9 @@ struct scsi_lu {
 
 	struct backingstore_template *bst;
 
+	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
+	struct mode_pg *mode_pgs[0x3f];
+
 	/* TODO: needs a structure for lots of device parameters */
 	struct lu_phy_attr attrs;
 };


From markh794 at gmail.com  Fri Jul  6 00:06:13 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 6 Jul 2007 08:06:13 +1000
Subject: [Stgt-devel] [Patch 1/2] Add MODE SENSE (6) & MODE SENSE (10)
	support
In-Reply-To: <200707051259.l65CxHhw025562@mbox.iij4u.or.jp>
References: <46860A7E.8040800@gmail.com>
	<200707051259.l65CxHhw025562@mbox.iij4u.or.jp>
Message-ID: <f29db9a80707051506j6a9e4f02qb8b28baf2fae433a@mail.gmail.com>

On 7/5/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> Thanks a lot and sorry for the delay.
>
> From: Mark Harvey <markh794 at gmail.com>
> Subject: [Stgt-devel] [Patch 1/2] Add MODE SENSE (6) & MODE SENSE (10)  support
> Date: Sat, 30 Jun 2007 17:47:10 +1000
>
> > >From 4afa975c190c87fab099f52bcd95cafa608fcf96 Mon Sep 17 00:00:00 2001
> > From: Mark Harvey <markh794 at gmail.com>
> > Date: Sat, 30 Jun 2007 16:56:19 +1000
> > Subject: Initial commit of Dynamic MODE SENSE support
> >
> > Add support for:
> >  - MODE SENSE (6)
> >  - MODE SENSE (10)
> >
> > Add ability to add mode pages 'on the fly'. i.e. At setup time.
> >
> > Configuration/creation of mode pages via the 'tgtadm --params mode_page'
> >
> > Page data information is seperated by ':'
> > e.g.
> >  --params mode_page=10:1:11:2:0:0:0:0:0:0:0:2:0:0
> > Where '10' is mode page 10
> >       '1'  is the subpage
> >       '11' is the length of the page data (11 bytes of information follow)
>
> I keep this format but is the length necessary?

I added the length for two reasons.
 - Simplicity in figuring out how much data was going to be saved &
returned via MODE SENSE.
 - Sanity check. Make sure the user entered the correct mode page
length & data to match..

It is not necessary, I just thought the sanity check was a valid reason for it.


> > SBC & MMC devices set up some default pages at lu creation time.
> >
> > The example script 'scripts/tgt-core-test' contains an executable example.
> >
> > The 'doc/README.lu_configuration' updated for mode page informaiton.
> >
> > Signed-off-by: Mark Harvey <markh794 at gmail.com>
>
> I simplified the code slightly. I'll apply this if it works for you.


ACK

It works for me.

Many thanks.
Mark


From fujita.tomonori at lab.ntt.co.jp  Fri Jul  6 01:57:42 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 06 Jul 2007 08:57:42 +0900
Subject: [Stgt-devel] [Patch 1/2] Add MODE SENSE (6) & MODE SENSE
	(10)	support
In-Reply-To: <f29db9a80707051506j6a9e4f02qb8b28baf2fae433a@mail.gmail.com>
References: <46860A7E.8040800@gmail.com>
	<200707051259.l65CxHhw025562@mbox.iij4u.or.jp>
	<f29db9a80707051506j6a9e4f02qb8b28baf2fae433a@mail.gmail.com>
Message-ID: <20070706085742G.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] [Patch 1/2] Add MODE SENSE (6) & MODE SENSE (10)	support
Date: Fri, 6 Jul 2007 08:06:13 +1000

> On 7/5/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > Thanks a lot and sorry for the delay.
> >
> > From: Mark Harvey <markh794 at gmail.com>
> > Subject: [Stgt-devel] [Patch 1/2] Add MODE SENSE (6) & MODE SENSE (10)  support
> > Date: Sat, 30 Jun 2007 17:47:10 +1000
> >
> > > >From 4afa975c190c87fab099f52bcd95cafa608fcf96 Mon Sep 17 00:00:00 2001
> > > From: Mark Harvey <markh794 at gmail.com>
> > > Date: Sat, 30 Jun 2007 16:56:19 +1000
> > > Subject: Initial commit of Dynamic MODE SENSE support
> > >
> > > Add support for:
> > >  - MODE SENSE (6)
> > >  - MODE SENSE (10)
> > >
> > > Add ability to add mode pages 'on the fly'. i.e. At setup time.
> > >
> > > Configuration/creation of mode pages via the 'tgtadm --params mode_page'
> > >
> > > Page data information is seperated by ':'
> > > e.g.
> > >  --params mode_page=10:1:11:2:0:0:0:0:0:0:0:2:0:0
> > > Where '10' is mode page 10
> > >       '1'  is the subpage
> > >       '11' is the length of the page data (11 bytes of information follow)
> >
> > I keep this format but is the length necessary?
> 
> I added the length for two reasons.
>  - Simplicity in figuring out how much data was going to be saved &
> returned via MODE SENSE.
>  - Sanity check. Make sure the user entered the correct mode page
> length & data to match..
> 
> It is not necessary, I just thought the sanity check was a valid reason for it.

The length check for the configuration via tgtadm is ok.

add_mode_page(struct scsi_lu *lu, char *p) looks odd. I think that we
would have something like:

int add_mode_page(struct scsi_lu *lu, uint16_t pcode, uint16_t
subpcode, uint16_t size, char *data)

But I'm ok with it for now.


> > > SBC & MMC devices set up some default pages at lu creation time.
> > >
> > > The example script 'scripts/tgt-core-test' contains an executable example.
> > >
> > > The 'doc/README.lu_configuration' updated for mode page informaiton.
> > >
> > > Signed-off-by: Mark Harvey <markh794 at gmail.com>
> >
> > I simplified the code slightly. I'll apply this if it works for you.
> 
> 
> ACK
> 
> It works for me.

Thanks, applied.


From markh794 at gmail.com  Fri Jul  6 10:22:06 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 06 Jul 2007 18:22:06 +1000
Subject: [Stgt-devel] [Patch 1/1] Add SCSI MEDIUM CHANGER support
Message-ID: <468DFBAE.9040409@gmail.com>


Re-work of initial SMC commit based on latest git head MODE PAGE commit.

This version includes the ability to load/unload media from the
DATA TRANSFER DEVICE at the configured TID/LUN address.

Update spc_test_unit() TEST UNIT READY op processing to 'understand'
online, Poweron/Reset and removable flags. i.e. Response from TUR
depends on the status of each of these flags.
 - If poweron_reset, return POWER-ON or RESET occurred, then clear flag.
 - If online - Return READY
 - If off-line and non-removable media - UNIT BECOMING READY
 - If off-line and removable media - MEDIUM NOT PRESENT

Online is when the backing file is open and ready for reading/writing.

To be done at at a later time:
Other SCSI op codes need to be aware of these flags.


As is, with the MMC device, this code will work as a working CD Jukebox (medium changer)


>From f76cecc5b8d14671fe523f50a854fd2102f51616 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Fri, 6 Jul 2007 18:03:58 +1000
Subject: Commit of SMC module

Add initial support of SCSI MEDIUM CHANGER module.

Includes all SCSI op codes defined as MANDATORY.

doc/README.lu_config updated with SMC spcific options.

scripts/tgt-core-test updated to create an SMC device.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 doc/README.lu_configuration |   47 +++
 scripts/tgt-core-test       |  104 +++++-
 usr/Makefile                |    5 +-
 usr/media.h                 |   28 ++
 usr/mmc.c                   |    1 +
 usr/osd.c                   |    2 +
 usr/sbc.c                   |    1 +
 usr/smc.c                   |  846 +++++++++++++++++++++++++++++++++++++++++++
 usr/smc.h                   |  121 ++++++
 usr/spc.c                   |   65 ++--
 usr/spc.h                   |    5 +-
 usr/target.c                |   62 ++++
 usr/tgtadm.c                |    2 +
 usr/tgtd.h                  |    7 +-
 14 files changed, 1255 insertions(+), 41 deletions(-)

diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
index d63668a..1e6327e 100644
--- a/doc/README.lu_configuration
+++ b/doc/README.lu_configuration
@@ -84,6 +84,53 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
          --params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 
 
+SMC unique options
+------------------
+
+--params have several unique key=value pairs ontop of all other modules.
+ - element_type=<1|2|3|4>
+ - start_address=Number between 1 & 65535
+ - quantity=Number between 1 & 65535
+ - sides=1|2
+ - address=Number between 1 & 65535
+ - barcode="Char string up to 10 chars"
+ - tid=<number>
+ - lun=<number>
+ - media_home=/path/to/virtual/media
+   The 'barcode' of media is appended to this path specified in media_home and
+   it is this file which is used for the backing store when reading/writing to
+   DATA TRANSFER DEVICE at address 'tid=x lun=x'
+
+Several of these parameters 'work together'
+
+e.g. To add 'quantity' slots as 'element_type' starting at 'start_address'
+ - element_type=<1|2|3|4>
+ - start_address=Number between 1 & 65535
+ - quantity=Number between 1 & 65535
+
+Note: start_address + quantity should not overlap with any other slots..
+
+
+While 'configuring slot 'address' of 'element_type':
+ - Set barcode of meda (occupy slot)
+ - If element type is DATA TRANSFER DEVICE, then define TID & LUN of device.
+
+ - element_type=<1|2|3|4>
+ - address=Number between 1 & 65535
+ - barcode="String up to 10 chars"
+ - sides=<1|2>
+ - tid=<tid of device which belongs at this address>
+ - lun=<lun of device which belongs at this address>
+
+
+It is the responsibility of the user not to configure overlapping slots
+of differing types.
+
+Slot types:
+ 1 -> Medium Transport (picker arm)
+ 2 -> Storage Element
+ 3 -> Import/Export Element
+ 4 -> Data Transfer device (CD drive, tape drive, MO drive etc)
 
 Please refer to scripts/tgt-core-test for a working example.
 
diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
index a31be1b..8c58972 100755
--- a/scripts/tgt-core-test
+++ b/scripts/tgt-core-test
@@ -17,15 +17,6 @@ fi
 if [ ! -f $HOME/hd_block ]; then
 	dd if=/dev/zero of=$HOME/hd_block bs=1M count=8
 fi
-if [ ! -f $HOME/cd_block0 ]; then
-	dd if=/dev/zero of=$HOME/cd_block0 bs=1M count=8
-fi
-if [ ! -f $HOME/cd_block1 ]; then
-	dd if=/dev/zero of=$HOME/cd_block1 bs=1M count=8
-fi
-if [ ! -f $HOME/cd_block2 ]; then
-	dd if=/dev/zero of=$HOME/cd_block2 bs=1M count=8
-fi
 
 set -x
 
@@ -85,10 +76,13 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 
 
-
 for LUN in 2 3 4; do
+	if [ ! -f $HOME/cdrom$LUN ]; then
+		dd if=/dev/zero of=$HOME/cdrom$LUN bs=1M count=8
+	fi
+
 	# Create LUN - CD/ROM
-	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
+	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cdrom$LUN --device-type=cd
 	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 		--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY1$LUN,removable=1
 	# Vendor Uniq - Mode page 0..
@@ -102,6 +96,94 @@ for LUN in 2 3 4; do
 		--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 done
 
+###############################################################################
+# Set up SMC Medium Changer
+###############################################################################
+LUN=5
+if [ ! -f $HOME/smc ]; then
+	dd if=/dev/zero of=$HOME/smc bs=1k count=1
+fi
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN \
+			-b $HOME/smc --device-type=changer
+
+#### Set up mode pages ####
+# From smc3-06.pdf
+# Page 0x02: Disconnect/Reconnect SPC-3
+# Page 0x0a: Control SPC-3
+# Page 0x18: Protocol Specific LUN SPC-3
+# Page 0x19: Protocol Specific Port SPC-3
+# Page 0x1a: Power Condition SPC-3
+# Page 0x1c: Informational Exceptions Control SPC-3
+# Page 0x1d: Element Address Assignment SMC-3 7.3.4
+# Page 0x1e: Transport Geometry Parameters SMC-3 7.3.5
+# Page 0x1f: Device Capabilities SMC-3 7.3.2
+# Page 0x1f/Subpage 0x41: Extended Device Capabilities SMC-3 7.3.3
+
+# Dummy 'page 0'
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0:0:0
+# Disconnect/Reconnect
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+# Power Condition
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1a:0:18:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
+# Informational Exceptions Control Mode Page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+# Element Address Assignment - Setup afterwards.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1d:0:0x12:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
+# Transport Geometry Parameters
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1e:0:2:0:0
+# Device Capabilities
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1f:0:0x12:0x0f:7:0x0f:0x0f:0x0f:0x0f:0:0:0:0:0x0f:0x0f:0x0f:0x0f:0:0:0:0
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params vendor_id=STK,product_id=L700,product_rev=0010,scsi_sn=XYZZY_0,removable=1
+
+
+## Add Data Transfer devices (3 drives)
+# Define slot address for devices.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,start_address=1,quantity=3
+# Now define which device at each address.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,address=1,tid=1,lun=2
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,address=2,tid=1,lun=3
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,address=3,tid=1,lun=4
+
+# Medium Transport Elements (robot arm / picker)
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=1,start_address=16,quantity=1
+
+## Storage Elements - 8 starting at addr 1024
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=2,start_address=1024,quantity=8
+# Add 'media' to slots
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=2,address=1024,barcode=ABC123,sides=1
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=2,address=1026,barcode=ULT001L3,sides=1
+
+# Import/Export Elements - 5 starting at addr 32
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=3,start_address=32,quantity=5
+
+# define path to virtual media
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params media_home=/d/01/vtl
+
+# Dump the list of configured slots to syslog...
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params dump=1
+
+
 # Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
 
diff --git a/usr/Makefile b/usr/Makefile
index 14be34b..c7fb2ca 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -43,8 +43,9 @@ INCLUDES += -I.
 CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
 
 PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o osd.o spt.o scc.o scsi.o log.o \
-	driver.o util.o work.o parser.o
+TGTD_OBJS += tgtd.o mgmt.o target.o \
+	spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o \
+	scsi.o log.o driver.o util.o work.o parser.o
 
 all: $(PROGRAMS)
 
diff --git a/usr/media.h b/usr/media.h
new file mode 100644
index 0000000..e54787e
--- /dev/null
+++ b/usr/media.h
@@ -0,0 +1,28 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef _MEDIA_H_
+#define _MEDIA_H_
+
+enum c_type {	/* Cartridge Types - Ref: smc3r06 - Table 20, page 37 */
+	CART_UNSPECIFIED,
+	CART_DATA,
+	CART_CLEAN,
+	CART_DIAGNOSTICS,
+	CART_WORM,
+	CART_MICROCODE,
+};
+
+#endif /* _MEDIA_H_ */
+
diff --git a/usr/mmc.c b/usr/mmc.c
index 0390bdb..7f70943 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -38,6 +38,7 @@
 #include "util.h"
 #include "tgtd.h"
 #include "target.h"
+#include "tgtadm_error.h"
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
diff --git a/usr/osd.c b/usr/osd.c
index 2bd33e6..1136b4f 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -29,6 +29,7 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "tgtadm_error.h"
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
@@ -67,6 +68,7 @@ static int osd_lu_init(struct scsi_lu *lu)
 static struct device_type_template osd_template = {
 	.type		= TYPE_OSD,
 	.lu_init	= osd_lu_init,
+	.lu_config	= spc_lu_config,
 	.ops		= {
 		[0x00 ... 0x0f] = {spc_illegal_op},
 
diff --git a/usr/sbc.c b/usr/sbc.c
index d285207..33485e6 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -34,6 +34,7 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "tgtadm_error.h"
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
diff --git a/usr/smc.c b/usr/smc.c
new file mode 100644
index 0000000..b97e071
--- /dev/null
+++ b/usr/smc.c
@@ -0,0 +1,846 @@
+/*
+ * SCSI Medium Changer command processing
+ * Based on smc3r06.pdf document from t10.org
+ *
+ * (C) 2004-2007 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
+ * (C) 2007      Mark Harvey <markh794 at gmail.com>
+ *
+ * SCSI target emulation code is based on Ardis's iSCSI implementation.
+ *   http://www.ardistech.com/iscsi/
+ *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
+ *   licensed under the terms of the GNU GPL v2.0,
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <errno.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <linux/fs.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "driver.h"
+#include "tgtadm_error.h"
+#include "scsi.h"
+#include "spc.h"
+#include "parser.h"
+#include "smc.h"
+#include "media.h"
+
+struct slot *slot_lookup(struct list_head *head, int element_type, int address);
+static int set_slot_full(struct slot *s, uint16_t src, char *path);
+static void set_slot_empty(struct slot *s);
+static int test_slot_full(struct slot *s);
+struct lu_phy_attr *lu_attr_lookup(int tid, uint64_t lun);
+int dtd_load_unload(uint8_t tid, uint64_t lun, int flg, char *filename);
+
+/* ********************************************************
+ * READ_ELEMENT_STATUS
+ *
+ * Ref: Working Draft SCSI Media Changer-3 (smc3r06.pdf), chapter 6.10
+ *
+ * The READ ELEMENT STATUS command request that the device server report the
+ * status of its internal elements to the application client.
+ * Support for READ ELEMENT STATUS command is mandatory.
+ * ******************************************************** */
+static int determine_element_sz(uint8_t dvcid, uint8_t voltag)
+{
+	if (voltag)
+		return (dvcid) ? 86 : 52;
+	else
+		return (dvcid) ? 50 : 16;
+}
+
+/**
+ * element_status_data_hdr  --  Fill in Element Status Header
+ * @data	uint8_t * - data pointer
+ * @dvcid	Device ID - true, return device ID information
+ * @voltag	true, return Volume Tag (barcode)
+ * @start	Start searching from slot 'start'
+ * @count	and return 'count' elements
+ *
+ * This builds the ELEMENT STATUS DATA header information built
+ * from the params passed.
+ *
+ * DATA header is always 8 bytes long
+ */
+static int element_status_data_hdr(uint8_t *data, uint8_t dvcid,
+					uint8_t voltag, int start, int count)
+{
+	int element_sz;
+	int size;
+
+	element_sz = determine_element_sz(dvcid, voltag);
+
+	/* First Element address reported */
+	*(uint16_t *)(data) = __cpu_to_be16(start);
+
+	/* Number of elements available */
+	*(uint16_t *)(data + 2) = __cpu_to_be16(count);
+
+	/* Byte count is the length required to return all valid data.
+	 * Allocated length is how much data the initiator will accept */
+	size = ((8 + (count * element_sz)) & 0xffffff);
+	*(uint32_t *)(data + 4) = __cpu_to_be32(size);
+
+return size;
+}
+
+static int add_element_descriptor(uint8_t *data, struct slot *s,
+			uint8_t element_type, uint8_t dvcid, uint8_t voltag)
+{
+	struct lu_phy_attr *attr = NULL;
+	int i;	/* data[] index */
+
+	*(uint16_t *)(data) = __cpu_to_be16(s->slot_addr);
+	data[2] = s->status;
+	data[3] = 0;	/* Reserved */
+	data[4] = (s->asc >> 8) & 0xff;	/* Additional Sense Code */
+	data[5] = s->asc & 0xff;	/* Additional Sense Code Qualifier */
+	/* [6], [7] & [8] reserved */
+	data[9] = (s->cart_type & 0xf);
+	if (s->last_addr) {	/* Source address is valid ? */
+		data[9] |= 0x80;
+		*(uint16_t *)(data + 10) = __cpu_to_be16(s->last_addr);
+	}
+	i = 12;
+	if (voltag) {
+		if (s->barcode[0] == ' ')
+			memset( &data[i], 0x20, 32);
+		else
+			snprintf((char *)&data[i], 32, "%-32s", s->barcode);
+
+		/* Reserve additional 4 bytes if dvcid is set */
+		i += (dvcid) ? 36 : 32;
+	}
+	if (element_type == ELEMENT_DATA_TRANSFER)
+		attr = lu_attr_lookup(s->drive_tid, s->drive_lun);
+	if (dvcid && attr) {
+		data[i] = 2;	/* ASCII code set */
+		data[i + 1] = attr->device_type;
+		data[i + 2] = 0;	/* reserved */
+		data[i + 3] = 34;	/* Length */
+		snprintf((char *)&data[i + 4], 9, "%-8s", attr->vendor_id);
+		snprintf((char *)&data[i + 12], 17, "%-16s", attr->product_id);
+		snprintf((char *)&data[i + 28], 11, "%-10s", attr->scsi_sn);
+	}
+
+return determine_element_sz(dvcid, voltag);
+}
+
+/**
+ * build_element_descriptor  --  Fill in Element details
+ * @data;	pointer
+ * @head;	Slot struct head
+ * @element_type; Slot type we are interested in.
+ * @first:	Return address of first slot found
+ * @start;	Start processing from this element #
+ * @dvcid;	Device ID
+ * @voltag;	Volume tag (barcode)
+ *
+ * Fill each Element Descriptor for slot *s
+ * Return number of elements
+ */
+static int build_element_descriptors(uint8_t *data, struct list_head *head,
+					uint8_t elem_type, int *first,
+					uint16_t start,
+					uint8_t dvcid, uint8_t voltag)
+{
+	struct slot *s;
+	int count = 0;
+	int len = 8;
+	int elem_sz = determine_element_sz(dvcid, voltag);
+
+	list_for_each_entry(s, head, slot_siblings) {
+		if (s->element_type == elem_type) {
+			if (s->slot_addr >= start) {
+				count++;
+				len += add_element_descriptor(&data[len],
+						s, elem_type, dvcid, voltag);
+			}
+		}
+		if (count == 1)	/* Record first found slot Address */
+			*first = s->slot_addr;
+	}
+
+	/* Fill in Element Status Page Header */
+	data[0] = elem_type;
+	data[1] = (voltag) ? 0x80 : 0;
+	*(uint16_t *)(data + 2) = __cpu_to_be16(elem_sz);
+
+	/* Total number of bytes in all element descriptors */
+	*(uint32_t *)(data + 4) = __cpu_to_be32((elem_sz * count) & 0xffffff);
+
+return count;
+}
+
+/**
+ * smc_read_element_status  -  READ ELEMENT STATUS op code
+ *
+ * Support the SCSI op code READ ELEMENT STATUS
+ * Ref: smc3r06, 6.10
+ */
+static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
+{
+	struct smc_info *smc = (struct smc_info *)cmd->dev->smc_p;
+	uint8_t *data;
+	uint8_t *scb;
+	uint8_t element_type;
+	uint8_t voltag;
+	uint16_t req_start_elem;
+	uint8_t dvcid;
+	uint32_t alloc_len;
+	uint16_t count = 0;
+	int first = 0;		/* First valid slot location */
+	int len = 8;
+	int elementSize;
+	int ret;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+
+	scb = cmd->scb;
+	element_type = scb[1] & 0x0f;
+	voltag	= (scb[1] & 0x10) >> 4;
+	dvcid = scb[6] & 0x01;
+	req_start_elem = __be16_to_cpu(*(uint16_t *)(scb + 2));
+	alloc_len = 0xffffff & __be32_to_cpu(*(uint32_t *)(scb + 6));
+
+	elementSize = determine_element_sz(dvcid, voltag);
+
+	cmd->len = 0;
+	if (cmd->dev) {
+		ret = device_reserved(cmd);
+		if (ret) {
+			dprintf("Reservation Conflict\n");
+			return SAM_STAT_RESERVATION_CONFLICT;
+		}
+	}
+
+	if (pagesize < alloc_len) {
+		dprintf("Can't allocate enough memory for cmd\n");
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	if ((data = valloc(pagesize)) == NULL) {
+		dprintf("valloc(%lu) failed\n", pagesize);
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	if (scb[11])	/* Reserved byte */
+		goto sense;
+
+	switch(element_type) {
+	case ELEMENT_ANY:
+		/* Return element in type order */
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MEDIUM_TRANSPORT, &first,
+					req_start_elem,
+					dvcid, voltag);
+		len = count * elementSize;
+		count += build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_STORAGE, &first,
+					req_start_elem,
+					dvcid, voltag);
+		len += count * elementSize;
+		count += build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MAP, &first,
+					req_start_elem,
+					dvcid, voltag);
+		len += count * elementSize;
+		count += build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_DATA_TRANSFER, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	case ELEMENT_MEDIUM_TRANSPORT:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MEDIUM_TRANSPORT, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	case ELEMENT_STORAGE:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_STORAGE, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	case ELEMENT_MAP:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MAP, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	case ELEMENT_DATA_TRANSFER:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_DATA_TRANSFER, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	default:
+		goto sense;
+		break;
+	}
+
+	/* Lastly, fill in data header */
+	len = element_status_data_hdr(data, dvcid, voltag, first, count);
+
+	cmd->len = min_t(int, len, alloc_len);
+	cmd->uaddr = (unsigned long) data;
+	cmd->rw = READ;
+
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+/**
+ * smc_move_medium  -  MOVE MEDIUM op code
+ *
+ * Support the SCSI op code MOVE MEDIUM
+ * Ref: smc3r06, 6.6
+ */
+static int smc_move_medium(int host_no, struct scsi_cmd *cmd)
+{
+	struct smc_info *smc = (struct smc_info *)cmd->dev->smc_p;
+	uint8_t *scb;
+	uint16_t src;
+	uint16_t dest;
+	uint8_t invert;
+	struct slot *src_slot = NULL;
+	struct slot *dest_slot = NULL;
+	struct slot *s;
+	int key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+
+	scb = cmd->scb;
+	src = __be16_to_cpu(*(uint16_t *)(scb + 4));
+	dest = __be16_to_cpu(*(uint16_t *)(scb + 6));
+	invert = scb[10] & 1;
+
+	list_for_each_entry(s, &smc->slots, slot_siblings) {
+		if (s->slot_addr == src)
+			src_slot = s;
+		if (s->slot_addr == dest)
+			dest_slot = s;
+	}
+
+	if (src_slot) {
+		if (!test_slot_full(src_slot)) {
+			asc = ASC_MEDIUM_SRC_EMPTY;
+			goto sense;
+		}
+	} else	/* Could not find src slot - Error */
+		goto sense;
+
+	if (dest_slot) {
+		if (test_slot_full(dest_slot)) {
+			asc = ASC_MEDIUM_DEST_FULL;
+			goto sense;
+		}
+	} else	/* Could not find dest slot - Error */
+		goto sense;
+
+	if (invert && (s->sides == 1))	/* Use default INVALID FIELD IN CDB */
+		goto sense;
+
+	memcpy(&dest_slot->barcode, &src_slot->barcode, sizeof(s->barcode));
+	if (dest_slot->element_type == ELEMENT_DATA_TRANSFER) {
+		char path[128];
+		int sz;
+		sz = snprintf(path, sizeof(path), "%s/%s",
+					smc->media_home, dest_slot->barcode);
+		if (sz >= sizeof(path)) {
+			dprintf("Path too long: %s\n", path);
+			key = ILLEGAL_REQUEST;
+			asc = ASC_INTERNAL_TGT_FAILURE;
+			memset(&dest_slot->barcode, ' ', sizeof(s->barcode));
+			goto sense;
+		}
+		if (set_slot_full(dest_slot, src, path)) {
+			key = HARDWARE_ERROR;
+			asc = ASC_MECHANICAL_POSITIONING_ERROR;
+			goto sense;
+		}
+	} else
+		set_slot_full(dest_slot, src, NULL);
+
+	set_slot_empty(src_slot);
+
+	cmd->len = 0;
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+static int smc_lu_init(struct scsi_lu *lu)
+{
+	struct smc_info *smc;
+
+	smc = zalloc(sizeof(struct smc_info));
+	if (smc)
+		lu->smc_p = smc;
+	else
+		return -ENOMEM;
+
+	spc_lu_init(lu);
+
+	strncpy(lu->attrs.product_id, "VIRTUAL-CHANGER",
+						sizeof(lu->attrs.product_id));
+	lu->attrs.version_desc[0] = 0x0480; /* SMC-3 no version claimed */
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
+
+	/* Vendor uniq - However most apps seem to call for mode page 0*/
+	add_mode_page(lu, "0:0:0");
+	/* Control page */
+	add_mode_page(lu, "10:0:10:2:0:0:0:0:0:0:0:2:0");
+	/* Power Condition */
+	add_mode_page(lu, "0x1a:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Informational Exceptions Control page */
+	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Address Assignment */
+	add_mode_page(lu, "0x1d:0:0x12:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0");
+	/* Transport Geometry Params */
+	add_mode_page(lu, "0x1e:0:2:0:0");
+	/* Device Capabilities */
+	add_mode_page(lu, "0x1f:0:0x12:15:7:15:15:15:15:0:0:0:0:15:15:15:15:0:0:0:0");
+
+	INIT_LIST_HEAD(&smc->slots);
+
+	lu->attrs.online = 1;	/* Library will now report as Online */
+	lu->attrs.reset = 1;	/* Poweron/reset occurred */
+	lu->attrs.removable = 1; /* Default to removable media */
+
+	return 0;
+}
+
+static void smc_lu_exit(struct scsi_lu *lu)
+{
+	struct smc_info *smc = lu->smc_p;
+
+	dprintf("Medium Changer shutdown() called\n");
+
+	free(smc);
+}
+
+static int set_slot_full(struct slot *s, uint16_t src, char *path)
+{
+	int err = 0;
+
+	if (path)
+		err = dtd_load_unload(s->drive_tid, s->drive_lun, LOAD, path);
+	if (err)
+		return err;
+
+	s->status |= 1;
+	s->last_addr=src;
+
+	return err;
+}
+
+static void set_slot_empty(struct slot *s)
+{
+	s-> status &= 0xfe;
+	s->last_addr=0;
+	memset(s->barcode, ' ', sizeof(s->barcode));
+	if (s->element_type == ELEMENT_DATA_TRANSFER)
+		dtd_load_unload(s->drive_tid, s->drive_lun, UNLOAD, NULL);
+}
+
+static int test_slot_full(struct slot *s)
+{
+	return s->status && 1;
+}
+
+static int slot_insert(struct list_head *head, int element_type, int address)
+{
+	struct slot *s;
+
+	if ((s = zalloc(sizeof(struct slot))) == NULL)
+		return TGTADM_NOMEM;
+
+	s->slot_addr = address;
+	s->element_type = element_type;
+	s->sides = 1;
+	if (element_type == ELEMENT_DATA_TRANSFER)	/* Drive */
+		s->asc = ASC_INITIALIZING_REQUIRED;
+
+	list_add_tail(&s->slot_siblings, head);
+
+	return 0;
+}
+
+/**
+ * slot_lookup  -- Find slot of type 'element_type' & address 'address'
+ * @element_type;	Type of slot, 0 == Any type
+ * @address;		Slot address, 0 == First found slot
+ *
+ * Return NULL if no match
+ */
+struct slot *slot_lookup(struct list_head *head, int element_type, int address)
+{
+	struct slot *s;
+
+	list_for_each_entry(s, head, slot_siblings) {
+		if (element_type && address) {
+			if ((s->slot_addr == address) &&
+					(s->element_type == element_type))
+				return s;
+		} else if (element_type) {
+			if (s->element_type == element_type)
+				return s;
+		} else if (address) {
+			if (s->slot_addr == address)
+				return s;
+		}
+	}
+	return NULL;
+}
+
+static void slot_dump(struct list_head *head)
+{
+	struct slot *s;
+
+	list_for_each_entry(s, head, slot_siblings)
+		if (s) {
+			dprintf("Slot %d Information\n", s->slot_addr);
+			dprintf("  Last Addr: %d\n", s->last_addr);
+			dprintf("  Type: %d\n", s->element_type);
+			dprintf("  Barcode: %s\n", s->barcode);
+			if (s->drive_tid) {
+				dprintf("  TID : %d\n", s->drive_tid);
+				dprintf("  LUN : %" PRIu64 "\n", s->drive_lun);
+			}
+			dprintf("  ASC/ASCQ : %d\n\n", s->asc);
+		}
+}
+
+static int add_slt(struct scsi_lu *lu, struct tmp_param *tmp)
+{
+	struct smc_info *smc = lu->smc_p;
+	int ret = TGTADM_INVALID_REQUEST;
+	struct mode_pg *pg;
+	struct slot *s;
+	uint16_t *element;
+	int sv_addr;
+	int qnty_save;
+	int i;
+
+	pg = lu->mode_pgs[0x1d];
+	if (!pg) {
+		dprintf("Failed to find Element Address Assignment mode pg\n");
+		return TGTADM_UNKNOWN_ERR;
+	}
+	element = (uint16_t *)pg->mode_data;
+
+	if (tmp->element_type && tmp->start_addr && tmp->quantity) {
+		switch(tmp->element_type) {
+		case ELEMENT_MEDIUM_TRANSPORT:
+			break;
+		case ELEMENT_MAP:
+			element += 4;
+			break;
+		case ELEMENT_STORAGE:
+			element += 2;
+			break;
+		case ELEMENT_DATA_TRANSFER:
+			element += 6;
+			break;
+		default:
+			goto dont_do_slots;
+			break;
+		}
+
+		sv_addr = __be16_to_cpu(element[0]);
+		qnty_save  = __be16_to_cpu(element[1]);
+
+		if (sv_addr)
+			element[0] =
+				__cpu_to_be16(min_t(int, tmp->start_addr, sv_addr));
+		else
+			element[0] = __cpu_to_be16(tmp->start_addr);
+		element[1] = __cpu_to_be16(tmp->quantity + qnty_save);
+
+		s = slot_lookup(&smc->slots, tmp->element_type, tmp->start_addr);
+		if (s)	// Opps... Found a slot at this address..
+			goto dont_do_slots;
+
+		ret = TGTADM_SUCCESS;
+		for(i=tmp->start_addr; i < (tmp->start_addr + tmp->quantity); i++)
+			if (slot_insert(&smc->slots, tmp->element_type, i))
+				ret = TGTADM_INVALID_REQUEST;
+	}
+
+dont_do_slots:
+	return ret;
+}
+
+static int config_slot(struct scsi_lu *lu, struct tmp_param *tmp)
+{
+	struct smc_info *smc = lu->smc_p;
+	struct mode_pg *m = NULL;
+	struct slot *s = NULL;
+	int ret = TGTADM_INVALID_REQUEST;
+
+	switch(tmp->element_type) {
+	case ELEMENT_MEDIUM_TRANSPORT:
+		/* If medium has more than one side, set the 'rotate' bit */
+		m = lu->mode_pgs[0x1e];
+		if (m) {
+			m->mode_data[0] = (tmp->sides > 1) ? 1 : 0;
+			ret = TGTADM_SUCCESS;
+		}
+		break;
+	case ELEMENT_STORAGE:
+	case ELEMENT_MAP:
+		if ((s = slot_lookup(&smc->slots, tmp->element_type, tmp->address)) == NULL)
+			break;	// Slot not found..
+		strncpy(s->barcode, tmp->barcode, sizeof(s->barcode));
+		set_slot_full(s, 0, NULL);
+		ret = TGTADM_SUCCESS;
+		break;
+	case ELEMENT_DATA_TRANSFER:
+		if (!tmp->tid)
+			break;	/* Fail if no TID specified */
+		if ((s = slot_lookup(&smc->slots, tmp->element_type, tmp->address)) == NULL)
+			break;	// Slot not found..
+		s->asc  = NO_ADDITIONAL_SENSE;
+		s->drive_tid = tmp->tid;
+		s->drive_lun = tmp->lun;
+		ret = TGTADM_SUCCESS;
+		break;
+	}
+	return ret;
+}
+
+#define ADD	1
+#define CONFIGURE 2
+
+static int __smc_lu_config(struct scsi_lu *lu, char *params)
+{
+	struct smc_info *smc = (struct smc_info *)lu->smc_p;
+	int err = TGTADM_SUCCESS;
+	char *p;
+	char buf[256];
+
+	while ((p = strsep(&params, ",")) != NULL) {
+		substring_t args[MAX_OPT_ARGS];
+		int token;
+		if (!*p)
+			continue;
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case Opt_element_type:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.element_type = atoi(buf);
+			break;
+		case Opt_start_address:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.start_addr = atoi(buf);
+			sv_param.operation = ADD;
+			break;
+		case Opt_quantity:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.quantity = atoi(buf);
+			break;
+		case Opt_sides:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.sides = atoi(buf);
+			break;
+		case Opt_address:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.address = atoi(buf);
+			sv_param.operation = CONFIGURE;
+			break;
+		case Opt_barcode:
+			match_strncpy(sv_param.barcode, &args[0],
+						sizeof(sv_param.barcode));
+			break;
+		case Opt_tid:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.tid = atoi(buf);
+			break;
+		case Opt_lun:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.lun = atoi(buf);
+			break;
+		case Opt_dump:
+			slot_dump(&smc->slots);
+			break;
+		case Opt_media_home:
+			if (smc->media_home)
+				free(smc->media_home);
+			match_strncpy(buf, &args[0], sizeof(buf));
+			smc->media_home = strdup(buf);
+			if (!smc->media_home)
+				return TGTADM_NOMEM;
+			break;
+		default:
+			err = TGTADM_UNKNOWN_PARAM;
+		}
+	}
+	return err;
+}
+
+static int smc_lu_config(struct scsi_lu *lu, char *params)
+{
+	int ret = TGTADM_SUCCESS;
+
+	memset(&sv_param, 0, sizeof(struct tmp_param));
+
+	if ((ret = lu_config(lu, params, __smc_lu_config)))
+		return TGTADM_UNKNOWN_PARAM;
+
+	switch(sv_param.operation) {
+		case ADD:
+			ret = add_slt(lu, &sv_param);
+			break;
+		case CONFIGURE:
+			ret = config_slot(lu, &sv_param);
+			break;
+	}
+	return ret;
+}
+
+struct device_type_template smc_template = {
+	.type		= TYPE_MEDIUM_CHANGER,
+	.lu_init	= smc_lu_init,
+	.lu_exit 	= smc_lu_exit,
+	.lu_config	= smc_lu_config,
+	.ops	= {
+		{spc_test_unit,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_request_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		/* 0x10 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_inquiry,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x20 ... 0x4f] = {spc_illegal_op,},
+
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x9f] = {spc_illegal_op,},
+
+		/* 0xA0 */
+		{spc_report_luns,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{smc_move_medium,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_test_unit,},
+
+		/* 0xB0 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{smc_read_element_status,},	// Mandatory
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0xc0 ... 0xff] = {spc_illegal_op},
+	}
+};
+
+__attribute__((constructor)) static void smc_init(void)
+{
+	device_type_register(&smc_template);
+}
diff --git a/usr/smc.h b/usr/smc.h
new file mode 100644
index 0000000..eab9b49
--- /dev/null
+++ b/usr/smc.h
@@ -0,0 +1,121 @@
+/*
+ * SCSI Medium Changer Command
+ *
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _SMC_H_
+#define _SMC_H_
+
+#define LOAD		1
+#define UNLOAD		0
+
+/**
+ * Define for ELEMENT TYPE
+ */
+#define ELEMENT_ANY		0
+#define	ELEMENT_MEDIUM_TRANSPORT	1
+#define	ELEMENT_STORAGE		2
+#define	ELEMENT_MAP		3
+#define	ELEMENT_DATA_TRANSFER	4
+
+/**
+ * struct slot - Virtual Library element
+ *
+ * @slot_addr: Slot address - number between 0 & 65535
+ * @last_addr: Last slot address where media came from
+ * @asc: ASC/ASCQ for this slot
+ * @element_type: 1 = Medium Transport, 2 = Storage, 3 = MAP, 4 = drive
+ * @cart_type: Type of media in this slot
+ * @status: Different bits used depending on element_type
+ * @sides: If media is single or double sided
+ * @barcode: Barcode of media ID
+ * @drive_tid: TID of DATA TRANSFER DEVICE configured at this slot address.
+ * @drive_lun: LUN of DATA TRANSFER DEVICE configured at this slot address.
+ *
+ * A linked list of slots describing each element within the virtual library
+ */
+struct slot {
+	struct list_head slot_siblings;
+	uint16_t slot_addr;
+	uint16_t last_addr;
+	uint16_t asc;
+	uint8_t element_type;
+	uint8_t cart_type;
+	uint8_t status;
+	uint8_t sides;
+	char barcode[11];
+	uint8_t drive_tid;
+	uint64_t drive_lun;
+};
+
+/**
+ * struct smc_info - Data structure for SMC device
+ * @media_home: Home directory for virtual media
+ * @slots: Linked list of 'slots' within the virtual library
+ *
+ */
+struct smc_info {
+	char *media_home;
+	struct list_head slots;
+};
+
+enum {
+	Opt_element_type, Opt_start_address,
+	Opt_quantity, Opt_sides,
+	Opt_address, Opt_barcode,
+	Opt_tid, Opt_lun,
+	Opt_type, Opt_dump,
+	Opt_media_home,
+	Opt_err,
+};
+
+static match_table_t tokens = {
+	{Opt_element_type, "element_type=%s"},
+	{Opt_start_address, "start_address=%s"},
+	{Opt_quantity, "quantity=%s"},
+	{Opt_sides, "sides=%s"},
+	{Opt_address, "address=%s"},
+	{Opt_barcode, "barcode=%s"},
+	{Opt_tid, "tid=%s"},
+	{Opt_lun, "lun=%s"},
+	{Opt_type, "type=%s"},
+	{Opt_dump, "dump=%s"},
+	{Opt_media_home, "media_home=%s"},
+	{Opt_err, NULL},
+};
+
+/**
+ * struct tmp_param{} -- temporary storage of param values from user
+ *
+ * As param parsing is stateless, several params need to be collected
+ * before we know if we are attempting to configure a slot or adding
+ * a number of new slots. This is just a temporary holder for all
+ * possible valid params before processing.
+ */
+struct tmp_param {
+	int operation;
+	int element_type;
+	int start_addr;
+	int quantity;
+	int address;
+	int tid;
+	uint64_t lun;
+	char barcode[20];
+	int sides;
+} sv_param;
+
+#endif // _SMC_H_
diff --git a/usr/spc.c b/usr/spc.c
index 7711078..e696682 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -226,16 +226,28 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
 
 	if (device_reserved(cmd))
 		return SAM_STAT_RESERVATION_CONFLICT;
-	else
+	if (cmd->dev->attrs.reset) {
+		cmd->dev->attrs.reset = 0;
+		sense_data_build(cmd, UNIT_ATTENTION, ASC_POWERON_RESET);
+		return SAM_STAT_CHECK_CONDITION;
+	}
+	if (cmd->dev->attrs.online)
 		return SAM_STAT_GOOD;
+	if (cmd->dev->attrs.removable)
+		sense_data_build(cmd, NOT_READY, ASC_MEDIUM_NOT_PRESENT);
+	else
+		sense_data_build(cmd, NOT_READY, ASC_BECOMING_READY);
+
+	return SAM_STAT_CHECK_CONDITION;
 }
 
-/*
- * Copy mode page data from list into SCSI data so it can be returned
- * to the initiator
+/**
+ * build_mode_page - static routine used by spc_mode_sense()
+ * @data:	destination pointer
+ * @m:		struct mode pointer (src of data)
  *
- * *data -> target address (destination)
- * pg -> Pointer to mode page information (source)
+ * Description: Copy mode page data from list into SCSI data so it can
+ * be returned to the initiator
  *
  * Returns number of bytes copied.
  */
@@ -254,6 +266,13 @@ static int build_mode_page(uint8_t *data, struct mode_pg *pg)
 	return len;
 }
 
+/**
+ * spc_mode_sense - Implement SCSI op MODE SENSE(6) and MODE SENSE(10)
+ *
+ * Reference : SPC4r11
+ * 6.11 - MODE SENSE(6)
+ * 6.12 - MODE SENSE(10)
+ */
 int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 {
 	int len = 0;
@@ -263,12 +282,6 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 	struct mode_pg *pg;
 
-	/*
-	 * Reference : SPC4r11
-	 * 6.11 - MODE SENSE(6)
-	 * 6.12 - MODE SENSE(10)
-	 */
-
 	scb = cmd->scb;
 	mode6 = (scb[0] == 0x1a);
 	dbd = scb[1] & 0x8; /* Disable Block Descriptors */
@@ -480,8 +493,9 @@ static match_table_t tokens = {
 	{Opt_err, NULL},
 };
 
-int spc_lu_config(struct scsi_lu *lu, char *params) {
-	int err = 0;
+int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
+{
+	int err = TGTADM_SUCCESS;
 	char *p;
 	char buf[256];
 
@@ -505,15 +519,15 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			break;
 		case Opt_vendor_id:
 			match_strncpy(lu->attrs.vendor_id, &args[0],
-					sizeof(lu->attrs.vendor_id));
+					sizeof(lu->attrs.vendor_id) - 1);
 			break;
 		case Opt_product_id:
 			match_strncpy(lu->attrs.product_id, &args[0],
-					sizeof(lu->attrs.product_id));
+					sizeof(lu->attrs.product_id) - 1);
 			break;
 		case Opt_product_rev:
 			match_strncpy(lu->attrs.product_rev, &args[0],
-					sizeof(lu->attrs.product_rev));
+					sizeof(lu->attrs.product_rev) - 1);
 			break;
 		case Opt_sense_format:
 			match_strncpy(buf, &args[0],  sizeof(buf));
@@ -532,21 +546,22 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			err = add_mode_page(lu, buf);
 			break;
 		default:
-			err = TGTADM_INVALID_REQUEST;
+			err |= fn ? fn(lu, p) : TGTADM_INVALID_REQUEST;
 		}
 	}
 	return err;
 }
 
-/*
- * Set initial power-on defaults for lu
- *
- * Currently always return '0'
- */
+int spc_lu_config(struct scsi_lu *lu, char *params)
+{
+	return lu_config(lu, params, NULL);
+}
+
 int spc_lu_init(struct scsi_lu *lu)
 {
-	strncpy(lu->attrs.vendor_id, VENDOR_ID, sizeof(lu->attrs.vendor_id));
-	memcpy(lu->attrs.product_rev, "0001", 4);
+	snprintf(lu->attrs.vendor_id, sizeof(lu->attrs.vendor_id) - 1,
+							"%-16s", VENDOR_ID);
+	snprintf(lu->attrs.product_rev, 4, "%s", "0001");
 	lu->attrs.removable = 0;
 	lu->attrs.sense_format = 0;
 	lu->attrs.online = 0;
diff --git a/usr/spc.h b/usr/spc.h
index 4b99268..1cc8623 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -8,7 +8,10 @@ extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
 extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
 extern int spc_lu_init(struct scsi_lu *lu);
-extern int spc_lu_config(struct scsi_lu *lu, char * params);
+
+typedef int (match_fn_t)(struct scsi_lu *lu, char *params);
+extern int lu_config(struct scsi_lu *lu, char *params, match_fn_t *);
+extern int spc_lu_config(struct scsi_lu *lu, char *params);
 extern void dump_cdb(struct scsi_cmd *cmd);
 extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
 extern int add_mode_page(struct scsi_lu *lu, char *params);
diff --git a/usr/target.c b/usr/target.c
index d3c9cb8..2474d05 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -200,6 +200,7 @@ static int tgt_device_path_update(struct target *target,
 	lu->addr = 0;
 	lu->size = size;
 	lu->path = path;
+	lu->attrs.online = 1;
 
 	return 0;
 }
@@ -341,6 +342,61 @@ int tgt_device_destroy(int tid, uint64_t lun, int force)
 	return 0;
 }
 
+struct lu_phy_attr *lu_attr_lookup(int tid, uint64_t lun)
+{
+	struct target *target;
+	struct scsi_lu *lu;
+
+	lu = __device_lookup(tid, lun, &target);
+	if (!lu)
+		return NULL;
+	return &lu->attrs;
+}
+
+/**
+ * dtd_load_unload  --  Load / unload media
+ * @tid:	Target ID
+ * @lun:	LUN
+ * @load:	True if load, not true - unload
+ * @file:	filename of 'media' top open
+ *
+ * load/unload media from the DATA TRANSFER DEVICE.
+ */
+int dtd_load_unload(int tid, uint64_t lun, int load, char *file)
+{
+	struct target *target;
+	struct scsi_lu *lu;
+	int err = TGTADM_SUCCESS;
+
+	lu = __device_lookup(tid, lun, &target);
+	if (!lu)
+		return TGTADM_NO_LUN;
+
+	if (!lu->attrs.removable)
+		return TGTADM_INVALID_REQUEST;
+
+	if (lu->path) {
+		close(lu->fd);
+		free(lu->path);
+		lu->path = NULL;
+	}
+
+	lu->size = 0;
+	lu->fd = 0;
+	lu->attrs.online = 0;
+
+	if (load) {
+		lu->path = strdup(file);
+		if (!lu->path)
+			return TGTADM_NOMEM;
+		lu->fd = backed_file_open(file, O_RDWR|O_LARGEFILE, &lu->size);
+		if (lu->fd < 0)
+			return TGTADM_UNSUPPORTED_OPERATION;
+		lu->attrs.online = 1;
+	}
+	return err;
+}
+
 int device_reserve(struct scsi_cmd *cmd)
 {
 	struct scsi_lu *lu;
@@ -1200,12 +1256,18 @@ int tgt_target_show_all(char *buf, int rest)
 				 _TAB3 "SCSI ID: %s\n"
 				 _TAB3 "SCSI SN: %s\n"
 				 _TAB3 "Size: %s\n"
+				 _TAB3 "Online: %s\n"
+				 _TAB3 "Poweron/Reset: %s\n"
+				 _TAB3 "Removable media: %s\n"
 				 _TAB3 "Backing store: %s\n",
 				 lu->lun,
   				 print_type(lu->attrs.device_type),
 				 lu->attrs.scsi_id,
 				 lu->attrs.scsi_sn,
 				 print_disksize(lu->size),
+				 lu->attrs.online ? "Yes" : "No",
+				 lu->attrs.reset ? "Yes" : "No",
+				 lu->attrs.removable ? "Yes" : "No",
 				 lu->path ? : "No backing store");
 
 		if (!strcmp(tgt_drivers[target->lid]->name, "iscsi")) {
diff --git a/usr/tgtadm.c b/usr/tgtadm.c
index c2315b6..0631a7d 100644
--- a/usr/tgtadm.c
+++ b/usr/tgtadm.c
@@ -300,6 +300,8 @@ static int str_to_device_type(char *str)
 		exit(EINVAL);
 	} else if (!strcmp(str, "cd"))
 		return TYPE_ROM;
+	else if (!strcmp(str, "changer"))
+		return TYPE_MEDIUM_CHANGER;
 	else if (!strcmp(str, "osd"))
 		return TYPE_OSD;
 	else if (!strcmp(str, "pt"))
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 1c1e3e2..112f0c7 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -73,7 +73,7 @@ struct backingstore_template {
 	int (*bs_open)(struct scsi_lu *dev, char *path, int *fd, uint64_t *size);
 	void (*bs_close)(struct scsi_lu *dev);
 	int (*bs_cmd_submit)(struct scsi_cmd *cmd);
-	int (*bs_cmd_done) (struct scsi_cmd *cmd);
+	int (*bs_cmd_done)(struct scsi_cmd *cmd);
 };
 
 struct mode_pg {
@@ -107,8 +107,11 @@ struct scsi_lu {
 	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
 	struct mode_pg *mode_pgs[0x3f];
 
-	/* TODO: needs a structure for lots of device parameters */
 	struct lu_phy_attr attrs;
+
+	/* TODO: needs a structure for lots of device parameters */
+	/* Currently only used by smc module */
+	void *smc_p;
 };
 
 struct scsi_cmd {
-- 
1.5.2.1






From fujita.tomonori at lab.ntt.co.jp  Sat Jul  7 14:37:28 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 07 Jul 2007 21:37:28 +0900
Subject: [Stgt-devel] [Patch 1/1] Add SCSI MEDIUM CHANGER support
In-Reply-To: <468DFBAE.9040409@gmail.com>
References: <468DFBAE.9040409@gmail.com>
Message-ID: <200707071237.l67CbnDc007262@mbox.iij4u.or.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 1/1] Add SCSI MEDIUM CHANGER support
Date: Fri, 06 Jul 2007 18:22:06 +1000

> Re-work of initial SMC commit based on latest git head MODE PAGE commit.
> 
> This version includes the ability to load/unload media from the
> DATA TRANSFER DEVICE at the configured TID/LUN address.
> 
> Update spc_test_unit() TEST UNIT READY op processing to 'understand'
> online, Poweron/Reset and removable flags. i.e. Response from TUR
> depends on the status of each of these flags.
>  - If poweron_reset, return POWER-ON or RESET occurred, then clear flag.
>  - If online - Return READY
>  - If off-line and non-removable media - UNIT BECOMING READY
>  - If off-line and removable media - MEDIUM NOT PRESENT
> 
> Online is when the backing file is open and ready for reading/writing.
> 
> To be done at at a later time:
> Other SCSI op codes need to be aware of these flags.

Applied, thanks a lot!

Please separate logical changes into a single patch file next
time. You could split this into load/unload media stuff and smc.


After applying this patch, I fixed and cleaned up many things so check
whether it works.


> Signed-off-by: Mark Harvey <markh794 at gmail.com>
> ---
>  doc/README.lu_configuration |   47 +++
>  scripts/tgt-core-test       |  104 +++++-
>  usr/Makefile                |    5 +-
>  usr/media.h                 |   28 ++
>  usr/mmc.c                   |    1 +
>  usr/osd.c                   |    2 +
>  usr/sbc.c                   |    1 +
>  usr/smc.c                   |  846 +++++++++++++++++++++++++++++++++++++++++++
>  usr/smc.h                   |  121 ++++++
>  usr/spc.c                   |   65 ++--
>  usr/spc.h                   |    5 +-
>  usr/target.c                |   62 ++++
>  usr/tgtadm.c                |    2 +
>  usr/tgtd.h                  |    7 +-
>  14 files changed, 1255 insertions(+), 41 deletions(-)
> 

(snip)


> +static int test_slot_full(struct slot *s)
> +{
> +	return s->status && 1;
> +}

?

s->status & 1;


> @@ -1200,12 +1256,18 @@ int tgt_target_show_all(char *buf, int rest)
>  				 _TAB3 "SCSI ID: %s\n"
>  				 _TAB3 "SCSI SN: %s\n"
>  				 _TAB3 "Size: %s\n"
> +				 _TAB3 "Online: %s\n"
> +				 _TAB3 "Poweron/Reset: %s\n"
> +				 _TAB3 "Removable media: %s\n"
>  				 _TAB3 "Backing store: %s\n",
>  				 lu->lun,
>    				 print_type(lu->attrs.device_type),
>  				 lu->attrs.scsi_id,
>  				 lu->attrs.scsi_sn,
>  				 print_disksize(lu->size),
> +				 lu->attrs.online ? "Yes" : "No",
> +				 lu->attrs.reset ? "Yes" : "No",
> +				 lu->attrs.removable ? "Yes" : "No",
>  				 lu->path ? : "No backing store");
>  

Probably, I'll change this later. I'd like to have more simple output.


From markh794 at gmail.com  Thu Jul 12 06:43:33 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 12 Jul 2007 14:43:33 +1000
Subject: [Stgt-devel] [Patch 1/1] Add SCSI MEDIUM CHANGER support
In-Reply-To: <200707071237.l67CbnDc007262@mbox.iij4u.or.jp>
References: <468DFBAE.9040409@gmail.com>
	<200707071237.l67CbnDc007262@mbox.iij4u.or.jp>
Message-ID: <f29db9a80707112143u6aa65135xd01cceff6bcd07ce@mail.gmail.com>

On 7/7/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: Mark Harvey <markh794 at gmail.com>
> Subject: [Stgt-devel] [Patch 1/1] Add SCSI MEDIUM CHANGER support
> Date: Fri, 06 Jul 2007 18:22:06 +1000
>
> > Re-work of initial SMC commit based on latest git head MODE PAGE commit.
> >
> > This version includes the ability to load/unload media from the
> > DATA TRANSFER DEVICE at the configured TID/LUN address.
> >
> > Update spc_test_unit() TEST UNIT READY op processing to 'understand'
> > online, Poweron/Reset and removable flags. i.e. Response from TUR
> > depends on the status of each of these flags.
> >  - If poweron_reset, return POWER-ON or RESET occurred, then clear flag.
> >  - If online - Return READY
> >  - If off-line and non-removable media - UNIT BECOMING READY
> >  - If off-line and removable media - MEDIUM NOT PRESENT
> >
> > Online is when the backing file is open and ready for reading/writing.
> >
> > To be done at at a later time:
> > Other SCSI op codes need to be aware of these flags.
>
> Applied, thanks a lot!
>
> Please separate logical changes into a single patch file next
> time. You could split this into load/unload media stuff and smc.

OK.

> After applying this patch, I fixed and cleaned up many things so check
> whether it works.

I most likely will not have time until next week but a quick review of
the patches, I'm not expecting any surprises.

>
>
> > Signed-off-by: Mark Harvey <markh794 at gmail.com>
> > ---
> >  doc/README.lu_configuration |   47 +++
> >  scripts/tgt-core-test       |  104 +++++-
> >  usr/Makefile                |    5 +-
> >  usr/media.h                 |   28 ++
> >  usr/mmc.c                   |    1 +
> >  usr/osd.c                   |    2 +
> >  usr/sbc.c                   |    1 +
> >  usr/smc.c                   |  846 +++++++++++++++++++++++++++++++++++++++++++
> >  usr/smc.h                   |  121 ++++++
> >  usr/spc.c                   |   65 ++--
> >  usr/spc.h                   |    5 +-
> >  usr/target.c                |   62 ++++
> >  usr/tgtadm.c                |    2 +
> >  usr/tgtd.h                  |    7 +-
> >  14 files changed, 1255 insertions(+), 41 deletions(-)
> >
>
> (snip)
>
>
> > +static int test_slot_full(struct slot *s)
> > +{
> > +     return s->status && 1;
> > +}
>
> ?
>
> s->status & 1;
>
>
> > @@ -1200,12 +1256,18 @@ int tgt_target_show_all(char *buf, int rest)
> >                                _TAB3 "SCSI ID: %s\n"
> >                                _TAB3 "SCSI SN: %s\n"
> >                                _TAB3 "Size: %s\n"
> > +                              _TAB3 "Online: %s\n"
> > +                              _TAB3 "Poweron/Reset: %s\n"
> > +                              _TAB3 "Removable media: %s\n"
> >                                _TAB3 "Backing store: %s\n",
> >                                lu->lun,
> >                                print_type(lu->attrs.device_type),
> >                                lu->attrs.scsi_id,
> >                                lu->attrs.scsi_sn,
> >                                print_disksize(lu->size),
> > +                              lu->attrs.online ? "Yes" : "No",
> > +                              lu->attrs.reset ? "Yes" : "No",
> > +                              lu->attrs.removable ? "Yes" : "No",
> >                                lu->path ? : "No backing store");
> >
>
> Probably, I'll change this later. I'd like to have more simple output.

I was not really planing on submitting this part.. It was more for my testing.


Many thanks
Mark


From fujita.tomonori at lab.ntt.co.jp  Thu Jul 12 06:49:32 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 12 Jul 2007 13:49:32 +0900
Subject: [Stgt-devel] [Patch 1/1] Add SCSI MEDIUM CHANGER support
In-Reply-To: <f29db9a80707112143u6aa65135xd01cceff6bcd07ce@mail.gmail.com>
References: <468DFBAE.9040409@gmail.com>
	<200707071237.l67CbnDc007262@mbox.iij4u.or.jp>
	<f29db9a80707112143u6aa65135xd01cceff6bcd07ce@mail.gmail.com>
Message-ID: <20070712134932G.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] [Patch 1/1] Add SCSI MEDIUM CHANGER support
Date: Thu, 12 Jul 2007 14:43:33 +1000

> > > +static int test_slot_full(struct slot *s)
> > > +{
> > > +     return s->status && 1;
> > > +}
> >
> > ?
> >
> > s->status & 1;

Is this correct?


From michaelc at cs.wisc.edu  Thu Jul 12 22:52:15 2007
From: michaelc at cs.wisc.edu (Mike Christie)
Date: Thu, 12 Jul 2007 15:52:15 -0500
Subject: [Stgt-devel] [PATCH] fix ia64 compilation
Message-ID: <4696947F.2060005@cs.wisc.edu>

Here is a patch to fix ia64 compilation.

From michaelc at cs.wisc.edu  Thu Jul 12 22:47:14 2007
From: michaelc at cs.wisc.edu (Mike Christie)
Date: Thu, 12 Jul 2007 15:47:14 -0500
Subject: [PATCH 1/1] Fix ia64 compilation
Message-ID: <mailman.15.1331738473.12506.stgt-devel@lists.berlios.de>

Some ia64 compilers do not like the set_scn_flag macro use
inside the htonl call. This just seperates the two.

Signed-off-by: Mike Christie <michaelc at cs.wisc.edu>
---
 usr/iscsi/isns.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/isns.c b/usr/iscsi/isns.c
index c3538d9..3277265 100644
--- a/usr/iscsi/isns.c
+++ b/usr/iscsi/isns.c
@@ -267,7 +267,8 @@ static int isns_scn_register(void)
 
 	scn_flags = ISNS_SCN_FLAG_INITIATOR | ISNS_SCN_FLAG_OBJECT_REMOVE |
 		ISNS_SCN_FLAG_OBJECT_ADDED | ISNS_SCN_FLAG_OBJECT_UPDATED;
-	scn_flags = htonl(set_scn_flag(scn_flags));
+	set_scn_flag(scn_flags);
+	scn_flags = htonl(scn_flags);
 
 	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_SCN_BITMAP,
 			       sizeof(scn_flags), &scn_flags);
-- 
1.5.1.2


--------------060603050906010805070708--


From tomof at acm.org  Fri Jul 13 00:37:29 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Fri, 13 Jul 2007 07:37:29 +0900
Subject: [Stgt-devel] [PATCH] fix ia64 compilation
In-Reply-To: <4696947F.2060005@cs.wisc.edu>
References: <4696947F.2060005@cs.wisc.edu>
Message-ID: <20070712134602G.tomof@acm.org>

From: Mike Christie <michaelc at cs.wisc.edu>
Subject: [Stgt-devel] [PATCH] fix ia64 compilation
Date: Thu, 12 Jul 2007 15:52:15 -0500

> Here is a patch to fix ia64 compilation.

Applied, thanks.


From markh794 at gmail.com  Fri Jul 13 12:11:14 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 13 Jul 2007 20:11:14 +1000
Subject: [Stgt-devel] [Patch 1/1] Add SCSI MEDIUM CHANGER support
In-Reply-To: <20070712134932G.fujita.tomonori@lab.ntt.co.jp>
References: <468DFBAE.9040409@gmail.com>
	<200707071237.l67CbnDc007262@mbox.iij4u.or.jp>
	<f29db9a80707112143u6aa65135xd01cceff6bcd07ce@mail.gmail.com>
	<20070712134932G.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80707130311n10bce33ma7a0e3641f97e7db@mail.gmail.com>

On 7/12/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: Re: [Stgt-devel] [Patch 1/1] Add SCSI MEDIUM CHANGER support
> Date: Thu, 12 Jul 2007 14:43:33 +1000
>
> > > > +static int test_slot_full(struct slot *s)
> > > > +{
> > > > +     return s->status && 1;
> > > > +}
> > >
> > > ?
> > >
> > > s->status & 1;
>
> Is this correct?
>

Sorry... Missed this one.

Yes. Return status of bit 0 in the 'status' byte.

Regards
Mark


From bardov at gmail.com  Tue Jul 24 13:43:56 2007
From: bardov at gmail.com (Dan Bar Dov)
Date: Tue, 24 Jul 2007 14:43:56 +0300
Subject: [Stgt-devel] STGT target setup information
Message-ID: <d6944c490707240443r471fc14fq2557dccd834a9183@mail.gmail.com>

Hi Tomo,

What documentation can I find regarding setting up an STGT target?
Is there some wiki? Other documentation?

Is STGT already part of the kernel (what vesion?) any distribution?
If not, do I start by downloading sources? from Berlios?

Thanks,
Dan
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070724/6e24b5cd/attachment.html>

From bardov at gmail.com  Tue Jul 24 13:54:17 2007
From: bardov at gmail.com (Dan Bar Dov)
Date: Tue, 24 Jul 2007 14:54:17 +0300
Subject: [Stgt-devel] STGT target setup information
In-Reply-To: <d6944c490707240443r471fc14fq2557dccd834a9183@mail.gmail.com>
References: <d6944c490707240443r471fc14fq2557dccd834a9183@mail.gmail.com>
Message-ID: <d6944c490707240454r716722e4v41785504bacf39af@mail.gmail.com>

OK, I found answers to most of my questions at http://stgt.berlios.de/
I havn't downloaded the code yet.

Does the userspace package include setup info?
What is the status of the iscsi starget? stable? can I use it for
production?
Is performance comparable to IET? (I remember some emails complaining about
not so good performance).

Also, what are the plans going forward?

BTW, If you would like, I volunteer to add this info and documentation to
the stgt home page.

Thanks,
Dan

On 7/24/07, Dan Bar Dov <bardov at gmail.com> wrote:
>
> Hi Tomo,
>
> What documentation can I find regarding setting up an STGT target?
> Is there some wiki? Other documentation?
>
> Is STGT already part of the kernel (what vesion?) any distribution?
> If not, do I start by downloading sources? from Berlios?
>
> Thanks,
> Dan
>
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070724/ec963734/attachment.html>

From fujita.tomonori at lab.ntt.co.jp  Tue Jul 24 14:17:40 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 24 Jul 2007 21:17:40 +0900
Subject: [Stgt-devel] STGT target setup information
In-Reply-To: <d6944c490707240454r716722e4v41785504bacf39af@mail.gmail.com>
References: <d6944c490707240443r471fc14fq2557dccd834a9183@mail.gmail.com>
	<d6944c490707240454r716722e4v41785504bacf39af@mail.gmail.com>
Message-ID: <20070724211740Q.fujita.tomonori@lab.ntt.co.jp>

From: "Dan Bar Dov" <bardov at gmail.com>
Subject: Re: [Stgt-devel] STGT target setup information
Date: Tue, 24 Jul 2007 14:54:17 +0300

> OK, I found answers to most of my questions at http://stgt.berlios.de/
> I havn't downloaded the code yet.
> 
> Does the userspace package include setup info?

Yeah.


> What is the status of the iscsi starget? stable? can I use it for
> production?

I guess that SUSE or RedHat people test it, so maybe they can answer
it.


> Is performance comparable to IET? (I remember some emails complaining about
> not so good performance).

Should be not bad though we still need to improve it.


> Also, what are the plans going forward?

I've been trying to adding target mode support to the transport
classes.

What features are you interested in?


> BTW, If you would like, I volunteer to add this info and documentation to
> the stgt home page.

I would appreciate any kind of documents. Thanks.


From pw at osc.edu  Wed Jul 25 22:56:56 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 25 Jul 2007 16:56:56 -0400
Subject: [Stgt-devel] [PATCH] iscsi roundup data buf
In-Reply-To: <20070725205621.GB26477@osc.edu>
References: <20070725205621.GB26477@osc.edu>
Message-ID: <20070725205656.GC26477@osc.edu>

Leave room for the padding after data.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 3a583d4..19251e6 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1379,7 +1379,7 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 
 	ahs_len = roundup(req->hlength * 4, 4);
 	imm_len = roundup(ntoh24(req->dlength), 4);
-	data_len = ntohl(req->data_length);
+	data_len = roundup(ntohl(req->data_length), 4);
 
 	dprintf("%u %x %d %d %d %x %x\n", conn->session->tsih,
 		req->cdb[0], ahs_len, imm_len, data_len,
@@ -1406,7 +1406,7 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 
 	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
 		task->offset = ntoh24(req->dlength);
-		task->r2t_count = data_len - task->offset;
+		task->r2t_count = ntohl(req->data_length) - task->offset;
 		task->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
 
 		dprintf("%d %d %d %d\n", conn->rx_size, task->r2t_count,
-- 
1.5.2.4



From pw at osc.edu  Wed Jul 25 22:55:57 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 25 Jul 2007 16:55:57 -0400
Subject: [Stgt-devel] [PATCH] debug printf fix
Message-ID: <20070725205557.GA26477@osc.edu>

Add a missing debug newline.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/bs_aio.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/usr/bs_aio.c b/usr/bs_aio.c
index 0af2674..20a7085 100644
--- a/usr/bs_aio.c
+++ b/usr/bs_aio.c
@@ -77,7 +77,7 @@ retry:
 
 	ret = io_getevents(info->ctx, 1, MAX_AIO_REQS, info->events, NULL);
 	nr = ret;
-	dprintf("%d", ret);
+	dprintf("%d\n", ret);
 	if (nr > 0) {
 	rewrite:
 		ret = write(info->done_fd[1], &nr, sizeof(nr));
-- 
1.5.2.4



From pw at osc.edu  Wed Jul 25 22:56:21 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 25 Jul 2007 16:56:21 -0400
Subject: [Stgt-devel] [PATCH] ahs fix state machine
Message-ID: <20070725205621.GB26477@osc.edu>

Fix AHS handling in new state machine introduced for digests.  Same issue
as in the INIT_AHS handler where we must short-circuit to INIT DATA.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    6 +++++-
 1 files changed, 5 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index fe26cc5..3a583d4 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1777,7 +1777,11 @@ again:
 	case IOSTATE_RX_AHS:
 		ret = do_recv(fd, conn, hdigest ?
 			      IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA);
-		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_HDIGEST)
+		if (ret <= 0)
+			break;
+		if (conn->rx_iostate == IOSTATE_RX_INIT_DATA)
+			goto again;
+		if (conn->rx_iostate != IOSTATE_RX_INIT_HDIGEST)
 			break;
 	case IOSTATE_RX_INIT_HDIGEST:
 		conn->rx_buffer = conn->rx_digest;
-- 
1.5.2.4



From pw at osc.edu  Wed Jul 25 22:57:20 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 25 Jul 2007 16:57:20 -0400
Subject: [Stgt-devel] [PATCH] osd request sense
Message-ID: <20070725205720.GD26477@osc.edu>

OSDs respond to request sense in the usual way.  Add note about missing
support for b0 and b1 inquiry page codes.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/osd.c |   23 ++++++++++++++++++++++-
 1 files changed, 22 insertions(+), 1 deletions(-)

diff --git a/usr/osd.c b/usr/osd.c
index 1136b4f..189fba4 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -51,6 +51,10 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 	return cmd->dev->bst->bs_cmd_submit(cmd);
 }
 
+/*
+ * XXX: missing support for b0 and b1, in page 0 and in inquiry code.
+ * Figure out how to make spc_inquiry handle extra mode pages.
+ */
 static int osd_lu_init(struct scsi_lu *lu)
 {
 	if (spc_lu_init(lu))
@@ -70,7 +74,24 @@ static struct device_type_template osd_template = {
 	.lu_init	= osd_lu_init,
 	.lu_config	= spc_lu_config,
 	.ops		= {
-		[0x00 ... 0x0f] = {spc_illegal_op},
+		/* 0x00 */
+		{spc_test_unit,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_request_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
 
 		/* 0x10 */
 		{spc_illegal_op,},
-- 
1.5.2.4



From pw at osc.edu  Fri Jul 27 01:18:13 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 26 Jul 2007 19:18:13 -0400
Subject: [Stgt-devel] [PATCH] iscsi param cleanup
Message-ID: <20070726231813.GA6664@osc.edu>

Remove inconsistencies in param structures and index usage.  This
seems like the cleanest way to keep the three separate lists of 19
parameters in sync.  The three spots are:  lookup of special params
by index #defines during login, session defaults, and target
defaults.  This fixes one real (although oddball) bug and several
potential bugs.

The real bug left the recv dlength size at 8k in spite of both
initiator and target wanting 256k: text_add_key thought 256k was
default and did not bother to send it.  The OFMarker code was errant
too, but it is unlikely that that was ever a problem for someone.

Target parameter defaults are not changed.  Except for the case
where you asked for a dlength of 256k using an explicit iscsiadm
target update command.

Further cleanups to iscsi_if.h would be possible.  Most of that is
legacy code from the target-in-kernel days.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_if.h |   43 +++++++------------------------------------
 usr/iscsi/iscsid.h   |    4 ----
 usr/iscsi/param.c    |   43 ++++++++++++++++++++++++++++++++++++-------
 usr/iscsi/param.h    |    4 ++++
 usr/iscsi/target.c   |   38 +++++++++++++++++++-------------------
 5 files changed, 66 insertions(+), 66 deletions(-)

diff --git a/usr/iscsi/iscsi_if.h b/usr/iscsi/iscsi_if.h
index 9008b5f..58a76a2 100644
--- a/usr/iscsi/iscsi_if.h
+++ b/usr/iscsi/iscsi_if.h
@@ -192,10 +192,10 @@ enum iscsi_err {
 };
 
 /*
- * iSCSI Parameters (RFC3720)
+ * iSCSI Parameters (RFC3720).  Keep the session_keys and
+ * default_tgt_session_param arrays consistent with this list.
  */
 enum iscsi_param {
-	/* passed in using netlink set param */
 	ISCSI_PARAM_MAX_RECV_DLENGTH,
 	ISCSI_PARAM_MAX_XMIT_DLENGTH,
 	ISCSI_PARAM_HDRDGST_EN,
@@ -210,44 +210,15 @@ enum iscsi_param {
 	ISCSI_PARAM_ERL,
 	ISCSI_PARAM_IFMARKER_EN,
 	ISCSI_PARAM_OFMARKER_EN,
-	ISCSI_PARAM_EXP_STATSN,
-	ISCSI_PARAM_TARGET_NAME,
-	ISCSI_PARAM_TPGT,
-	ISCSI_PARAM_PERSISTENT_ADDRESS,
-	ISCSI_PARAM_PERSISTENT_PORT,
-	ISCSI_PARAM_SESS_RECOVERY_TMO,
-
-	/* pased in through bind conn using transport_fd */
-	ISCSI_PARAM_CONN_PORT,
-	ISCSI_PARAM_CONN_ADDRESS,
-
+	ISCSI_PARAM_DEFAULTTIME2WAIT,
+	ISCSI_PARAM_DEFAULTTIME2RETAIN,
+	ISCSI_PARAM_OFMARKINT,
+	ISCSI_PARAM_IFMARKINT,
+	ISCSI_PARAM_MAXCONNECTIONS,
 	/* must always be last */
 	ISCSI_PARAM_MAX,
 };
 
-#define ISCSI_MAX_RECV_DLENGTH		(1 << ISCSI_PARAM_MAX_RECV_DLENGTH)
-#define ISCSI_MAX_XMIT_DLENGTH		(1 << ISCSI_PARAM_MAX_XMIT_DLENGTH)
-#define ISCSI_HDRDGST_EN		(1 << ISCSI_PARAM_HDRDGST_EN)
-#define ISCSI_DATADGST_EN		(1 << ISCSI_PARAM_DATADGST_EN)
-#define ISCSI_INITIAL_R2T_EN		(1 << ISCSI_PARAM_INITIAL_R2T_EN)
-#define ISCSI_MAX_R2T			(1 << ISCSI_PARAM_MAX_R2T)
-#define ISCSI_IMM_DATA_EN		(1 << ISCSI_PARAM_IMM_DATA_EN)
-#define ISCSI_FIRST_BURST		(1 << ISCSI_PARAM_FIRST_BURST)
-#define ISCSI_MAX_BURST			(1 << ISCSI_PARAM_MAX_BURST)
-#define ISCSI_PDU_INORDER_EN		(1 << ISCSI_PARAM_PDU_INORDER_EN)
-#define ISCSI_DATASEQ_INORDER_EN	(1 << ISCSI_PARAM_DATASEQ_INORDER_EN)
-#define ISCSI_ERL			(1 << ISCSI_PARAM_ERL)
-#define ISCSI_IFMARKER_EN		(1 << ISCSI_PARAM_IFMARKER_EN)
-#define ISCSI_OFMARKER_EN		(1 << ISCSI_PARAM_OFMARKER_EN)
-#define ISCSI_EXP_STATSN		(1 << ISCSI_PARAM_EXP_STATSN)
-#define ISCSI_TARGET_NAME		(1 << ISCSI_PARAM_TARGET_NAME)
-#define ISCSI_TPGT			(1 << ISCSI_PARAM_TPGT)
-#define ISCSI_PERSISTENT_ADDRESS	(1 << ISCSI_PARAM_PERSISTENT_ADDRESS)
-#define ISCSI_PERSISTENT_PORT		(1 << ISCSI_PARAM_PERSISTENT_PORT)
-#define ISCSI_SESS_RECOVERY_TMO		(1 << ISCSI_PARAM_SESS_RECOVERY_TMO)
-#define ISCSI_CONN_PORT			(1 << ISCSI_PARAM_CONN_PORT)
-#define ISCSI_CONN_ADDRESS		(1 << ISCSI_PARAM_CONN_ADDRESS)
-
 #define iscsi_ptr(_handle) ((void*)(unsigned long)_handle)
 #define iscsi_handle(_ptr) ((uint64_t)(unsigned long)_ptr)
 #define hostdata_session(_hostdata) (iscsi_ptr(*(unsigned long *)_hostdata))
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 6704488..a8c8cb1 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -60,10 +60,6 @@ struct iscsi_pdu {
 	unsigned int datasize;
 };
 
-#define KEY_STATE_START		0
-#define KEY_STATE_REQUEST	1
-#define KEY_STATE_DONE		2
-
 struct iscsi_session {
 	int refcount;
 
diff --git a/usr/iscsi/param.c b/usr/iscsi/param.c
index 29007d7..9eac62c 100644
--- a/usr/iscsi/param.c
+++ b/usr/iscsi/param.c
@@ -212,10 +212,10 @@ static int marker_val_to_str(unsigned int val, char *str)
 
 static int marker_set_val(struct param *param, int idx, unsigned int *val)
 {
-	if ((idx == ISCSI_OFMARKER_EN &&
-	     param[ISCSI_OFMARKER_EN].state == KEY_STATE_DONE) ||
-	    (idx == ISCSI_IFMARKER_EN &&
-	     param[ISCSI_IFMARKER_EN].state == KEY_STATE_DONE))
+	if ((idx == ISCSI_PARAM_OFMARKER_EN &&
+	     param[ISCSI_PARAM_OFMARKER_EN].state == KEY_STATE_DONE) ||
+	    (idx == ISCSI_PARAM_IFMARKER_EN &&
+	     param[ISCSI_PARAM_IFMARKER_EN].state == KEY_STATE_DONE))
 		*val = 0;
 	else
 		*val = 1;
@@ -297,25 +297,54 @@ static struct iscsi_key_ops marker_ops = {
 
 #define	SET_KEY_VALUES(x)	DEFAULT_NR_##x,MIN_NR_##x, MAX_NR_##x
 
+/*
+ * The defaults here are according to the spec and must not be changed,
+ * otherwise the initiator may make the wrong assumption.  If you want
+ * to change a value, edit the value in iscsi_target_create.
+ *
+ * The param MaxXmitDataSegmentLength doesn't really exist.  It's a way
+ * to remember the RDSL of the initiator, which defaults to 8k if he has
+ * not told us otherwise.
+ */
 struct iscsi_key session_keys[] = {
-	{"MaxRecvDataSegmentLength", 262144, 512, 16777215, &minimum_ops},
-	{"MaxXmitDataSegmentLength", 262144, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_MAX_RECV_DLENGTH] =
+	{"MaxRecvDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_MAX_XMIT_DLENGTH] =
+	{"MaxXmitDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_HDRDGST_EN] =
 	{"HeaderDigest", DIGEST_NONE, DIGEST_NONE, DIGEST_ALL, &digest_ops},
+	[ISCSI_PARAM_DATADGST_EN] =
 	{"DataDigest", DIGEST_NONE, DIGEST_NONE, DIGEST_ALL, &digest_ops},
-	{"InitialR2T", 0, 0, 1, &or_ops},
+	[ISCSI_PARAM_INITIAL_R2T_EN] =
+	{"InitialR2T", 1, 0, 1, &or_ops},
+	[ISCSI_PARAM_MAX_R2T] =
 	{"MaxOutstandingR2T", 1, 1, 65535, &minimum_ops},
+	[ISCSI_PARAM_IMM_DATA_EN] =
 	{"ImmediateData", 1, 0, 1, &and_ops},
+	[ISCSI_PARAM_FIRST_BURST] =
 	{"FirstBurstLength", 65536, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_MAX_BURST] =
 	{"MaxBurstLength", 262144, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_PDU_INORDER_EN] =
 	{"DataPDUInOrder", 1, 0, 1, &or_ops},
+	[ISCSI_PARAM_DATASEQ_INORDER_EN] =
 	{"DataSequenceInOrder", 1, 0, 1, &or_ops},
+	[ISCSI_PARAM_ERL] =
 	{"ErrorRecoveryLevel", 0, 0, 2, &minimum_ops},
+	[ISCSI_PARAM_IFMARKER_EN] =
 	{"IFMarker", 0, 0, 1, &and_ops},
+	[ISCSI_PARAM_OFMARKER_EN] =
 	{"OFMarker", 0, 0, 1, &and_ops},
+	[ISCSI_PARAM_DEFAULTTIME2WAIT] =
 	{"DefaultTime2Wait", 2, 0, 3600, &maximum_ops},
+	[ISCSI_PARAM_DEFAULTTIME2RETAIN] =
 	{"DefaultTime2Retain", 20, 0, 3600, &minimum_ops},
+	[ISCSI_PARAM_OFMARKINT] =
 	{"OFMarkInt", 2048, 1, 65535, &marker_ops},
+	[ISCSI_PARAM_IFMARKINT] =
 	{"IFMarkInt", 2048, 1, 65535, &marker_ops},
+	[ISCSI_PARAM_MAXCONNECTIONS] =
 	{"MaxConnections", 1, 1, 65535, &minimum_ops},
+	[ISCSI_PARAM_MAX] =
 	{NULL,},
 };
diff --git a/usr/iscsi/param.h b/usr/iscsi/param.h
index fcee1e1..b5dd567 100644
--- a/usr/iscsi/param.h
+++ b/usr/iscsi/param.h
@@ -26,6 +26,10 @@ struct param {
 	unsigned int val;
 };
 
+#define KEY_STATE_START		0
+#define KEY_STATE_REQUEST	1
+#define KEY_STATE_DONE		2
+
 struct iscsi_key_ops {
 	int (*val_to_str)(unsigned int, char *);
 	int (*str_to_val)(char *, unsigned int *);
diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
index f2ecfd8..3e63485 100644
--- a/usr/iscsi/target.c
+++ b/usr/iscsi/target.c
@@ -265,25 +265,25 @@ int iscsi_target_create(struct target *t)
 	int tid = t->tid;
 	struct iscsi_target *target;
 	struct param default_tgt_session_param[] = {
-		{0, 8192},
-		{0, 8192},
-		{0, DIGEST_NONE},
-		{0, DIGEST_NONE},
-		{0, 1},
-		{0, 1},
-		{0, 1},
-		{0, 65536},
-		{0, 262144},
-		{0, 1},
-		{0, 1},
-		{0, 0},
-		{0, 0},
-		{0, 0},
-		{0, 2},
-		{0, 20},
-		{0, 2048},
-		{0, 2048},
-		{0, 1},
+		[ISCSI_PARAM_MAX_RECV_DLENGTH] = {0, 8192},
+		[ISCSI_PARAM_MAX_XMIT_DLENGTH] = {0, 8192},  /* do not edit */
+		[ISCSI_PARAM_HDRDGST_EN] = {0, DIGEST_NONE},
+		[ISCSI_PARAM_DATADGST_EN] = {0, DIGEST_NONE},
+		[ISCSI_PARAM_INITIAL_R2T_EN] = {0, 1},
+		[ISCSI_PARAM_MAX_R2T] = {0, 1},
+		[ISCSI_PARAM_IMM_DATA_EN] = {0, 1},
+		[ISCSI_PARAM_FIRST_BURST] = {0, 65536},
+		[ISCSI_PARAM_MAX_BURST] = {0, 262144},
+		[ISCSI_PARAM_PDU_INORDER_EN] = {0, 1},
+		[ISCSI_PARAM_DATASEQ_INORDER_EN] = {0, 1},
+		[ISCSI_PARAM_ERL] = {0, 0},
+		[ISCSI_PARAM_IFMARKER_EN] = {0, 0},
+		[ISCSI_PARAM_OFMARKER_EN] = {0, 0},
+		[ISCSI_PARAM_DEFAULTTIME2WAIT] = {0, 2},
+		[ISCSI_PARAM_DEFAULTTIME2RETAIN] = {0, 20},
+		[ISCSI_PARAM_OFMARKINT] = {0, 2048},
+		[ISCSI_PARAM_IFMARKINT] = {0, 2048},
+		[ISCSI_PARAM_MAXCONNECTIONS] = {0, 1},
 	};
 
 	target = malloc(sizeof(*target));
-- 
1.5.2.4



From fujita.tomonori at lab.ntt.co.jp  Sun Jul 29 09:22:42 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 29 Jul 2007 16:22:42 +0900
Subject: [Stgt-devel] [PATCH] debug printf fix
In-Reply-To: <20070725205557.GA26477@osc.edu>
References: <20070725205557.GA26477@osc.edu>
Message-ID: <20070729162242M.fujita.tomonori@lab.ntt.co.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] debug printf fix
Date: Wed, 25 Jul 2007 16:55:57 -0400

> Add a missing debug newline.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/bs_aio.c |    2 +-
>  1 files changed, 1 insertions(+), 1 deletions(-)

Applied, thanks.

We don't use usr/bs_aio.c now, but we might use it.


From fujita.tomonori at lab.ntt.co.jp  Sun Jul 29 09:24:06 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 29 Jul 2007 16:24:06 +0900
Subject: [Stgt-devel] [PATCH] ahs fix state machine
In-Reply-To: <20070725205621.GB26477@osc.edu>
References: <20070725205621.GB26477@osc.edu>
Message-ID: <20070729162406U.fujita.tomonori@lab.ntt.co.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] ahs fix state machine
Date: Wed, 25 Jul 2007 16:56:21 -0400

> Fix AHS handling in new state machine introduced for digests.  Same issue
> as in the INIT_AHS handler where we must short-circuit to INIT DATA.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsid.c |    6 +++++-
>  1 files changed, 5 insertions(+), 1 deletions(-)

Nice catch. Applied, thanks a lot.


From fujita.tomonori at lab.ntt.co.jp  Sun Jul 29 09:26:20 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 29 Jul 2007 16:26:20 +0900
Subject: [Stgt-devel] [PATCH] iscsi roundup data buf
In-Reply-To: <20070725205656.GC26477@osc.edu>
References: <20070725205621.GB26477@osc.edu> <20070725205656.GC26477@osc.edu>
Message-ID: <20070729162620J.fujita.tomonori@lab.ntt.co.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] iscsi roundup data buf
Date: Wed, 25 Jul 2007 16:56:56 -0400

> Leave room for the padding after data.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsid.c |    4 ++--
>  1 files changed, 2 insertions(+), 2 deletions(-)

Thanks, applied.


From fujita.tomonori at lab.ntt.co.jp  Sun Jul 29 09:26:44 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 29 Jul 2007 16:26:44 +0900
Subject: [Stgt-devel] [PATCH] osd request sense
In-Reply-To: <20070725205720.GD26477@osc.edu>
References: <20070725205720.GD26477@osc.edu>
Message-ID: <20070729162644D.fujita.tomonori@lab.ntt.co.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] osd request sense
Date: Wed, 25 Jul 2007 16:57:20 -0400

> OSDs respond to request sense in the usual way.  Add note about missing
> support for b0 and b1 inquiry page codes.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/osd.c |   23 ++++++++++++++++++++++-
>  1 files changed, 22 insertions(+), 1 deletions(-)

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Sun Jul 29 09:31:22 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 29 Jul 2007 16:31:22 +0900
Subject: [Stgt-devel] [PATCH] iscsi param cleanup
In-Reply-To: <20070726231813.GA6664@osc.edu>
References: <20070726231813.GA6664@osc.edu>
Message-ID: <20070729163122W.fujita.tomonori@lab.ntt.co.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] iscsi param cleanup
Date: Thu, 26 Jul 2007 19:18:13 -0400

> Remove inconsistencies in param structures and index usage.  This
> seems like the cleanest way to keep the three separate lists of 19
> parameters in sync.  The three spots are:  lookup of special params
> by index #defines during login, session defaults, and target
> defaults.  This fixes one real (although oddball) bug and several
> potential bugs.
> 
> The real bug left the recv dlength size at 8k in spite of both
> initiator and target wanting 256k: text_add_key thought 256k was
> default and did not bother to send it.  The OFMarker code was errant
> too, but it is unlikely that that was ever a problem for someone.
> 
> Target parameter defaults are not changed.  Except for the case
> where you asked for a dlength of 256k using an explicit iscsiadm
> target update command.
> 
> Further cleanups to iscsi_if.h would be possible.  Most of that is
> legacy code from the target-in-kernel days.
>
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsi_if.h |   43 +++++++------------------------------------
>  usr/iscsi/iscsid.h   |    4 ----
>  usr/iscsi/param.c    |   43 ++++++++++++++++++++++++++++++++++++-------
>  usr/iscsi/param.h    |    4 ++++
>  usr/iscsi/target.c   |   38 +++++++++++++++++++-------------------
>  5 files changed, 66 insertions(+), 66 deletions(-)

Applied, thanks.

But we might restore some of the parameters that you removed to
support iSCSI HW cards in the future.


From pw at osc.edu  Mon Jul 30 19:29:11 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 13:29:11 -0400
Subject: [Stgt-devel] misc fixes
Message-ID: <20070730172911.GA12789@osc.edu>

Here are six more patches, all pretty much unrelated to each other.
I'll respond to this mail to send them to the list.

You can also pull from:

    git://git.osc.edu/tgt misc-fixes

to grab all six.

		-- Pete


From pw at osc.edu  Mon Jul 30 19:29:44 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 13:29:44 -0400
Subject: [Stgt-devel] [PATCH] spt warning fix
In-Reply-To: <20070730172911.GA12789@osc.edu>
References: <20070730172911.GA12789@osc.edu>
Message-ID: <20070730172944.GB12789@osc.edu>

Remove unused variable.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/spt.c |    1 -
 1 files changed, 0 insertions(+), 1 deletions(-)

diff --git a/usr/spt.c b/usr/spt.c
index 6ad36f8..509e06d 100644
--- a/usr/spt.c
+++ b/usr/spt.c
@@ -64,7 +64,6 @@ struct backingstore_template sg_bst = {
 static int spt_cmd_perform(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
-	struct device_type_operations *ops;
 
 	if (!cmd->dev) {
 		cmd->len = 0;
-- 
1.5.2.4



From pw at osc.edu  Mon Jul 30 19:30:06 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 13:30:06 -0400
Subject: [Stgt-devel] [PATCH] fix no blkgetsize64
In-Reply-To: <20070730172911.GA12789@osc.edu>
References: <20070730172911.GA12789@osc.edu>
Message-ID: <20070730173006.GC12789@osc.edu>

Fix build for old machines that do not have 64-bit BLKGETSIZE.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/util.c |   10 ++++++++++
 1 files changed, 10 insertions(+), 0 deletions(-)

diff --git a/usr/util.c b/usr/util.c
index 9f54820..54bf399 100644
--- a/usr/util.c
+++ b/usr/util.c
@@ -101,11 +101,21 @@ int backed_file_open(char *path, int oflag, uint64_t *size)
 	if (S_ISREG(st.st_mode))
 		*size = st.st_size;
 	else if (S_ISBLK(st.st_mode)) {
+#ifdef BLKGETSIZE64
 		err = ioctl(fd, BLKGETSIZE64, size);
 		if (err < 0) {
 			eprintf("Cannot get size, %m\n");
 			goto close_fd;
 		}
+#else
+		unsigned long usize;
+		err = ioctl(fd, BLKGETSIZE, &usize);
+		if (err < 0) {
+			eprintf("Cannot get size (ulong), %m\n");
+			goto close_fd;
+		}
+		*size = usize;
+#endif
 	} else {
 		eprintf("Cannot use this mode %x\n", st.st_mode);
 		err = -EINVAL;
-- 
1.5.2.4



From pw at osc.edu  Mon Jul 30 19:30:26 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 13:30:26 -0400
Subject: [Stgt-devel] [PATCH] remove unneeded kernel header
In-Reply-To: <20070730172911.GA12789@osc.edu>
References: <20070730172911.GA12789@osc.edu>
Message-ID: <20070730173026.GD12789@osc.edu>

This netlink header is unused and causes build problems on old machines.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/target.c |    1 -
 1 files changed, 0 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
index 3e63485..2653839 100644
--- a/usr/iscsi/target.c
+++ b/usr/iscsi/target.c
@@ -26,7 +26,6 @@
 #include <netdb.h>
 #include <sys/stat.h>
 #include <sys/un.h>
-#include <linux/netlink.h>
 #include <netinet/in.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
-- 
1.5.2.4



From pw at osc.edu  Mon Jul 30 19:30:44 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 13:30:44 -0400
Subject: [Stgt-devel] [PATCH] silence gcc
In-Reply-To: <20070730172911.GA12789@osc.edu>
References: <20070730172911.GA12789@osc.edu>
Message-ID: <20070730173044.GE12789@osc.edu>

Avoid bogus unused variable warning from gcc.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    2 +-
 usr/spc.c          |    2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 19251e6..8fd9099 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1190,7 +1190,7 @@ static int iscsi_tm_execute(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_tm *req = (struct iscsi_tm *) &task->req;
-	int fn, err = 0;
+	int fn = 0, err = 0;
 
 	switch (req->flags & ISCSI_FLAG_TM_FUNC_MASK) {
 	case ISCSI_TM_FUNC_ABORT_TASK:
diff --git a/usr/spc.c b/usr/spc.c
index 899508c..b56c0b3 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -40,7 +40,7 @@
 
 int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
-	int len, ret = SAM_STAT_CHECK_CONDITION;
+	int len = 0, ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data;
 	uint8_t *scb = cmd->scb;
 	unsigned char key = ILLEGAL_REQUEST;
-- 
1.5.2.4



From pw at osc.edu  Mon Jul 30 19:31:10 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 13:31:10 -0400
Subject: [Stgt-devel] [PATCH] iscsi no zero data buffer
In-Reply-To: <20070730172911.GA12789@osc.edu>
References: <20070730172911.GA12789@osc.edu>
Message-ID: <20070730173110.GF12789@osc.edu>

Avoid zeroing out all the bytes of every incoming and outgoing data
buffer.  This has a measurable performance impact.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 8fd9099..ae840ad 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -966,9 +966,10 @@ iscsi_alloc_task(struct iscsi_connection *conn, int ext_len)
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
 	struct iscsi_task *task;
 
-	task = zalloc(sizeof(*task) + ext_len);
+	task = malloc(sizeof(*task) + ext_len);
 	if (!task)
 		return NULL;
+	memset(task, 0, sizeof(*task));
 
 	memcpy(&task->req, req, sizeof(*req));
 	task->conn = conn;
-- 
1.5.2.4



From pw at osc.edu  Mon Jul 30 19:31:44 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 13:31:44 -0400
Subject: [Stgt-devel] [PATCH] iscsi no spin with async bs
In-Reply-To: <20070730172911.GA12789@osc.edu>
References: <20070730172911.GA12789@osc.edu>
Message-ID: <20070730173144.GG12789@osc.edu>

A missing call to tgt_event_modify(fd, EPOLLIN) is added.  Without this, an
asynchronous backing store would cause tgtd to spin in epoll, always
reporting EPOLLOUT on the socket but having nothing to write.  When the
thread completes the command, the bs will cause cmd_done, turning EPOLLOUT
back on.

No change for synchronous backing stores, as epoll does not get called
until the command completes.

It would also spin briefly waiting for the rest of the unsolicited packets,
in both sync and async cases.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |   10 +++++-----
 1 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index ae840ad..e092462 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1145,16 +1145,16 @@ static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 	int err = 0;
 
 	if (rw && task->r2t_count) {
-		if (!task->unsol_count)
+		if (!task->unsol_count) {
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
-		goto no_queuing;
+			tgt_event_modify(conn->fd, EPOLLIN | EPOLLOUT);
+		}
+		return err;
 	}
 
 	task->offset = 0;  /* for use as transmit pointer for data-ins */
+	tgt_event_modify(conn->fd, EPOLLIN);
 	err = iscsi_target_cmd_queue(task);
-no_queuing:
-	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
-
 	return err;
 }
 
-- 
1.5.2.4



From pw at osc.edu  Mon Jul 30 20:23:40 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 14:23:40 -0400
Subject: [Stgt-devel] Announcing new open source iSER (iSCSI/RDMA) target
Message-ID: <20070730182340.GI12789@osc.edu>

We are releasing code to add support for iSCSI Extensions for RDMA
(iSER) to the existing STGT user space SCSI target.  It uses
OpenFabrics libraries and kernel drivers to act as a SCSI target
over RDMA-capable devices.  The code has been tested against
the existing Linux iSER initiator over InfiniBand cards, but
should be specification compliant and work generally.

A bit of documentation is included, and a short technical report is
available at http://www.osc.edu/~pw/papers/iser-techreport.pdf .
For performance, a single SCSI client using iSCSI over gigabit
ethernet does 100 MB/s.  iSCSI over IPoIB gets 200 MB/s, and iSER
over native IB sees 500 MB/s.

More information on STGT is available at http://stgt.berlios.de .

The seven iSER patches can be downloaded from:

	git://git.osc.edu/tgt

or browsed at:

	http://git.osc.edu/?p=tgt.git;a=summary

New and modified files are distributed under a GPLv2 license.  I'll
submit individual patches to stgt-devel for review and eventual
inclusion in STGT.

		-- Pete



From pw at osc.edu  Mon Jul 30 20:54:49 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 14:54:49 -0400
Subject: [Stgt-devel] iser patches
Message-ID: <20070730185449.GN12789@osc.edu>

Here are the seven patches that make up the iSER changes.  They sit
on top of the previous six in the misc-fixes branch.

Full tree at git://git.osc.edu/tgt .  Please review, for eventual
inclusion in STGT.

Brief descriptions:

iser docs
    Single file in doc/, to explain the big picture of iSER and
    details of the implementation.

iser counter events
    RDMA interface cannot be driven by polling on fd.  This adds
    a new event management interface to tgtd.

iser transport buf
    Allocate in- and out-buffer space in transport always, not in
    valloc() in inquiry et al.

iser bidi alloc read buf
    Allocate read buffer for bidirectional commands in iscsi.

iser generalize iscsi
    Virtualize functions for memore management, event modification,
    RDMA read/write, pushing current implementations into TCP.

iser rounding
    Wire interface differences between iSCSI/TCP and iSER.

iser core
    Big iscsi_rdma.c file, build if ISCSI_RDMA=1.

Thanks,

		-- Pete


From pw at osc.edu  Mon Jul 30 20:55:49 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 14:55:49 -0400
Subject: [Stgt-devel] [PATCH 1/7] iser docs
In-Reply-To: <20070730185449.GN12789@osc.edu>
References: <20070730185449.GN12789@osc.edu>
Message-ID: <20070730185549.GO12789@osc.edu>

A document describing what iSCSI on RDMA is about, how it is
implemented in tgtd, and how to use it.  Also things that
should be fixed someday.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 doc/README.iser |  196 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 196 insertions(+), 0 deletions(-)
 create mode 100644 doc/README.iser

diff --git a/doc/README.iser b/doc/README.iser
new file mode 100644
index 0000000..6dd3470
--- /dev/null
+++ b/doc/README.iser
@@ -0,0 +1,196 @@
+iSCSI Extensions for RDMA (iSER)
+================================
+
+Background
+----------
+
+There is a draft specification at ietf.org to extend the iSCSI protocol
+to work on RDMA-capable networks as well as on traditional TCP/IP.  The
+current version is:
+
+	"iSCSI Extensions for RDMA Specification", Mike Ko, 20-Oct-05,
+	<draft-ietf-ips-iser-06.txt>
+
+RDMA stands for Remote Direct Memory Access, a way of accessing memory
+of a remote node directly through the network without involving the
+processor of that remote node.  Many network devices implement some form
+of RDMA.  Two of the more popular network devices are InfiniBand (IB)
+and iWARP.  IB uses its own physical and network layer, while iWARP sits
+on top of TCP/IP (or SCTP).
+
+Using these devices requires a new application programming interface
+(API).  The Linux kernel has many components of the OpenFabrics software
+stack, including APIs for access from user space and drivers for some
+popular RDMA-capable NICs, including IB cards with the Mellanox chipset
+and iWARP cards from NetEffect, Chelsio, and Ammasso.  Most Linux
+distributions ship the user space libraries for device access and RDMA
+connection management.
+
+
+RDMA in tgtd
+------------
+
+The Linux kernel can act as a SCSI initiator on the iSER transport, but
+not as a target.  tgtd is a user space target that supports multiple
+transports, including iSCSI/TCP, and now iSER on RDMA devices.
+
+The iSER code was written by researchers at the Ohio Supercomputer
+Center in early 2007:
+
+	Dennis Dalessandro <dennis at osc.edu>
+	Ananth Devulapalli <ananth at osc.edu>
+	Pete Wyckoff <pw at osc.edu>
+
+We wanted to use a faster transport to test the capabilities of an
+object-based storage device (OSD) emulator we had previously written.
+Our cluster has InfiniBand cards, and while running TCP/IP over IB is
+possible, the performance is not nearly as good as using native IB
+directly.
+
+A short technical report describing this implementation and some
+performance results is available at:
+
+	http://www.osc.edu/~pw/papers/iser-techreport.pdf
+
+The code mostly lives in iscsi/iscsi_rdma.c, with a few places in
+iscsi/iscsid.c that check if the transport is RDMA or not and behave
+accordingly.  iSCSI already had the idea of a transport, with just the
+single TCP one defined.  We added the RDMA transport and virtualized
+some more functions where TCP and RDMA behave differently.
+
+
+Design Issues
+-------------
+
+In general, a SCSI system includes two components, an initiator and a
+target. The initiator submits commands and awaits responses.  The target
+services commands from initiators and returns responses.  Data may flow
+from the initiator, from the client, or both (bidirectional).  The iSER
+specification requires all data transfers to be started by the target,
+regardless of direction.  In a read operation, the target uses RDMA
+Write to move data to the initiator, while a write operation uses RDMA
+Read to fetch data from the initiator.
+
+
+1. Memory registration
+
+One of the most severe stumbling blocks in moving any application to
+take advantage of RDMA features is memory registration.  Before using
+RDMA, both the sending and receiving buffers must be registered with the
+operating system.  This operation ensures that the underlying hardware
+pages will not be modified during the transfer, and provides the
+physical addresses of the buffers to the network card.  However, the
+process itself is time consuming, and CPU intensive.  Previous
+investigations have shown that for InfiniBand, with a nominal transfer
+rate of 900 MB/s, the throughput drops to around 500 MB/s when memory
+registration and deregistration are included in the critical path.
+
+Our target implementation uses pre-registered buffers for RDMA
+operations.  In general such a scheme is difficult to justify due to the
+large per-connection resource requirements.  However, in this
+application it may be appropriate.  Since the target always initiates
+RDMA operations and never advertises RDMA buffers, it can securely use
+one pool of buffers for multiple clients and can manage its memory
+resources explicitly.  Also, the architecture of the code is such that
+the iSCSI layer dictates incoming and outgoing buffer locations to the
+storage device layer, so supplying a registered buffer is relatively
+easy.
+
+
+2. Event management
+
+There is a mismatch between what the tgtd event framework assumes and
+what the RDMA notification interface provides.  The existing TCP-based
+iSCSI target code has one file descriptor per connection and it is
+driven by readability or writeability of the socket.  A single poll
+system call returns which sockets can be serviced, driving the TCP code
+to read or write as appropriate.  The RDMA interface can be used in
+accordance with this design by requesting interrupts from the network
+card on work request completions.  Notifications appear on the file
+descriptor that represents a completion queue to which all RDMA events
+are delivered.
+
+However, the existing sockets-based code goes beyond this and changes
+the bitmask of requested events to control its code flow.  For instance,
+after it finishes sending a response, it will modify the bitmask to only
+look for readability.  Even if the socket is writeable, there is no data
+to write, hence polling for that status is not useful.  The code also
+disables new message arrival during command execution as a sort of
+exclusion facility, again by modifying the bitmask.  We cannot do this
+with the RDMA interface.  Hence we must maintain an active list of tasks
+that have data to write and drive a progress engine to service them.
+The need for progress is tracked by a counter, and the tgtd event loop
+checks this counter and calls into the iSER-specific while the counter
+is still non-zero.  tgtd will block in the poll call when it must wait
+on network activity.  No dedicated thread is needed for iSER.
+
+
+3. Padding
+
+The iSCSI specification clearly states that all segments in the protocol
+data unit (PDU) must be individually padded to four-byte boundaries.
+However, the iSER specification remains mute on the subject of padding.
+It is clear from an implementation perspective that padding data
+segments is both unnecessary and would add considerable overhead to
+implement.  (Possibly a memory copy or extra SG entry on the initiator
+when sending directly from user memory.)   RDMA is used to move all
+data, with byte granularity provided by the network.  The need for
+padding in the TCP case was motivated by the optional marker support to
+work around the limitations of the streaming mode of TCP.  IB and iWARP
+are message-based networks and would never need markers.  And finally,
+the Linux initiator does not add padding either.
+
+
+Using iSER
+----------
+
+Compile tgtd with "make ISCSI_RDMA=1" to build iSER too.  You'll need to
+have two libraries installed on your system:  libibverbs.so and
+librdmacm.so.  If they are not installed in system paths, modify
+CFLAGS and LIBS to find them.
+
+The target will listen on all TCP interfaces (as usual), as well as all
+RDMA devices.  Both use the same default iSCSI port, 3260.  Clients on
+TCP or RDMA will connect to the same tgtd instance.
+
+To make your initiator use RDMA, make sure the "ib_iser" module is
+installed in your kernel.  Then do discovery as usual, over TCP, then
+type something like the following to change the transport type:
+
+	iscsiadm -m node -p $targetip -T $targetname --op update \
+	    -n node.transport_name -v iser
+
+Next, login as usual.  The negotiation phases go across TCP, then both
+sides switch to RDMA for full feature mode.
+
+Note that iSER does not use data or header digests.  This is a feature
+of the specification:  IB and iWARP use better checksums than TCP, so
+digesting is not needed in the application.
+
+
+Errata
+------
+
+The Linux kernel iSER initiator is currently lacking support for
+bidirectional transfers, and for extended command descriptors (CDBs).
+We'll send the patches for these soon.
+
+The Linux kernel iSER initiator uses a different header structure on its
+packets than is in the iSER draft specification.  This is described in
+an InfiniBand document and is required for that network, which only
+supports for Zero-Based Addressing.  If you are using a non-IB initiator
+that doesn't need this header extension, it won't work with tgtd.  There
+may be some way to negotiate the header format.  Using iWARP hardware
+devices with the Linux kernel iSER initiator should be fine, but has not
+been tested yet.
+
+There's no way to find out the IP address of a connecting initiator, so
+ACL support for network addresses is disabled in RDMA mode.  Anybody can
+connect if they are using RDMA.  CHAP authentication still works.
+
+The current code hard-codes the sizes of its resources.  This works fine
+for our particular initiator, but should be dynamic to support other
+initiators.  And Linux iSER does not support the
+MaxOutstandingUnexpectedPDUs parameter, making it rather difficult to
+implement there.
+
-- 
1.5.2.4



From pw at osc.edu  Mon Jul 30 20:59:53 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 14:59:53 -0400
Subject: [Stgt-devel] [PATCH 2/7] iser counter events
In-Reply-To: <20070730185449.GN12789@osc.edu>
References: <20070730185449.GN12789@osc.edu>
Message-ID: <20070730185953.GP12789@osc.edu>

Like fd event handling, also handle integer counter events.  This will
be used in RDMA to make progress on a connection, necessary because
RDMA API does not have a file descriptor that can be used with poll
to detect connection writability.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/tgtd.c |   70 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 usr/tgtd.h |    3 ++
 2 files changed, 69 insertions(+), 4 deletions(-)

diff --git a/usr/tgtd.c b/usr/tgtd.c
index 42e21f4..6744534 100644
--- a/usr/tgtd.c
+++ b/usr/tgtd.c
@@ -41,9 +41,15 @@
 #define MAX_FDS	4096
 
 struct tgt_event {
-	event_handler_t *handler;
+	union {
+		event_handler_t *handler;
+		counter_event_handler_t *counter_handler;
+	};
+	union {
+		int fd;
+		int *counter;
+	};
 	void *data;
-	int fd;
 	struct list_head e_list;
 };
 
@@ -52,6 +58,7 @@ unsigned long pagesize, pageshift, pagemask;
 static int ep_fd;
 static char program_name[] = "tgtd";
 static LIST_HEAD(tgt_events_list);
+static LIST_HEAD(tgt_counter_events_list);
 
 static struct option const long_options[] =
 {
@@ -129,6 +136,22 @@ int tgt_event_add(int fd, int events, event_handler_t handler, void *data)
 	return err;
 }
 
+int tgt_counter_event_add(int *counter, counter_event_handler_t handler,
+			  void *data)
+{
+	struct tgt_event *tev;
+
+	tev = zalloc(sizeof(*tev));
+	if (!tev)
+		return -ENOMEM;
+
+	tev->data = data;
+	tev->counter_handler = handler;
+	tev->counter = counter;
+	list_add(&tev->e_list, &tgt_counter_events_list);
+	return 0;
+}
+
 static struct tgt_event *tgt_event_lookup(int fd)
 {
 	struct tgt_event *tev;
@@ -140,6 +163,17 @@ static struct tgt_event *tgt_event_lookup(int fd)
 	return NULL;
 }
 
+static struct tgt_event *tgt_counter_event_lookup(int *counter)
+{
+	struct tgt_event *tev;
+
+	list_for_each_entry(tev, &tgt_counter_events_list, e_list) {
+		if (tev->counter == counter)
+			return tev;
+	}
+	return NULL;
+}
+
 void tgt_event_del(int fd)
 {
 	struct tgt_event *tev;
@@ -155,6 +189,20 @@ void tgt_event_del(int fd)
 	free(tev);
 }
 
+void tgt_counter_event_del(int *counter)
+{
+	struct tgt_event *tev;
+
+	tev = tgt_counter_event_lookup(counter);
+	if (!tev) {
+		eprintf("Cannot find counter event %p\n", counter);
+		return;
+	}
+
+	list_del(&tev->e_list);
+	free(tev);
+}
+
 int tgt_event_modify(int fd, int events)
 {
 	struct epoll_event ev;
@@ -174,11 +222,25 @@ int tgt_event_modify(int fd, int events)
 
 static void event_loop(void)
 {
-	int nevent, i, timeout = TGTD_TICK_PERIOD * 1000;
+	int nevent, i, done, timeout = TGTD_TICK_PERIOD * 1000;
 	struct epoll_event events[1024];
-	struct tgt_event *tev;
+	struct tgt_event *tev, *tevn;
 
 retry:
+	/*
+	 * Check the counter events to see if they have any work to run.
+	 */
+	do {
+		done = 1;
+		list_for_each_entry_safe(tev, tevn, &tgt_counter_events_list,
+					e_list) {
+			if (*tev->counter) {
+				done = 0;
+				tev->counter_handler(tev->counter, tev->data);
+			}
+		}
+	} while (!done);
+
 	nevent = epoll_wait(ep_fd, events, ARRAY_SIZE(events), timeout);
 	if (nevent < 0) {
 		if (errno != EINTR) {
diff --git a/usr/tgtd.h b/usr/tgtd.h
index c39b9c2..f2ca458 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -195,8 +195,11 @@ extern int tgt_unbind_host_to_target(int tid, int host_no);
 extern int tgt_bound_target_lookup(int host_no);
 
 typedef void (event_handler_t)(int fd, int events, void *data);
+typedef void (counter_event_handler_t)(int *counter, void *data);
 extern int tgt_event_add(int fd, int events, event_handler_t handler, void *data);
+extern int tgt_counter_event_add(int *counter, counter_event_handler_t handler, void *data);
 extern void tgt_event_del(int fd);
+extern void tgt_counter_event_del(int *counter);
 extern int tgt_event_modify(int fd, int events);
 extern int target_cmd_queue(int tid, struct scsi_cmd *cmd);
 extern void target_cmd_done(struct scsi_cmd *cmd);
-- 
1.5.2.4



From pw at osc.edu  Mon Jul 30 21:00:15 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 15:00:15 -0400
Subject: [Stgt-devel] [PATCH 3/7] iser transport buf
In-Reply-To: <20070730185449.GN12789@osc.edu>
References: <20070730185449.GN12789@osc.edu>
Message-ID: <20070730190015.GQ12789@osc.edu>

For RDMA, it is often nice to use data from a pool of pre-registered
buffers.  To do this, the transport allocates memory for a response and
passes it down to the devices to fill.  Some operations, though, allocate
their own buffer and return that new memory instead.  These are usually
small and the allocation is just done for convenience to avoid error
checking.  Copy the data into the provided transport buffer instead.

If the transport does not provide a buffer at cmd->uaddr, the newly
alloced buffer is returned as before.

Also fixes some leaks of these extra buffers in error paths, and cleans
up unreachable code in ibmvio inquiry.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/ibmvio/ibmvio.c |   25 +++++++++----------------
 usr/mmc.c           |    6 ++----
 usr/sbc.c           |    3 +--
 usr/smc.c           |    9 +++++----
 usr/spc.c           |   36 +++++++++++++++++++++++++++---------
 usr/spc.h           |    1 +
 6 files changed, 45 insertions(+), 35 deletions(-)

diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index cdd3782..a0002cf 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -143,10 +143,16 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	uint8_t *data, *scb = cmd->scb;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+	uint32_t len;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
 
+	dprintf("%x %x\n", scb[1], scb[2]);
+
+	if (scb[1] & 0x3)
+		return spc_inquiry(host_no, cmd);
+
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
@@ -155,23 +161,12 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	}
 	memset(data, 0, pagesize);
 
-	dprintf("%x %x\n", scb[1], scb[2]);
-
-	if (!(scb[1] & 0x3)) {
-		cmd->len = __ibmvio_inquiry(host_no, cmd, data);
-		ret = SAM_STAT_GOOD;
-	} else
-		return spc_inquiry(host_no, cmd);
-
-	if (ret != SAM_STAT_GOOD)
-		goto sense;
-
-	cmd->len = min_t(int, cmd->len, scb[4]);
-	cmd->uaddr = (unsigned long) data;
+	len = __ibmvio_inquiry(host_no, cmd, data);
 
 	if (cmd->dev->lun != cmd->dev_id)
 		data[0] = TYPE_NO_LUN;
 
+	spc_return_buf(cmd, data, min_t(int, len, scb[4]));
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
@@ -194,7 +189,6 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 	struct list_head *dev_list = &cmd->c_target->device_list;
 	uint64_t lun, *data;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096;
-	int *len = &cmd->len;
 	uint8_t *lun_buf = cmd->lun;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
@@ -210,7 +204,6 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 		goto sense;
 	}
 	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long)data;
 
 	alen &= ~(8 - 1);
 	oalen = alen;
@@ -240,7 +233,7 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 
 done:
 	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
-	*len = min(oalen, nr_luns * 8 + 8);
+	spc_return_buf(cmd, data, min(oalen, nr_luns * 8 + 8));
 	return SAM_STAT_GOOD;
 sense:
 	*len = 0;
diff --git a/usr/mmc.c b/usr/mmc.c
index 7f70943..74968fb 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -75,7 +75,6 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long) data;
 
 	/* forged for single session data cd only. all iso file fall into this */
 	if (cmd->scb[1] & 0x2) {
@@ -94,7 +93,7 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 		data[6] = 0x01;
 	}
 
-	cmd->len = data[1] + 2;
+	spc_return_buf(cmd, data, data[1] + 2);
 
 	return SAM_STAT_GOOD;
 }
@@ -111,14 +110,13 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long) data;
 
 	size = cmd->dev->size >> MMC_BLK_SHIFT;
 
 	data[0] = (size >> 32) ?
 		__cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
 	data[1] = __cpu_to_be32(1U << MMC_BLK_SHIFT);
-	cmd->len = 8;
+	spc_return_buf(cmd, data, 8);
 
 	return SAM_STAT_GOOD;
 }
diff --git a/usr/sbc.c b/usr/sbc.c
index 33485e6..32100a6 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -121,15 +121,14 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
-	cmd->uaddr = (unsigned long) data;
 
 	size = cmd->dev->size >> BLK_SHIFT;
 
 	data[0] = (size >> 32) ?
 		__cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
 	data[1] = __cpu_to_be32(1U << BLK_SHIFT);
-	cmd->len = 8;
 
+	spc_return_buf(cmd, data, 8);
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
diff --git a/usr/smc.c b/usr/smc.c
index 4f0ee4b..4397523 100644
--- a/usr/smc.c
+++ b/usr/smc.c
@@ -282,8 +282,10 @@ static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
 	}
 	memset(data, 0, pagesize);
 
-	if (scb[11])	/* Reserved byte */
+	if (scb[11]) {	/* Reserved byte */
+		free(data);
 		goto sense;
+	}
 
 	switch(element_type) {
 	case ELEMENT_ANY:
@@ -333,6 +335,7 @@ static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
 						  dvcid, voltag);
 		break;
 	default:
+		free(data);
 		goto sense;
 		break;
 	}
@@ -340,10 +343,8 @@ static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
 	/* Lastly, fill in data header */
 	len = element_status_data_hdr(data, dvcid, voltag, first, count);
 
-	cmd->len = min_t(int, len, alloc_len);
-	cmd->uaddr = (unsigned long) data;
 	cmd->rw = READ;
-
+	spc_return_buf(cmd, data, min_t(int, len, alloc_len));
 	return SAM_STAT_GOOD;
 
 sense:
diff --git a/usr/spc.c b/usr/spc.c
index b56c0b3..d01836e 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -38,6 +38,22 @@
 #define PRODUCT_REV	"0"
 #define BLK_SHIFT	9
 
+/*
+ * Helper to move return data into read result buffer allocated by transport,
+ * if one exists.
+ */
+void spc_return_buf(struct scsi_cmd *cmd, void *data, uint32_t len)
+{
+	if (cmd->uaddr) {
+		memcpy((void *) (unsigned long) cmd->uaddr, data,
+		       min(cmd->len, len));
+		free(data);
+	} else {
+		cmd->uaddr = (unsigned long) data;
+	}
+	cmd->len = len;
+}
+
 int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int len = 0, ret = SAM_STAT_CHECK_CONDITION;
@@ -139,15 +155,17 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 		}
 	}
 
-	if (ret != SAM_STAT_GOOD)
+	if (ret != SAM_STAT_GOOD) {
+		free(data);
 		goto sense;
+	}
 
-	cmd->len = min_t(int, len, scb[4]);
-	cmd->uaddr = (unsigned long) data;
-
+	if (scb[4] < len)
+	    len = scb[4];
 	if (cmd->dev->lun != cmd->dev_id)
 		data[0] = TYPE_NO_LUN;
 
+	spc_return_buf(cmd, data, len);
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
@@ -202,9 +220,8 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 		}
 	}
 
-	cmd->uaddr = (unsigned long)data;
 	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
-	cmd->len = min(oalen, nr_luns * 8 + 8);
+	spc_return_buf(cmd, data, min(oalen, nr_luns * 8 + 8));
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
@@ -278,7 +295,7 @@ static int build_mode_page(uint8_t *data, struct mode_pg *pg)
 int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 {
 	int len = 0;
-	uint8_t *data, *scb, mode6, dbd, pcode, subpcode;
+	uint8_t *data = NULL, *scb, mode6, dbd, pcode, subpcode;
 	uint16_t alloc_len;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
@@ -341,11 +358,12 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 		data[7] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
 	}
 
-	cmd->len = len;
-	cmd->uaddr = (unsigned long)data;
+	spc_return_buf(cmd, data, len);
 	return SAM_STAT_GOOD;
 
 sense:
+	if (data)
+		free(data);
 	cmd->len = 0;
 	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
diff --git a/usr/spc.h b/usr/spc.h
index 1cc8623..c9824c6 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -1,6 +1,7 @@
 #ifndef __SPC_H
 #define __SPC_H
 
+extern void spc_return_buf(struct scsi_cmd *cmd, void *data, uint32_t len);
 extern int spc_inquiry(int host_no, struct scsi_cmd *cmd);
 extern int spc_report_luns(int host_no, struct scsi_cmd *cmd);
 extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
-- 
1.5.2.4



From pw at osc.edu  Mon Jul 30 21:00:23 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 15:00:23 -0400
Subject: [Stgt-devel] [PATCH 4/7] iser bidi alloc read buf
In-Reply-To: <20070730185449.GN12789@osc.edu>
References: <20070730185449.GN12789@osc.edu>
Message-ID: <20070730190023.GR12789@osc.edu>

Allocate the read buffer for bidirectional commands in the transport,
to pass down to devices.  A device can fill and return this buffer in
task->uaddr, and thus choose to do the read or write processing in any
order.  Unfortunately, this allocation can not be combined with the
task and task->data allocation as the bidi read size is not known until
after AHS processing.

Necessary for iscsi RDMA transport to be able to provide its own buffers
too.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |   27 +++++++++++++++++++--------
 usr/tgtd.h         |    2 ++
 2 files changed, 21 insertions(+), 8 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index e092462..be0f449 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -987,6 +987,8 @@ void iscsi_free_task(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 
+	if (task->addr && task->addr != (unsigned long) task->data)
+		free((void *) (unsigned long) task->addr);
 	free(task);
 	/* from alloc */
 	conn_put(conn);
@@ -1002,10 +1004,6 @@ static void iscsi_free_cmd_task(struct iscsi_task *task)
 	target_cmd_done(&task->scmd);
 
 	list_del(&task->c_hlist);
-	if (task->data) {
-		if ((unsigned long) task->data != task->addr)
-			free((void *) (unsigned long) task->addr);
-	}
 	iscsi_free_task(task);
 }
 
@@ -1066,7 +1064,6 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 	struct scsi_cmd *scmd = &task->scmd;
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
-	unsigned long uaddr = (unsigned long) task->data;
 	uint32_t data_len;
 	uint8_t *ahs;
 	int ahslen;
@@ -1109,18 +1106,32 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 
 	/* figure out incoming (write) and outgoing (read) sizes */
 	data_len = 0;
+	scmd->bidi_uaddr = 0;
+	scmd->bidi_len = 0;
+	task->read_len = 0;
 	task->write_len = 0;
+
 	if (task->dir == WRITE || task->dir == BIDIRECTIONAL) {
 		task->write_len = ntohl(req->data_length);
 		data_len = task->write_len;
 	}
-	task->read_len = 0;
 	if (task->dir == BIDIRECTIONAL && ahslen >= 8) {
 		struct iscsi_rlength_ahdr *ahs_bidi = (void *) ahs;
 		if (ahs_bidi->ahstype == ISCSI_AHSTYPE_RLENGTH) {
 			task->read_len = ntohl(ahs_bidi->read_length);
 			dprintf("bidi read len %u\n", task->read_len);
 		}
+		if (task->read_len) {
+			uint32_t len;
+			void *buf;
+			
+			len = roundup(task->read_len, 4);
+			buf = malloc(len);
+			if (!buf)
+				return -ENOMEM;
+			scmd->bidi_uaddr = (unsigned long) buf;
+			scmd->bidi_len = task->read_len;
+		}
 	}
 	if (task->dir == READ) {
 		task->read_len = ntohl(req->data_length);
@@ -1129,10 +1140,10 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 
 	memcpy(scmd->lun, task->req.lun, sizeof(scmd->lun));
 	scmd->rw = req->flags & ISCSI_FLAG_CMD_WRITE;
-	scmd->len = ntohl(req->data_length);
+	scmd->len = data_len;
 	scmd->attribute = cmd_attr(task);
 	scmd->tag = req->itt;
-	scmd->uaddr = uaddr;
+	scmd->uaddr = (unsigned long) task->data;
 
 	return target_cmd_queue(conn->session->target->tid, scmd);
 }
diff --git a/usr/tgtd.h b/usr/tgtd.h
index f2ca458..2e50aac 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -129,6 +129,8 @@ struct scsi_cmd {
 
 	uint64_t uaddr;
 	uint32_t len;
+	uint64_t bidi_uaddr;  /* for read part when bidi */
+	uint32_t bidi_len;
 	int mmapped;
 	struct scsi_lu *dev;
 	unsigned long state;
-- 
1.5.2.4



From pw at osc.edu  Mon Jul 30 21:00:31 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 15:00:31 -0400
Subject: [Stgt-devel] [PATCH 5/7] iser generalize iscsi
In-Reply-To: <20070730185449.GN12789@osc.edu>
References: <20070730185449.GN12789@osc.edu>
Message-ID: <20070730190031.GS12789@osc.edu>

Virtualize more functions in the iscsi transport to support RDMA:
memory management, event modification, and new RDMA read/write calls.

Export some functions from iscsid.c for RDMA to use.  It needs to call
directly to the TX and RX handlers when network or progress events happen.

Add session flag for RDMA.  Transport flag already existed and was unused.

Add two teensy functions in natural places:  be64_to_cpu and back, and
list_del_init.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |   40 +++++++++++++++++++++++++++++++---------
 usr/iscsi/iscsid.c    |   36 +++++++++++++++++++-----------------
 usr/iscsi/iscsid.h    |    8 ++++++++
 usr/iscsi/transport.h |    9 +++++++++
 usr/list.h            |    6 ++++++
 5 files changed, 73 insertions(+), 26 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 0c35aa5..e7f5989 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -183,7 +183,7 @@ static int iscsi_tcp_init(void)
 	return !nr_sock;
 }
 
-static size_t iscsi_tcp_read (int ep, void *buf, size_t nbytes)
+static size_t iscsi_tcp_read(int ep, void *buf, size_t nbytes)
 {
 	return read(ep, buf, nbytes);
 }
@@ -232,13 +232,35 @@ static int iscsi_tcp_show(int ep, char *buf, int rest)
 	return total > 0 ? total : 0;
 }
 
+void iscsi_event_modify(int fd, int events)
+{
+	int ret;
+
+	ret = tgt_event_modify(fd, events);
+	if (ret)
+		eprintf("tgt_event_modify failed");
+}
+
+void *iscsi_tcp_malloc(size_t sz)
+{
+	return malloc(sz);
+}
+
+void iscsi_tcp_free(void *buf)
+{
+	free(buf);
+}
+
 struct iscsi_transport iscsi_tcp = {
-	.name		= "iscsi",
-	.rdma		= 0,
-	.ep_init	= iscsi_tcp_init,
-	.ep_read	= iscsi_tcp_read,
-	.ep_write_begin	= iscsi_tcp_write_begin,
-	.ep_write_end	= iscsi_tcp_write_end,
-	.ep_close	= iscsi_tcp_close,
-	.ep_show	= iscsi_tcp_show,
+	.name			= "iscsi",
+	.rdma			= 0,
+	.ep_init		= iscsi_tcp_init,
+	.ep_read		= iscsi_tcp_read,
+	.ep_write_begin		= iscsi_tcp_write_begin,
+	.ep_write_end		= iscsi_tcp_write_end,
+	.ep_close		= iscsi_tcp_close,
+	.ep_show		= iscsi_tcp_show,
+	.ep_event_modify	= iscsi_event_modify,
+	.ep_malloc		= iscsi_tcp_malloc,
+	.ep_free		= iscsi_tcp_free,
 };
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index be0f449..4a37c6f 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -966,7 +966,7 @@ iscsi_alloc_task(struct iscsi_connection *conn, int ext_len)
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
 	struct iscsi_task *task;
 
-	task = malloc(sizeof(*task) + ext_len);
+	task = conn->tp->ep_malloc(sizeof(*task) + ext_len);
 	if (!task)
 		return NULL;
 	memset(task, 0, sizeof(*task));
@@ -988,8 +988,8 @@ void iscsi_free_task(struct iscsi_task *task)
 	struct iscsi_connection *conn = task->conn;
 
 	if (task->addr && task->addr != (unsigned long) task->data)
-		free((void *) (unsigned long) task->addr);
-	free(task);
+		task->conn->tp->ep_free((void *) (unsigned long) task->addr);
+	task->conn->tp->ep_free(task);
 	/* from alloc */
 	conn_put(conn);
 }
@@ -1034,7 +1034,7 @@ static int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *scmd)
 	}
 
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
-	tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+	task->conn->tp->ep_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 
 	return 0;
 }
@@ -1126,7 +1126,7 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 			void *buf;
 			
 			len = roundup(task->read_len, 4);
-			buf = malloc(len);
+			buf = conn->tp->ep_malloc(len);
 			if (!buf)
 				return -ENOMEM;
 			scmd->bidi_uaddr = (unsigned long) buf;
@@ -1148,7 +1148,7 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 	return target_cmd_queue(conn->session->target->tid, scmd);
 }
 
-static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
+int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
@@ -1158,13 +1158,13 @@ static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 	if (rw && task->r2t_count) {
 		if (!task->unsol_count) {
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
-			tgt_event_modify(conn->fd, EPOLLIN | EPOLLOUT);
+			conn->tp->ep_event_modify(conn->fd, EPOLLIN | EPOLLOUT);
 		}
 		return err;
 	}
 
 	task->offset = 0;  /* for use as transmit pointer for data-ins */
-	tgt_event_modify(conn->fd, EPOLLIN);
+	conn->tp->ep_event_modify(conn->fd, EPOLLIN);
 	err = iscsi_target_cmd_queue(task);
 	return err;
 }
@@ -1194,7 +1194,7 @@ static int iscsi_tm_done(struct mgmt_req *mreq)
 		break;
 	}
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
-	tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+	task->conn->tp->ep_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 	return 0;
 }
 
@@ -1250,7 +1250,8 @@ static int iscsi_task_execute(struct iscsi_task *task)
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_LOGOUT:
 		list_add_tail(&task->c_list, &task->conn->tx_clist);
-		tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+		task->conn->tp->ep_event_modify(task->conn->fd,
+						EPOLLIN | EPOLLOUT);
 		break;
 	case ISCSI_OP_SCSI_CMD:
 		/* convenient directionality for our internal use */
@@ -1270,7 +1271,8 @@ static int iscsi_task_execute(struct iscsi_task *task)
 		err = iscsi_tm_execute(task);
 		if (err) {
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
-			tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+			task->conn->tp->ep_event_modify(task->conn->fd,
+							EPOLLIN | EPOLLOUT);
 		}
 		break;
 	case ISCSI_OP_TEXT:
@@ -1709,7 +1711,7 @@ static int iscsi_task_tx_start(struct iscsi_connection *conn)
 
 nodata:
 	dprintf("no more data\n");
-	tgt_event_modify(conn->fd, EPOLLIN);
+	conn->tp->ep_event_modify(conn->fd, EPOLLIN);
 	return -EAGAIN;
 }
 
@@ -1736,7 +1738,7 @@ static int do_recv(int fd, struct iscsi_connection *conn, int next_state)
 	return ret;
 }
 
-static void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
+void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -1873,7 +1875,7 @@ again:
 			conn_read_pdu(conn);
 	} else {
 		conn_write_pdu(conn);
-		tgt_event_modify(fd, EPOLLOUT);
+		conn->tp->ep_event_modify(fd, EPOLLOUT);
 		ret = cmnd_execute(conn);
 		if (ret)
 			conn->state = STATE_CLOSE;
@@ -1903,7 +1905,7 @@ again:
 	return 0;
 }
 
-static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
+void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -2017,7 +2019,7 @@ static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		else {
 			conn->state = STATE_SCSI;
 			conn_read_pdu(conn);
-			tgt_event_modify(fd, EPOLLIN);
+			conn->tp->ep_event_modify(fd, EPOLLIN);
 		}
 		break;
 	case STATE_EXIT:
@@ -2028,7 +2030,7 @@ static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		break;
 	default:
 		conn_read_pdu(conn);
-		tgt_event_modify(fd, EPOLLIN);
+		conn->tp->ep_event_modify(fd, EPOLLIN);
 		break;
 	}
 }
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index a8c8cb1..95540f2 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -33,8 +33,10 @@
 
 #define cpu_to_be16(x)	__cpu_to_be16(x)
 #define cpu_to_be32(x)	__cpu_to_be32(x)
+#define cpu_to_be64(x)	__cpu_to_be64(x)
 #define be16_to_cpu(x)	__be16_to_cpu(x)
 #define be32_to_cpu(x)	__be32_to_cpu(x)
+#define be64_to_cpu(x)	__be64_to_cpu(x)
 
 #define ISCSI_NAME_LEN 256
 
@@ -89,6 +91,9 @@ struct iscsi_session {
 	struct param session_param[ISCSI_PARAM_MAX];
 
 	char *info;
+
+	/* if this session uses rdma connections */
+	int rdma;
 };
 
 struct iscsi_task {
@@ -261,6 +266,9 @@ extern void iscsi_event_handler(int fd, int events, void *data);
 extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
 extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
 extern void conn_read_pdu(struct iscsi_connection *conn);
+extern void iscsi_tx_handler(int fd, struct iscsi_connection *conn);
+extern void iscsi_rx_handler(int fd, struct iscsi_connection *conn);
+extern int iscsi_scsi_cmd_execute(struct iscsi_task *task);
 
 /* iscsid.c iscsi_task */
 extern void iscsi_free_task(struct iscsi_task *task);
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index ec34bb0..bfba784 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -1,6 +1,9 @@
 #ifndef __TRANSPORT_H
 #define __TRANSPORT_H
 
+struct iscsi_pdu;
+struct iscsi_task;
+
 struct iscsi_transport {
 	const char *name;
 	int rdma;
@@ -11,6 +14,12 @@ struct iscsi_transport {
 	void (*ep_write_end)(int ep);
 	size_t (*ep_close) (int ep);
 	int (*ep_show) (int ep, char *buf, int rest);
+	int (*ep_rdma_write) (int ep, struct iscsi_pdu *rsp,
+			      struct iscsi_task *task);
+	int (*ep_rdma_read) (int ep, struct iscsi_pdu *rsp);
+	void *(*ep_malloc) (size_t sz);
+	void (*ep_free) (void *buf);
+	void (*ep_event_modify) (int ep, int events);
 };
 
 extern struct iscsi_transport iscsi_tcp;
diff --git a/usr/list.h b/usr/list.h
index 3e85c9b..d2e0019 100644
--- a/usr/list.h
+++ b/usr/list.h
@@ -83,4 +83,10 @@ static inline void list_del(struct list_head *entry)
 	entry->next = entry->prev = NULL;
 }
 
+static inline void list_del_init(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	INIT_LIST_HEAD(entry);
+}
+
 #endif
-- 
1.5.2.4



From pw at osc.edu  Mon Jul 30 21:00:51 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 15:00:51 -0400
Subject: [Stgt-devel] [PATCH 6/7] iser rounding
In-Reply-To: <20070730185449.GN12789@osc.edu>
References: <20070730185449.GN12789@osc.edu>
Message-ID: <20070730190051.GT12789@osc.edu>

RDMA data packets are not padded up to 4 byte boundaries, unlike TCP.
Reasons for this can be found in doc/README.iser.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |   24 +++++++++++++++++-------
 1 files changed, 17 insertions(+), 7 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 4a37c6f..4f9194a 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1125,7 +1125,9 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 			uint32_t len;
 			void *buf;
 			
-			len = roundup(task->read_len, 4);
+			len = task->read_len;
+			if (!conn->tp->rdma)
+				len = roundup(len, 4);
 			buf = conn->tp->ep_malloc(len);
 			if (!buf)
 				return -ENOMEM;
@@ -1392,8 +1394,12 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 	int ahs_len, imm_len, data_len, task_len;
 
 	ahs_len = roundup(req->hlength * 4, 4);
-	imm_len = roundup(ntoh24(req->dlength), 4);
-	data_len = roundup(ntohl(req->data_length), 4);
+	imm_len = ntoh24(req->dlength);
+	data_len = ntohl(req->data_length);
+	if (!conn->tp->rdma) {
+		imm_len = roundup(imm_len, 4);
+		data_len = roundup(data_len, 4);
+	}
 
 	dprintf("%u %x %d %d %d %x %x\n", conn->session->tsih,
 		req->cdb[0], ahs_len, imm_len, data_len,
@@ -1770,7 +1776,7 @@ again:
 		}
 		conn->req.ahssize = conn->req.bhs.hlength * 4;
 		conn->req.datasize = ntoh24(conn->req.bhs.dlength);
-		conn->rx_size = roundup(conn->req.ahssize, 4);
+		conn->rx_size = conn->req.ahssize;
 		if (conn->rx_size) {
 			conn->rx_buffer = conn->req.ahs;
 			conn->rx_iostate = IOSTATE_RX_AHS;
@@ -1819,7 +1825,10 @@ again:
 		}
 		conn->rx_iostate = IOSTATE_RX_INIT_DATA;
 	case IOSTATE_RX_INIT_DATA:
-		conn->rx_size = roundup(conn->req.datasize, 4);
+		if (conn->tp->rdma)
+			conn->rx_size = conn->req.datasize;
+		else
+			conn->rx_size = roundup(conn->req.datasize, 4);
 		if (conn->rx_size) {
 			conn->rx_iostate = IOSTATE_RX_DATA;
 			conn->rx_buffer = conn->req.data;
@@ -1959,12 +1968,13 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 			break;
 	case IOSTATE_TX_INIT_DATA:
 		if (conn->rsp.datasize) {
-			int pad;
+			int pad = 0;
 
 			conn->tx_iostate = IOSTATE_TX_DATA;
 			conn->tx_buffer = conn->rsp.data;
 			conn->tx_size = conn->rsp.datasize;
-			pad = conn->tx_size & (PAD_WORD_LEN - 1);
+			if (!conn->tp->rdma)
+				pad = conn->tx_size & (PAD_WORD_LEN - 1);
 			if (pad) {
 				pad = PAD_WORD_LEN - pad;
 				memset(conn->tx_buffer + conn->tx_size, 0, pad);
-- 
1.5.2.4



From pw at osc.edu  Mon Jul 30 21:01:05 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 30 Jul 2007 15:01:05 -0400
Subject: [Stgt-devel] [PATCH 7/7] iser core
In-Reply-To: <20070730185449.GN12789@osc.edu>
References: <20070730185449.GN12789@osc.edu>
Message-ID: <20070730190105.GU12789@osc.edu>

Core iSCSI RDMA support.  Adds the iscsi_rdma.c file implementing
the RDMA transport.

Adds a Makefile bit that get turned on if you define ISCSI_RDMA.
No behavior change if that is not defined.  But requires RDMA API
headers and libraries if it is defined.

Adds iSCSI parameters defined in the draft iSER specification.
No change unless initiatior explictly asks for "RDMAExtensions".

Some checks against conn->tp->rdma in iscsid.c to do
RDMA-specific things that did not warrant new iscsi/transport.h
functions.  This includes handling the lack of a status collapse
in iSER, redirecting R2T and DATA_IN outgoing packets to RDMA
handlers, pushing TX state machine without going through epoll,
and some login negotiation changes.

Errata documented in doc/README.iser.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/Makefile           |    5 +
 usr/iscsi/iscsi_if.h   |    5 +
 usr/iscsi/iscsi_rdma.c | 1451 ++++++++++++++++++++++++++++++++++++++++++++++++
 usr/iscsi/iscsid.c     |   97 +++-
 usr/iscsi/param.c      |   38 ++
 usr/iscsi/session.c    |    2 +
 usr/iscsi/target.c     |    8 +
 usr/iscsi/transport.c  |    3 +
 usr/iscsi/transport.h  |    3 +
 9 files changed, 1603 insertions(+), 9 deletions(-)
 create mode 100644 usr/iscsi/iscsi_rdma.c

diff --git a/usr/Makefile b/usr/Makefile
index f48f259..0f2a116 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -37,6 +37,11 @@ TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o iscsid.o target.o \
 	chap.o transport.o iscsi_tcp.o isns.o libcrc32c.o)
 TGTD_OBJS += bs_sync.o
 LIBS += -lcrypto -lpthread
+ifneq ($(ISCSI_RDMA),)
+CFLAGS += -DISCSI_RDMA
+TGTD_OBJS += iscsi/iscsi_rdma.o
+LIBS += -libverbs -lrdmacm
+endif
 endif
 
 INCLUDES += -I.
diff --git a/usr/iscsi/iscsi_if.h b/usr/iscsi/iscsi_if.h
index 58a76a2..b4f1e04 100644
--- a/usr/iscsi/iscsi_if.h
+++ b/usr/iscsi/iscsi_if.h
@@ -215,6 +215,11 @@ enum iscsi_param {
 	ISCSI_PARAM_OFMARKINT,
 	ISCSI_PARAM_IFMARKINT,
 	ISCSI_PARAM_MAXCONNECTIONS,
+	/* iSER draft */
+	ISCSI_PARAM_RDMA_EXTENSIONS,
+	ISCSI_PARAM_TARGET_RDSL,
+	ISCSI_PARAM_INITIATOR_RDSL,
+	ISCSI_PARAM_MAX_OUTST_PDU,
 	/* must always be last */
 	ISCSI_PARAM_MAX,
 };
diff --git a/usr/iscsi/iscsi_rdma.c b/usr/iscsi/iscsi_rdma.c
new file mode 100644
index 0000000..88b2b48
--- /dev/null
+++ b/usr/iscsi/iscsi_rdma.c
@@ -0,0 +1,1451 @@
+/*
+ * iSCSI extensions for RDMA (iSER) data path
+ *
+ * Copyright (C) 2007 Dennis Dalessandro (dennis at osc.edu)
+ * Copyright (C) 2007 Ananth Devulapalli (ananth at osc.edu)
+ * Copyright (C) 2007 Pete Wyckoff (pw at osc.edu)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <sys/epoll.h>
+#include <sys/socket.h>
+#include <stdarg.h>
+#include <math.h>
+#include <sys/types.h>
+#include <libgen.h>
+#include <sys/errno.h>
+#include <time.h>
+#include <assert.h>
+#include <poll.h>
+
+#if 0 && !defined(NDEBUG)
+#include <valgrind/memcheck.h>
+#else
+#define VALGRIND_MAKE_MEM_DEFINED(addr,len)
+#endif
+
+#include "infiniband/verbs.h"
+#include "rdma/rdma_cma.h"
+#include "util.h"
+#include "iscsid.h"
+#include "tgtd.h"
+#include "list.h"
+
+#ifndef NDEBUG
+#define iser_debug_level 10
+#define iser_out(lvl,fmt,args...) \
+    do { \
+		if (lvl <= iser_debug_level) \
+		iser_print_info(fmt,##args); \
+    } while (0)
+#else
+#define iser_out(lvl,fmt,...) do { } while (0)
+#endif
+
+/*
+ * The IB-extended version from the kernel.  Stags and VAs are in
+ * big-endian format.
+ */
+struct iser_hdr {
+	uint8_t   flags;
+	uint8_t   rsvd[3];
+	uint32_t  write_stag; /* write rkey */
+	uint64_t  write_va;
+	uint32_t  read_stag;  /* read rkey */
+	uint64_t  read_va;
+} __attribute__((packed));
+
+#define ISER_WSV	(0x08)
+#define ISER_RSV	(0x04)
+#define ISCSI_CTRL	(0x10)
+#define ISER_HELLO	(0x20)
+#define ISER_HELLORPLY	(0x30)
+
+struct recvlist {
+	struct list_head list;
+	struct ibv_sge		sge;
+	void			*buf;
+	struct ibv_recv_wr	wr;
+	int			conn_index;
+	unsigned long		bytes_recvd;
+};
+
+struct sendlist {
+	struct list_head list;
+	struct ibv_sge		sge;
+	void			*buf;
+	struct ibv_send_wr	wr;
+	int			conn_index;
+	int			free; /* if 1 can use if 0 already in use */
+};
+
+/* pre-registered memory for RDMA ops */
+struct mempool {
+	struct list_head list;
+	void *buf;
+};
+
+/* rem_va & rem_stag already available in struct ibv_send_wr */
+struct rdmalist {
+	struct list_head list;
+	struct ibv_sge		sge;
+	void			*buf;
+	struct ibv_send_wr	wr;
+	int			conn_index;
+	int			free;
+	struct iscsi_task	*task;
+};
+
+/*
+ * One of these for each iscsi_connection, adds more fields needed for iser.
+ */
+struct conn_info {
+	int			valid, busy;
+	int			conn_num;  /* index into cl.conn[] */
+	struct ibv_qp		*qp_hndl;
+	struct rdma_cm_id	*cma_id;
+	struct iscsi_connection *iscsi_conn;
+	size_t			rlen;
+	size_t			slen;
+	/* read and write from the initiator's point of view */
+	uint32_t rem_read_stag, rem_write_stag;
+	uint64_t rem_read_va, rem_write_va;
+	/*
+	 * TODO: mv readb/writeb to some task like struct. In case of
+	 * multithreaded apps they will fail.
+	 */
+	uint32_t readb;
+	uint32_t writeb;
+
+	void *srbuf;    /* all sends and recvs on this connection (not rdma) */
+	void *listbuf;  /* space for the send, recv, rdma list elements */
+	struct ibv_mr *srmr;   /* mr for registered srbuf */
+
+	/* point to the lists */
+	struct list_head rdmal, sendl, recvl;
+	struct list_head rdmal_write_busy;  /* rdma writes in progress */
+
+	/* points to the current recvlist, sendlist items for each conn */
+	struct	recvlist	*rcv_comm_event;
+	struct	sendlist	*send_comm_event;
+
+	/* to chain this connection onto the list of those ready to tx */
+	struct list_head conn_tx_ready;
+};
+
+#define ISCSI_LISTEN_PORT	3260
+
+#define MAX_CONN 256
+#define MAX_WQE 250
+#define MAX_SSIZE 8192
+#define MAX_RSIZE 8192
+#define ISER_INITIAL_POST 10  /*XXX make this a global variable and set it to what gets negotiated at login*/
+
+#define MEMPOOL_SZ (64)
+/* 512K + sizeof(iscsi_task) + AHS size */
+#define MEM_SZ (roundup((1 << 19) + sizeof(struct iscsi_task) + 260+28+48, \
+			4096))
+
+#define uint64_from_ptr(p) ((uint64_t)(uintptr_t)(p))
+#define ptr_from_int64(p) (void *)(unsigned long)(p)
+
+/* global connection list variables */
+struct rdma_conn_list {
+	struct conn_info conn[MAX_CONN];
+	/*variables that all connections will share*/
+	struct ibv_context	*ibv_hndl;
+	struct rdma_event_channel *rdma_evt_channel;
+	struct rdma_cm_id	*cma_listen_id;
+	struct ibv_pd		*prot_id;
+	struct ibv_cq		*cq_hndl;
+	struct ibv_comp_channel *cq_channel;
+	struct list_head conn_tx_ready;  /* conns with tasks ready to tx */
+
+	/* prereg rdma bufs */
+	void *regbuf;
+	void *membuf;
+	struct ibv_mr *regmr;
+	struct list_head freel, allocl;
+	int num_tx_ready;
+};
+static struct rdma_conn_list cl;
+
+static void iser_cqe_handler(int fd, int events, void *data);
+static ssize_t iser_rdma_read_completion(struct rdmalist *rdma);
+static int handle_wc(struct ibv_wc *wc);
+static void iser_progress(int *counter, void *data);
+static void iser_event_modify(int ep, int events);
+
+#ifndef NDEBUG
+static void iser_print_info(const char *fmt, ...)
+{
+	va_list ap;
+	fprintf(stderr, "[iSER]:");
+	va_start(ap, fmt);
+	vfprintf(stderr, fmt, ap);
+	va_end(ap);
+	fprintf(stderr, ".\n");
+}
+#endif
+
+static void openfab_error(const char *msg, int code)
+{
+	char error_string[256];
+	strerror_r(code, error_string, sizeof(error_string));
+	fprintf(stderr,"----------ERROR----------\n");
+	fprintf(stderr, "%s : %s\n", msg, error_string);
+	fprintf(stderr,"----------ERROR----------\n");
+}
+
+static int conn_find_free(void)
+{
+	int i;
+
+	for (i=0; i < MAX_CONN; i++)
+		if (cl.conn[i].busy == 0) {
+			cl.conn[i].busy = 1;
+			return i;
+		}
+	return -1;
+}
+
+static int iser_match_qp(uint32_t qp_num)
+{
+	int i;
+
+	iser_out(5, "%s() Looking for QP num %d", __func__, qp_num);
+	for (i=0; i<MAX_CONN; i++) {
+		if (cl.conn[i].valid == 1) { /* don't look at invalid conns */
+			if (qp_num == cl.conn[i].qp_hndl->qp_num) {
+				return i;
+			}
+		}
+	}
+	return -1;
+}
+
+static int iser_init_comm(struct conn_info *conn, ssize_t ssize,
+			  ssize_t rsize, int id)
+{
+	int i;
+	unsigned long size;
+	uint8_t *srbuf, *listbuf;
+	struct rdmalist *rdmal;
+	struct sendlist *sendl;
+	struct recvlist *recvl;
+
+	size = (rsize + ssize) * ISER_INITIAL_POST;
+	conn->srbuf = malloc(size);
+	if (!conn->srbuf) {
+		eprintf("malloc srbuf %lu\n", size);
+		return -ENOMEM;
+	}
+	conn->srmr = ibv_reg_mr(cl.prot_id, conn->srbuf, size,
+				IBV_ACCESS_LOCAL_WRITE);
+	if (!conn->srmr) {
+		eprintf("register srbuf\n");
+		return -1;
+	}
+
+	INIT_LIST_HEAD(&conn->sendl);
+	INIT_LIST_HEAD(&conn->recvl);
+	INIT_LIST_HEAD(&conn->rdmal);
+	INIT_LIST_HEAD(&conn->rdmal_write_busy);
+
+	size = ISER_INITIAL_POST * (sizeof(struct rdmalist)
+		+ sizeof(struct sendlist) + sizeof(struct recvlist));
+	conn->listbuf = malloc(size);
+	if (!conn->listbuf) {
+		eprintf("malloc listbuf %lu\n", size);
+		return -1;
+	}
+
+	srbuf = conn->srbuf;
+	listbuf = conn->listbuf;
+	for (i=0; i<ISER_INITIAL_POST; i++){
+		rdmal = (void *) listbuf;
+		listbuf += sizeof(*rdmal);
+
+		sendl = (void *) listbuf;
+		listbuf += sizeof(*sendl);
+
+		recvl = (void *) listbuf;
+		listbuf += sizeof(*recvl);
+
+		recvl->buf = srbuf;
+		srbuf += rsize;
+
+		sendl->buf = srbuf;
+		srbuf += ssize;
+
+		rdmal->conn_index = id;
+		sendl->conn_index = id;
+		recvl->conn_index = id;
+
+		sendl->free = 1;
+		rdmal->free = 1;
+
+		list_add_tail(&sendl->list, &conn->sendl);
+		list_add_tail(&recvl->list, &conn->recvl);
+		list_add_tail(&rdmal->list, &conn->rdmal);
+	}
+	conn->slen = ssize;
+	conn->rlen = rsize;
+
+	return 0;
+}
+
+static int iser_init_mempool(void)
+{
+	int i = 0;
+	struct mempool *freel;
+	uint8_t *regbuf, *membuf;
+	size_t size = MEM_SZ * MEMPOOL_SZ;
+
+	cl.regbuf = malloc(size);
+	if (!cl.regbuf) {
+		eprintf("malloc regbuf %lu\n", size);
+		return -ENOMEM;
+	}
+	cl.regmr = ibv_reg_mr(cl.prot_id, cl.regbuf, size,
+			      IBV_ACCESS_LOCAL_WRITE);
+	if (!cl.regmr) {
+		eprintf("register regbuf\n");
+		return -1;
+	}
+
+	INIT_LIST_HEAD(&cl.freel);
+	INIT_LIST_HEAD(&cl.allocl);
+	size = MEMPOOL_SZ * sizeof(struct mempool);
+	cl.membuf = malloc(size);
+	if (!cl.membuf) {
+		eprintf("malloc membuf %lu\n", size);
+		return -ENOMEM;
+	}
+	
+	membuf = cl.membuf;
+	regbuf = cl.regbuf;
+	for (i = 0; i < MEMPOOL_SZ; i++) {
+		freel = (void *)membuf;
+		membuf += sizeof(*freel);
+		freel->buf = regbuf;
+		regbuf += MEM_SZ;
+
+		list_add_tail(&freel->list, &cl.freel);
+	}
+
+	return 0;
+}
+
+static int iser_init_wr(struct conn_info *conn)
+{
+	int ret;
+	struct sendlist *sendl;
+	struct recvlist *recvl;
+	struct ibv_recv_wr *bad_wr;
+
+	iser_out(8, "%s() Entry", __func__);
+
+	list_for_each_entry(sendl, &conn->sendl, list) {
+		sendl->sge.addr = uint64_from_ptr(sendl->buf);
+		sendl->sge.length = conn->slen;
+		sendl->sge.lkey = conn->srmr->lkey;
+
+		memset(&(sendl->wr), 0, sizeof(sendl->wr));
+		sendl->wr.wr_id = uint64_from_ptr(sendl);
+		sendl->wr.sg_list = &(sendl->sge);
+		sendl->wr.num_sge = 1;
+		sendl->wr.opcode = IBV_WR_SEND;
+		sendl->wr.send_flags = IBV_SEND_SIGNALED;
+	}
+
+	list_for_each_entry(recvl, &conn->recvl, list) {
+		recvl->sge.addr = uint64_from_ptr(recvl->buf);
+		recvl->sge.length = conn->rlen;
+		recvl->sge.lkey = conn->srmr->lkey;
+
+		memset(&(recvl->wr), 0, sizeof(recvl->wr));
+		recvl->wr.wr_id = uint64_from_ptr(recvl);
+		recvl->wr.sg_list = &(recvl->sge);
+		recvl->wr.num_sge = 1;
+		recvl->wr.next = NULL;
+
+		ret = ibv_post_recv(conn->qp_hndl, &recvl->wr, &bad_wr);
+		if (ret) {
+			openfab_error("Can't post RECV", errno);
+			return -1;
+		}
+
+		iser_out(5, "%s() Send/Recv Init - Recv Posted wr_id %p",
+			 __func__, recvl);
+	}
+
+	iser_out(8, "%s() Exit", __func__);
+	return 0;
+}
+
+static void iser_accept_connection(struct rdma_cm_event *event)
+{
+	int ret, cqe_num;
+	struct ibv_device_attr device_attr;
+	struct ibv_qp_init_attr qp_init_attr;
+	int conn_index;
+	ssize_t rsize;
+	struct conn_info *ci;
+	struct rdma_conn_param conn_param = {
+		.responder_resources = 1,
+		.initiator_depth = 1,
+		.retry_count = 5,
+	};
+	int need_notify;
+
+	iser_out(8, "%s() Entry", __func__);
+
+	if (cl.ibv_hndl == NULL) {
+		cl.ibv_hndl = event->id->verbs;
+
+		/* allocate PD */
+		cl.prot_id = ibv_alloc_pd(cl.ibv_hndl);
+		if (!cl.prot_id)
+			openfab_error("Unable to create PD", errno);
+
+		ret = iser_init_mempool();
+		if (ret) {	
+			iser_out(4, "%s iser_init_mempool failed", __func__);
+			return;
+		}
+	}
+
+
+	need_notify = 0;
+	if (cl.cq_channel == NULL) {
+		ret = ibv_query_device(cl.ibv_hndl, &device_attr);
+		if (ret < 0) {
+			openfab_error("Unable to query device for max CQs",
+					errno);
+			exit(1);
+		}
+		iser_out(5, "%s() Max %d completion queue entries", __func__,
+					device_attr.max_cqe);
+		cqe_num = device_attr.max_cqe;
+
+		cl.cq_channel = ibv_create_comp_channel(cl.ibv_hndl);
+		if (!cl.cq_channel) {
+			openfab_error("Unable to create CQ channel", errno);
+			exit(1);
+		}
+
+		cl.cq_hndl = ibv_create_cq(cl.ibv_hndl, cqe_num, NULL,
+						cl.cq_channel, 0);
+		if (!cl.cq_hndl) {
+			openfab_error("Unable to create CQ", errno);
+			exit(1);
+		}
+
+		ret = tgt_event_add(cl.cq_channel->fd, EPOLLIN,
+				iser_cqe_handler, NULL);
+		if (ret) {
+			eprintf("Unable to add CQ channel FD to poll %m");
+			exit(1);
+
+		}
+
+		need_notify = 1;
+	}
+
+	/* now it gets specific for each connection */
+	conn_index = conn_find_free();
+	if (conn_index < 0) {
+		iser_out(0, "Unable to find a free connection");
+		return;
+	}
+
+	iser_out(2, "%s() Using connection index %d", __func__, conn_index);
+
+	ci = &cl.conn[conn_index];
+
+	ci->cma_id = event->id;
+
+	/* create qp next */
+	memset(&qp_init_attr, 0, sizeof(qp_init_attr));
+	/* wire both send and recv to the same CQ */
+	qp_init_attr.send_cq =  cl.cq_hndl;
+	qp_init_attr.recv_cq  = cl.cq_hndl;
+	qp_init_attr.cap.max_send_wr = MAX_WQE;
+	qp_init_attr.cap.max_recv_wr = MAX_WQE;
+	qp_init_attr.cap.max_send_sge = 1;  /* scatter/gather entries */
+	qp_init_attr.cap.max_recv_sge = 1;
+	qp_init_attr.qp_type = IBV_QPT_RC;
+	/* only generate completion queue entries if requested */
+	qp_init_attr.sq_sig_all = 0;
+
+	ret = rdma_create_qp(ci->cma_id, cl.prot_id, &qp_init_attr);
+	if (ret) {
+		eprintf("create qp failed\n");
+		return;
+	}
+	ci->qp_hndl = ci->cma_id->qp;
+	VALGRIND_MAKE_MEM_DEFINED(ci->qp_hndl, sizeof(*ci->qp_hndl));
+
+	iser_out(5, "%s() QP num = %d", __func__, ci->qp_hndl->qp_num);
+
+	/* Leave room for iser hdr, iscsi hdr, ahs extcdb, ahs rhdr,
+	 * immediate data.  Should negotiate max immediate data.  */
+	rsize = sizeof(struct iser_hdr) + sizeof(struct iscsi_hdr)
+		+ sizeof(struct iscsi_ecdb_ahdr)
+		+ sizeof(struct iscsi_rlength_ahdr) + MAX_RSIZE;
+	ret = iser_init_comm(ci, MAX_SSIZE, rsize, conn_index);
+	if (ret) {
+		eprintf("Unable to init send/recv mem regions");
+		return;
+	}
+
+	ret = iser_init_wr(ci);
+	if (ret) {
+		/* should never happen */
+		eprintf("Unable to init work requests");
+		return;
+	}
+
+
+	if (need_notify) {
+		iser_out(5, "%s() Need to set notif", __func__);
+		ret = ibv_req_notify_cq(cl.cq_hndl, 0);  /*get CQE for recv*/
+		if (ret) {
+			openfab_error("Can't req notify", ret);
+			return;
+		}
+	}
+
+	/* now we can actually accept the connection */
+	ret = rdma_accept(ci->cma_id, &conn_param);
+	if (ret) {
+		eprintf("rdma_accept failed\n");
+		return;
+	}
+}
+
+/*
+ * Finish putting the connection together, now that the other side
+ * has ACKed our acceptance.
+ */
+static void iser_conn_established(struct rdma_cm_event *event)
+{
+	int i, conn_index = -1;
+	struct conn_info *ci;
+
+	for (i=0; i<MAX_CONN; i++)
+		if (cl.conn[i].cma_id == event->id) {
+			conn_index = i;
+			break;
+		}
+	if (conn_index == -1) {
+		eprintf("cma id %p not found\n", event->id);
+		return;
+	}
+	ci = &cl.conn[conn_index];
+
+	iser_out(2, "%s() Connection fully accepted at index %d", __func__,
+		conn_index);
+
+	ci->rcv_comm_event = NULL;
+	ci->send_comm_event = NULL;
+	ci->readb = ci->writeb = 0;
+	ci->iscsi_conn = conn_alloc();
+	if (!ci->iscsi_conn) {
+		eprintf("unable to allocate iscsi_conn\n");
+		return;
+	}
+
+	ci->iscsi_conn->fd = conn_index;
+	ci->iscsi_conn->tp = &iscsi_iser;
+	conn_read_pdu(ci->iscsi_conn); /* just to set state */
+	INIT_LIST_HEAD(&ci->conn_tx_ready);
+	ci->valid = 1;  /* now can mark the connection ready */
+}
+
+static void iser_disconnect(struct rdma_cm_event *ev)
+{
+	int ind, ret, i;
+	struct conn_info *ci;
+
+	iser_out(8, "%s() Entry", __func__);
+
+	ind = iser_match_qp(ev->id->qp->qp_num);
+
+	if (ind < 0) {
+		eprintf("Unable to look up connection");
+		return;
+	}
+	ci = &cl.conn[ind];
+
+	iser_out(5, "%s() Connection Index = %d", __func__, ind);
+
+	/* invalidate conn */
+	ci->valid = 0;
+	list_del_init(&ci->conn_tx_ready);
+
+	/* disconnect */
+	ret = rdma_disconnect(ci->cma_id);
+	if (ret) {
+		openfab_error("Unable to disconnect cma id", -ret);
+	} else {
+		iser_out(5, "%s() RDMA disconnect complete", __func__);
+	}
+
+	/* flush receive work requests */
+	for (i=0; i<ISER_INITIAL_POST; ) {
+		struct ibv_wc wc;
+		ret = ibv_poll_cq(cl.cq_hndl, 1, &wc);
+		if (ret < 0) {
+			eprintf("ibv_poll_cq %d", ret);
+			exit(1);
+		} else if (ret == 0) {
+			usleep(1000);
+		} else {
+			VALGRIND_MAKE_MEM_DEFINED(&wc, sizeof(wc));
+			if (wc.status == IBV_WC_WR_FLUSH_ERR) {
+				++i;
+			} else if (wc.status == IBV_WC_SUCCESS) {
+				/* handle somebody else's WR */
+				ret = handle_wc(&wc);
+				if (ret)
+					eprintf("oops\n");
+			} else {
+				eprintf("bad WC status %d for wr_id 0x%lx\n",
+					wc.status, wc.wr_id);
+				exit(1);
+			}
+		}
+	}
+
+	/* free iscsi_conn */
+	if (ci->iscsi_conn->refcount != 1)
+		eprintf("iscsi conn refcount = %d\n", ci->iscsi_conn->refcount);
+	conn_put(ci->iscsi_conn);
+
+	iser_out(5, "%s() iscsi_conn is deallocated", __func__);
+
+	/* release mr and free the lists */
+	ret = ibv_dereg_mr(ci->srmr);
+	if (ret)
+		eprintf("ibv_dereg_mr\n");
+	free(ci->srbuf);
+	free(ci->listbuf);
+
+/*	ret = ibv_dereg_mr(ci->regmr);
+	if (ret)
+		eprintf("ibv_dereg_mr failed\n");
+	free(ci->regbuf);
+	free(ci->membuf); */
+
+	iser_out(5, "%s() Done freeing recv, send and rdma lists", __func__);
+
+	/* then can destory QP */
+	ret = ibv_destroy_qp(ci->qp_hndl); /* XXX: efence cribs: free err */
+	if (ret) {
+		openfab_error("Unable to destroy QP", -ret);
+	}
+
+	ci->busy = 0;
+	iser_out(8, "%s() Exit", __func__);
+}
+
+/*
+ * Handle RDMA connection events.
+ */
+void iser_handle_rdmacm(int fd __attribute__((unused)),
+			int events __attribute__((unused)),
+			void *data __attribute__((unused)))
+{
+	int ret;
+	struct rdma_cm_event *event;
+	struct rdma_cm_id *destroy_cm_id = NULL;
+
+	iser_out(8, "%s() Entry", __func__);
+
+	ret = rdma_get_cm_event(cl.rdma_evt_channel, &event);
+	if (ret) {
+		eprintf("rdma_get_cm_event failed\n");
+		return;
+	}
+
+	VALGRIND_MAKE_MEM_DEFINED(event, sizeof(*event));
+	switch (event->event) {
+	case RDMA_CM_EVENT_CONNECT_REQUEST:
+		iser_accept_connection(event);
+		break;
+	case RDMA_CM_EVENT_ESTABLISHED:
+		iser_conn_established(event);
+		break;
+	case RDMA_CM_EVENT_DISCONNECTED:
+		iser_disconnect(event);
+		destroy_cm_id = event->id;
+		break;
+	default:
+		eprintf("unknown event %d\n", event->event);
+		break;
+	}
+
+	ret = rdma_ack_cm_event(event);
+	if (ret) {
+		eprintf("ack cm event failed\n");
+		return;
+	}
+
+	if (destroy_cm_id) {
+		ret = rdma_destroy_id(destroy_cm_id);
+		if (ret)
+			eprintf("rdma_destroy_id failed\n");
+	}
+}
+
+/*
+ * Deal with just one work completion.
+ * TODO: When getting a completion event set the xxx_comm_event to NULL
+ */
+static int handle_wc(struct ibv_wc *wc)
+{
+	int ret = 0;
+	struct recvlist *recvl;
+	struct sendlist *sendl;
+	struct rdmalist *rdmal, *rc, *rn;
+	struct conn_info *ci;
+	struct ibv_recv_wr *bad_wr;
+
+	switch (wc->opcode) {
+	case IBV_WC_SEND:
+		iser_out(5, "%s() Outgoing Cmd - COMPLETE", __func__);
+		sendl = ptr_from_int64(wc->wr_id);
+		ci = &cl.conn[sendl->conn_index];
+		if (ci->iscsi_conn->state == STATE_CLOSE)
+			goto close_err;
+
+		sendl->free = 1;
+		break;
+
+	case IBV_WC_RDMA_WRITE:
+		iser_out(5, "%s() Outgoing Data - COMPLETE", __func__);
+		rdmal = ptr_from_int64(wc->wr_id);
+		ci = &cl.conn[rdmal->conn_index];
+		if (ci->iscsi_conn->state == STATE_CLOSE)
+			goto close_err;
+
+		dprintf("putting ep %d back on tx ready list\n",
+			rdmal->conn_index);
+		iser_event_modify(rdmal->conn_index, EPOLLIN | EPOLLOUT);
+
+		/*
+		 * Free this one and the previous unsignaled writes that
+		 * must have completed by now.
+		 */
+		list_for_each_entry_safe(rc, rn, &ci->rdmal_write_busy, list) {
+			if (rc->task == rdmal->task) {
+				rc->free = 1;
+				list_del(&rc->list);
+				list_add(&rc->list, &ci->rdmal);
+			}
+		}
+		break;
+
+	case IBV_WC_RDMA_READ:
+		iser_out(5, "%s() Incoming RDMA READ data", __func__);
+		rdmal = ptr_from_int64(wc->wr_id);
+		ci = &cl.conn[rdmal->conn_index];
+		if (ci->iscsi_conn->state == STATE_CLOSE)
+			goto close_err;
+
+		assert(rdmal->sge.length == wc->byte_len);
+		iser_rdma_read_completion(rdmal);
+		rdmal->free = 1;
+		break;
+
+	case IBV_WC_RECV:
+		iser_out(5, "%s() Incoming Cmd - COMPLETE (%d bytes)",
+			 __func__, wc->byte_len);
+		recvl = ptr_from_int64(wc->wr_id);
+		ci = &cl.conn[recvl->conn_index];
+		if (ci->iscsi_conn->state == STATE_CLOSE)
+			goto close_err;
+
+		recvl->bytes_recvd = wc->byte_len;
+		VALGRIND_MAKE_MEM_DEFINED(recvl->buf, recvl->bytes_recvd);
+
+		/*
+		 * Global pointer to the working receive on this connection
+		 * for reads from iscsid.c.
+		 */
+		ci->rcv_comm_event = recvl;
+		iscsi_rx_handler(recvl->conn_index, ci->iscsi_conn);
+		ci->rcv_comm_event = NULL;
+
+		ret = ibv_post_recv(ci->qp_hndl, &recvl->wr, &bad_wr);
+		if (ret) {
+			eprintf("ibv_post_recv failed\n");
+			exit(1);
+		}
+
+		iser_out(5, "%s() Done processing recv %p, reposted it",
+			 __func__, recvl);
+		break;
+
+	default:
+		eprintf("unexpected opcode %d\n", wc->opcode);
+		exit(1);
+	}
+
+	/*
+	 * XXX:
+	 *	The impl assumes single threaded backing store. If there is
+	 *	more than one thread, then event driven mechanism will break,
+	 *	which won't trigger tx_handler, and will disrupt request
+	 *	reply sequence.
+	 *
+	 * TODO:
+	 *	handle breach of MAX OUTSTANDING requests
+	 */
+
+	return ret;
+
+close_err:
+	eprintf("conn state set to closed .. IMPLEMENT ME\n");
+	/* conn_close(conn, fd); */
+	exit(1);
+}
+
+/*
+ * Called directly from main event loop when a CQ notification is
+ * available.
+ */
+static void iser_cqe_handler(int fd __attribute__((unused)),
+			     int events __attribute__((unused)),
+			     void *data __attribute__((unused)))
+{
+	int ret;
+	struct ibv_wc wc;
+	void *cq_context;
+
+	iser_out(8, "%s() Entry", __func__);
+
+	ret = ibv_get_cq_event(cl.cq_channel, &cl.cq_hndl, &cq_context);
+	if (ret != 0){
+		eprintf("notification, but no CQ event\n");
+		exit(1);
+	}
+
+	ibv_ack_cq_events(cl.cq_hndl, 1);
+
+	ret = ibv_req_notify_cq(cl.cq_hndl, 0);
+	if (ret) {
+		openfab_error("Can't req notify", ret);
+		exit(1);
+	}
+
+	/* drain the CQ */
+	for (;;) {
+		ret = ibv_poll_cq(cl.cq_hndl, 1, &wc);
+		if (ret < 0) {
+			eprintf("ibv_poll_cq %d\n", ret);
+			exit(1);
+		} else if (ret == 0) {
+			break;
+		}
+
+		VALGRIND_MAKE_MEM_DEFINED(&wc, sizeof(wc));
+		if (wc.status != IBV_WC_SUCCESS) {
+			eprintf("bad WC status %d for wr_id 0x%lx\n", wc.status,
+				wc.wr_id);
+			exit(1);
+		}
+		ret = handle_wc(&wc);
+		if (ret)
+			break;
+	}
+
+	iser_out(8, "%s() Exit", __func__);
+}
+
+static int iser_parse_hdr(struct conn_info *ci, struct recvlist *recvl)
+{
+	int ret;
+	struct iser_hdr *hdr = recvl->buf;
+
+	switch (hdr->flags & 0xF0) {
+	case ISCSI_CTRL:
+		iser_out(4, "iSCSI control type PDU");
+		if (hdr->flags & ISER_RSV) {
+			ci->rem_read_stag = be32_to_cpu(hdr->read_stag);
+			ci->rem_read_va = be64_to_cpu(hdr->read_va);
+			iser_out(4, "rem_read_stag %x rem_read_va %lx",
+				 ci->rem_read_stag, ci->rem_read_va);
+		}
+		if (hdr->flags & ISER_WSV) {
+			ci->rem_write_stag = be32_to_cpu(hdr->write_stag);
+			ci->rem_write_va = be64_to_cpu(hdr->write_va);
+			iser_out(4, "rem_write_stag %x rem_write_va %lx",
+				 ci->rem_write_stag, ci->rem_write_va);
+		}
+		ret = 0;
+		break;
+	case ISER_HELLO:
+		iser_out(4, "iSER Hello message??");
+		ret = -1;
+		break;
+	default:
+		iser_out(4, "Malformed iser hdr");
+		ret = -1;
+		break;
+	}
+
+	ci->readb = sizeof(*hdr);
+	return ret;
+}
+
+static size_t iscsi_iser_read(int ind, void *buf, size_t nbytes)
+{
+	int ret;
+	struct conn_info *ci;
+	struct recvlist *recvl;
+
+	iser_out(4, "in %s buf %p nbytes %d", __func__, buf, nbytes);
+
+	ci = &cl.conn[ind];
+	if (!ci->valid) {
+		eprintf("conn %d not valid\n", ind);
+		exit(1);
+	}
+
+	recvl = ci->rcv_comm_event;
+	assert(recvl != NULL);
+
+	if (ci->readb == 0) {
+		if (recvl->bytes_recvd < sizeof(struct iser_hdr))
+			return 0;
+
+		ret = iser_parse_hdr(ci, recvl);
+		if (ret != 0)
+			return 0;
+	}
+
+	if (ci->readb + nbytes > recvl->bytes_recvd) {
+		if (ci->readb > recvl->bytes_recvd)
+			nbytes = recvl->bytes_recvd;
+		else
+			nbytes = recvl->bytes_recvd - ci->readb;
+	}
+
+	/* TODO: can this copy be eliminated? */
+	memcpy(buf, (char *)recvl->buf + ci->readb, nbytes);
+	ci->readb += nbytes;
+
+	if (ci->readb == recvl->bytes_recvd) {
+		memset(recvl->buf, 0, ci->readb); /* TODO: for debugging */
+		ci->readb = 0;
+		/* TODO: should we dequeu the recvl?? */
+	}
+
+	iser_out(4, "%s ret %d", __func__, nbytes);
+	return nbytes;
+}
+
+static size_t iscsi_iser_write_begin(int ind, void *buf, size_t nbytes)
+{
+	struct conn_info *ci;
+	struct sendlist *send;
+
+	iser_out(4, "in %s nbytes %d", __func__, nbytes);
+
+	ci = &cl.conn[ind];
+	if (!ci->valid) {
+		eprintf("conn %d not valid\n", ind);
+		exit(1);
+	}
+
+	if (ci->send_comm_event == NULL) {
+		int found = 0;
+		/* find one, first time here */
+		list_for_each_entry(send, &ci->sendl, list) {
+			if (send->free) {
+				found = 1;
+				break;
+			}
+		}
+		if (!found) {
+			eprintf("Unable to find send slot\n");
+			return 0;
+		}
+		send->free = 0;
+		ci->send_comm_event = send;
+		iser_out(4, "%s: alloc new send event %p", __func__, send);
+	} else {
+		send = ci->send_comm_event;
+		iser_out(4, "%s: reuse existing send event %p", __func__, send);
+	}
+
+	if (ci->writeb + nbytes > MAX_SSIZE) {
+		eprintf("send buf overflow %d + %zd", ci->writeb, nbytes);
+		exit(1);
+	}
+
+	if (ci->writeb == 0) {
+		/* insert iser hdr */
+		struct iser_hdr *hdr = send->buf;
+
+		memset(hdr, 0, sizeof(*hdr));
+		hdr->flags = ISCSI_CTRL;
+		ci->writeb = sizeof(*hdr);
+	}
+
+	memcpy((char *)send->buf + ci->writeb, buf, nbytes);
+	ci->writeb += nbytes;
+
+	return nbytes;
+}
+
+static void iscsi_iser_write_end(int ind)
+{
+	int ret;
+	struct ibv_send_wr *bad_wr;
+	struct conn_info *ci = NULL;
+	struct sendlist *send = NULL;
+
+	ci = &cl.conn[ind];
+	if (!ci->valid) {
+		eprintf("conn %d not valid\n", ind);
+		exit(1);
+	}
+
+	send = ci->send_comm_event; /* should be set from func above */
+	iser_out(4, "%s: continue send event %p, writeb %d", __func__, send,
+		 ci->writeb);
+
+	send->sge.length = ci->writeb;
+
+	ret = ibv_post_send(ci->qp_hndl, &send->wr, &bad_wr);
+	if (ret) {
+		openfab_error("Can't post SEND", errno);
+		return;
+	}
+
+	ci->writeb = 0;  /* reset count */
+	ci->send_comm_event = NULL;
+
+	/* wake up the progress engine to do the done */
+	dprintf("waking up progress to finish cmd\n");
+	++cl.num_tx_ready;
+
+	iser_out(4, "%s exit %p", __func__, send);
+	return;
+}
+
+static size_t iscsi_iser_close(int ep __attribute__((unused)) )
+{
+	eprintf("not implemented\n");
+	return 0;
+}
+
+static int iscsi_iser_show(int ep, char *buf, int rest)
+{
+	struct conn_info *ci = &cl.conn[ep];
+
+	snprintf(buf, rest, "RDMA connection, QP %p", ci->qp_hndl);
+	return 0;
+}
+
+static int iscsi_iser_init(void)
+{
+	int ret;
+	struct sockaddr_in sock_addr;
+	short int port = ISCSI_LISTEN_PORT;
+
+	iser_out(8, "%s() Entry", __func__);
+
+	memset(&cl, 0, sizeof(cl));
+
+	memset(&sock_addr, 0, sizeof(sock_addr));
+	sock_addr.sin_family = AF_INET;
+	sock_addr.sin_port = htons(port);
+	sock_addr.sin_addr.s_addr = INADDR_ANY;
+
+	cl.rdma_evt_channel = rdma_create_event_channel();
+
+	ret = rdma_create_id(cl.rdma_evt_channel, &cl.cma_listen_id, NULL,
+			     RDMA_PS_TCP);
+	if (ret) {
+		openfab_error("Unable to create rdma id", ret);
+		return -1;
+	}
+
+	ret = rdma_bind_addr(cl.cma_listen_id, (struct sockaddr *) &sock_addr);
+	if (ret) {
+		if (ret == -1)
+			openfab_error("can't bind address", errno);
+		else
+			openfab_error("can't bind address", -ret);
+		return -1;
+	}
+
+	/* 0 means maximum backlog */
+	ret = rdma_listen(cl.cma_listen_id, 0);
+	if (ret) {
+		if (ret == -1)
+			openfab_error("Can't listen", errno);
+		else
+			openfab_error("Can't listen", -ret);
+		return -1;
+	}
+
+	iser_out(5, "%s() Listening on %d for an iSER connection", __func__,
+			port);
+
+	iser_out(5, "%s() FD we want to watch is %d", __func__,
+			cl.cma_listen_id->channel->fd);
+
+	ret = tgt_event_add(cl.cma_listen_id->channel->fd, EPOLLIN,
+			    iser_handle_rdmacm, NULL);
+	if (ret) {
+		eprintf("Unable to add RDMA event channel FD to poll %m\n");
+		return -1;
+	}
+
+	INIT_LIST_HEAD(&cl.conn_tx_ready);
+	cl.num_tx_ready = 0;
+	ret = tgt_counter_event_add(&cl.num_tx_ready, iser_progress, NULL);
+	if (ret)
+		return ret;
+
+	cl.cq_channel = NULL;
+
+	iser_out(8, "%s() Exit", __func__);
+
+	return 0;
+}
+
+
+static struct rdmalist *iser_find_rdma_slot(struct conn_info *ci, uint8_t *buf,
+					    ssize_t size)
+{
+	struct rdmalist *rdmal;
+	int found = 0;
+
+	list_for_each_entry(rdmal, &ci->rdmal, list) {
+		if (rdmal->free) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		eprintf("Unable to find rdma slot\n");
+		exit(1);
+	}
+
+	rdmal->free = 0;
+	rdmal->buf = buf;
+	return rdmal;
+}
+
+/*
+ * NOTE: for signaled use IBV_SEND_SIGNALED it is != 1, for unsignaled use 0
+ * NOTE: exp opcodes are: IBV_WR_RDMA_WRITE, IBV_WR_RDMA_READ
+ */
+static int iser_post_rdma_wr(struct conn_info *ci, struct rdmalist *rdma,
+			     ssize_t size, int op, int signaled_flag,
+			     uint64_t remote_va, uint32_t remote_rkey,
+			     struct iscsi_task *task)
+{
+	int ret;
+	struct ibv_send_wr *bad_wr;
+
+	iser_out(4, "in %s size %d rem_va %lx rem_stag %x", __func__, size,
+		 remote_va, remote_rkey);
+
+	rdma->task = task;
+
+	rdma->sge.addr = uint64_from_ptr(rdma->buf);
+	rdma->sge.length = size;
+	rdma->sge.lkey = cl.regmr->lkey;
+
+	memset(&rdma->wr, 0, sizeof(rdma->wr));
+	rdma->wr.wr_id = uint64_from_ptr(rdma);
+	rdma->wr.sg_list = &rdma->sge;
+	rdma->wr.num_sge = 1;
+	rdma->wr.wr.rdma.remote_addr = remote_va;
+	rdma->wr.wr.rdma.rkey = remote_rkey;
+	rdma->wr.opcode = op;
+	rdma->wr.send_flags = signaled_flag;
+
+	ret = ibv_post_send(ci->qp_hndl, &rdma->wr, &bad_wr);
+	if (ret)
+		openfab_error("Can't post SEND", errno);
+
+	iser_out(8, "%s() Exit rdma = %p", __func__, rdma);
+	return ret;
+}
+
+/*
+ * Convert the iscsi data-in response to an RDMA write and send it.
+ */
+static int iser_rdma_write(int ind, struct iscsi_pdu *rsp,
+			   struct iscsi_task *task)
+{
+	uint32_t offset;
+	int ret;
+	struct rdmalist *rdmal;
+	struct conn_info *ci = &cl.conn[ind];
+	struct iscsi_data_rsp *datain = (struct iscsi_data_rsp *) &rsp->bhs;
+	int last_rdma = (task->offset == task->len);
+
+	iser_out(4, "in %s size %d, %p", __func__, rsp->datasize, rsp);
+
+	rdmal = iser_find_rdma_slot(ci, rsp->data, rsp->datasize);
+	if (rdmal == NULL) {
+		eprintf("iser_find_rdma_slot failed\n");
+		return -1;
+	}
+
+	/* to find unsignaled ones when the last one completes */
+	list_del(&rdmal->list);
+	list_add(&rdmal->list, &ci->rdmal_write_busy);
+
+	offset = be32_to_cpu(datain->offset);
+
+	/* only signal on the last RDMA write */
+	dprintf("offset %d len %d last %d\n", task->offset, task->len,
+		last_rdma);
+
+	ret = iser_post_rdma_wr(ci, rdmal, rsp->datasize, IBV_WR_RDMA_WRITE,
+				last_rdma ? IBV_SEND_SIGNALED : 0,
+				ci->rem_read_va + offset, ci->rem_read_stag,
+				task);
+
+	if (ret < 0) {
+		eprintf("iser_post_rdma_wr failed\n");
+		exit(1);
+	}
+
+	/* iscsi thinks we are txing, but really we're waiting for this
+	 * rdma to finish before sending the completion.  Then we'll stick
+	 * ourselves back on the list.
+	 */
+	if (last_rdma) {
+		dprintf("removing ep %d from tx ready list\n", ind);
+		iser_event_modify(ind, EPOLLIN);
+	} else {
+		/* poke ourselves to do the next rdma */
+		++cl.num_tx_ready;
+	}
+
+	return ret;
+}
+
+static int iser_rdma_read(int ind, struct iscsi_pdu *rsp)
+{
+	struct conn_info *ci = &cl.conn[ind];
+	struct iscsi_connection *conn = ci->iscsi_conn;
+	struct iscsi_task *task = conn->tx_task;
+	struct iscsi_r2t_rsp *r2t = (struct iscsi_r2t_rsp *) &rsp->bhs;
+	uint8_t *buf;
+	uint32_t len;
+	struct rdmalist *rdma;
+	int ret;
+
+	iser_out(4, "in %s", __func__);
+
+	buf = task->data + task->offset;
+	len = be32_to_cpu(r2t->data_length);
+	rdma = iser_find_rdma_slot(ci, buf, len);
+	if (rdma == NULL) {
+		iser_out(4, "iser_find_rdma_slot failed");
+		return -1;
+	}
+
+	ret = iser_post_rdma_wr(ci, rdma, len, IBV_WR_RDMA_READ,
+				IBV_SEND_SIGNALED, ci->rem_write_va,
+				ci->rem_write_stag, task);
+	if (ret < 0) {
+		iser_out(4, "iser_post_rdma_wr failed");
+		return ret;
+	}
+
+	/*
+	 * Initiator registers the entire buffer, but gives us a VA that
+	 * is advanced by immediate + unsolicited data amounts.  Advance
+	 * rem_va as we read, knowing that the target always grabs segments
+	 * in order.
+	 */
+	ci->rem_write_va += len;
+
+	return 0;
+}
+
+static ssize_t iser_rdma_read_completion(struct rdmalist *rdma)
+{
+	int ret = 0;
+	struct conn_info *ci = &cl.conn[rdma->conn_index];
+	struct iscsi_connection *conn = ci->iscsi_conn;
+	struct iscsi_task *task;
+
+	iser_out(4, "in %s", __func__);
+
+	/* task is no longer conn->tx_task, look it up */
+	list_for_each_entry(task, &conn->session->cmd_list, c_hlist) {
+		if (task == rdma->task)
+			goto found;
+	}
+	return -EINVAL;
+
+found:
+	/* equivalent of iscsi_data_out_rx_start + _done */
+	conn->rx_buffer = ptr_from_int64(rdma->sge.addr);
+	conn->rx_size = rdma->sge.length;
+	task->offset += rdma->sge.length;
+	task->r2t_count -= rdma->sge.length;
+	VALGRIND_MAKE_MEM_DEFINED(conn->rx_buffer, conn->rx_size);
+
+	dprintf("more bytes %u arrived, now r2t_count %d\n", rdma->sge.length,
+		task->r2t_count);
+
+	/*
+	 * We soliticed this data, so hdr->ttt is what we asked for.  Bypass
+	 * data_out_rx_done and just run the task.  If more r2t are needed,
+	 * this will generate them.
+	 */
+	ret = iscsi_scsi_cmd_execute(task);
+
+	conn->rx_task = NULL;
+	conn_read_pdu(conn);
+
+	iser_out(4, "%s exit conn %p conn->rx_buffer %p ret %d", __func__,
+		 conn, conn->rx_buffer, ret);
+	return ret;
+}
+
+/*
+ * Called from tgtd when cl.num_tx_ready (counter) non-zero.  Walks the
+ * list of active connections and tries to push tx on each, until nothing
+ * is ready anymore.
+ */
+static void iser_progress(int *counter, void *data)
+{
+	int done;
+	struct conn_info *ci, *cin;
+	struct iscsi_connection *conn;
+
+	iser_out(8, "%s() Entry", __func__);
+
+	if (cl.num_tx_ready == 0)
+		goto out;
+
+	--cl.num_tx_ready;
+	do {
+		done = 1;
+		list_for_each_entry_safe(ci, cin, &cl.conn_tx_ready,
+					 conn_tx_ready) {
+			conn = ci->iscsi_conn;
+			dprintf("trying tx on fd %d conn %p\n", conn->fd, conn);
+			done = 0;
+			iscsi_tx_handler(conn->fd, conn);
+		}
+	} while (!done);
+
+out:
+	iser_out(8, "%s() Exit", __func__);
+}
+
+void *iser_malloc(size_t sz)
+{
+	struct mempool *mem;
+
+	if (list_empty(&cl.freel)) {
+		/* TODO: take slow path: allocate & register */
+		eprintf("free list empty\n");
+		return NULL;
+	}
+
+	assert(sz <= MEM_SZ);
+
+	mem = list_entry(cl.freel.next, struct mempool, list);
+	list_del(&mem->list);
+	list_add(&mem->list, &cl.allocl);
+
+	iser_out(4, "meml %p buf %p", mem, mem->buf);
+	return mem->buf;
+}
+
+void iser_free(void *buf)
+{
+	int found = 0;
+	struct mempool *mem;
+
+	list_for_each_entry(mem, &cl.allocl, list) {
+		if (mem->buf == buf) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		eprintf("couldn't locate buf %p\n", buf);
+		return;
+	}
+	list_del(&mem->list);
+	list_add(&mem->list, &cl.freel);
+}
+
+static void iser_event_modify(int ep, int events)
+{
+	struct conn_info *ci = &cl.conn[ep];
+
+	dprintf("ep %d events %d\n", ep, events);
+	if (events & EPOLLOUT) {
+		/* only add if not already on the list? */
+		if (list_empty(&ci->conn_tx_ready)) {
+			dprintf("adding ep %d to tx ready list\n", ep);
+			list_add(&ci->conn_tx_ready, &cl.conn_tx_ready);
+		} else {
+			eprintf("ep %d was already on the list.  Track?\n", ep);
+		}
+		++cl.num_tx_ready;
+	} else {
+		dprintf("removing ep %d from tx ready list\n", ep);
+		list_del_init(&ci->conn_tx_ready);
+	}
+}
+
+struct iscsi_transport iscsi_iser = {
+	.name			= "iser",
+	.rdma			= 1,
+	.ep_init		= iscsi_iser_init,
+	.ep_read		= iscsi_iser_read,
+	.ep_write_begin		= iscsi_iser_write_begin,
+	.ep_write_end		= iscsi_iser_write_end,
+	.ep_close		= iscsi_iser_close,
+	.ep_show		= iscsi_iser_show,
+	.ep_rdma_write		= iser_rdma_write,
+	.ep_rdma_read		= iser_rdma_read,
+	.ep_malloc		= iser_malloc,
+	.ep_free		= iser_free,
+	.ep_event_modify	= iser_event_modify,
+};
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 4f9194a..15c3623 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -270,7 +270,7 @@ static void login_security_done(struct iscsi_connection *conn)
 static void text_scan_login(struct iscsi_connection *conn)
 {
 	char *key, *value, *data;
-	int datasize, idx;
+	int datasize, idx, is_rdma = 0;
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
 
 	data = conn->req.data;
@@ -289,6 +289,9 @@ static void text_scan_login(struct iscsi_connection *conn)
 			if (idx == ISCSI_PARAM_MAX_RECV_DLENGTH)
 				idx = ISCSI_PARAM_MAX_XMIT_DLENGTH;
 
+			if (idx == ISCSI_PARAM_RDMA_EXTENSIONS)
+				is_rdma = 1;
+
 			if (param_str_to_val(session_keys, idx, value, &val) < 0) {
 				if (conn->session_param[idx].state
 				    == KEY_STATE_START) {
@@ -335,6 +338,10 @@ static void text_scan_login(struct iscsi_connection *conn)
 			text_key_add(conn, key, "NotUnderstood");
 	}
 
+	/* do not offer, initiator must explicitly request */
+	if (!is_rdma)
+		conn->session_param[ISCSI_PARAM_RDMA_EXTENSIONS].val = 0;
+
 out:
 	return;
 }
@@ -354,6 +361,13 @@ static int text_check_param(struct iscsi_connection *conn)
 					p[i].state = KEY_STATE_DONE;
 					continue;
 				}
+				if (p[ISCSI_PARAM_RDMA_EXTENSIONS].val == 1) {
+					if (i == ISCSI_PARAM_MAX_RECV_DLENGTH)
+						continue;
+				} else {
+					if (i >= ISCSI_PARAM_RDMA_EXTENSIONS)
+						continue;
+				}
 				memset(buf, 0, sizeof(buf));
 				param_val_to_str(session_keys, i, p[i].val,
 						 buf);
@@ -435,7 +449,7 @@ static void login_start(struct iscsi_connection *conn)
 			return;
 		}
 
-		if (ip_acl(conn->tid, conn->fd)) {
+		if (!conn->tp->rdma && ip_acl(conn->tid, conn->fd)) {
 			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
 			rsp->status_detail = ISCSI_LOGIN_STATUS_TGT_NOT_FOUND;
 			conn->state = STATE_EXIT;
@@ -469,12 +483,43 @@ static void login_start(struct iscsi_connection *conn)
 
 static void login_finish(struct iscsi_connection *conn)
 {
+	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
+	int ret;
+
 	switch (conn->session_type) {
 	case SESSION_NORMAL:
-		if (!conn->session)
+	       /*
+		* XXX: call into transport to initialize resources.  It looks
+		* at conn->session_param to know how big buffers to pin, e.g.
+		*/
+		/* ret = conn->tp->alloc_resources(conn); */
+		ret = 0;
+		if (ret) {
+			rsp->flags = 0;
+			rsp->status_class = ISCSI_STATUS_CLS_TARGET_ERR;
+			rsp->status_detail = ISCSI_LOGIN_STATUS_NO_RESOURCES;
+			conn->state = STATE_EXIT;
+			break;
+		}
+
+		if (!conn->session) {
 			session_create(conn);
+		} else {
+			if (conn->tp->rdma ^ conn->session->rdma) {
+				eprintf("new conn rdma %d, but session %d\n",
+					conn->tp->rdma, conn->session->rdma);
+				rsp->flags = 0;
+				rsp->status_class =
+					ISCSI_STATUS_CLS_INITIATOR_ERR;
+				rsp->status_detail =
+					ISCSI_LOGIN_STATUS_INVALID_REQUEST;
+				conn->state = STATE_EXIT;
+				break;
+			}
+		}
 		memcpy(conn->isid, conn->session->isid, sizeof(conn->isid));
 		conn->tsih = conn->session->tsih;
+
 		break;
 	case SESSION_DISCOVERY:
 		/* set a dummy tsih value */
@@ -636,8 +681,11 @@ static void cmnd_exec_login(struct iscsi_connection *conn)
 			default:
 				goto init_err;
 			}
-			if (!stay && !nsg_disagree)
+			if (!stay && !nsg_disagree) {
 				login_finish(conn);
+				if (rsp->status_class)
+					return;
+			}
 			break;
 		default:
 			goto init_err;
@@ -916,7 +964,7 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 		rsp->flags = ISCSI_FLAG_CMD_FINAL;
 
 		/* collapse status into final packet if successful */
-		if (task->result == 0 && task->dir != BIDIRECTIONAL) {
+		if (task->result == 0 && task->dir != BIDIRECTIONAL && !conn->tp->rdma) {
 			rsp->flags |= ISCSI_FLAG_DATA_STATUS;
 			rsp->cmd_status = task->result;
 			rsp->statsn = cpu_to_be32(conn->stat_sn++);
@@ -1643,7 +1691,7 @@ static int iscsi_scsi_cmd_tx_done(struct iscsi_connection *conn)
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
 		if (task->offset < task->len || task->result != 0
-		   || task->dir == BIDIRECTIONAL) {
+		   || task->dir == BIDIRECTIONAL || conn->tp->rdma) {
 			dprintf("more data or sense or bidir %x\n", hdr->itt);
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
 			return 0;
@@ -1932,6 +1980,31 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 			return;
 	}
 
+	/*
+	 * For rdma, grab the data-in or r2t packet and covert to
+	 * an RDMA operation.
+	 */
+	if (conn->tp->rdma && conn->state == STATE_SCSI) {
+		switch (conn->rsp.bhs.opcode) {
+		case ISCSI_OP_R2T:
+			ret = conn->tp->ep_rdma_read(fd, &conn->rsp);
+			if (ret < 0)
+				conn->state = STATE_CLOSE;
+			goto finish;
+
+		case ISCSI_OP_SCSI_DATA_IN:
+			ret = conn->tp->ep_rdma_write(fd, &conn->rsp,
+						      conn->tx_task);
+			if (ret < 0)
+				conn->state = STATE_CLOSE;
+			goto finish;
+
+		default:
+			break;
+		}
+	}
+
+again:
 	switch (conn->tx_iostate) {
 	case IOSTATE_TX_BHS:
 		ret = do_send(fd, conn, IOSTATE_TX_INIT_AHS);
@@ -2007,11 +2080,15 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		exit(1);
 	}
 
-	if (ret < 0 ||
-	    conn->tx_iostate != IOSTATE_TX_END ||
-	    conn->state == STATE_CLOSE)
+	if (ret < 0 || conn->state == STATE_CLOSE)
 		return;
 
+	if (conn->tx_iostate != IOSTATE_TX_END) {
+		if (conn->tp->rdma)
+			goto again;  /* avoid event loop, just push */
+		return;
+	}
+
 	if (conn->tx_size) {
 		eprintf("error %d %d %d\n", conn->state, conn->tx_iostate,
 			conn->tx_size);
@@ -2019,6 +2096,8 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 	}
 
 	conn->tp->ep_write_end(fd);
+
+finish:
 	cmnd_finish(conn);
 
 	switch (conn->state) {
diff --git a/usr/iscsi/param.c b/usr/iscsi/param.c
index 9eac62c..76236d1 100644
--- a/usr/iscsi/param.c
+++ b/usr/iscsi/param.c
@@ -118,6 +118,18 @@ static int minimum_check_val(struct iscsi_key *key, unsigned int *val)
 	return 0;
 }
 
+static int min_or_zero_check_val(struct iscsi_key *key, unsigned int *val)
+{
+	int err = 0;
+
+	if (*val != 0 && (*val < key->min || key->max < *val)) {
+		*val = key->min;
+		err = -EINVAL;
+	}
+
+	return 0;
+}
+
 static int maximum_check_val(struct iscsi_key *key, unsigned int *val)
 {
 	int err = 0;
@@ -140,6 +152,16 @@ static int minimum_set_val(struct param *param, int idx, unsigned int *val)
 	return 0;
 }
 
+static int min_or_zero_set_val(struct param *param, int idx, unsigned int *val)
+{
+	if (*val > param[idx].val || *val == 0)
+		*val = param[idx].val;
+	else
+		param[idx].val = *val;
+
+	return 0;
+}
+
 static int maximum_set_val(struct param *param, int idx, unsigned int *val)
 {
 	if (param[idx].val > *val)
@@ -265,6 +287,13 @@ static struct iscsi_key_ops minimum_ops = {
 	.set_val = minimum_set_val,
 };
 
+static struct iscsi_key_ops min_or_zero_ops = {
+	.val_to_str = range_val_to_str,
+	.str_to_val = range_str_to_val,
+	.check_val = min_or_zero_check_val,
+	.set_val = min_or_zero_set_val,
+};
+
 static struct iscsi_key_ops maximum_ops = {
 	.val_to_str = range_val_to_str,
 	.str_to_val = range_str_to_val,
@@ -345,6 +374,15 @@ struct iscsi_key session_keys[] = {
 	{"IFMarkInt", 2048, 1, 65535, &marker_ops},
 	[ISCSI_PARAM_MAXCONNECTIONS] =
 	{"MaxConnections", 1, 1, 65535, &minimum_ops},
+	/* iSER draft */
+	[ISCSI_PARAM_RDMA_EXTENSIONS] =
+	{"RDMAExtensions", 0, 0, 1, &and_ops},
+	[ISCSI_PARAM_TARGET_RDSL] =
+	{"TargetRecvDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_INITIATOR_RDSL] =
+	{"InitiatorRecvDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_MAX_OUTST_PDU] =
+	{"MaxOutstandingUnexpectedPDUs", 0, 2, 4294967295U, &min_or_zero_ops},
 	[ISCSI_PARAM_MAX] =
 	{NULL,},
 };
diff --git a/usr/iscsi/session.c b/usr/iscsi/session.c
index dfb94d0..36beadc 100644
--- a/usr/iscsi/session.c
+++ b/usr/iscsi/session.c
@@ -128,6 +128,8 @@ int session_create(struct iscsi_connection *conn)
 	memcpy(session->isid, conn->isid, sizeof(session->isid));
 	session->tsih = last_tsih = tsih;
 
+	session->rdma = conn->tp->rdma;
+
 	conn_add_to_session(conn, session);
 
 	dprintf("session_create: %#" PRIx64 "\n", sid64(conn->isid, session->tsih));
diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
index 2653839..d47f05f 100644
--- a/usr/iscsi/target.c
+++ b/usr/iscsi/target.c
@@ -283,6 +283,14 @@ int iscsi_target_create(struct target *t)
 		[ISCSI_PARAM_OFMARKINT] = {0, 2048},
 		[ISCSI_PARAM_IFMARKINT] = {0, 2048},
 		[ISCSI_PARAM_MAXCONNECTIONS] = {0, 1},
+#ifdef ISCSI_RDMA
+		[ISCSI_PARAM_RDMA_EXTENSIONS] = {0, 1},
+#else
+		[ISCSI_PARAM_RDMA_EXTENSIONS] = {0, 0},
+#endif
+		[ISCSI_PARAM_TARGET_RDSL] = {0, 262144},
+		[ISCSI_PARAM_INITIATOR_RDSL] = {0, 262144},
+		[ISCSI_PARAM_MAX_OUTST_PDU] =  {0, 0},  /* not in open-iscsi */
 	};
 
 	target = malloc(sizeof(*target));
diff --git a/usr/iscsi/transport.c b/usr/iscsi/transport.c
index ba232ed..e17b554 100644
--- a/usr/iscsi/transport.c
+++ b/usr/iscsi/transport.c
@@ -29,6 +29,9 @@
 
 struct iscsi_transport *iscsi_transports[] = {
 	&iscsi_tcp,
+#ifdef ISCSI_RDMA
+	&iscsi_iser,
+#endif
 	NULL,
 };
 
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index bfba784..ebb9a23 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -23,5 +23,8 @@ struct iscsi_transport {
 };
 
 extern struct iscsi_transport iscsi_tcp;
+#ifdef ISCSI_RDMA
+extern struct iscsi_transport iscsi_iser;
+#endif
 
 #endif
-- 
1.5.2.4



From markh794 at gmail.com  Tue Jul 31 11:57:41 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Tue, 31 Jul 2007 19:57:41 +1000
Subject: [Stgt-devel] stgt backing store & SSC
Message-ID: <46AF0795.1010306@gmail.com>

Hi One and all,

I'm after some input on the best way to incorporate the SSC device with 
the current backing store implementations.

The 'block' format used currently for SBC, MMC devices do not map well 
for streaming device(s). - For both implicit and explicit addressing mode.

The 'problem':
==========
For Variable block SSC device, the block size written needs to be 
tracked. Otherwise the SSC device will be unable to correctly handle the 
scenario where a read request arrives (from the application client) that 
requests a 'large block'. The SSC device needs the ability to set the 
REQUEST SENSE with ILI bit set correctly.
e.g.
A application client wrote a previous write of a 1k block of data:
An application client reserves 64k and requests a 'read'. The lu 
receives a 64k read request.
The lu should now return 1k of data with REQUEST SENSE and ILI set 
correctly.

Without some sore of way of tracking each block written, I can see no 
way of achieving this.

My current thoughts of a solution:
========================
A block header describes each block written -> Analogy to the 'tar' 
format where a header is written, followed by the 'data' followed by 
another header, followed by more data...repeat...until blank header...

/**
 * Tape layout
 *
 * @block_type: (BOT, Uncompress data, compressed data, EOT etc)
 * @blk_size: Uncompressed size of data block
 * @disk_blk_size: Amount of space block takes up in the backing 'file'
 *
 * @prev_blk, curr_blk & next_blk form a 'poor mans DLL'
 */
struct blk_header {
        uint32_t blk_type;
        uint32_t blk_size;
        uint32_t disk_blk_size;
        loff_t blk_number;
        loff_t prev_blk;
        loff_t curr_blk;
        loff_t next_blk;
};

The file format I've used before is similar to:
<Beginning of tape blk_header>
<Media Aux Memory>
<blk header>
<Blk size data>
       [repeat header/data blocks n times for n writes]
<End of Data blk header>


However the current implementation for iSCSI -> bs_sync uses a 
pread64()/pwrite64() and writes data based on information stored in 
scsi_cmd -
 pwrite64(fd, cmd->uaddr, cmd->len, cmd->offset)
 pread64(fd, cmd->uaddr, cmd->len, cmd->offset)


Would it be OK to add a 'blk_header' structure to struct scsi_cmd and if 
blk_header is set, write this blk header as well ?
I will attempt to put the above idea into code and submit for comment...

Or does somebody have a better / cleaner way of achieving this ?

Regards
Mark




From mangoo at wpkg.org  Tue Jul 31 12:07:30 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Tue, 31 Jul 2007 12:07:30 +0200 (CEST)
Subject: [Stgt-devel] "exporting" SCSI tape drives - possible?
Message-ID: <43362.87.79.32.190.1185876450.squirrel@ssl.syneticon.net>

Can I "export" a SCSI tape drive using stgt, and then, use this tape on
any initiator?


-- 
Tomasz Chmielewski
http://wpkg.org




From agr at powerkom-dd.de  Tue Jul 31 17:59:19 2007
From: agr at powerkom-dd.de (Arne Redlich)
Date: Tue, 31 Jul 2007 17:59:19 +0200
Subject: [Stgt-devel] [PATCH 7/7] iser core
In-Reply-To: <20070730190105.GU12789@osc.edu>
References: <20070730185449.GN12789@osc.edu> <20070730190105.GU12789@osc.edu>
Message-ID: <1185897559.15430.4.camel@confield.dd.xiranet.com>

Am Montag, den 30.07.2007, 15:01 -0400 schrieb Pete Wyckoff:

> +/* global connection list variables */
> +struct rdma_conn_list {
> +	struct conn_info conn[MAX_CONN];
> +	/*variables that all connections will share*/
> +	struct ibv_context	*ibv_hndl;
> +	struct rdma_event_channel *rdma_evt_channel;
> +	struct rdma_cm_id	*cma_listen_id;
> +	struct ibv_pd		*prot_id;
> +	struct ibv_cq		*cq_hndl;
> +	struct ibv_comp_channel *cq_channel;
> +	struct list_head conn_tx_ready;  /* conns with tasks ready to tx */
> +	/* prereg rdma bufs */
> +	void *regbuf;
> +	void *membuf;
> +	struct ibv_mr *regmr;
> +	struct list_head freel, allocl;
> +	int num_tx_ready;
> +};
> +static struct rdma_conn_list cl;

Haven't found it in the errata, but it seems that with this design only
one HCA is supported?

Arne



From pw at osc.edu  Tue Jul 31 20:19:21 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 31 Jul 2007 14:19:21 -0400
Subject: [Stgt-devel] [PATCH 7/7] iser core
In-Reply-To: <1185897559.15430.4.camel@confield.dd.xiranet.com>
References: <20070730185449.GN12789@osc.edu> <20070730190105.GU12789@osc.edu>
	<1185897559.15430.4.camel@confield.dd.xiranet.com>
Message-ID: <20070731181921.GA16612@osc.edu>

agr at powerkom-dd.de wrote on Tue, 31 Jul 2007 17:59 +0200:
> Am Montag, den 30.07.2007, 15:01 -0400 schrieb Pete Wyckoff:
> 
> > +/* global connection list variables */
> > +struct rdma_conn_list {
> > +	struct conn_info conn[MAX_CONN];
> > +	/*variables that all connections will share*/
> > +	struct ibv_context	*ibv_hndl;
> > +	struct rdma_event_channel *rdma_evt_channel;
> > +	struct rdma_cm_id	*cma_listen_id;
> > +	struct ibv_pd		*prot_id;
> > +	struct ibv_cq		*cq_hndl;
> > +	struct ibv_comp_channel *cq_channel;
> > +	struct list_head conn_tx_ready;  /* conns with tasks ready to tx */
> > +	/* prereg rdma bufs */
> > +	void *regbuf;
> > +	void *membuf;
> > +	struct ibv_mr *regmr;
> > +	struct list_head freel, allocl;
> > +	int num_tx_ready;
> > +};
> > +static struct rdma_conn_list cl;
> 
> Haven't found it in the errata, but it seems that with this design only
> one HCA is supported?

Yes, correct.  We will need multiple event channels and PDs at
least.  I will add this as an erratum.  Perhaps someone who is
blessed with multiple HCAs will fix it for us.

		-- Pete


