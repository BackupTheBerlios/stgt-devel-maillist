From contact at ellediscount.fr  Sat Dec  1 12:52:01 2007
From: contact at ellediscount.fr (ellediscount)
Date: Sat,  1 Dec 2007 13:52:01 +0200
Subject: ellediscount ,La Qualité à Prix Discount
Message-ID: <NS28422jIL2jpWkfb810003db5d@smtp.marieamaury.com>

  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071201/e7e70c41/attachment.html>

From contact at ellediscount.fr  Tue Dec  4 15:09:49 2007
From: contact at ellediscount.fr (ellediscount s'éxcuse)
Date: Tue,  4 Dec 2007 15:09:49 +0100
Subject: ellediscount s'éxcuse au près de ces internautes
Message-ID: <NS6692RuMrzpeSKR8kf00060142@ns6692>

ellediscount                                                                                     Le 03 12 2007
                                                               Monsieur ,Mesdames,
                                 Ellediscount vient vous pr?sentez ces excuses pour le d?sagr?ment caus?, suite a une erreur de Emailing.
                                 Notre syst?me a envoy? sur votre boite une publicit? .
                                 Malheureusement cela na pas ?t? intentionnel et vous a indispos?, 
                                Nous en somme r?ellement d?sole ,un syst?me a ?t? mis au points pour Se d?sinscrire de la mailing-list ,
                                en bas de page , notre site vient tout juste de voir le jour, 
                                Les services internet nous ont pr?venu que cela ?tait tr?s d?rangeant pour certains internaute de recevoir 
                               de la publicit?, Nous r?spectons cela et prenons en compte, car cela est votre droit .
                                Notre Emailing doit ?tre donc remis ? jour suite a une fusion fort d?sagr?able .
                                si vous ne d?sirez pas faire partie de ce Emailing merci de clique sur ce d?sabonner ci dessous , 
                                et si vous l accepte merci de r?pondre a ce message, a contact at ellediscount.fr Sujet : inscrire simplement   OK
                                Merci pour votre Compr?hension.
                                                Toute l' ?quipe d' ellediscount vous repr?sente ces excuses 
                                Ainsi qu'aux ?quipe FAI abuse ,et vous prie de croire que tout est mis en oeuvre pour pallier ? ce probl?me.
                                                                                                                                 ? Bient?t ,nous l' esp?rons.
                                                                                                                                 Le responsable M Caufourier
 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071204/1eef3037/attachment.html>

From robin.humble+stgt at anu.edu.au  Wed Dec  5 14:56:09 2007
From: robin.humble+stgt at anu.edu.au (Robin Humble)
Date: Wed, 5 Dec 2007 08:56:09 -0500
Subject: [Stgt-devel] read << write
Message-ID: <20071205135609.GA1864@lemming.cita.utoronto.ca>

Hi,

I'm finding that reads are a lot slower than writes when I have a real
file or device behind tgt instead of a ramdisk. is this expected?

iSER reads backed by a file on lustre or a md raid0 device seem to be at
most ~100MB/s which is 4 or 5 times slower than writes:

bonnie++
 Version  1.03    ------Sequential Output------ --Sequential Input- --Random-
                  -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
 Machine     Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
 iSER/ramdisk  4G 79699  98 458229 96 260343 38 87650  98 474552 32 +++++ +++
 iSER/md0      4G 79479  98 341628 68  96554 13 86280  96  64672  4 788.0   0
 iSER/lustre   4G 78691  97 484972 90 131885 18 82747  93  98331  6 236.8   0
                             ^^^                            ^^^
 IPoIB/lustre  4G 76653  96 225736 50  71555  9 67401  90  91115  4 241.6   0 
 GigE/lustre   4G 75556  96 115951 26  46772  5 64280  84  93495  5 247.3   0
 native lustre 4G 69852  98 367647 87  62090 38 75893  93 333886 98 272.0   1
 native md0                 309000                        335000

where:
 iSER/ramdisk  - iSER to a 7G ramdisk
 iSER/md0      - iSER to a software raid0 device
 iSER/lustre   - iSER to a file on a Lustre fs client (also using IB)
 IPoIB/lustre  - iSCSI over IP-over-IB to a file on a Lustre fs
 GigE/lustre   - iSCSI over gigE to a file on a Lustre fs
 native lustre - to native lustre
 native md0    - dd speeds to /dev/md0

the trend of reads being limited to ~100MB/s seems to continue with
normal iSCSI IPoIB and with TCP over gigE, which is odd.

perhaps I didn't see this before because my filesystems were too slow...??

environment is centos5 + OFED 1.2.5, rhel5.1 kernel 2.6.18-53.1.4.el5,
x86_64, DDR IB, and target/initiator nodes both with mem=512M.
iSER tgt from osc.edu git from a while ago (Oct 5?), and iSCSI from
kernel tgt git a while ago too (Sept?).
all iSCSI/iSER tests use ext3 fs on the target.
 
cheers,
robin


From fujita.tomonori at lab.ntt.co.jp  Wed Dec  5 23:54:53 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 06 Dec 2007 07:54:53 +0900
Subject: [Stgt-devel] read << write
In-Reply-To: <20071205135609.GA1864@lemming.cita.utoronto.ca>
References: <20071205135609.GA1864@lemming.cita.utoronto.ca>
Message-ID: <20071206075453J.fujita.tomonori@lab.ntt.co.jp>

On Wed, 5 Dec 2007 08:56:09 -0500
Robin Humble <robin.humble+stgt at anu.edu.au> wrote:

> Hi,
> 
> I'm finding that reads are a lot slower than writes when I have a real
> file or device behind tgt instead of a ramdisk. is this expected?
> 
> iSER reads backed by a file on lustre or a md raid0 device seem to be at
> most ~100MB/s which is 4 or 5 times slower than writes:
> 
> bonnie++
>  Version  1.03    ------Sequential Output------ --Sequential Input- --Random-
>                   -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
>  Machine     Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
>  iSER/ramdisk  4G 79699  98 458229 96 260343 38 87650  98 474552 32 +++++ +++
>  iSER/md0      4G 79479  98 341628 68  96554 13 86280  96  64672  4 788.0   0
>  iSER/lustre   4G 78691  97 484972 90 131885 18 82747  93  98331  6 236.8   0
>                              ^^^                            ^^^
>  IPoIB/lustre  4G 76653  96 225736 50  71555  9 67401  90  91115  4 241.6   0 
>  GigE/lustre   4G 75556  96 115951 26  46772  5 64280  84  93495  5 247.3   0
>  native lustre 4G 69852  98 367647 87  62090 38 75893  93 333886 98 272.0   1
>  native md0                 309000                        335000
> 
> where:
>  iSER/ramdisk  - iSER to a 7G ramdisk
>  iSER/md0      - iSER to a software raid0 device
>  iSER/lustre   - iSER to a file on a Lustre fs client (also using IB)
>  IPoIB/lustre  - iSCSI over IP-over-IB to a file on a Lustre fs
>  GigE/lustre   - iSCSI over gigE to a file on a Lustre fs
>  native lustre - to native lustre
>  native md0    - dd speeds to /dev/md0
> 
> the trend of reads being limited to ~100MB/s seems to continue with
> normal iSCSI IPoIB and with TCP over gigE, which is odd.
> 
> perhaps I didn't see this before because my filesystems were too slow...??

Can you try a block-level benchmark like disktest to avoid file
systems effects?


From kensandars at hotmail.com  Thu Dec  6 07:55:43 2007
From: kensandars at hotmail.com (Ken Sandars)
Date: Thu, 6 Dec 2007 17:55:43 +1100
Subject: [Stgt-devel] iSER enabled TGT source
Message-ID: <BLU117-W279BAE75D30AB23EF36297D76F0@phx.gbl>

Hi,

When I pull the source code from the git server I can't find the iSER support. I tried to apply the set of 20 patches in the group posts, but I'm finding they are applying with numerous errors to the current git codebase. Where can I find or assemble the current stgt with iSER support? I'm happy to be told I'm a goose if I'm missing something really obvious! ;-)

Thanks
Ken

_________________________________________________________________
New music from the Rogue Traders - listen now!
http://ninemsn.com.au/share/redir/adTrack.asp?mode=click&clientID=832&referral=hotmailtaglineOct07&URL=http://music.ninemsn.com.au/roguetraders
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071206/06cb875c/attachment.html>

From nejc.porenta at gmail.com  Thu Dec  6 08:12:55 2007
From: nejc.porenta at gmail.com (Jernej Porenta)
Date: Thu, 6 Dec 2007 08:12:55 +0100
Subject: [Stgt-devel] iSER enabled TGT source
In-Reply-To: <BLU117-W279BAE75D30AB23EF36297D76F0@phx.gbl>
References: <BLU117-W279BAE75D30AB23EF36297D76F0@phx.gbl>
Message-ID: <df5c931c0712052312q2e440ccavd7978a069ae87e92@mail.gmail.com>

On Dec 6, 2007 7:55 AM, Ken Sandars <kensandars at hotmail.com> wrote:
>
> Hi,
>
> When I pull the source code from the git server I can't find the iSER
> support. I tried to apply the set of 20 patches in the group posts, but I'm
> finding they are applying with numerous errors to the current git codebase.
> Where can I find or assemble the current stgt with iSER support? I'm happy
> to be told I'm a goose if I'm missing something really obvious! ;-)

The sources for iSER are available through Pete's GIT repository:
http://git.osc.edu/

As far as I know, iSER patches are slowly integrating in mainline TGT.
Pete's project is just a spinoff which is quite useful :)

cheers, J.


From fujita.tomonori at lab.ntt.co.jp  Thu Dec  6 08:47:41 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 06 Dec 2007 16:47:41 +0900
Subject: [Stgt-devel] iSER enabled TGT source
In-Reply-To: <df5c931c0712052312q2e440ccavd7978a069ae87e92@mail.gmail.com>
References: <BLU117-W279BAE75D30AB23EF36297D76F0@phx.gbl>
	<df5c931c0712052312q2e440ccavd7978a069ae87e92@mail.gmail.com>
Message-ID: <20071206164741J.fujita.tomonori@lab.ntt.co.jp>

On Thu, 6 Dec 2007 08:12:55 +0100
"Jernej Porenta" <nejc.porenta at gmail.com> wrote:

> On Dec 6, 2007 7:55 AM, Ken Sandars <kensandars at hotmail.com> wrote:
> >
> > Hi,
> >
> > When I pull the source code from the git server I can't find the iSER
> > support. I tried to apply the set of 20 patches in the group posts, but I'm
> > finding they are applying with numerous errors to the current git codebase.
> > Where can I find or assemble the current stgt with iSER support? I'm happy
> > to be told I'm a goose if I'm missing something really obvious! ;-)
> 
> The sources for iSER are available through Pete's GIT repository:
> http://git.osc.edu/
> 
> As far as I know, iSER patches are slowly integrating in mainline TGT.
> Pete's project is just a spinoff which is quite useful :)

Yeah, I've merged most of changes to tgt for iSER. I've been waiting
Pete to submit the new iSER patchset.





From robin.humble+stgt at anu.edu.au  Thu Dec  6 09:40:54 2007
From: robin.humble+stgt at anu.edu.au (Robin Humble)
Date: Thu, 6 Dec 2007 03:40:54 -0500
Subject: [Stgt-devel] read << write
In-Reply-To: <20071206075453J.fujita.tomonori@lab.ntt.co.jp>
References: <20071205135609.GA1864@lemming.cita.utoronto.ca>
	<20071206075453J.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20071206084054.GA30936@lemming.cita.utoronto.ca>

On Thu, Dec 06, 2007 at 07:54:53AM +0900, FUJITA Tomonori wrote:
>On Wed, 5 Dec 2007 08:56:09 -0500 Robin Humble <robin.humble+stgt at anu.edu.au> wrote:
>> I'm finding that reads are a lot slower than writes when I have a real
>> file or device behind tgt instead of a ramdisk. is this expected?
>> 
>> iSER reads backed by a file on lustre or a md raid0 device seem to be at
>> most ~100MB/s which is 4 or 5 times slower than writes:
>Can you try a block-level benchmark like disktest to avoid file
>systems effects?

I'm afraid I don't have enough experience with disktest to know when
it's lying to me and/or when I'm driving it foolishly.

how about just large dd's?

                          write    read (MB/s)
 iSER + /dev/md0           333     110
 iSER + file on lustre     552     207
 iSER + ramdisk            905     410

 local /dev/md0            313     330
 local file on lustre      705     473
 local ramdisk            1600    2900

which are eg.
  dd if=/dev/zero of=/dev/sdc bs=1M count=10000
where 10G is >> (512M ram on initiator + 512M ram on target) so
buffering should be small.

cheers,
robin


From pw at osc.edu  Thu Dec  6 14:42:44 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 6 Dec 2007 08:42:44 -0500
Subject: [Stgt-devel] iSER enabled TGT source
In-Reply-To: <20071206164741J.fujita.tomonori@lab.ntt.co.jp>
References: <BLU117-W279BAE75D30AB23EF36297D76F0@phx.gbl>
	<df5c931c0712052312q2e440ccavd7978a069ae87e92@mail.gmail.com>
	<20071206164741J.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20071206134244.GA23760@osc.edu>

fujita.tomonori at lab.ntt.co.jp wrote on Thu, 06 Dec 2007 16:47 +0900:
> On Thu, 6 Dec 2007 08:12:55 +0100
> "Jernej Porenta" <nejc.porenta at gmail.com> wrote:
> 
> > On Dec 6, 2007 7:55 AM, Ken Sandars <kensandars at hotmail.com> wrote:
> > >
> > > Hi,
> > >
> > > When I pull the source code from the git server I can't find the iSER
> > > support. I tried to apply the set of 20 patches in the group posts, but I'm
> > > finding they are applying with numerous errors to the current git codebase.
> > > Where can I find or assemble the current stgt with iSER support? I'm happy
> > > to be told I'm a goose if I'm missing something really obvious! ;-)
> > 
> > The sources for iSER are available through Pete's GIT repository:
> > http://git.osc.edu/
> > 
> > As far as I know, iSER patches are slowly integrating in mainline TGT.
> > Pete's project is just a spinoff which is quite useful :)
> 
> Yeah, I've merged most of changes to tgt for iSER. I've been waiting
> Pete to submit the new iSER patchset.

I'm exactly half way through the 52 (!) patches Tomo applied in a
flurry in November.  They make the iser change simpler, but require
lots of rebasing to make sure I don't miss anything.

		-- Pete


From pw at osc.edu  Thu Dec  6 16:20:33 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 6 Dec 2007 10:20:33 -0500
Subject: [Stgt-devel] read << write
In-Reply-To: <20071206084054.GA30936@lemming.cita.utoronto.ca>
References: <20071205135609.GA1864@lemming.cita.utoronto.ca>
	<20071206075453J.fujita.tomonori@lab.ntt.co.jp>
	<20071206084054.GA30936@lemming.cita.utoronto.ca>
Message-ID: <20071206152033.GC23760@osc.edu>

robin.humble+stgt at anu.edu.au wrote on Thu, 06 Dec 2007 03:40 -0500:
> On Thu, Dec 06, 2007 at 07:54:53AM +0900, FUJITA Tomonori wrote:
> >On Wed, 5 Dec 2007 08:56:09 -0500 Robin Humble <robin.humble+stgt at anu.edu.au> wrote:
> >> I'm finding that reads are a lot slower than writes when I have a real
> >> file or device behind tgt instead of a ramdisk. is this expected?
> >> 
> >> iSER reads backed by a file on lustre or a md raid0 device seem to be at
> >> most ~100MB/s which is 4 or 5 times slower than writes:
> >Can you try a block-level benchmark like disktest to avoid file
> >systems effects?
> 
> I'm afraid I don't have enough experience with disktest to know when
> it's lying to me and/or when I'm driving it foolishly.
> 
> how about just large dd's?
> 
>                           write    read (MB/s)
>  iSER + /dev/md0           333     110
>  iSER + file on lustre     552     207
>  iSER + ramdisk            905     410
> 
>  local /dev/md0            313     330
>  local file on lustre      705     473
>  local ramdisk            1600    2900
> 
> which are eg.
>   dd if=/dev/zero of=/dev/sdc bs=1M count=10000
> where 10G is >> (512M ram on initiator + 512M ram on target) so
> buffering should be small.

Interesting, but I can not guess why.  My results to ram disk for
the default tgt and linux client config show reads at line rate (920
MB/s) but writes somewhat slower (850 MB/s).  It is important to get
multiple outstanding commands from the client point of view, and
perhaps dd is not doing that, nor is bonnie?

You might wander around /sys to make sure that iscsi is keeping
enough commands in flight (128 is default, plenty).  And try things
like sg_dd, sgp_dd, and disktest as Tomo suggests.

One of the big effects we noticed with speeds like this is that
caching effects on the target become significant.  Yes, normal L2
processor cache compared to memory speeds show up in a big way.

Here's some numbers and details on ramdisk performance from a
talk I gave at SNAPI, if it helps you with insight:

    http://www.osc.edu/~pw/talks/iser-snapi07/talk.pdf

You are lucky/cursed to have such good-performing disks.  Will be
interested to see if you find much.  Other tools of interest may be
blktrace and oprofile on the target.

		-- Pete


From pw at osc.edu  Thu Dec  6 18:49:06 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 6 Dec 2007 12:49:06 -0500
Subject: [Stgt-devel] read << write
In-Reply-To: <20071206152033.GC23760@osc.edu>
References: <20071205135609.GA1864@lemming.cita.utoronto.ca>
	<20071206075453J.fujita.tomonori@lab.ntt.co.jp>
	<20071206084054.GA30936@lemming.cita.utoronto.ca>
	<20071206152033.GC23760@osc.edu>
Message-ID: <20071206174906.GA24151@osc.edu>

pw at osc.edu wrote on Thu, 06 Dec 2007 10:20 -0500:
> Here's some numbers and details on ramdisk performance from a
> talk I gave at SNAPI, if it helps you with insight:
> 
>     http://www.osc.edu/~pw/talks/iser-snapi07/talk.pdf

Oops.

http://www.osc.edu/~pw/papers/wyckoff-iser-snapi07-talk.pdf



From pw at osc.edu  Thu Dec  6 20:14:06 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 6 Dec 2007 14:14:06 -0500
Subject: [Stgt-devel] [PATCH] bidi rounding bug
Message-ID: <20071206191406.GA24206@osc.edu>

Round up the data allocation for the bidi read buffer, but store the
true length in the scsi_data_buffer for use by devices.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    5 +++--
 1 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 1b19b35..502ab1e 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1163,10 +1163,11 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 			dprintf("bidi read len %u\n", in_length);
 
 			if (in_length) {
+				uint32_t len;
 				void *buf;
 
-				in_length = roundup(in_length, 4);
-				buf = conn->tp->alloc_data_buf(conn, in_length);
+				len = roundup(in_length, 4);
+				buf = conn->tp->alloc_data_buf(conn, len);
 				if (!buf)
 					return -ENOMEM;
 
-- 
1.5.3.4



From tomof at acm.org  Thu Dec  6 22:46:09 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Fri, 7 Dec 2007 06:46:09 +0900
Subject: [Stgt-devel] [PATCH] bidi rounding bug
In-Reply-To: <20071206191406.GA24206@osc.edu>
References: <20071206191406.GA24206@osc.edu>
Message-ID: <20071207064611T.tomof@acm.org>

On Thu, 6 Dec 2007 14:14:06 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> Round up the data allocation for the bidi read buffer, but store the
> true length in the scsi_data_buffer for use by devices.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsid.c |    5 +++--
>  1 files changed, 3 insertions(+), 2 deletions(-)

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Fri Dec  7 01:01:49 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 07 Dec 2007 09:01:49 +0900
Subject: [Stgt-devel] iSER enabled TGT source
In-Reply-To: <20071206134244.GA23760@osc.edu>
References: <df5c931c0712052312q2e440ccavd7978a069ae87e92@mail.gmail.com>
	<20071206164741J.fujita.tomonori@lab.ntt.co.jp>
	<20071206134244.GA23760@osc.edu>
Message-ID: <20071207090149K.fujita.tomonori@lab.ntt.co.jp>

On Thu, 6 Dec 2007 08:42:44 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> fujita.tomonori at lab.ntt.co.jp wrote on Thu, 06 Dec 2007 16:47 +0900:
> > On Thu, 6 Dec 2007 08:12:55 +0100
> > "Jernej Porenta" <nejc.porenta at gmail.com> wrote:
> > 
> > > On Dec 6, 2007 7:55 AM, Ken Sandars <kensandars at hotmail.com> wrote:
> > > >
> > > > Hi,
> > > >
> > > > When I pull the source code from the git server I can't find the iSER
> > > > support. I tried to apply the set of 20 patches in the group posts, but I'm
> > > > finding they are applying with numerous errors to the current git codebase.
> > > > Where can I find or assemble the current stgt with iSER support? I'm happy
> > > > to be told I'm a goose if I'm missing something really obvious! ;-)
> > > 
> > > The sources for iSER are available through Pete's GIT repository:
> > > http://git.osc.edu/
> > > 
> > > As far as I know, iSER patches are slowly integrating in mainline TGT.
> > > Pete's project is just a spinoff which is quite useful :)
> > 
> > Yeah, I've merged most of changes to tgt for iSER. I've been waiting
> > Pete to submit the new iSER patchset.
> 
> I'm exactly half way through the 52 (!) patches Tomo applied in a
> flurry in November.  They make the iser change simpler, but require
> lots of rebasing to make sure I don't miss anything.

Thanks, I'm looking forward to the next patchset (and sorry about lots
of the changes).


From kensandars at hotmail.com  Fri Dec  7 07:24:53 2007
From: kensandars at hotmail.com (Ken Sandars)
Date: Fri, 7 Dec 2007 17:24:53 +1100
Subject: [Stgt-devel] iSER enabled TGT source
In-Reply-To: <20071206134244.GA23760@osc.edu>
References: <BLU117-W279BAE75D30AB23EF36297D76F0@phx.gbl>
	<df5c931c0712052312q2e440ccavd7978a069ae87e92@mail.gmail.com>
	<20071206164741J.fujita.tomonori@lab.ntt.co.jp> 
	<20071206134244.GA23760@osc.edu>
Message-ID: <BLU117-W293003F16E2E9E544F9FDCD7680@phx.gbl>


Hi Pete,

I'm having trouble getting the code base - is it because you're still cranking away at the sky-high pile of patches?

error: Could not interpret 



_________________________________________________________________
It's simple! Sell your car for just $30 at CarPoint.com.au
http://a.ninemsn.com.au/b.aspx?URL=http%3A%2F%2Fsecure%2Dau%2Eimrworldwide%2Ecom%2Fcgi%2Dbin%2Fa%2Fci%5F450304%2Fet%5F2%2Fcg%5F801459%2Fpi%5F1004813%2Fai%5F859641&_t=762955845&_r=tig_OCT07&_m=EXT

From pw at osc.edu  Fri Dec  7 18:09:27 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Fri, 7 Dec 2007 12:09:27 -0500
Subject: [Stgt-devel] [PATCH 15/20] iser rounding
In-Reply-To: <20071115112052Z.fujita.tomonori@lab.ntt.co.jp>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
	<6dae60a5f3d8f3947bceeb57f3c7c4bcead8fadb.1192554396.git.pw@osc.edu>
	<20071115112052Z.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20071207170927.GA26300@osc.edu>

fujita.tomonori at lab.ntt.co.jp wrote on Thu, 15 Nov 2007 11:20 +0900:
> On Tue, 16 Oct 2007 11:21:23 -0400
> Pete Wyckoff <pw at osc.edu> wrote:
> 
> > RDMA data packets are not padded up to 4 byte boundaries, unlike TCP.
> > Reasons for this can be found in doc/README.iser.
> > 
> > Signed-off-by: Pete Wyckoff <pw at osc.edu>
> > ---
> >  usr/iscsi/iscsid.c |   24 +++++++++++++++++-------
> >  1 files changed, 17 insertions(+), 7 deletions(-)
> > 
> > diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> > index 8b7b48e..6d5471e 100644
> > --- a/usr/iscsi/iscsid.c
> > +++ b/usr/iscsi/iscsid.c
> > @@ -1157,7 +1157,9 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
> >  			uint32_t len;
> >  			void *buf;
> >  
> > -			len = roundup(task->read_len, 4);
> > +			len = task->read_len;
> > +			if (!conn->tp->rdma)
> > +				len = roundup(len, 4);
> 
> I want to avoid doing something like this:
> 
> if (conn->tp->rdma)
> 	do iser
> else
> 	do tcp
> 
> 
> Can you add 'pad_len' to iscsi_transport struct and do something like:
> 
> len = roundup(task->read_len, conn->tp->pad_len);
> 
> tcp sets it to PAD_WORD_LEN and iser sets it to 1.

Good suggestion.  I called it "data_padding" though as other
segments are rounded even for RDMA (e.g. AHS).

		-- Pete


From pw at osc.edu  Fri Dec  7 21:21:43 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Fri, 7 Dec 2007 15:21:43 -0500
Subject: [Stgt-devel] [PATCH 08/20] iser virtualize malloc
In-Reply-To: <20071112231205A.tomof@acm.org>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
	<8d2b6cf668663c5ea180d67c60c865cf3fa249de.1192554396.git.pw@osc.edu>
	<20071112231205A.tomof@acm.org>
Message-ID: <20071207202143.GA26406@osc.edu>

tomof at acm.org wrote on Mon, 12 Nov 2007 23:14 +0900:
> On Tue, 16 Oct 2007 11:20:21 -0400
> Pete Wyckoff <pw at osc.edu> wrote:
> 
> > Virtualize malloc and free when dealing with memory that the
> > transport will use.  It must be per-connection for RDMA.
> 
> I modified and merged this.
> 
> As I said, we need aligned buffer for data transfer so I added
> alloc/free_data_buf to iscsi_transport.

This works well.  Haven't looked at the timings yet, though.

> If you need pre-registered buffer for iscsi_task too (for sense, I
> guess), you can add alloc/free_task to iscsi_transport. But I think
> that you don't need to use pre-registered buffer for sense and you can
> register sense buffer when you need it.

Sense goes in response message, so is memcpy-ed to pre-registered
small packet areas.  Only DATA_IN gets converted to RDMA write
and R2T to RDMA read.  Everything else goes through a memcpy
currently.

Perhaps there is an optimization to avoid the copies, but it would
require managing conn->rx_buffer and tx_buffer and sense in a way
that is a bit invasive to core iscsid.c.  I'm not going to try it.

		-- Pete


From pw at osc.edu  Fri Dec  7 21:23:53 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Fri, 7 Dec 2007 15:23:53 -0500
Subject: [Stgt-devel] [PATCH] task data leak
Message-ID: <20071207202353.GA26422@osc.edu>

iscsi_scsi_cmd_rx_start always allocates a buffer of 4096 to accommodate
assumptions in spc, sbc, etc.  Even when a SCSI command asks for data
length of zero, task->data is allocated to 4096.  However this is never
assigned as in or out buf on scmd.  Thus never freed.

This works around that by freeing an orphaned task->data.  Again, though,
the better solution is to fix up all the little functions like inquiry
that cause this situation in the first place.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |   11 +++++++++++
 1 files changed, 11 insertions(+), 0 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 1e0172a..ab1999d 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1024,6 +1024,17 @@ void iscsi_free_task(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 
+	/*
+	 * Catch case when data_len is zero but pushed up to 4096
+	 * to work around spc allocation assumption, but then later
+	 * determined to be DATA_NONE and not used as either in or
+	 * out buffer.
+	 */
+	if (task->data &&
+	    task->data != scsi_get_in_buffer(&task->scmd) &&
+	    task->data != scsi_get_out_buffer(&task->scmd))
+		conn->tp->free_data_buf(conn, task->data);
+
 	conn->tp->free_data_buf(conn, scsi_get_in_buffer(&task->scmd));
 	conn->tp->free_data_buf(conn, scsi_get_out_buffer(&task->scmd));
 
-- 
1.5.3.4



From pw at osc.edu  Fri Dec  7 21:37:41 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Fri, 7 Dec 2007 15:37:41 -0500
Subject: [Stgt-devel] [PATCH 16/20] iser params
In-Reply-To: <20071115112445G.fujita.tomonori@lab.ntt.co.jp>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
	<f95af5713c1de674b0792b7742c6babe91c7be83.1192554396.git.pw@osc.edu>
	<20071115112445G.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20071207203741.GA26440@osc.edu>

fujita.tomonori at lab.ntt.co.jp wrote on Thu, 15 Nov 2007 11:24 +0900:
> On Tue, 16 Oct 2007 11:21:24 -0400
> Pete Wyckoff <pw at osc.edu> wrote:
> > diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
> > index ab0685f..d7c1d57 100644
> > --- a/usr/iscsi/target.c
> > +++ b/usr/iscsi/target.c
> > @@ -283,6 +283,14 @@ int iscsi_target_create(struct target *t)
> >  		[ISCSI_PARAM_OFMARKINT] = {0, 2048},
> >  		[ISCSI_PARAM_IFMARKINT] = {0, 2048},
> >  		[ISCSI_PARAM_MAXCONNECTIONS] = {0, 1},
> > +#ifdef ISCSI_RDMA
> > +		[ISCSI_PARAM_RDMA_EXTENSIONS] = {0, 1},
> > +#else
> > +		[ISCSI_PARAM_RDMA_EXTENSIONS] = {0, 0},
> > +#endif
> > +		[ISCSI_PARAM_TARGET_RDSL] = {0, 262144},
> > +		[ISCSI_PARAM_INITIATOR_RDSL] = {0, 262144},
> > +		[ISCSI_PARAM_MAX_OUTST_PDU] =  {0, 0},  /* not in open-iscsi */
> >  	};
> 
> Can we avoid adding another #ifdef?
> 
> I really like to remove the existing #ifdef.

Yes, turns out this ifdef is no longer needed due to the chunk here:

> > diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> >  static void text_scan_login(struct iscsi_connection *conn)
> >  {
[..]
> > @@ -289,6 +289,9 @@ static void text_scan_login(struct iscsi_connection *conn)
> >  			if (idx == ISCSI_PARAM_MAX_RECV_DLENGTH)
> >  				idx = ISCSI_PARAM_MAX_XMIT_DLENGTH;
> >  
> > +			if (idx == ISCSI_PARAM_RDMA_EXTENSIONS)
> > +				is_rdma = 1;
> > +
> >  			if (param_str_to_val(session_keys, idx, value, &val) < 0) {
> >  				if (conn->session_param[idx].state
> >  				    == KEY_STATE_START) {
> > @@ -335,6 +338,15 @@ static void text_scan_login(struct iscsi_connection *conn)
> >  			text_key_add(conn, key, "NotUnderstood");
> >  	}
> >  
> > +	if (is_rdma) {
> > +		/* do not try to do digests, not supported in iser */
> > +		conn->session_param[ISCSI_PARAM_HDRDGST_EN].val = DIGEST_NONE;
> > +		conn->session_param[ISCSI_PARAM_DATADGST_EN].val = DIGEST_NONE;
> > +	} else {
> > +		/* do not offer RDMA, initiator must explicitly request */
> > +		conn->session_param[ISCSI_PARAM_RDMA_EXTENSIONS].val = 0;
> > +	}
> > +
> >  out:
> >  	return;
> >  }

Now patch is always "= { 0, 1 }".  But the code in text_scan_login
ensures that the target will never offer RDMAExtension unless it
sees the initiator offer it first.  This perhaps isn't exactly
right, as the spec seems to allow the target to offer it during
Operational Parameter Negotiation phase.  But doing so would confuse
initiators that do not recognize the key, so I think it wise to wait
for the initiator to ask.

		-- Pete


From tomof at acm.org  Sat Dec  8 13:59:58 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 08 Dec 2007 21:59:58 +0900
Subject: [Stgt-devel] [PATCH] task data leak
In-Reply-To: <20071207202353.GA26422@osc.edu>
References: <20071207202353.GA26422@osc.edu>
Message-ID: <200712081300.lB8D01JC014951@mbox.iij4u.or.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] task data leak
Date: Fri, 7 Dec 2007 15:23:53 -0500

> iscsi_scsi_cmd_rx_start always allocates a buffer of 4096 to accommodate
> assumptions in spc, sbc, etc.  Even when a SCSI command asks for data
> length of zero, task->data is allocated to 4096.  However this is never
> assigned as in or out buf on scmd.  Thus never freed.
> 
> This works around that by freeing an orphaned task->data.  Again, though,
> the better solution is to fix up all the little functions like inquiry
> that cause this situation in the first place.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsid.c |   11 +++++++++++
>  1 files changed, 11 insertions(+), 0 deletions(-)
> 
> diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> index 1e0172a..ab1999d 100644
> --- a/usr/iscsi/iscsid.c
> +++ b/usr/iscsi/iscsid.c
> @@ -1024,6 +1024,17 @@ void iscsi_free_task(struct iscsi_task *task)
>  {
>  	struct iscsi_connection *conn = task->conn;
>  
> +	/*
> +	 * Catch case when data_len is zero but pushed up to 4096
> +	 * to work around spc allocation assumption, but then later
> +	 * determined to be DATA_NONE and not used as either in or
> +	 * out buffer.
> +	 */
> +	if (task->data &&
> +	    task->data != scsi_get_in_buffer(&task->scmd) &&
> +	    task->data != scsi_get_out_buffer(&task->scmd))
> +		conn->tp->free_data_buf(conn, task->data);
> +

Nice catch, thanks.

How about this patch?

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 1e0172a..e27c74c 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1435,7 +1435,7 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 	/*
 	 * fix spc, sbc, etc. they assume that buffer is long enough.
 	 */
-	if (data_len < 4096)
+	if (data_len && data_len < 4096)
 		data_len = 4096;
 
 	ext_len = ahs_len ? sizeof(req->cdb) + ahs_len : 0;


From pw at osc.edu  Sat Dec  8 16:30:16 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 8 Dec 2007 10:30:16 -0500
Subject: [Stgt-devel] [PATCH] task data leak
In-Reply-To: <200712081300.lB8D01JC014951@mbox.iij4u.or.jp>
References: <20071207202353.GA26422@osc.edu>
	<200712081300.lB8D01JC014951@mbox.iij4u.or.jp>
Message-ID: <20071208153016.GA10075@osc.edu>

tomof at acm.org wrote on Sat, 08 Dec 2007 21:59 +0900:
> From: Pete Wyckoff <pw at osc.edu>
> Subject: [Stgt-devel] [PATCH] task data leak
> Date: Fri, 7 Dec 2007 15:23:53 -0500
> 
> > iscsi_scsi_cmd_rx_start always allocates a buffer of 4096 to accommodate
> > assumptions in spc, sbc, etc.  Even when a SCSI command asks for data
> > length of zero, task->data is allocated to 4096.  However this is never
> > assigned as in or out buf on scmd.  Thus never freed.
> > 
> > This works around that by freeing an orphaned task->data.  Again, though,
> > the better solution is to fix up all the little functions like inquiry
> > that cause this situation in the first place.
> > 
> > Signed-off-by: Pete Wyckoff <pw at osc.edu>
> > ---
> >  usr/iscsi/iscsid.c |   11 +++++++++++
> >  1 files changed, 11 insertions(+), 0 deletions(-)
> > 
> > diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> > index 1e0172a..ab1999d 100644
> > --- a/usr/iscsi/iscsid.c
> > +++ b/usr/iscsi/iscsid.c
> > @@ -1024,6 +1024,17 @@ void iscsi_free_task(struct iscsi_task *task)
> >  {
> >  	struct iscsi_connection *conn = task->conn;
> >  
> > +	/*
> > +	 * Catch case when data_len is zero but pushed up to 4096
> > +	 * to work around spc allocation assumption, but then later
> > +	 * determined to be DATA_NONE and not used as either in or
> > +	 * out buffer.
> > +	 */
> > +	if (task->data &&
> > +	    task->data != scsi_get_in_buffer(&task->scmd) &&
> > +	    task->data != scsi_get_out_buffer(&task->scmd))
> > +		conn->tp->free_data_buf(conn, task->data);
> > +
> 
> Nice catch, thanks.
> 
> How about this patch?
> 
> diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> index 1e0172a..e27c74c 100644
> --- a/usr/iscsi/iscsid.c
> +++ b/usr/iscsi/iscsid.c
> @@ -1435,7 +1435,7 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
>  	/*
>  	 * fix spc, sbc, etc. they assume that buffer is long enough.
>  	 */
> -	if (data_len < 4096)
> +	if (data_len && data_len < 4096)
>  		data_len = 4096;
>  
>  	ext_len = ahs_len ? sizeof(req->cdb) + ahs_len : 0;
> 

Would be simpler, yes, but less safe.  Client could do an inquiry
with data_len of 0 and lead to a crash in spc_inquiry, e.g.

We really should just fix those functions.  Adding a bunch of "if
(data_len > ...)" is one way, although one would need many of these
tests for all the various cases.  I had proposed allocating a temp
buffer, then memcpy with bounds checking into whatever out_buffer is
available as the final step.  See the old 03/20 iser-transport-buf
patch if you think that has merit.

The other issue is that inquiry etc. expect a zeroed buffer, and
trying to guess if scsi_is_io_opcode() to determine if the handler
function doesn't need zeroing is insufficient.  I'll send a terrible
patch to work around this for OSD, but would prefer to fix inquiry
and friends instead.

		-- Pete


From pw at osc.edu  Sat Dec  8 16:31:28 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 8 Dec 2007 10:31:28 -0500
Subject: [Stgt-devel] [PATCH] osd avoid memzero
Message-ID: <20071208153128.GB10075@osc.edu>

To work around the zeroing of task->data, add VARLEN_CDB as an "IO"
opcode.  It isn't necesssarily, but the only handler of this opcode is
OSD and it does not require zeroing for any of its commands.

Remove this once the spc, sbc, etc. functions that assume a zeroed buffer
have been fixed.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/scsi.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/usr/scsi.c b/usr/scsi.c
index 2bdc0b5..b2db738 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -154,6 +154,7 @@ int scsi_is_io_opcode(unsigned char op)
 	case WRITE_16:
 	case VERIFY_16:
 	case WRITE_VERIFY_16:
+	case VARLEN_CDB:  /* not necessarily IO, but does not need allocation */
 		ret = 1;
 		break;
 	default:
-- 
1.5.3.4



From markh794 at gmail.com  Sat Dec  8 10:12:21 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 08 Dec 2007 20:12:21 +1100
Subject: [Stgt-devel] [PATCH] INQUIRY Additional len size incorrectly
	calculated
Message-ID: <475A5FF5.6020707@gmail.com>

>From 70246d2420b5ec4180289ae64a1abb92ae3c8e11 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Sat, 8 Dec 2007 19:46:54 +1100
Subject: Incorrect calculation for standard INQUIRY additional len field

Additional len calculated incorrectly due to len not being set
before use.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/spc.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/usr/spc.c b/usr/spc.c
index 5b258bd..aa8ff9e 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -182,8 +182,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 		for (i = 0; i < ARRAY_SIZE(attrs->version_desc); i++)
 			*desc++ = __cpu_to_be16(attrs->version_desc[i]);
 
-		data[4] = len - 5;	/* Additional Length */
 		len = 66;
+		data[4] = len - 5;	/* Additional Length */
 		ret = SAM_STAT_GOOD;
 	} else if (scb[1] & 0x2) {
 		/* CmdDt bit is set */
-- 
1.5.2.5






From pw at osc.edu  Mon Dec 10 16:03:25 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 10 Dec 2007 10:03:25 -0500
Subject: [Stgt-devel] iSER patches, third release
Message-ID: <20071210150325.GA31889@osc.edu>

This is the third major release of support for iSCSI Extensions
for RDMA (iSER) to the existing TGT user space SCSI target.  It
uses OpenFabrics libraries and kernel drivers to act as a SCSI
target over RDMA-capable devices.  The code has been tested
against the existing Linux iSER initiator over InfiniBand cards,
but should be specification compliant and work generally.

A bit of documentation is included, and a short technical report is
available at http://www.osc.edu/~pw/papers/iser-snapi07.pdf with
slides from a presentation at
http://www.osc.edu/~pw/papers/wyckoff-iser-snapi07-talk.pdf .

The iSER patches can be downloaded from:

        git://git.osc.edu/tgt

or browsed at:

        http://git.osc.edu/?p=tgt.git;a=summary

Changes since previous series are as follows.

Tomo redid substantial parts of tgt, including data buffer handling,
and merged many of the easier patches from the previous iSER
patches.  This reduces the load from 20 patches down to 6 this time.
(Not counting two little task->data ones recently posted.)

There is not a lot of change in the remaining patches from the
previous release, just some minor alterations to accommodate core
tgt changes and to follow some suggestions from Tomo.  Here's the
summary:

1 iser docs - just doc/

2 iser task transport data - need private data in struct task,
    could merge as is, or let iscsi transport do allocation as
    with connection struct.

3 iser rounding - removed "if (conn->tp->rdma)" approach, now uses
    "conn->tp->data_padding".  Also deleted some roundup()s that
    were unnecessary in both cases.

4 iser params - new parameters for iSER straight from spec docs.  No
    ifdef on ISCSI_RDMA, we let initiator say if it wants RDMA or
    not.

5 iser iscsid changes - five little "if (conn->tp->rdma)" changes,
    all necessary due to protocol differences and different event
    handler

6 iser core - add iscsi/iscsi_rdma.c and hooks to use it

Performance has changed a bit for the worse in tgt core since the
last release, unfortunately.  Brief results from an unscientfic
study, using the same kernel (2.6.23-rc1) but different userspace
libraries (f8 vs f7).  All ramdisk.  Same tuning in all cases.

GigE: I'm seeing about 5 MB/s less for both read and write.  IPoIB:
writes are unchanged but reads go up(!) from 140 to 180 MB/s.  Must
be libibverbs.so improvements.  iSER: writes are a bit worse this
time around, by maybe 50 MB/s or so, and reads lose about 100 MB/s
for some transfer sizes.  Still 400 MB/s-ish for writes but now only
500 MB/s-ish for reads.  Hopefully none of this shows up when using
real disks.

I'll look at what causes these performance changes and try out some
more recent kernels.  But I wanted to get the patches to people so
as not to hold up any other work.  Would love to see some more
scientific numbers from people, and help figuring out where the time
is going.

		-- Pete


From pw at osc.edu  Mon Dec 10 16:04:13 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 10 Dec 2007 10:04:13 -0500
Subject: [Stgt-devel] [PATCH 1/6] iser docs
In-Reply-To: <20071210150325.GA31889@osc.edu>
References: <20071210150325.GA31889@osc.edu>
Message-ID: <20071210150413.GB31889@osc.edu>

A document describing what iSCSI on RDMA is about, how it is
implemented in tgtd, and how to use it.  Also things that
should be fixed someday.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 doc/README.iser |  264 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 264 insertions(+), 0 deletions(-)
 create mode 100644 doc/README.iser

diff --git a/doc/README.iser b/doc/README.iser
new file mode 100644
index 0000000..2361c4e
--- /dev/null
+++ b/doc/README.iser
@@ -0,0 +1,264 @@
+iSCSI Extensions for RDMA (iSER)
+================================
+
+Copyright (C) 2007 Pete Wyckoff <pw at osc.edu>
+
+Background
+----------
+
+There is an IETF standards track RFC 5046 that extends the iSCSI protocol
+to work on RDMA-capable networks as well as on traditional TCP/IP:
+
+	Internet Small Computer System Interface (iSCSI) Extensions
+	for Remote Direct Memory Access (RDMA), Mike Ko, October 2007.
+
+RDMA stands for Remote Direct Memory Access, a way of accessing memory
+of a remote node directly through the network without involving the
+processor of that remote node.  Many network devices implement some form
+of RDMA.  Two of the more popular network devices are InfiniBand (IB)
+and iWARP.  IB uses its own physical and network layer, while iWARP sits
+on top of TCP/IP (or SCTP).
+
+Using these devices requires a new application programming interface
+(API).  The Linux kernel has many components of the OpenFabrics software
+stack, including APIs for access from user space and drivers for some
+popular RDMA-capable NICs, including IB cards with the Mellanox chipset
+and iWARP cards from NetEffect, Chelsio, and Ammasso.  Most Linux
+distributions ship the user space libraries for device access and RDMA
+connection management.
+
+
+RDMA in tgtd
+------------
+
+The Linux kernel can act as a SCSI initiator on the iSER transport, but
+not as a target.  tgtd is a user space target that supports multiple
+transports, including iSCSI/TCP, and now iSER on RDMA devices.
+
+The iSER code was written by researchers at the Ohio Supercomputer
+Center in early 2007:
+
+	Dennis Dalessandro <dennis at osc.edu>
+	Ananth Devulapalli <ananth at osc.edu>
+	Pete Wyckoff <pw at osc.edu>
+
+We wanted to use a faster transport to test the capabilities of an
+object-based storage device (OSD) emulator we had previously written.
+Our cluster has InfiniBand cards, and while running TCP/IP over IB is
+possible, the performance is not nearly as good as using native IB
+directly.
+
+A report describing this implementation and some performance results
+appears in IEEE conference proceedings as:
+
+	Dennis Dalessandro, Ananth Devulapalli and Pete Wyckoff,
+	iSER Storage Target for Object-based Storage Devices,
+	Proceedings of MSST'07, SNAPI Workshop, San Diego, CA,
+	September 2007.
+
+and is available at:
+
+	http://www.osc.edu/~pw/papers/iser-snapi07.pdf
+
+Slides of the talk with more results and analysis are also available at:
+
+	http://www.osc.edu/~pw/papers/wyckoff-iser-snapi07-talk.pdf
+
+The code mostly lives in iscsi/iscsi_rdma.c, with a few places in
+iscsi/iscsid.c that check if the transport is RDMA or not and behave
+accordingly.  iSCSI already had the idea of a transport, with just the
+single TCP one defined.  We added the RDMA transport and virtualized
+some more functions where TCP and RDMA behave differently.
+
+
+Design Issues
+-------------
+
+In general, a SCSI system includes two components, an initiator and a
+target. The initiator submits commands and awaits responses.  The target
+services commands from initiators and returns responses.  Data may flow
+from the initiator, from the client, or both (bidirectional).  The iSER
+specification requires all data transfers to be started by the target,
+regardless of direction.  In a read operation, the target uses RDMA
+Write to move data to the initiator, while a write operation uses RDMA
+Read to fetch data from the initiator.
+
+
+1. Memory registration
+
+One of the most severe stumbling blocks in moving any application to
+take advantage of RDMA features is memory registration.  Before using
+RDMA, both the sending and receiving buffers must be registered with the
+operating system.  This operation ensures that the underlying hardware
+pages will not be modified during the transfer, and provides the
+physical addresses of the buffers to the network card.  However, the
+process itself is time consuming, and CPU intensive.  Previous
+investigations have shown that for InfiniBand, with a nominal transfer
+rate of 900 MB/s, the throughput drops to around 500 MB/s when memory
+registration and deregistration are included in the critical path.
+
+Our target implementation uses pre-registered buffers for RDMA
+operations.  In general such a scheme is difficult to justify due to the
+large per-connection resource requirements.  However, in this
+application it may be appropriate.  Since the target always initiates
+RDMA operations and never advertises RDMA buffers, it can securely use
+one pool of buffers for multiple clients and can manage its memory
+resources explicitly.  Also, the architecture of the code is such that
+the iSCSI layer dictates incoming and outgoing buffer locations to the
+storage device layer, so supplying a registered buffer is relatively
+easy.
+
+
+2. Event management
+
+There is a mismatch between what the tgtd event framework assumes and
+what the RDMA notification interface provides.  The existing TCP-based
+iSCSI target code has one file descriptor per connection and it is
+driven by readability or writeability of the socket.  A single poll
+system call returns which sockets can be serviced, driving the TCP code
+to read or write as appropriate.  The RDMA interface can be used in
+accordance with this design by requesting interrupts from the network
+card on work request completions.  Notifications appear on the file
+descriptor that represents a completion queue to which all RDMA events
+are delivered.
+
+However, the existing sockets-based code goes beyond this and changes
+the bitmask of requested events to control its code flow.  For instance,
+after it finishes sending a response, it will modify the bitmask to only
+look for readability.  Even if the socket is writeable, there is no data
+to write, hence polling for that status is not useful.  The code also
+disables new message arrival during command execution as a sort of
+exclusion facility, again by modifying the bitmask.  We cannot do this
+with the RDMA interface.  Hence we must maintain an active list of tasks
+that have data to write and drive a progress engine to service them.
+The need for progress is tracked by a counter, and the tgtd event loop
+checks this counter and calls into the iSER-specific while the counter
+is still non-zero.  tgtd will block in the poll call when it must wait
+on network activity.  No dedicated thread is needed for iSER.
+
+
+3. Padding
+
+The iSCSI specification clearly states that all segments in the protocol
+data unit (PDU) must be individually padded to four-byte boundaries.
+However, the iSER specification remains mute on the subject of padding.
+It is clear from an implementation perspective that padding data
+segments is both unnecessary and would add considerable overhead to
+implement.  (Possibly a memory copy or extra SG entry on the initiator
+when sending directly from user memory.)   RDMA is used to move all
+data, with byte granularity provided by the network.  The need for
+padding in the TCP case was motivated by the optional marker support to
+work around the limitations of the streaming mode of TCP.  IB and iWARP
+are message-based networks and would never need markers.  And finally,
+the Linux initiator does not add padding either.
+
+
+Using iSER
+----------
+
+Compile tgtd with "make ISCSI=1 ISCSI_RDMA=1" to build iSCSI and iSER.
+You'll need to have two libraries installed on your system:
+libibverbs.so and librdmacm.so.  If they are installed in the normal
+system paths (/usr/include and /usr/lib or /usr/lib64), they will be
+found automatically.  Otherwise, edit CFLAGS and LIBS in usr/Makefile
+near ISCSI_RDMA to specify the paths by hand, e.g., for a /usr/local
+install, it should look like:
+
+	ifneq ($(ISCSI_RDMA),)
+	CFLAGS += -DISCSI_RDMA -I/usr/local/include
+	TGTD_OBJS += iscsi/iscsi_rdma.o
+	LIBS += -L/usr/local/lib -libverbs -lrdmacm
+	endif
+
+If these libraries are not in the normal system paths, you may
+possibly also have to set, e.g., LD_LIBRARY_PATH=/usr/local/lib
+in your environment to find the shared libraries at runtime.
+
+The target will listen on all TCP interfaces (as usual), as well as all
+RDMA devices.  Both use the same default iSCSI port, 3260.  Clients on
+TCP or RDMA will connect to the same tgtd instance.
+
+Start the daemon (as root):
+
+	./tgtd
+
+It will send messages to syslog.  You can add "-d 9" to turn on debug
+messages.
+
+Configure the running target with one or more devices, using the tgtadm
+program you just built (also as root).  Full information is in
+doc/README.iscsi.  Here is a quick-start guide:
+
+	dd if=/dev/zero bs=1k count=1 seek=1048575 of=/tmp/tid1lun1
+	./tgtadm --lld iscsi --mode target \
+		 --op new --tid 1 --targetname $(hostname)
+	./tgtadm --lld iscsi --mode target \
+		 --op bind --tid 1 --initiator-address ALL
+	./tgtadm --lld iscsi --mode logicalunit \
+		 --op new --tid 1 --lun 1 --backing-store /tmp/tid1lun1
+
+To make your initiator use RDMA, make sure the "ib_iser" module is
+loaded in your kernel.  Then do discovery as usual, over TCP:
+
+	iscsiadm -m discovery -t sendtargets -p $targetip
+
+where $targetip is the ethernet address of your IPoIB device.  Discovery
+traffic will use IPoIB, but login and full feature phase will use RDMA
+natively.
+
+Then do something like the following to change the transport type:
+
+	iscsiadm -m node -p $targetip -T $targetname --op update \
+	    -n node.transport_name -v iser
+
+Next, login as usual:
+
+	iscsiadm -m node -p $targetip -T $targetname --login
+
+And access the new block device, e.g. /dev/sdb.
+
+
+Errata
+------
+
+There is a major bug in the mthca driver in linux kernels before 2.6.21.
+This includes the popular rhel5 kernels, such as 2.6.18-8.1.6.el5 and
+possibly later.  The critical commit is:
+
+    608d8268be392444f825b4fc8fc7c8b509627129
+    IB/mthca: Fix data corruption after FMR unmap on Sinai
+
+If you use single-port memfree cards, SCSI read operations will
+frequently result in randomly corrupted memory, leading to bad
+application data or unexplainable kernel crashes.  Older kernels are
+also missing some nice iSCSI changes that avoids crashes in some
+situations where the target goes away.  Stock kernel.org linux
+2.6.22-rc5 and 2.6.23-rc6 have been tested and are known to work.
+
+The Linux kernel iSER initiator is currently lacking support for
+bidirectional transfers, and for extended command descriptors (CDBs).
+Progress toward adding this is being made, with patches frequently
+appearing on the relevant mailing lists.
+
+The Linux kernel iSER initiator uses a different header structure on its
+packets than is in the iSER specification.  This is described in
+an InfiniBand document and is required for that network, which only
+supports for Zero-Based Addressing.  If you are using a non-IB initiator
+that doesn't need this header extension, it won't work with tgtd.  There
+may be some way to negotiate the header format.  Using iWARP hardware
+devices with the Linux kernel iSER initiator also will not work due to
+its reliance on fast memory registration (FMR), an InfiniBand-only feature.
+
+The current code sizes its per-connection resource consumption based on
+negotiatied parameters.  However, the Linux iSER initiator does not
+support negotiation of MaxOutstandingUnexpectedPDUs, so that value is
+hard-coded in the target.  Also, open-iscsi is hard-coded with a very
+small value of TargetRecvDataSegmentLength, so even though the target
+would be willing to accept a larger size, it cannot.  This may limit
+performance of small transfers on high-speed networks:  transfers bigger
+than 8 kB, but not large enough to amortize a round-trip for RDMA setup.
+
+The data structures for connection management in the iSER code are
+desgined to handle multiple devices, but have never been tested with
+such hardware.
+
-- 
1.5.3.4



From pw at osc.edu  Mon Dec 10 16:04:51 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 10 Dec 2007 10:04:51 -0500
Subject: [Stgt-devel] [PATCH 2/6] iser task transport data
In-Reply-To: <20071210150325.GA31889@osc.edu>
References: <20071210150325.GA31889@osc.edu>
Message-ID: <20071210150451.GC31889@osc.edu>

RDMA will need to store some per-task data to use initiator-provided tags
in later RDMA operations.  Provide some space for this and hook into the
transport at task initialization time.

Based on the patch by Erez Zilber <erezz at voltaire.com>.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |    6 ++++++
 usr/iscsi/iscsid.c    |   13 +++++++++++--
 usr/iscsi/iscsid.h    |    8 ++++----
 usr/iscsi/transport.h |    3 +++
 4 files changed, 24 insertions(+), 6 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 38d2df6..99db99d 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -226,6 +226,10 @@ static int iscsi_tcp_conn_login_complete(struct iscsi_connection *conn)
 	return 0;
 }
 
+static void iscsi_tcp_task_init(struct iscsi_task *task)
+{
+}
+
 static size_t iscsi_tcp_read(struct iscsi_connection *conn, void *buf,
 			     size_t nbytes)
 {
@@ -334,8 +338,10 @@ int iscsi_tcp_getpeername(struct iscsi_connection *conn, struct sockaddr *sa,
 struct iscsi_transport iscsi_tcp = {
 	.name			= "iscsi",
 	.rdma			= 0,
+	.task_trans_len		= 0,
 	.ep_init		= iscsi_tcp_init,
 	.ep_login_complete	= iscsi_tcp_conn_login_complete,
+	.ep_task_init		= iscsi_tcp_task_init,
 	.ep_read		= iscsi_tcp_read,
 	.ep_write_begin		= iscsi_tcp_write_begin,
 	.ep_write_end		= iscsi_tcp_write_end,
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index ab1999d..3cb804e 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -997,10 +997,10 @@ static struct iscsi_task *iscsi_alloc_task(struct iscsi_connection *conn,
 	struct iscsi_task *task;
 	void *buf;
 
-	task = malloc(sizeof(*task) + ext_len);
+	task = malloc(sizeof(*task) + conn->tp->task_trans_len + ext_len);
 	if (!task)
 		return NULL;
-	memset(task, 0, sizeof(*task) + ext_len);
+	memset(task, 0, sizeof(*task) + conn->tp->task_trans_len + ext_len);
 
 	if (data_len) {
 		buf = conn->tp->alloc_data_buf(conn, data_len);
@@ -1016,6 +1016,13 @@ static struct iscsi_task *iscsi_alloc_task(struct iscsi_connection *conn,
 	INIT_LIST_HEAD(&task->c_hlist);
 	INIT_LIST_HEAD(&task->c_list);
 
+	if (conn->tp->task_trans_len)
+		task->trans_data = (void *) &task[1];
+
+	if (ext_len)
+		task->extdata = (void *)((uintptr_t) &task[1] +
+				      conn->tp->task_trans_len);
+
 	conn_get(conn);
 	return task;
 }
@@ -1465,6 +1472,8 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 
 	task->tag = req->itt;
 
+	conn->tp->ep_task_init(task);
+
 	if (ahs_len) {
 		task->ahs = task->extdata + sizeof(req->cdb);
 		conn->req.ahs = task->ahs;
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 518c0eb..3fabfba 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -117,12 +117,12 @@ struct iscsi_task {
 	int unsol_count;
 	int exp_r2tsn;
 
-	void *ahs;
-	void *data;
-
 	struct scsi_cmd scmd;
 
-	unsigned long extdata[0];
+	void *trans_data;   /* transport specific data */
+	void *extdata;      /* extra data, after transport, for ahs only */
+	void *ahs;
+	void *data;
 };
 
 struct iscsi_connection {
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index e1b514d..38e28ae 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -4,13 +4,16 @@
 #include <sys/socket.h>
 
 struct iscsi_connection;
+struct iscsi_task;
 
 struct iscsi_transport {
 	const char *name;
 	int rdma;
+	int task_trans_len;
 
 	int (*ep_init) (void);
 	int (*ep_login_complete)(struct iscsi_connection *conn);
+	void (*ep_task_init)(struct iscsi_task *task);
 	size_t (*ep_read)(struct iscsi_connection *conn, void *buf,
 			  size_t nbytes);
 	size_t (*ep_write_begin)(struct iscsi_connection *conn, void *buf,
-- 
1.5.3.4



From pw at osc.edu  Mon Dec 10 16:05:18 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 10 Dec 2007 10:05:18 -0500
Subject: [Stgt-devel] [PATCH 3/6] iser rounding
In-Reply-To: <20071210150325.GA31889@osc.edu>
References: <20071210150325.GA31889@osc.edu>
Message-ID: <20071210150518.GD31889@osc.edu>

RDMA data packets are not padded up to 4 byte boundaries, unlike TCP.
Reasons for this can be found in doc/README.iser.  Add a transport
field to specify the padding amount, using 1 for RDMA to effectively
disable rounding.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |    1 +
 usr/iscsi/iscsid.c    |   28 ++++++++++++++++------------
 usr/iscsi/transport.h |    1 +
 3 files changed, 18 insertions(+), 12 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 99db99d..68ec7c8 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -339,6 +339,7 @@ struct iscsi_transport iscsi_tcp = {
 	.name			= "iscsi",
 	.rdma			= 0,
 	.task_trans_len		= 0,
+	.data_padding		= PAD_WORD_LEN,
 	.ep_init		= iscsi_tcp_init,
 	.ep_login_complete	= iscsi_tcp_conn_login_complete,
 	.ep_task_init		= iscsi_tcp_task_init,
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 3cb804e..defe3a7 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1184,7 +1184,8 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 				uint32_t len;
 				void *buf;
 
-				len = roundup(in_length, 4);
+				len = roundup(in_length,
+					      conn->tp->data_padding);
 				buf = conn->tp->alloc_data_buf(conn, len);
 				if (!buf)
 					return -ENOMEM;
@@ -1442,9 +1443,9 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 	struct iscsi_task *task;
 	int ahs_len, imm_len, data_len, ext_len;
 
-	ahs_len = roundup(req->hlength * 4, 4);
-	imm_len = roundup(ntoh24(req->dlength), 4);
-	data_len = roundup(ntohl(req->data_length), 4);
+	ahs_len = req->hlength * 4;
+	imm_len = roundup(ntoh24(req->dlength), conn->tp->data_padding);
+	data_len = roundup(ntohl(req->data_length), conn->tp->data_padding);
 
 	dprintf("%u %x %d %d %d %x %x\n", conn->session->tsih,
 		req->cdb[0], ahs_len, imm_len, data_len,
@@ -1835,11 +1836,11 @@ again:
 			conn->rx_buffer = conn->req_buffer;
 			conn->req.ahs = conn->rx_buffer;
 			conn->req.data = conn->rx_buffer
-				+ roundup(conn->req.bhs.hlength * 4, 4);
+				+ conn->req.bhs.hlength * 4;
 		}
 		conn->req.ahssize = conn->req.bhs.hlength * 4;
 		conn->req.datasize = ntoh24(conn->req.bhs.dlength);
-		conn->rx_size = roundup(conn->req.ahssize, 4);
+		conn->rx_size = conn->req.ahssize;
 		if (conn->rx_size) {
 			conn->rx_buffer = conn->req.ahs;
 			conn->rx_iostate = IOSTATE_RX_AHS;
@@ -1878,8 +1879,7 @@ again:
 		crc = ~0;
 		crc = crc32c(crc, &conn->req.bhs, BHS_SIZE);
 		if (conn->req.ahssize)
-			crc = crc32c(crc, conn->req.ahs,
-				     roundup(conn->req.ahssize, 4));
+			crc = crc32c(crc, conn->req.ahs, conn->req.ahssize);
 		crc = ~crc;
 		if (*((uint32_t *)conn->rx_digest) != crc) {
 			eprintf("rx hdr digest error 0x%x calc 0x%x\n",
@@ -1888,7 +1888,8 @@ again:
 		}
 		conn->rx_iostate = IOSTATE_RX_INIT_DATA;
 	case IOSTATE_RX_INIT_DATA:
-		conn->rx_size = roundup(conn->req.datasize, 4);
+		conn->rx_size = roundup(conn->req.datasize,
+					conn->tp->data_padding);
 		if (conn->rx_size) {
 			conn->rx_iostate = IOSTATE_RX_DATA;
 			conn->rx_buffer = conn->req.data;
@@ -1911,7 +1912,9 @@ again:
 			break;
 	case IOSTATE_RX_CHECK_DDIGEST:
 		crc = ~0;
-		crc = crc32c(crc, conn->req.data, roundup(conn->req.datasize, 4));
+		crc = crc32c(crc, conn->req.data,
+			     roundup(conn->req.datasize,
+				     conn->tp->data_padding));
 		crc = ~crc;
 		conn->rx_iostate = IOSTATE_RX_END;
 		if (*((uint32_t *)conn->rx_digest) != crc) {
@@ -2033,7 +2036,7 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 			conn->tx_iostate = IOSTATE_TX_DATA;
 			conn->tx_buffer = conn->rsp.data;
 			conn->tx_size = conn->rsp.datasize;
-			pad = conn->tx_size & (PAD_WORD_LEN - 1);
+			pad = conn->tx_size & (conn->tp->data_padding - 1);
 			if (pad) {
 				pad = PAD_WORD_LEN - pad;
 				memset(conn->tx_buffer + conn->tx_size, 0, pad);
@@ -2053,7 +2056,8 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 	case IOSTATE_TX_INIT_DDIGEST:
 		crc = ~0;
 		crc = crc32c(crc, conn->rsp.data,
-			     roundup(conn->rsp.datasize, 4));
+			     roundup(conn->rsp.datasize,
+				     conn->tp->data_padding));
 		*(uint32_t *)conn->tx_digest = ~crc;
 		conn->tx_iostate = IOSTATE_TX_DDIGEST;
 		conn->tx_buffer = conn->tx_digest;
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index 38e28ae..58bb992 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -10,6 +10,7 @@ struct iscsi_transport {
 	const char *name;
 	int rdma;
 	int task_trans_len;
+	int data_padding;
 
 	int (*ep_init) (void);
 	int (*ep_login_complete)(struct iscsi_connection *conn);
-- 
1.5.3.4



From pw at osc.edu  Mon Dec 10 16:05:41 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 10 Dec 2007 10:05:41 -0500
Subject: [Stgt-devel] [PATCH 4/6] iser params
In-Reply-To: <20071210150325.GA31889@osc.edu>
References: <20071210150325.GA31889@osc.edu>
Message-ID: <20071210150541.GE31889@osc.edu>

Add iSCSI parameters as defined in the iSER specification.
Handle special parameter cases for RDMA:

    - no digests
    - do not offer iSER parameters unless initiator requests them
    - do not offer MRDSL (use [IT]RDSL instead)

Except do not advertise MaxOutstandingUnexpectedPDUs just yet, as
the open-iscsi initiatior does not understand it.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_if.h |    5 +++++
 usr/iscsi/iscsid.c   |   21 ++++++++++++++++++++-
 usr/iscsi/param.c    |   38 ++++++++++++++++++++++++++++++++++++++
 usr/iscsi/target.c   |    4 ++++
 4 files changed, 67 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/iscsi_if.h b/usr/iscsi/iscsi_if.h
index 58a76a2..0e9c2eb 100644
--- a/usr/iscsi/iscsi_if.h
+++ b/usr/iscsi/iscsi_if.h
@@ -215,6 +215,11 @@ enum iscsi_param {
 	ISCSI_PARAM_OFMARKINT,
 	ISCSI_PARAM_IFMARKINT,
 	ISCSI_PARAM_MAXCONNECTIONS,
+	/* iSCSI Extensions for RDMA (RFC5046) */
+	ISCSI_PARAM_RDMA_EXTENSIONS,
+	ISCSI_PARAM_TARGET_RDSL,
+	ISCSI_PARAM_INITIATOR_RDSL,
+	ISCSI_PARAM_MAX_OUTST_PDU,
 	/* must always be last */
 	ISCSI_PARAM_MAX,
 };
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index defe3a7..df0fec4 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -270,7 +270,7 @@ static void login_security_done(struct iscsi_connection *conn)
 static void text_scan_login(struct iscsi_connection *conn)
 {
 	char *key, *value, *data;
-	int datasize, idx;
+	int datasize, idx, is_rdma = 0;
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
 
 	data = conn->req.data;
@@ -289,6 +289,9 @@ static void text_scan_login(struct iscsi_connection *conn)
 			if (idx == ISCSI_PARAM_MAX_RECV_DLENGTH)
 				idx = ISCSI_PARAM_MAX_XMIT_DLENGTH;
 
+			if (idx == ISCSI_PARAM_RDMA_EXTENSIONS)
+				is_rdma = 1;
+
 			if (param_str_to_val(session_keys, idx, value, &val) < 0) {
 				if (conn->session_param[idx].state
 				    == KEY_STATE_START) {
@@ -335,6 +338,15 @@ static void text_scan_login(struct iscsi_connection *conn)
 			text_key_add(conn, key, "NotUnderstood");
 	}
 
+	if (is_rdma) {
+		/* do not try to do digests, not supported in iser */
+		conn->session_param[ISCSI_PARAM_HDRDGST_EN].val = DIGEST_NONE;
+		conn->session_param[ISCSI_PARAM_DATADGST_EN].val = DIGEST_NONE;
+	} else {
+		/* do not offer RDMA, initiator must explicitly request */
+		conn->session_param[ISCSI_PARAM_RDMA_EXTENSIONS].val = 0;
+	}
+
 out:
 	return;
 }
@@ -354,6 +366,13 @@ static int text_check_param(struct iscsi_connection *conn)
 					p[i].state = KEY_STATE_DONE;
 					continue;
 				}
+				if (p[ISCSI_PARAM_RDMA_EXTENSIONS].val == 1) {
+					if (i == ISCSI_PARAM_MAX_RECV_DLENGTH)
+						continue;
+				} else {
+					if (i >= ISCSI_PARAM_RDMA_EXTENSIONS)
+						continue;
+				}
 				memset(buf, 0, sizeof(buf));
 				param_val_to_str(session_keys, i, p[i].val,
 						 buf);
diff --git a/usr/iscsi/param.c b/usr/iscsi/param.c
index 9eac62c..76236d1 100644
--- a/usr/iscsi/param.c
+++ b/usr/iscsi/param.c
@@ -118,6 +118,18 @@ static int minimum_check_val(struct iscsi_key *key, unsigned int *val)
 	return 0;
 }
 
+static int min_or_zero_check_val(struct iscsi_key *key, unsigned int *val)
+{
+	int err = 0;
+
+	if (*val != 0 && (*val < key->min || key->max < *val)) {
+		*val = key->min;
+		err = -EINVAL;
+	}
+
+	return 0;
+}
+
 static int maximum_check_val(struct iscsi_key *key, unsigned int *val)
 {
 	int err = 0;
@@ -140,6 +152,16 @@ static int minimum_set_val(struct param *param, int idx, unsigned int *val)
 	return 0;
 }
 
+static int min_or_zero_set_val(struct param *param, int idx, unsigned int *val)
+{
+	if (*val > param[idx].val || *val == 0)
+		*val = param[idx].val;
+	else
+		param[idx].val = *val;
+
+	return 0;
+}
+
 static int maximum_set_val(struct param *param, int idx, unsigned int *val)
 {
 	if (param[idx].val > *val)
@@ -265,6 +287,13 @@ static struct iscsi_key_ops minimum_ops = {
 	.set_val = minimum_set_val,
 };
 
+static struct iscsi_key_ops min_or_zero_ops = {
+	.val_to_str = range_val_to_str,
+	.str_to_val = range_str_to_val,
+	.check_val = min_or_zero_check_val,
+	.set_val = min_or_zero_set_val,
+};
+
 static struct iscsi_key_ops maximum_ops = {
 	.val_to_str = range_val_to_str,
 	.str_to_val = range_str_to_val,
@@ -345,6 +374,15 @@ struct iscsi_key session_keys[] = {
 	{"IFMarkInt", 2048, 1, 65535, &marker_ops},
 	[ISCSI_PARAM_MAXCONNECTIONS] =
 	{"MaxConnections", 1, 1, 65535, &minimum_ops},
+	/* iSER draft */
+	[ISCSI_PARAM_RDMA_EXTENSIONS] =
+	{"RDMAExtensions", 0, 0, 1, &and_ops},
+	[ISCSI_PARAM_TARGET_RDSL] =
+	{"TargetRecvDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_INITIATOR_RDSL] =
+	{"InitiatorRecvDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_MAX_OUTST_PDU] =
+	{"MaxOutstandingUnexpectedPDUs", 0, 2, 4294967295U, &min_or_zero_ops},
 	[ISCSI_PARAM_MAX] =
 	{NULL,},
 };
diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
index ab0685f..0471d15 100644
--- a/usr/iscsi/target.c
+++ b/usr/iscsi/target.c
@@ -283,6 +283,10 @@ int iscsi_target_create(struct target *t)
 		[ISCSI_PARAM_OFMARKINT] = {0, 2048},
 		[ISCSI_PARAM_IFMARKINT] = {0, 2048},
 		[ISCSI_PARAM_MAXCONNECTIONS] = {0, 1},
+		[ISCSI_PARAM_RDMA_EXTENSIONS] = {0, 1},
+		[ISCSI_PARAM_TARGET_RDSL] = {0, 262144},
+		[ISCSI_PARAM_INITIATOR_RDSL] = {0, 262144},
+		[ISCSI_PARAM_MAX_OUTST_PDU] =  {0, 0},  /* not in open-iscsi */
 	};
 
 	target = malloc(sizeof(*target));
-- 
1.5.3.4



From pw at osc.edu  Mon Dec 10 16:06:01 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 10 Dec 2007 10:06:01 -0500
Subject: [Stgt-devel] [PATCH 5/6] iser iscsid changes
In-Reply-To: <20071210150325.GA31889@osc.edu>
References: <20071210150325.GA31889@osc.edu>
Message-ID: <20071210150601.GF31889@osc.edu>

Handle the special cases for RDMA in core iscsid code.  These changes
all look at conn->tp->rdma and do not affect TCP code.

    - track RDMA setting at session and verify conns are compatible
    - no status collapse on final data packet
    - all data-in transmits must reenable TX for conn
    - TX state machine finishes tasks without going through epoll
    - TX handler returns status to trigger RDMA flow control

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c  |   45 ++++++++++++++++++++++++++++++++++-----------
 usr/iscsi/iscsid.h  |    5 ++++-
 usr/iscsi/session.c |    2 ++
 3 files changed, 40 insertions(+), 12 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index df0fec4..b0c1b6d 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -511,8 +511,21 @@ static void login_finish(struct iscsi_connection *conn)
 			conn->state = STATE_EXIT;
 			break;
 		}
-		if (!conn->session)
+		if (!conn->session) {
 			session_create(conn);
+		} else {
+			if (conn->tp->rdma ^ conn->session->rdma) {
+				eprintf("new conn rdma %d, but session %d\n",
+					conn->tp->rdma, conn->session->rdma);
+				rsp->flags = 0;
+				rsp->status_class =
+					ISCSI_STATUS_CLS_INITIATOR_ERR;
+				rsp->status_detail =
+					ISCSI_LOGIN_STATUS_INVALID_REQUEST;
+				conn->state = STATE_EXIT;
+				break;
+			}
+		}
 		memcpy(conn->isid, conn->session->isid, sizeof(conn->isid));
 		conn->tsih = conn->session->tsih;
 		break;
@@ -965,7 +978,8 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 
 		/* collapse status into final packet if successful */
 		if (result == SAM_STAT_GOOD &&
-		    scsi_get_data_dir(&task->scmd) != DATA_BIDIRECTIONAL) {
+		    scsi_get_data_dir(&task->scmd) != DATA_BIDIRECTIONAL &&
+		    !conn->tp->rdma) {
 			rsp->flags |= ISCSI_FLAG_DATA_STATUS;
 			rsp->cmd_status = result;
 			rsp->statsn = cpu_to_be32(conn->stat_sn++);
@@ -1720,8 +1734,9 @@ static int iscsi_scsi_cmd_tx_done(struct iscsi_connection *conn)
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
 		if (task->offset < task->len ||
-		    scsi_get_result(&task->scmd) != SAM_STAT_GOOD
-		    || scsi_get_data_dir(&task->scmd) == DATA_BIDIRECTIONAL) {
+		    scsi_get_result(&task->scmd) != SAM_STAT_GOOD ||
+		    scsi_get_data_dir(&task->scmd) == DATA_BIDIRECTIONAL ||
+		    conn->tp->rdma) {
 			dprintf("more data or sense or bidir %x\n", hdr->itt);
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
 			return 0;
@@ -1996,7 +2011,7 @@ again:
 	return 0;
 }
 
-void iscsi_tx_handler(struct iscsi_connection *conn)
+int iscsi_tx_handler(struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -2011,9 +2026,10 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 	if (conn->state == STATE_SCSI && !conn->tx_task) {
 		ret = iscsi_task_tx_start(conn);
 		if (ret)
-			return;
+			goto out;
 	}
 
+again:
 	switch (conn->tx_iostate) {
 	case IOSTATE_TX_BHS:
 		ret = do_send(conn, IOSTATE_TX_INIT_AHS);
@@ -2069,7 +2085,7 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 		ret = do_send(conn, ddigest ?
 			      IOSTATE_TX_INIT_DDIGEST : IOSTATE_TX_END);
 		if (ret < 0)
-			return;
+			goto out;
 		if (conn->tx_iostate != IOSTATE_TX_INIT_DDIGEST)
 			break;
 	case IOSTATE_TX_INIT_DDIGEST:
@@ -2089,10 +2105,14 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 		exit(1);
 	}
 
-	if (ret < 0 ||
-	    conn->tx_iostate != IOSTATE_TX_END ||
-	    conn->state == STATE_CLOSE)
-		return;
+	if (ret < 0 || conn->state == STATE_CLOSE)
+		goto out;
+
+	if (conn->tx_iostate != IOSTATE_TX_END) {
+		if (conn->tp->rdma)
+			goto again;  /* avoid event loop, just push */
+		goto out;
+	}
 
 	if (conn->tx_size) {
 		eprintf("error %d %d %d\n", conn->state, conn->tx_iostate,
@@ -2125,6 +2145,9 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 		conn->tp->ep_event_modify(conn, EPOLLIN);
 		break;
 	}
+
+out:
+	return ret;
 }
 
 static struct tgt_driver iscsi = {
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 3fabfba..de681f7 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -91,6 +91,9 @@ struct iscsi_session {
 	struct param session_param[ISCSI_PARAM_MAX];
 
 	char *info;
+
+	/* if this session uses rdma connections */
+	int rdma;
 };
 
 struct iscsi_task {
@@ -258,7 +261,7 @@ extern void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_sess
 extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
 extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
 extern void conn_read_pdu(struct iscsi_connection *conn);
-extern void iscsi_tx_handler(struct iscsi_connection *conn);
+extern int iscsi_tx_handler(struct iscsi_connection *conn);
 extern void iscsi_rx_handler(struct iscsi_connection *conn);
 extern int iscsi_scsi_cmd_execute(struct iscsi_task *task);
 
diff --git a/usr/iscsi/session.c b/usr/iscsi/session.c
index 3b1650d..028d538 100644
--- a/usr/iscsi/session.c
+++ b/usr/iscsi/session.c
@@ -128,6 +128,8 @@ int session_create(struct iscsi_connection *conn)
 	memcpy(session->isid, conn->isid, sizeof(session->isid));
 	session->tsih = last_tsih = tsih;
 
+	session->rdma = conn->tp->rdma;
+
 	conn_add_to_session(conn, session);
 
 	dprintf("session_create: %#" PRIx64 "\n", sid64(conn->isid, session->tsih));
-- 
1.5.3.4



From pw at osc.edu  Mon Dec 10 16:06:27 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 10 Dec 2007 10:06:27 -0500
Subject: [Stgt-devel] [PATCH 6/6] iser core
In-Reply-To: <20071210150325.GA31889@osc.edu>
References: <20071210150325.GA31889@osc.edu>
Message-ID: <20071210150627.GG31889@osc.edu>

Core iSCSI RDMA support.  Adds the iscsi_rdma.c file that implements the
RDMA transport.  Enabled only if ISCSI_RDMA is defined during the build,
in which case RDMA libraries and headers must be present on the system.

The iscsi TX handler redirects R2T and DATA_IN packets to new transport
functions for RDMA mode.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/Makefile           |    5 +
 usr/iscsi/iscsi_rdma.c | 1711 ++++++++++++++++++++++++++++++++++++++++++++++++
 usr/iscsi/iscsid.c     |   25 +
 usr/iscsi/transport.c  |    3 +
 usr/iscsi/transport.h  |    3 +
 5 files changed, 1747 insertions(+), 0 deletions(-)
 create mode 100644 usr/iscsi/iscsi_rdma.c

diff --git a/usr/Makefile b/usr/Makefile
index e7716ea..5ad6017 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -11,6 +11,11 @@ TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o \
 		isns.o libcrc32c.o)
 TGTD_OBJS += bs_rdwr.o
 LIBS += -lcrypto
+ifneq ($(ISCSI_RDMA),)
+CFLAGS += -DISCSI_RDMA
+TGTD_OBJS += iscsi/iscsi_rdma.o
+LIBS += -libverbs -lrdmacm
+endif
 endif
 
 ifneq ($(FCP),)
diff --git a/usr/iscsi/iscsi_rdma.c b/usr/iscsi/iscsi_rdma.c
new file mode 100644
index 0000000..4469be3
--- /dev/null
+++ b/usr/iscsi/iscsi_rdma.c
@@ -0,0 +1,1711 @@
+/*
+ * iSCSI extensions for RDMA (iSER) data path
+ *
+ * Copyright (C) 2007 Dennis Dalessandro (dennis at osc.edu)
+ * Copyright (C) 2007 Ananth Devulapalli (ananth at osc.edu)
+ * Copyright (C) 2007 Pete Wyckoff (pw at osc.edu)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <assert.h>
+#include <netdb.h>
+#include <sys/epoll.h>
+#include <infiniband/verbs.h>
+#include <rdma/rdma_cma.h>
+
+#include "util.h"
+#include "iscsid.h"
+
+#if defined(HAVE_VALGRIND) && !defined(NDEBUG)
+#include <valgrind/memcheck.h>
+#else
+#define VALGRIND_MAKE_MEM_DEFINED(addr, len)
+#endif
+
+/*
+ * The IB-extended version from the kernel.  Stags and VAs are in
+ * big-endian format.
+ */
+struct iser_hdr {
+	uint8_t   flags;
+	uint8_t   rsvd[3];
+	uint32_t  write_stag; /* write rkey */
+	uint64_t  write_va;
+	uint32_t  read_stag;  /* read rkey */
+	uint64_t  read_va;
+} __attribute__((packed));
+
+#define ISER_WSV	(0x08)
+#define ISER_RSV	(0x04)
+#define ISCSI_CTRL	(0x10)
+#define ISER_HELLO	(0x20)
+#define ISER_HELLORPLY	(0x30)
+
+struct conn_info;
+
+/*
+ * Posted receives for control messages.  All must start with the conn
+ * pointer, which will be followed up from a work request during a flush,
+ * when it is not known what type to expect.
+ */
+struct recvlist {
+	struct conn_info *conn;
+	struct ibv_sge sge;
+	void *buf;
+	struct ibv_recv_wr wr;
+	unsigned long bytes_recvd;
+};
+
+/*
+ * Posted sends for control messages.
+ */
+struct sendlist {
+	struct conn_info *conn;
+	struct ibv_sge sge;
+	void *buf;
+	struct ibv_send_wr wr;
+	struct list_head list;
+};
+
+/*
+ * RDMA read and write operations.
+ */
+struct rdmalist {
+	struct conn_info *conn;
+	struct ibv_sge sge;
+	struct ibv_send_wr wr;
+	struct list_head list;
+	struct iscsi_task *task;  /* to get iser_task for remote stag and va */
+};
+
+/*
+ * Each SCSI command may have its own RDMA parameters.  These appear on
+ * the connection then later are assigned to the particular task to be
+ * used when the target responds.
+ */
+struct iser_task {
+	/* read and write from the initiator's point of view */
+	uint32_t rem_read_stag, rem_write_stag;
+	uint64_t rem_read_va, rem_write_va;
+};
+
+struct iser_device;
+
+/*
+ * Parallels iscsi_connection.  Adds more fields for iser.
+ */
+struct conn_info {
+	struct iscsi_connection iscsi_conn;
+	struct ibv_qp *qp_hndl;
+	struct rdma_cm_id *cma_id;
+	struct iser_device *dev;
+	struct sockaddr_storage peer_addr;  /* initiator address */
+	struct sockaddr_storage self_addr;  /* target address */
+	unsigned int ssize, rsize, max_outst_pdu;
+	unsigned int readb, writeb;
+
+	/* read and write from the initiator's point of view */
+	uint32_t rem_read_stag, rem_write_stag;
+	uint64_t rem_read_va, rem_write_va;
+
+	enum {
+	    LOGIN_PHASE_START,      /* keep 1 send spot and 1 recv posted */
+	    LOGIN_PHASE_LAST_SEND,  /* need 1 more send before ff */
+	    LOGIN_PHASE_FF,         /* full feature */
+	} login_phase;
+
+	void *srbuf;    /* registered space for non-rdma send and recv */
+	void *listbuf;  /* space for the send, recv, rdma list elements */
+	struct ibv_mr *srmr;   /* mr for registered srbuf */
+
+	/* lists of free send, rdma slots */
+	struct list_head sendl, rdmal;
+
+	/* no recvl: just always immediately repost */
+	/* but count so we can drain CQ on close */
+	int recvl_posted;
+
+	/* login phase resources, freed at full-feature */
+	void *srbuf_login;
+	void *listbuf_login;
+	struct ibv_mr *srmr_login;
+	struct list_head sendl_login, recvl_login;
+
+	/* points to the current recvlist, sendlist items for each conn */
+	struct recvlist *rcv_comm_event;
+	struct sendlist *send_comm_event;
+
+	/* to chain this connection onto the list of those ready to tx */
+	struct list_head conn_tx_ready;
+
+	/* list of all iser conns */
+	struct list_head iser_conn_list;
+
+	/* to consume posted receives after disconnect */
+	int draining;
+
+	/* when free has been called, waits until all posted msgs complete */
+	int freed;
+};
+
+/*
+ * Pre-registered memory.  Buffers are allocated by iscsi from us, handed
+ * to device to fill, then iser can send them directly without registration.
+ * Also for write path.
+ */
+struct mempool {
+	struct list_head list;
+	void *buf;
+};
+
+/*
+ * Shared variables for a particular device.  The conn[] array will
+ * have to be broken out when multiple device support is added, maybe with
+ * a pointer into this "device" struct.
+ */
+struct iser_device {
+	struct list_head list;
+	struct ibv_context *ibv_hndl;
+	struct ibv_pd *pd;
+	struct ibv_cq *cq;
+	struct ibv_comp_channel *cq_channel;
+
+	/* mempool registered buffer, list area, handle */
+	void *mempool_regbuf;
+	void *mempool_listbuf;
+	struct ibv_mr *mempool_mr;
+
+	/* free and allocated mempool entries */
+	struct list_head mempool_free, mempool_alloc;
+};
+
+/* global, across all devices */
+static struct rdma_event_channel *rdma_evt_channel;
+static struct rdma_cm_id *cma_listen_id;
+static struct list_head conn_tx_ready;  /* conns with tasks ready to tx */
+
+/* accepted at RDMA layer, but not yet established */
+static struct list_head temp_conn;
+
+/* all devices */
+static struct list_head iser_dev_list;
+
+/* all iser connections */
+static struct list_head iser_conn_list;
+
+/* if any task needs an rdma read or write slot to proceed */
+static int waiting_rdma_slot;
+
+/* progress available, used with tgt_counter_event */
+static int num_tx_ready;
+static int num_rx_ready;
+
+#define uint64_from_ptr(p) (uint64_t)(uintptr_t)(p)
+#define ptr_from_int64(p) (void *)(unsigned long)(p)
+
+#define ISCSI_LISTEN_PORT 3260
+
+/*
+ * Crazy hard-coded linux iser settings need 128 * 8 slots + slop, plus
+ * room for our rdmas and send requests.
+ */
+#define MAX_WQE 1800
+
+/*
+ * Number of outstanding RDMAs per command; should instead wait for previous
+ * RDMAs to complete before starting new ones.
+ *
+ * The RDMA size is completely up to the target.  Parameters IRDSL and TRDSL
+ * only apply to control-type PDUs.  We allocate only so many rdma slots
+ * per connection, but many tasks might be in progress on the connection.
+ * Internal flow control stops tasks when there are no slots.
+ *
+ * RDMA size tradeoffs:
+ *    big RDMA operations are more efficient
+ *    small RDMA operations better for fairness with many clients
+ *    small RDMA operations allow better pipelining
+ *    eventually target devices may not want to have to malloc and return
+ *        entire buffer to transport in one go
+ */
+#define RDMA_PER_CONN 20
+#define RDMA_TRANSFER_SIZE (512 * 1024)
+
+/*
+ * Number of allocatable data buffers, each of this size.  Do at least 128
+ * for linux iser.  The mempool size is rounded up at initialization time
+ * to the hardware page size so that allocations for direct IO devices are
+ * aligned.
+ */
+static int mempool_num = 192;
+static size_t mempool_size = 512 * 1024;
+
+static inline struct conn_info *RDMA_CONN(struct iscsi_connection *conn)
+{
+	return container_of(conn, struct conn_info, iscsi_conn);
+}
+
+static void iser_cqe_handler(int fd, int events, void *data);
+static void iser_rx_progress(int *counter, void *data);
+static void iser_rdma_read_completion(struct rdmalist *rdma);
+static void iscsi_rdma_release(struct iscsi_connection *conn);
+static int iscsi_rdma_show(struct iscsi_connection *conn, char *buf,
+			   int rest);
+static void iscsi_rdma_event_modify(struct iscsi_connection *conn, int events);
+
+/*
+ * Called when ready for full feature, builds resources.
+ */
+static int iser_init_comm(struct conn_info *conn)
+{
+	unsigned int i;
+	int ret = -1;
+	unsigned long size;
+	uint8_t *srbuf, *listbuf;
+	struct sendlist *sendl;
+	struct recvlist *recvl;
+	struct rdmalist *rdmal;
+	struct ibv_recv_wr *bad_wr;
+	int rdma_per_conn = RDMA_PER_CONN;
+
+	dprintf("sizing %u/%u outst %u\n", conn->ssize, conn->rsize,
+		conn->max_outst_pdu);
+
+	size = (conn->rsize + conn->ssize) * conn->max_outst_pdu;
+	conn->srbuf = malloc(size);
+	if (!conn->srbuf) {
+		eprintf("malloc srbuf %lu\n", size);
+		goto out;
+	}
+
+	conn->srmr = ibv_reg_mr(conn->dev->pd, conn->srbuf, size,
+				IBV_ACCESS_LOCAL_WRITE);
+	if (!conn->srmr) {
+		eprintf("register srbuf\n");
+		goto out;
+	}
+
+	INIT_LIST_HEAD(&conn->sendl);
+	INIT_LIST_HEAD(&conn->rdmal);
+
+	size = conn->max_outst_pdu * sizeof(struct sendlist) +
+	       conn->max_outst_pdu * sizeof(struct recvlist) +
+	       conn->max_outst_pdu * rdma_per_conn * sizeof(struct rdmalist);
+	conn->listbuf = malloc(size);
+	if (!conn->listbuf) {
+		eprintf("malloc listbuf %lu\n", size);
+		goto out;
+	}
+	memset(conn->listbuf, 0, size);
+
+	srbuf = conn->srbuf;
+	listbuf = conn->listbuf;
+	for (i = 0; i < conn->max_outst_pdu; i++) {
+		sendl = (void *) listbuf;
+		listbuf += sizeof(*sendl);
+		sendl->buf = srbuf;
+		srbuf += conn->ssize;
+		sendl->conn = conn;
+
+		sendl->sge.addr = uint64_from_ptr(sendl->buf);
+		sendl->sge.length = conn->ssize;
+		sendl->sge.lkey = conn->srmr->lkey;
+
+		sendl->wr.wr_id = uint64_from_ptr(sendl);
+		sendl->wr.sg_list = &sendl->sge;
+		sendl->wr.num_sge = 1;
+		sendl->wr.opcode = IBV_WR_SEND;
+		sendl->wr.send_flags = IBV_SEND_SIGNALED;
+		list_add_tail(&sendl->list, &conn->sendl);
+	}
+
+	for (i = 0; i < conn->max_outst_pdu; i++) {
+		recvl = (void *) listbuf;
+		listbuf += sizeof(*recvl);
+		recvl->buf = srbuf;
+		srbuf += conn->rsize;
+		recvl->conn = conn;
+
+		recvl->sge.addr = uint64_from_ptr(recvl->buf);
+		recvl->sge.length = conn->rsize;
+		recvl->sge.lkey = conn->srmr->lkey;
+
+		recvl->wr.wr_id = uint64_from_ptr(recvl);
+		recvl->wr.sg_list = &recvl->sge;
+		recvl->wr.num_sge = 1;
+
+		ret = ibv_post_recv(conn->qp_hndl, &recvl->wr, &bad_wr);
+		if (ret) {
+			eprintf("ibv_post_recv (%d/%d): %m\n", i,
+				conn->max_outst_pdu);
+			exit(1);
+		}
+		++conn->recvl_posted;
+	}
+
+	for (i = 0; i < conn->max_outst_pdu * rdma_per_conn; i++) {
+		rdmal = (void *) listbuf;
+		listbuf += sizeof(*rdmal);
+		rdmal->conn = conn;
+		rdmal->sge.lkey = conn->dev->mempool_mr->lkey;
+
+		rdmal->wr.wr_id = uint64_from_ptr(rdmal);
+		rdmal->wr.sg_list = &rdmal->sge;
+		rdmal->wr.num_sge = 1;
+		rdmal->wr.send_flags = IBV_SEND_SIGNALED;
+		list_add_tail(&rdmal->list, &conn->rdmal);
+	}
+
+	ret = 0;
+
+out:
+	return ret;
+}
+
+/*
+ * Called at accept time, builds resources just for login phase.
+ */
+static int iser_init_comm_login(struct conn_info *conn)
+{
+	unsigned int i;
+	int ret = -1;
+	unsigned long size;
+	uint8_t *srbuf, *listbuf;
+	struct sendlist *sendl;
+	struct recvlist *recvl;
+	struct ibv_recv_wr *bad_wr;
+
+	dprintf("sizing %u/%u outst %u\n", conn->ssize, conn->rsize,
+		conn->max_outst_pdu);
+
+	size = (conn->rsize + conn->ssize) * conn->max_outst_pdu;
+	conn->srbuf_login = malloc(size);
+	if (!conn->srbuf_login) {
+		eprintf("malloc srbuf %lu\n", size);
+		goto out;
+	}
+
+	conn->srmr_login = ibv_reg_mr(conn->dev->pd, conn->srbuf_login, size,
+				      IBV_ACCESS_LOCAL_WRITE);
+	if (!conn->srmr_login) {
+		eprintf("ibv_reg_mr srbuf failed\n");
+		goto out;
+	}
+
+	INIT_LIST_HEAD(&conn->sendl_login);
+	INIT_LIST_HEAD(&conn->recvl_login);
+
+	size = conn->max_outst_pdu * sizeof(struct sendlist) +
+	       conn->max_outst_pdu * sizeof(struct recvlist);
+	conn->listbuf_login = malloc(size);
+	if (!conn->listbuf_login) {
+		eprintf("malloc listbuf %lu\n", size);
+		goto out;
+	}
+	memset(conn->listbuf_login, 0, size);
+
+	srbuf = conn->srbuf_login;
+	listbuf = conn->listbuf_login;
+	for (i = 0; i < conn->max_outst_pdu; i++) {
+		sendl = (void *) listbuf;
+		listbuf += sizeof(*sendl);
+		sendl->buf = srbuf;
+		srbuf += conn->ssize;
+		sendl->conn = conn;
+
+		sendl->sge.addr = uint64_from_ptr(sendl->buf);
+		sendl->sge.length = conn->ssize;
+		sendl->sge.lkey = conn->srmr_login->lkey;
+
+		sendl->wr.wr_id = uint64_from_ptr(sendl);
+		sendl->wr.sg_list = &sendl->sge;
+		sendl->wr.num_sge = 1;
+		sendl->wr.opcode = IBV_WR_SEND;
+		sendl->wr.send_flags = IBV_SEND_SIGNALED;
+		list_add_tail(&sendl->list, &conn->sendl_login);
+	}
+
+	for (i = 0; i < conn->max_outst_pdu; i++) {
+		recvl = (void *) listbuf;
+		listbuf += sizeof(*recvl);
+		recvl->buf = srbuf;
+		srbuf += conn->rsize;
+		recvl->conn = conn;
+
+		recvl->sge.addr = uint64_from_ptr(recvl->buf);
+		recvl->sge.length = conn->rsize;
+		recvl->sge.lkey = conn->srmr_login->lkey;
+
+		recvl->wr.wr_id = uint64_from_ptr(recvl);
+		recvl->wr.sg_list = &recvl->sge;
+		recvl->wr.num_sge = 1;
+		recvl->wr.next = NULL;
+
+		ret = ibv_post_recv(conn->qp_hndl, &recvl->wr, &bad_wr);
+		if (ret) {
+			eprintf("ibv_post_recv: %m\n");
+			goto out;
+		}
+	}
+
+	ret = 0;
+
+out:
+	return ret;
+}
+
+/*
+ * On connection shutdown.
+ */
+static void iser_free_comm(struct conn_info *ci)
+{
+	int ret;
+
+	dprintf("freeing conn %p\n", ci);
+
+	/* release mr and free the lists */
+	dprintf("dereg mr %p\n", ci->srmr);
+	ret = ibv_dereg_mr(ci->srmr);
+	if (ret)
+		eprintf("ibv_dereg_mr\n");
+	free(ci->srbuf);
+	free(ci->listbuf);
+}
+
+/*
+ * When ready for full-feature mode, free login-phase resources.
+ */
+static void iser_free_comm_login(struct conn_info *ci)
+{
+	int ret;
+
+	if (ci->srbuf_login == NULL)
+		return;
+
+	dprintf("freeing, login phase %d\n", ci->login_phase);
+
+	/* release mr and free the lists */
+	ret = ibv_dereg_mr(ci->srmr_login);
+	if (ret)
+		eprintf("ibv_dereg_mr\n");
+	free(ci->srbuf_login);
+	free(ci->listbuf_login);
+	ci->srbuf_login = NULL;  /* remember freed */
+}
+
+/*
+ * One pool of registered memory per device (per PD that is).
+ */
+static int iser_init_mempool(struct iser_device *dev)
+{
+	struct mempool *mp;
+	uint8_t *regbuf, *listbuf;
+	int i;
+
+	mempool_size = roundup(mempool_size, pagesize);
+	regbuf = valloc(mempool_num * mempool_size);
+	if (!regbuf) {
+		eprintf("malloc regbuf %zu\n", mempool_num * mempool_size);
+		return -ENOMEM;
+	}
+
+	listbuf = malloc(mempool_num * sizeof(*mp));
+	if (!listbuf) {
+		eprintf("malloc listbuf %zu\n", mempool_num * sizeof(*mp));
+		free(regbuf);
+		return -ENOMEM;
+	}
+
+	dev->mempool_mr = ibv_reg_mr(dev->pd, regbuf,
+				     mempool_num * mempool_size,
+				     IBV_ACCESS_LOCAL_WRITE);
+	if (!dev->mempool_mr) {
+		eprintf("register regbuf\n");
+		free(regbuf);
+		free(listbuf);
+		return -1;
+	}
+
+	dev->mempool_regbuf = regbuf;
+	dev->mempool_listbuf = listbuf;
+	INIT_LIST_HEAD(&dev->mempool_free);
+	INIT_LIST_HEAD(&dev->mempool_alloc);
+
+	for (i = 0; i < mempool_num; i++) {
+		mp = (void *) listbuf;
+		listbuf += sizeof(*mp);
+		mp->buf = regbuf;
+		regbuf += mempool_size;
+		list_add_tail(&mp->list, &dev->mempool_free);
+	}
+
+	return 0;
+}
+
+/*
+ * First time a new connection is received on an RDMA device, record
+ * it and build a PD and static memory.
+ */
+static int iser_device_init(struct iser_device *dev)
+{
+	struct ibv_device_attr device_attr;
+	int cqe_num;
+	int ret = -1;
+
+	dprintf("dev %p\n", dev);
+	dev->pd = ibv_alloc_pd(dev->ibv_hndl);
+	if (dev->pd == NULL) {
+		eprintf("ibv_alloc_pd failed\n");
+		goto out;
+	}
+
+	ret = iser_init_mempool(dev);
+	if (ret) {
+		eprintf("iser_init_mempool failed\n");
+		goto out;
+	}
+
+	ret = ibv_query_device(dev->ibv_hndl, &device_attr);
+	if (ret < 0) {
+		eprintf("ibv_query_device: %m\n");
+		goto out;
+	}
+	cqe_num = device_attr.max_cqe;
+	dprintf("max %d CQEs\n", cqe_num);
+
+	ret = -1;
+	dev->cq_channel = ibv_create_comp_channel(dev->ibv_hndl);
+	if (dev->cq_channel == NULL) {
+		eprintf("ibv_create_comp_channel failed: %m\n");
+		goto out;
+	}
+
+	dev->cq = ibv_create_cq(dev->ibv_hndl, cqe_num, NULL,
+				dev->cq_channel, 0);
+	if (dev->cq == NULL) {
+		eprintf("ibv_create_cq failed: %m\n");
+		goto out;
+	}
+
+	ret = ibv_req_notify_cq(dev->cq, 0);
+	if (ret) {
+		eprintf("ibv_req_notify failed: %s\n", strerror(ret));
+		goto out;
+	}
+
+	ret = tgt_event_add(dev->cq_channel->fd, EPOLLIN, iser_cqe_handler,
+			    dev);
+	if (ret) {
+		eprintf("tgt_event_add failed: %m\n");
+		goto out;
+
+	}
+
+	list_add(&dev->list, &iser_dev_list);
+
+out:
+	return ret;
+}
+
+static void iser_accept_connection(struct rdma_cm_event *event)
+{
+	int ret, found;
+	struct ibv_qp_init_attr qp_init_attr;
+	struct iscsi_connection *conn;
+	struct conn_info *ci;
+	struct iser_device *dev;
+	unsigned int hdrsz;
+	struct rdma_conn_param conn_param = {
+		.responder_resources = 1,
+		.initiator_depth = 1,
+		.retry_count = 5,
+	};
+
+	dprintf("entry\n");
+
+	/* find device */
+	found = 0;
+	list_for_each_entry(dev, &iser_dev_list, list) {
+		if (dev->ibv_hndl == event->id->verbs) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		dev = malloc(sizeof(*dev));
+		if (dev == NULL) {
+			eprintf("unable to allocate dev\n");
+			goto reject;
+		}
+		dev->ibv_hndl = event->id->verbs;
+		ret = iser_device_init(dev);
+		if (ret) {
+			free(dev);
+			goto reject;
+		}
+	}
+
+	/* build a new connection structure */
+	ci = zalloc(sizeof(*ci));
+	if (!ci) {
+		eprintf("unable to allocate conn\n");
+		goto reject;
+	}
+	conn = &ci->iscsi_conn;
+
+	ret = conn_init(conn);
+	if (ret) {
+		free(ci);
+		goto reject;
+	}
+
+	conn->tp = &iscsi_iser;
+	conn_read_pdu(conn);
+	ci->cma_id = event->id;
+	ci->dev = dev;
+	ci->login_phase = LOGIN_PHASE_START;
+	INIT_LIST_HEAD(&ci->conn_tx_ready);
+	list_add(&ci->iser_conn_list, &temp_conn);
+	/* initiator sits at dst, we are src */
+	memcpy(&ci->peer_addr, &event->id->route.addr.dst_addr,
+	       sizeof(ci->peer_addr));
+	memcpy(&ci->self_addr, &event->id->route.addr.src_addr,
+	       sizeof(ci->self_addr));
+#ifndef NDEBUG
+	{
+		char str[256];
+
+		iscsi_rdma_show(conn, str, sizeof(str));
+		str[sizeof(str)-1] = 0;
+		dprintf("new conn %p from %s\n", ci, str);
+	}
+#endif
+
+	/* create qp next */
+	memset(&qp_init_attr, 0, sizeof(qp_init_attr));
+	/* wire both send and recv to the same CQ */
+	qp_init_attr.send_cq =  dev->cq;
+	qp_init_attr.recv_cq  = dev->cq;
+	qp_init_attr.cap.max_send_wr = MAX_WQE;
+	qp_init_attr.cap.max_recv_wr = MAX_WQE;
+	qp_init_attr.cap.max_send_sge = 1;  /* scatter/gather entries */
+	qp_init_attr.cap.max_recv_sge = 1;
+	qp_init_attr.qp_type = IBV_QPT_RC;
+	/* only generate completion queue entries if requested */
+	qp_init_attr.sq_sig_all = 0;
+
+	ret = rdma_create_qp(ci->cma_id, dev->pd, &qp_init_attr);
+	if (ret) {
+		eprintf("create qp failed\n");
+		goto free_conn;
+	}
+	ci->qp_hndl = ci->cma_id->qp;
+	VALGRIND_MAKE_MEM_DEFINED(ci->qp_hndl, sizeof(*ci->qp_hndl));
+
+	ci->rcv_comm_event = NULL;
+	ci->send_comm_event = NULL;
+	ci->readb = 0;
+	ci->writeb = 0;
+
+	/*
+	 * Post buffers for the login phase, only.
+	 */
+	hdrsz = sizeof(struct iser_hdr) +
+		sizeof(struct iscsi_hdr) +
+		sizeof(struct iscsi_ecdb_ahdr) +
+		sizeof(struct iscsi_rlength_ahdr);
+	ci->ssize = hdrsz + 8192;
+	ci->rsize = hdrsz + 8192;
+	ci->max_outst_pdu = 1;
+	ret = iser_init_comm_login(ci);
+	if (ret) {
+		iser_free_comm_login(ci);
+		goto free_conn;
+	}
+
+	/* now we can actually accept the connection */
+	ret = rdma_accept(ci->cma_id, &conn_param);
+	if (ret) {
+		eprintf("rdma_accept failed\n");
+		iser_free_comm_login(ci);
+		goto free_conn;
+	}
+
+	return;
+
+free_conn:
+	conn_exit(conn);
+	free(ci);
+reject:
+	ret = rdma_reject(event->id, NULL, 0);
+	if (ret)
+		eprintf("rdma_reject failed: %s\n", strerror(-ret));
+}
+
+/*
+ * Finish putting the connection together, now that the other side
+ * has ACKed our acceptance.  Moves it from the temp_conn to the
+ * iser_conn_list.
+ *
+ * Release the temporary conn_info and glue it into iser_conn_list.
+ */
+static void iser_conn_established(struct rdma_cm_event *event)
+{
+	int found = 0;
+	struct conn_info *ci;
+
+	/* find it in connection list */
+	list_for_each_entry(ci, &temp_conn, iser_conn_list) {
+		if (ci->cma_id == event->id) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		eprintf("cma id %p not found\n", event->id);
+		return;
+	}
+	dprintf("established conn %p\n", ci);
+	list_del(&ci->iser_conn_list);
+	list_add(&ci->iser_conn_list, &iser_conn_list);
+}
+
+static void iser_disconnect(struct rdma_cm_event *ev)
+{
+	struct conn_info *ci;
+
+	/*
+	 * If not found, initiator disconnected first, so tell iscsi about
+	 * it; else iscsi already did the conn_close.
+	 */
+	dprintf("initiator disconn, QP %d\n", ev->id->qp->qp_num);
+	list_for_each_entry(ci, &iser_conn_list, iser_conn_list) {
+		if (ci->qp_hndl->qp_num == ev->id->qp->qp_num) {
+			struct iscsi_connection *conn = &ci->iscsi_conn;
+			conn->state = STATE_CLOSE;
+			conn_close(conn);
+			break;
+		}
+	}
+}
+
+/*
+ * Handle RDMA connection events.
+ */
+static void iser_handle_rdmacm(int fd __attribute__((unused)),
+			       int events __attribute__((unused)),
+			       void *data __attribute__((unused)))
+{
+	int ret;
+	struct rdma_cm_event *event;
+	struct rdma_cm_id *destroy_cm_id = NULL;
+
+	dprintf("entry\n");
+	ret = rdma_get_cm_event(rdma_evt_channel, &event);
+	if (ret) {
+		eprintf("rdma_get_cm_event failed\n");
+		return;
+	}
+
+	VALGRIND_MAKE_MEM_DEFINED(event, sizeof(*event));
+	switch (event->event) {
+	case RDMA_CM_EVENT_CONNECT_REQUEST:
+		iser_accept_connection(event);
+		break;
+	case RDMA_CM_EVENT_ESTABLISHED:
+		iser_conn_established(event);
+		break;
+	case RDMA_CM_EVENT_DISCONNECTED:
+		iser_disconnect(event);
+		destroy_cm_id = event->id;
+		break;
+	default:
+		eprintf("unknown event %d\n", event->event);
+		break;
+	}
+
+	ret = rdma_ack_cm_event(event);
+	if (ret) {
+		eprintf("ack cm event failed\n");
+		return;
+	}
+
+	if (destroy_cm_id) {
+		ret = rdma_destroy_id(destroy_cm_id);
+		if (ret)
+			eprintf("rdma_destroy_id failed\n");
+	}
+}
+
+/*
+ * Deal with just one work completion.
+ */
+static void handle_wc(struct ibv_wc *wc)
+{
+	int ret;
+	struct recvlist *recvl;
+	struct sendlist *sendl;
+	struct rdmalist *rdmal;
+	struct conn_info *ci;
+	struct iscsi_connection *conn;
+	struct ibv_recv_wr *bad_wr;
+
+	switch (wc->opcode) {
+	case IBV_WC_SEND:
+		dprintf("outgoing rsp complete\n");
+		sendl = ptr_from_int64(wc->wr_id);
+		ci = sendl->conn;
+		if (ci->login_phase == LOGIN_PHASE_START) {
+		    list_add(&sendl->list, &ci->sendl_login);
+		} else if (ci->login_phase == LOGIN_PHASE_LAST_SEND) {
+			/* release login resources */
+			dprintf("last login send completed, release, to ff\n");
+			iser_free_comm_login(ci);
+			ci->login_phase = LOGIN_PHASE_FF;
+			break;
+		} else {
+		    list_add(&sendl->list, &ci->sendl);
+		}
+		break;
+
+	case IBV_WC_RECV:
+		dprintf("incoming cmd, len %d\n", wc->byte_len);
+		recvl = ptr_from_int64(wc->wr_id);
+		ci = recvl->conn;
+		conn = &ci->iscsi_conn;
+		--ci->recvl_posted;
+		if (conn->state == STATE_CLOSE)
+			goto close_err;
+
+		recvl->bytes_recvd = wc->byte_len;
+		VALGRIND_MAKE_MEM_DEFINED(recvl->buf, recvl->bytes_recvd);
+
+		/*
+		 * Global pointer to the working receive on this connection
+		 * for reads from iscsid.c.
+		 */
+		ci->rcv_comm_event = recvl;
+		iscsi_rx_handler(conn);
+		ci->rcv_comm_event = NULL;
+
+		if (ci->login_phase == LOGIN_PHASE_LAST_SEND) {
+			/* do not repost, just one more send then reinit */
+			dprintf("transitioning to full-feature, no repost\n");
+			break;
+		}
+
+		dprintf("incoming cmd proc done, repost\n");
+		ret = ibv_post_recv(ci->qp_hndl, &recvl->wr, &bad_wr);
+		if (ret) {
+			eprintf("ibv_post_recv failed\n");
+			exit(1);
+		}
+		++ci->recvl_posted;
+		break;
+
+	case IBV_WC_RDMA_WRITE:
+		dprintf("RDMA write done\n");
+		rdmal = ptr_from_int64(wc->wr_id);
+		ci = rdmal->conn;
+		conn = &ci->iscsi_conn;
+		if (conn->state == STATE_CLOSE)
+			goto close_err;
+
+		iscsi_rdma_event_modify(conn, EPOLLIN | EPOLLOUT);
+		list_add(&rdmal->list, &ci->rdmal);
+		if (waiting_rdma_slot) {
+			waiting_rdma_slot = 0;
+			num_tx_ready = 1;
+		}
+		break;
+
+	case IBV_WC_RDMA_READ:
+		dprintf("RDMA read done, len %d\n", wc->byte_len);
+		rdmal = ptr_from_int64(wc->wr_id);
+		ci = rdmal->conn;
+		conn = &ci->iscsi_conn;
+		if (conn->state == STATE_CLOSE)
+			goto close_err;
+
+		assert(rdmal->sge.length == wc->byte_len);
+		iser_rdma_read_completion(rdmal);
+		list_add(&rdmal->list, &ci->rdmal);
+		if (waiting_rdma_slot) {
+			waiting_rdma_slot = 0;
+			num_tx_ready = 1;
+		}
+		break;
+
+	default:
+		eprintf("unexpected opcode %d\n", wc->opcode);
+		exit(1);
+	}
+
+	return;
+
+close_err:
+	eprintf("conn state set to closed .. IMPLEMENT ME\n");
+	exit(1);
+}
+
+/*
+ * Called directly from main event loop when a CQ notification is
+ * available.
+ */
+static void iser_cqe_handler(int fd __attribute__((unused)),
+			     int events __attribute__((unused)),
+			     void *data)
+{
+	int ret;
+	void *cq_context;
+	struct iser_device *dev = data;
+
+	ret = ibv_get_cq_event(dev->cq_channel, &dev->cq, &cq_context);
+	if (ret != 0) {
+		eprintf("notification, but no CQ event\n");
+		exit(1);
+	}
+
+	ibv_ack_cq_events(dev->cq, 1);
+
+	ret = ibv_req_notify_cq(dev->cq, 0);
+	if (ret) {
+		eprintf("ibv_req_notify_cq: %s\n", strerror(ret));
+		exit(1);
+	}
+
+	iser_rx_progress(NULL, dev);
+}
+
+/*
+ * Called from tgtd when num_tx_ready (counter) non-zero.  Walks the
+ * list of active connections and tries to push tx on each, until nothing
+ * is ready anymore.  No progress limit here.
+ */
+static void iser_tx_progress(int *counter __attribute__((unused)),
+			     void *data __attribute__((unused)))
+{
+	int reloop, ret;
+	struct conn_info *ci, *cin;
+	struct iscsi_connection *conn;
+
+	dprintf("entry\n");
+	num_tx_ready = 0;
+
+	do {
+		reloop = 0;
+		list_for_each_entry_safe(ci, cin, &conn_tx_ready,
+					 conn_tx_ready) {
+			conn = &ci->iscsi_conn;
+			if (conn->state == STATE_CLOSE) {
+				dprintf("ignoring tx for closed conn\n");
+			} else {
+				dprintf("trying tx\n");
+				ret = iscsi_tx_handler(conn);
+				if (conn->state == STATE_CLOSE) {
+					conn_close(conn);
+					dprintf("connection %p closed\n", ci);
+				} else {
+					if (ret == 0) {
+						reloop = 1;
+					} else {
+						/* but leave on tx ready list */
+						waiting_rdma_slot = 1;
+					}
+				}
+			}
+		}
+	} while (reloop);
+}
+
+/*
+ * Could read as many entries as possible without blocking, but
+ * that just fills up a list of tasks.  Instead pop out of here
+ * so that tx progress, like issuing rdma reads and writes, can
+ * happen periodically.
+ */
+#define MAX_RX_PROGRESS 8
+static void iser_rx_progress_one(struct iser_device *dev)
+{
+	int ret, numwc = 0;
+	struct ibv_wc wc;
+	struct conn_info *ci;
+	struct recvlist *recvl;
+
+	for (;;) {
+		ret = ibv_poll_cq(dev->cq, 1, &wc);
+		if (ret < 0) {
+			eprintf("ibv_poll_cq %d\n", ret);
+			break;
+		} else if (ret == 0) {
+			break;
+		}
+
+		VALGRIND_MAKE_MEM_DEFINED(&wc, sizeof(wc));
+		if (wc.status == IBV_WC_SUCCESS) {
+			handle_wc(&wc);
+			if (++numwc == MAX_RX_PROGRESS) {
+				num_rx_ready = 1;
+				break;
+			}
+		} else if (wc.status == IBV_WC_WR_FLUSH_ERR) {
+			recvl = ptr_from_int64(wc.wr_id);
+			ci = recvl->conn;
+			if (ci->draining) {
+				--ci->recvl_posted;
+				if (ci->freed && ci->recvl_posted == 0)
+					iscsi_rdma_release(&ci->iscsi_conn);
+			} else {
+				eprintf("conn %p wr flush err\n", ci);
+				/* call disconnect now? */
+			}
+		} else {
+			eprintf("bad WC status %d for wr_id 0x%llx\n",
+				wc.status, (unsigned long long) wc.wr_id);
+		}
+	}
+}
+
+/*
+ * Only one progress counter, must look across all devs.
+ */
+static void iser_rx_progress(int *counter __attribute__((unused)), void *data)
+{
+	struct iser_device *dev;
+
+	dprintf("entry\n");
+	num_rx_ready = 0;
+	if (data == NULL) {
+		list_for_each_entry(dev, &iser_dev_list, list)
+			iser_rx_progress_one(dev);
+	} else {
+		dev = data;
+		iser_rx_progress_one(dev);
+	}
+}
+
+/*
+ * Init entire iscsi transport.  Begin listening for connections.
+ */
+static int iscsi_rdma_init(void)
+{
+	int ret;
+	struct sockaddr_in sock_addr;
+	short int port = ISCSI_LISTEN_PORT;
+
+	rdma_evt_channel = rdma_create_event_channel();
+
+	if (!rdma_evt_channel) {
+		eprintf("cannot initialize RDMA; load kernel modules?\n");
+		return -1;
+	}
+
+	ret = rdma_create_id(rdma_evt_channel, &cma_listen_id, NULL,
+			     RDMA_PS_TCP);
+	if (ret) {
+		eprintf("rdma_create_id: %s\n", strerror(ret));
+		return -1;
+	}
+
+	memset(&sock_addr, 0, sizeof(sock_addr));
+	sock_addr.sin_family = AF_INET;
+	sock_addr.sin_port = htons(port);
+	sock_addr.sin_addr.s_addr = INADDR_ANY;
+	ret = rdma_bind_addr(cma_listen_id, (struct sockaddr *) &sock_addr);
+	if (ret) {
+		if (ret == -1)
+			eprintf("rdma_bind_addr -1: %m\n");
+		else
+			eprintf("rdma_bind_addr: %s\n", strerror(-ret));
+		return -1;
+	}
+
+	/* 0 == maximum backlog */
+	ret = rdma_listen(cma_listen_id, 0);
+	if (ret) {
+		if (ret == -1)
+			eprintf("rdma_listen -1: %m\n");
+		else
+			eprintf("rdma_listen: %s\n", strerror(-ret));
+		return -1;
+	}
+
+	dprintf("listening for iser connections on port %d\n", port);
+	ret = tgt_event_add(cma_listen_id->channel->fd, EPOLLIN,
+			    iser_handle_rdmacm, NULL);
+	if (ret)
+		return ret;
+
+	INIT_LIST_HEAD(&conn_tx_ready);
+	INIT_LIST_HEAD(&iser_dev_list);
+	INIT_LIST_HEAD(&iser_conn_list);
+	INIT_LIST_HEAD(&temp_conn);
+	num_tx_ready = 0;
+	num_rx_ready = 0;
+	ret = tgt_counter_event_add(&num_tx_ready, iser_tx_progress, NULL);
+	ret = tgt_counter_event_add(&num_rx_ready, iser_rx_progress, NULL);
+	return ret;
+}
+
+/*
+ * Allocate resources for this new connection.  Called after login, when
+ * final negotiated transfer parameters are known.
+ */
+static int iscsi_rdma_login_complete(struct iscsi_connection *conn)
+{
+	int ret = -1;
+	struct conn_info *ci = RDMA_CONN(conn);
+	unsigned int irdsl, trdsl, outst_pdu, hdrsz;
+
+	dprintf("entry\n");
+
+	/*
+	 * Build full feature connection structures, but leave around the
+	 * login ones until the final send finishes.
+	 */
+	ci->login_phase = LOGIN_PHASE_LAST_SEND;  /* one more send, then done */
+	irdsl = conn->session_param[ISCSI_PARAM_INITIATOR_RDSL].val;
+	trdsl = conn->session_param[ISCSI_PARAM_TARGET_RDSL].val;
+	outst_pdu = conn->session_param[ISCSI_PARAM_MAX_OUTST_PDU].val;
+
+	/* hack, ib/ulp/iser does not have this param, but reading the code
+	 * shows
+	 *    ISCSI_XMIT_CMDS_MAX=128
+	 *    ISER_INFLIGHT_DATAOUTS=8
+	 *    ISER_MAX_RX_MISC_PDUS=4
+	 *    ISER_MAX_TX_MISC_PDUS=6
+	 * and their formula for max tx dtos outstanding
+	 *    = cmds_max * (1 + dataouts) + rx_misc + tx_misc
+	 */
+	if (outst_pdu == 0)
+		outst_pdu = 128 * (1 + 8) + 6 + 4;
+
+	/* RDSLs do not include headers. */
+	hdrsz = sizeof(struct iser_hdr) +
+		sizeof(struct iscsi_hdr) +
+		sizeof(struct iscsi_ecdb_ahdr) +
+		sizeof(struct iscsi_rlength_ahdr);
+
+	ci->ssize = hdrsz + irdsl;
+	ci->rsize = hdrsz + trdsl;
+	ci->max_outst_pdu = outst_pdu;
+	ret = iser_init_comm(ci);
+	if (ret) {
+		eprintf("iser_init_comm failed\n");
+		goto out;
+	}
+
+	/*
+	 * How much data to grab in an RDMA operation, read or write.
+	 */
+	conn->data_inout_max_length = RDMA_TRANSFER_SIZE;
+
+out:
+	return ret;
+}
+
+/*
+ * Copy the remote va and stag that were temporarily saved in conn_info.
+ */
+static void iscsi_iser_task_init(struct iscsi_task *task)
+{
+	struct conn_info *ci = RDMA_CONN(task->conn);
+	struct iser_task *itask = task->trans_data;
+
+	itask->rem_read_stag = ci->rem_read_stag;
+	itask->rem_read_va = ci->rem_read_va;
+	itask->rem_write_stag = ci->rem_write_stag;
+	itask->rem_write_va = ci->rem_write_va;
+}
+
+static int iser_parse_hdr(struct conn_info *ci, struct recvlist *recvl)
+{
+	int ret = -1;
+	struct iser_hdr *hdr = recvl->buf;
+
+	switch (hdr->flags & 0xF0) {
+	case ISCSI_CTRL:
+		dprintf("control type PDU\n");
+		if (hdr->flags & ISER_RSV) {
+			ci->rem_read_stag = be32_to_cpu(hdr->read_stag);
+			ci->rem_read_va = be64_to_cpu(hdr->read_va);
+			dprintf("rstag %x va %llx\n",
+				ci->rem_read_stag,
+				(unsigned long long) ci->rem_read_va);
+		}
+		if (hdr->flags & ISER_WSV) {
+			ci->rem_write_stag = be32_to_cpu(hdr->write_stag);
+			ci->rem_write_va = be64_to_cpu(hdr->write_va);
+			dprintf("wstag %x va %llx\n",
+				ci->rem_write_stag,
+				(unsigned long long) ci->rem_write_va);
+		}
+		ret = 0;
+		break;
+	case ISER_HELLO:
+		dprintf("iSER Hello message??\n");
+		break;
+	default:
+		eprintf("malformed iser hdr, flags 0x%02x\n", hdr->flags);
+		break;
+	}
+
+	ci->readb = sizeof(*hdr);
+	return ret;
+}
+
+static size_t iscsi_iser_read(struct iscsi_connection *conn, void *buf,
+			      size_t nbytes)
+{
+	int ret;
+	struct conn_info *ci = RDMA_CONN(conn);
+	struct recvlist *recvl;
+
+	dprintf("buf %p nbytes %zu\n", buf, nbytes);
+	recvl = ci->rcv_comm_event;
+	assert(recvl != NULL);
+
+	if (ci->readb == 0) {
+		if (recvl->bytes_recvd < sizeof(struct iser_hdr))
+			return 0;
+
+		ret = iser_parse_hdr(ci, recvl);
+		if (ret != 0)
+			return 0;
+	}
+
+	if (ci->readb + nbytes > recvl->bytes_recvd) {
+		if (ci->readb > recvl->bytes_recvd)
+			nbytes = recvl->bytes_recvd;
+		else
+			nbytes = recvl->bytes_recvd - ci->readb;
+	}
+
+	/* always copy headers into iscsi task structure */
+	memcpy(buf, (char *) recvl->buf + ci->readb, nbytes);
+	ci->readb += nbytes;
+
+	if (ci->readb == recvl->bytes_recvd)
+		ci->readb = 0;
+
+	return nbytes;
+}
+
+static size_t iscsi_iser_write_begin(struct iscsi_connection *conn,
+				     void *buf, size_t nbytes)
+{
+	struct conn_info *ci = RDMA_CONN(conn);
+	struct sendlist *sendl;
+
+	if (ci->send_comm_event == NULL) {
+		/* find one, first time here */
+		struct list_head *ci_sendl = &ci->sendl;
+
+		if (ci->login_phase != LOGIN_PHASE_FF)
+			ci_sendl = &ci->sendl_login;
+
+		if (list_empty(ci_sendl)) {
+			/* bug, max outst pdu should constrain this */
+			eprintf("no free send slot\n");
+			exit(1);
+		}
+		sendl = list_entry(ci_sendl->next, typeof(*sendl), list);
+		list_del(&sendl->list);
+		ci->send_comm_event = sendl;
+		dprintf("new sendl %p len %zu\n", sendl, nbytes);
+	} else {
+		sendl = ci->send_comm_event;
+		dprintf("reuse sendl %p len %u + %zu\n", sendl, ci->writeb,
+			nbytes);
+	}
+
+	if (ci->writeb + nbytes > ci->ssize) {
+		eprintf("send buf overflow %d + %zd > %u\n", ci->writeb,
+			nbytes, ci->ssize);
+		exit(1);
+	}
+
+	if (ci->writeb == 0) {
+		/* insert iser hdr */
+		struct iser_hdr *hdr = sendl->buf;
+
+		memset(hdr, 0, sizeof(*hdr));
+		hdr->flags = ISCSI_CTRL;
+		ci->writeb = sizeof(*hdr);
+	}
+
+	memcpy((char *) sendl->buf + ci->writeb, buf, nbytes);
+	ci->writeb += nbytes;
+	return nbytes;
+}
+
+static void iscsi_iser_write_end(struct iscsi_connection *conn)
+{
+	int ret;
+	struct ibv_send_wr *bad_wr;
+	struct conn_info *ci = RDMA_CONN(conn);
+	struct sendlist *sendl;
+
+	sendl = ci->send_comm_event;  /* set from _write_begin above */
+	dprintf("sendl %p len %d\n", sendl, ci->writeb);
+
+	sendl->sge.length = ci->writeb;
+
+	ret = ibv_post_send(ci->qp_hndl, &sendl->wr, &bad_wr);
+	if (ret) {
+		/* bug, should have sized max_outst_pdu properly */
+		eprintf("ibv_post_send ret %d\n", ret);
+		exit(1);
+	}
+
+	ci->writeb = 0;  /* reset count */
+	ci->send_comm_event = NULL;
+
+	/* wake up the progress engine to do the done */
+	dprintf("inc progress to finish cmd\n");
+	num_tx_ready = 1;
+}
+
+/*
+ * Expected opcodes are: IBV_WR_RDMA_WRITE, IBV_WR_RDMA_READ.
+ */
+static int iser_post_rdma_wr(struct conn_info *ci, struct iscsi_task *task,
+			     void *buf, ssize_t size, int op,
+			     uint64_t remote_va, uint32_t remote_rkey)
+{
+	int ret;
+	struct rdmalist *rdmal;
+	struct ibv_send_wr *bad_wr;
+
+	if (list_empty(&ci->rdmal)) {
+		eprintf("no slot\n");
+		return -1;
+	}
+	rdmal = list_entry(ci->rdmal.next, typeof(*rdmal), list);
+	list_del(&rdmal->list);
+
+	rdmal->task = task;
+	rdmal->sge.addr = uint64_from_ptr(buf);
+	rdmal->sge.length = size;
+
+	rdmal->wr.opcode = op;
+	rdmal->wr.wr.rdma.remote_addr = remote_va;
+	rdmal->wr.wr.rdma.rkey = remote_rkey;
+
+	ret = ibv_post_send(ci->qp_hndl, &rdmal->wr, &bad_wr);
+	if (ret)
+		eprintf("ibv_post_send ret %d\n", ret);
+
+	return ret;
+}
+
+/*
+ * Convert the iscsi r2t request to an RDMA read and post it.
+ */
+static int iscsi_rdma_rdma_read(struct iscsi_connection *conn)
+{
+	struct conn_info *ci = RDMA_CONN(conn);
+	struct iscsi_task *task = conn->tx_task;
+	struct iser_task *itask = task->trans_data;
+	struct iscsi_r2t_rsp *r2t = (struct iscsi_r2t_rsp *) &conn->rsp.bhs;
+	uint8_t *buf;
+	uint32_t len;
+	int ret;
+
+	buf = (uint8_t *) task->data + task->offset;
+	len = be32_to_cpu(r2t->data_length);
+
+	dprintf("len %u stag %x va %llx\n",
+		len, itask->rem_write_stag,
+		(unsigned long long) itask->rem_write_va);
+
+	ret = iser_post_rdma_wr(ci, task, buf, len, IBV_WR_RDMA_READ,
+				itask->rem_write_va, itask->rem_write_stag);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Initiator registers the entire buffer, but gives us a VA that
+	 * is advanced by immediate + unsolicited data amounts.  Advance
+	 * rem_va as we read, knowing that the target always grabs segments
+	 * in order.
+	 */
+	itask->rem_write_va += len;
+
+	return 0;
+}
+
+/*
+ * Convert the iscsi data-in response to an RDMA write and send it.
+ */
+static int iscsi_rdma_rdma_write(struct iscsi_connection *conn)
+{
+	struct conn_info *ci = RDMA_CONN(conn);
+	struct iscsi_task *task = conn->tx_task;
+	struct iser_task *itask = task->trans_data;
+	struct iscsi_pdu *rsp = &conn->rsp;
+	struct iscsi_data_rsp *datain = (struct iscsi_data_rsp *) &rsp->bhs;
+	uint32_t offset;
+	int ret;
+
+	offset = be32_to_cpu(datain->offset);
+
+	dprintf("offset %d len %d stag %x va %llx\n", offset, rsp->datasize,
+		itask->rem_read_stag, (unsigned long long) itask->rem_read_va);
+
+	ret = iser_post_rdma_wr(ci, task, rsp->data, rsp->datasize,
+				IBV_WR_RDMA_WRITE, itask->rem_read_va + offset,
+				itask->rem_read_stag);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * iscsi thinks we are txing, but really we're waiting for this
+	 * rdma to finish before sending the completion.  Then we'll stick
+	 * ourselves back on the list.
+	 */
+	if (task->offset == task->len) {
+		iscsi_rdma_event_modify(conn, EPOLLIN);
+	} else {
+		/* poke ourselves to do the next rdma */
+		num_tx_ready = 1;
+	}
+
+	return ret;
+}
+
+/*
+ * Called from CQ processing.  Hands completed write data to iscsi.
+ */
+static void iser_rdma_read_completion(struct rdmalist *rdmal)
+{
+	struct conn_info *ci = rdmal->conn;
+	struct iscsi_connection *conn = &ci->iscsi_conn;
+	struct iscsi_task *task;
+
+	/* task is no longer conn->tx_task, look it up */
+	list_for_each_entry(task, &conn->session->cmd_list, c_hlist) {
+		if (task == rdmal->task)
+			goto found;
+	}
+	eprintf("no task\n");
+	return;
+
+found:
+	/* equivalent of iscsi_data_out_rx_start + _done */
+	conn->rx_buffer = ptr_from_int64(rdmal->sge.addr);
+	conn->rx_size = rdmal->sge.length;
+	task->offset += rdmal->sge.length;
+	task->r2t_count -= rdmal->sge.length;
+	VALGRIND_MAKE_MEM_DEFINED(conn->rx_buffer, conn->rx_size);
+
+	dprintf("itt %x len %u arrived, r2t_count %d\n", (uint32_t) task->tag,
+		rdmal->sge.length, task->r2t_count);
+
+	/*
+	 * We soliticed this data, so hdr->ttt is what we asked for.  Bypass
+	 * data_out_rx_done and just run the task.  If more r2t are needed,
+	 * this will generate them.
+	 */
+	iscsi_scsi_cmd_execute(task);
+
+	conn->rx_task = NULL;
+	conn_read_pdu(conn);
+}
+
+/*
+ * Close connection.  There is no device close function.  This is called
+ * from iscsi.
+ */
+static size_t iscsi_rdma_close(struct iscsi_connection *conn)
+{
+	struct conn_info *ci = RDMA_CONN(conn);
+	int ret;
+
+	ret = rdma_disconnect(ci->cma_id);
+	if (ret)
+		eprintf("rdma_disconnect: %s\n", strerror(-ret));
+	dprintf("did rdma_disconnect\n");
+	list_del(&ci->conn_tx_ready);
+	list_del(&ci->iser_conn_list);
+	ci->draining = 1;
+	return 0;
+}
+
+/*
+ * Called when the connection is freed, from iscsi, but won't do anything until
+ * all posted WRs have gone away.  So also called again from RX progress when
+ * it notices this happens.
+ */
+static void iscsi_rdma_release(struct iscsi_connection *conn)
+{
+	struct conn_info *ci = RDMA_CONN(conn);
+	int ret;
+
+	dprintf("conn %p recvl %d\n", ci, ci->recvl_posted);
+
+	ci->freed = 1;
+
+	/* wait until all WRs flushed */
+	if (ci->recvl_posted != 0)
+		return;
+
+	iser_free_comm_login(ci);
+	if (ci->login_phase == LOGIN_PHASE_FF)
+		iser_free_comm(ci);
+
+	/* finally destory QP */
+	ret = ibv_destroy_qp(ci->qp_hndl);
+	if (ret)
+		eprintf("ibv_destroy_qp: %s\n", strerror(-ret));
+
+	/* and free the connection */
+	conn_exit(conn);
+	free(ci);
+}
+
+static int iscsi_rdma_show(struct iscsi_connection *conn, char *buf,
+			   int rest)
+{
+	int ret;
+	char host[NI_MAXHOST];
+	struct conn_info *ci = RDMA_CONN(conn);
+
+	ret = getnameinfo((struct sockaddr *) &ci->peer_addr,
+			  sizeof(ci->peer_addr), host, sizeof(host), NULL, 0,
+			  NI_NUMERICHOST);
+	if (ret) {
+		eprintf("getnameinfo: %m\n");
+		return 0;
+	}
+	return snprintf(buf, rest, "RDMA IP Address: %s", host);
+}
+
+static void iscsi_rdma_event_modify(struct iscsi_connection *conn, int events)
+{
+	struct conn_info *ci = RDMA_CONN(conn);
+
+	if (events & EPOLLOUT) {
+		/* with multiple commands queued, may already be on list */
+		if (list_empty(&ci->conn_tx_ready)) {
+			dprintf("tx ready adding %p\n", ci);
+			list_add(&ci->conn_tx_ready, &conn_tx_ready);
+		}
+		num_tx_ready = 1;
+	} else {
+		dprintf("tx ready removing %p\n", ci);
+		list_del_init(&ci->conn_tx_ready);
+	}
+}
+
+static void *iscsi_rdma_alloc_data_buf(struct iscsi_connection *conn,
+				       size_t sz)
+{
+	struct mempool *mem;
+	struct conn_info *ci = RDMA_CONN(conn);
+	struct iser_device *dev = ci->dev;
+
+	if (list_empty(&dev->mempool_free)) {
+		/* XXX: take slow path: allocate and register */
+		eprintf("free list empty\n");
+		exit(1);
+	}
+
+	if (sz > mempool_size) {
+		eprintf("size %zu too big\n", sz);
+		exit(1);
+	}
+
+	mem = list_entry(dev->mempool_free.next, typeof(*mem), list);
+	list_del(&mem->list);
+	list_add(&mem->list, &dev->mempool_alloc);
+	dprintf("malloc %p sz %zu\n", mem->buf, sz);
+	return mem->buf;
+}
+
+static void iscsi_rdma_free_data_buf(struct iscsi_connection *conn, void *buf)
+{
+	int found = 0;
+	struct mempool *mem;
+	struct conn_info *ci = RDMA_CONN(conn);
+	struct iser_device *dev = ci->dev;
+
+	if (!buf)
+		return;
+	list_for_each_entry(mem, &dev->mempool_alloc, list) {
+		if (mem->buf == buf) {
+			found = 1;
+			break;
+		}
+	}
+	dprintf("free %p\n", mem->buf);
+	if (!found) {
+		eprintf("couldn't locate buf %p\n", buf);
+		exit(1);
+	}
+	list_del(&mem->list);
+	list_add(&mem->list, &dev->mempool_free);
+}
+
+static int iscsi_rdma_getsockname(struct iscsi_connection *conn,
+				  struct sockaddr *sa, socklen_t *len)
+{
+	struct conn_info *ci = RDMA_CONN(conn);
+
+	if (*len > sizeof(ci->self_addr))
+		*len = sizeof(ci->self_addr);
+	memcpy(sa, &ci->self_addr, *len);
+	return 0;
+}
+
+static int iscsi_rdma_getpeername(struct iscsi_connection *conn,
+				  struct sockaddr *sa, socklen_t *len)
+{
+	struct conn_info *ci = RDMA_CONN(conn);
+
+	if (*len > sizeof(ci->peer_addr))
+		*len = sizeof(ci->peer_addr);
+	memcpy(sa, &ci->peer_addr, *len);
+	return 0;
+}
+
+struct iscsi_transport iscsi_iser = {
+	.name			= "iser",
+	.rdma			= 1,
+	.task_trans_len		= sizeof(struct iser_task),
+	.data_padding		= 1,
+	.ep_init		= iscsi_rdma_init,
+	.ep_login_complete	= iscsi_rdma_login_complete,
+	.ep_task_init		= iscsi_iser_task_init,
+	.ep_read		= iscsi_iser_read,
+	.ep_write_begin		= iscsi_iser_write_begin,
+	.ep_write_end		= iscsi_iser_write_end,
+	.ep_rdma_read		= iscsi_rdma_rdma_read,
+	.ep_rdma_write		= iscsi_rdma_rdma_write,
+	.ep_close		= iscsi_rdma_close,
+	.ep_release		= iscsi_rdma_release,
+	.ep_show		= iscsi_rdma_show,
+	.ep_event_modify	= iscsi_rdma_event_modify,
+	.alloc_data_buf		= iscsi_rdma_alloc_data_buf,
+	.free_data_buf		= iscsi_rdma_free_data_buf,
+	.ep_getsockname		= iscsi_rdma_getsockname,
+	.ep_getpeername		= iscsi_rdma_getpeername,
+};
+
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index b0c1b6d..dfdc374 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -2029,6 +2029,29 @@ int iscsi_tx_handler(struct iscsi_connection *conn)
 			goto out;
 	}
 
+	/*
+	 * For rdma, grab the data-in or r2t packet and covert to
+	 * an RDMA operation.
+	 */
+	if (conn->tp->rdma && conn->state == STATE_SCSI) {
+		switch (conn->rsp.bhs.opcode) {
+		case ISCSI_OP_R2T:
+			ret = conn->tp->ep_rdma_read(conn);
+			if (ret < 0)  /* wait for free slot */
+				goto out;
+			goto finish;
+
+		case ISCSI_OP_SCSI_DATA_IN:
+			ret = conn->tp->ep_rdma_write(conn);
+			if (ret < 0)
+				goto out;
+			goto finish;
+
+		default:
+			break;
+		}
+	}
+
 again:
 	switch (conn->tx_iostate) {
 	case IOSTATE_TX_BHS:
@@ -2121,6 +2144,8 @@ again:
 	}
 
 	conn->tp->ep_write_end(conn);
+
+finish:
 	cmnd_finish(conn);
 
 	switch (conn->state) {
diff --git a/usr/iscsi/transport.c b/usr/iscsi/transport.c
index 006442e..fc10e5d 100644
--- a/usr/iscsi/transport.c
+++ b/usr/iscsi/transport.c
@@ -29,6 +29,9 @@
 
 struct iscsi_transport *iscsi_transports[] = {
 	&iscsi_tcp,
+#ifdef ISCSI_RDMA
+	&iscsi_iser,
+#endif
 	NULL,
 };
 
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index 58bb992..4f9b943 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -20,6 +20,8 @@ struct iscsi_transport {
 	size_t (*ep_write_begin)(struct iscsi_connection *conn, void *buf,
 				 size_t nbytes);
 	void (*ep_write_end)(struct iscsi_connection *conn);
+	int (*ep_rdma_read)(struct iscsi_connection *conn);
+	int (*ep_rdma_write)(struct iscsi_connection *conn);
 	size_t (*ep_close)(struct iscsi_connection *conn);
 	void (*ep_release)(struct iscsi_connection *conn);
 
@@ -34,5 +36,6 @@ struct iscsi_transport {
 };
 
 extern struct iscsi_transport iscsi_tcp;
+extern struct iscsi_transport iscsi_iser;
 
 #endif
-- 
1.5.3.4



From rcj at linux.vnet.ibm.com  Mon Dec 10 17:12:04 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Mon, 10 Dec 2007 10:12:04 -0600
Subject: [Stgt-devel] [Patch 0/4] bs_mmap / kreq_send threading
In-Reply-To: <20071116183359J.fujita.tomonori@lab.ntt.co.jp>
References: <20071023211400.GA6091@linux.vnet.ibm.com>
	<20071106012928S.tomof@acm.org>
	<20071116183359J.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20071210161203.GA14038@linux.vnet.ibm.com>

* FUJITA Tomonori (fujita.tomonori at lab.ntt.co.jp) wrote:
> On Tue, 6 Nov 2007 01:27:10 +0900
> FUJITA Tomonori <tomof at acm.org> wrote:
> 
> > Sorry about the delay.
> > 
> > On Tue, 23 Oct 2007 16:14:01 -0500
> > Robert Jennings <rcj at linux.vnet.ibm.com> wrote:
> > 
> > > A little threading work like we have in bs_sync for bs_mmap.  The mmap
> > > can be taken care of with a small pool of worker threads this way.
> > > 
> > > After the mmap the completed commands enter back into the main tgtd
> > > thread and would be sent to the kernel for in-kernel drivers through
> > > kreq_send.  Unfortunately kreq_send can sleep in blk_rq_map_user or
> > > scsi_map_user_pages and hold up processing in tgtd.  So kreq_send can
> > > add the command to a list and hand it off to a small thread pool to
> > > process sending the replies to the kernel.
> > 
> > tgtd is blocked when the data of a file isn't in page cache. So how
> > about worker threads does access to the data before tgtd calls
> > kreq_send? It works like the flush web server.
> 
> Have you measured the performance with your patch?
> 
> I tried the worker thread idea, but the performance drops (probabaly
> due to pipe notification overveheads).

Took me a while to get back to this but I had done performance measures
as I made these changes.  

Applying only the patch to thread bs_sync testing would show that for
readv/writev operations there is a slight performance regression.
For aioread/aiowrite, pread/pwrite, and read/write the performance
improved with this patch by itself.  With the full patchset the random
readv/writev performance was stable with respect to the unpatched tree.

> diff --git a/usr/Makefile b/usr/Makefile
> index addf5be..7339dfc 100644
> --- a/usr/Makefile
> +++ b/usr/Makefile
> @@ -29,6 +29,7 @@ ifneq ($(IBMVIO),)
>  CFLAGS += -DIBMVIO -DUSE_KERNEL
>  TGTD_OBJS += $(addprefix ibmvio/, ibmvio.o)
>  TGTD_OBJS += bs_mmap.o tgtif.o
> +LIBS += -lpthread
>  endif
> 
>  ifneq ($(ISCSI),)
> diff --git a/usr/bs_mmap.c b/usr/bs_mmap.c
> index ad1bb4f..e4c0b86 100644
> --- a/usr/bs_mmap.c
> +++ b/usr/bs_mmap.c
> @@ -26,59 +26,277 @@
>  #include <stdlib.h>
>  #include <string.h>
>  #include <unistd.h>
> +#include <pthread.h>
>  #include <sys/mman.h>
> +#include <sys/epoll.h>
> 
>  #include "list.h"
>  #include "util.h"
>  #include "tgtd.h"
>  #include "scsi.h"
> 
> -static int bs_mmap_open(struct scsi_lu *lu, char *path, int *fd, uint64_t *size)
> -{
> -	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
> +#define NR_WORKER_THREADS	4
> 
> -	return *fd >= 0 ? 0 : *fd;
> -}
> +struct bs_mmap_info {
> +	pthread_t ack_thread;
> +	pthread_t worker_thread[NR_WORKER_THREADS];
> 
> -static void bs_mmap_close(struct scsi_lu *lu)
> +	/* protected by pipe */
> +	struct list_head ack_list;
> +
> +	pthread_cond_t finished_cond;
> +	pthread_mutex_t finished_lock;
> +	struct list_head finished_list;
> +
> +	/* wokers sleep on this and signaled by tgtd */
> +	pthread_cond_t pending_cond;
> +	/* locked by tgtd and workers */
> +	pthread_mutex_t pending_lock;
> +	/* protected by pending_lock */
> +	struct list_head pending_list;
> +
> +	int command_fd[2];
> +	int done_fd[2];
> +
> +	int stop;
> +};
> +
> +static void *bs_mmap_ack_fn(void *arg)
>  {
> -	close(lu->fd);
> +	struct bs_mmap_info *info = arg;
> +	int command, ret, nr;
> +	struct scsi_cmd *cmd;
> +
> +retry:
> +	ret = read(info->command_fd[0], &command, sizeof(command));
> +	if (ret < 0) {
> +		eprintf("ack pthread will be dead, %m\n");
> +		if (errno == EAGAIN || errno == EINTR)
> +			goto retry;
> +
> +		goto out;
> +	}
> +
> +	pthread_mutex_lock(&info->finished_lock);
> +retest:
> +	if (list_empty(&info->finished_list)) {
> +		pthread_cond_wait(&info->finished_cond, &info->finished_lock);
> +		goto retest;
> +	}
> +
> +	while (!list_empty(&info->finished_list)) {
> +		cmd = list_entry(info->finished_list.next,
> +				 struct scsi_cmd, bs_list);
> +
> +		dprintf("found %p\n", cmd);
> +
> +		list_del(&cmd->bs_list);
> +		list_add(&cmd->bs_list, &info->ack_list);
> +	}
> +
> +	pthread_mutex_unlock(&info->finished_lock);
> +
> +	nr = 1;
> +rewrite:
> +	ret = write(info->done_fd[1], &nr, sizeof(nr));
> +	if (ret < 0) {
> +		eprintf("can't ack tgtd, %m\n");
> +		if (errno == EAGAIN || errno == EINTR)
> +			goto rewrite;
> +
> +		goto out;
> +	}
> +
> +	goto retry;
> +out:
> +	return NULL;
>  }
> 
>  #define pgcnt(size, offset)	((((size) + ((offset) & (pagesize - 1))) + (pagesize - 1)) >> pageshift)
> 
> -static int bs_mmap_cmd_submit(struct scsi_cmd *cmd)
> +static void *bs_mmap_worker_fn(void *arg)
>  {
> -	int fd = cmd->dev->fd, ret = 0;
> -	void *p;
> -	uint64_t addr;
> +	int ret = 0;
> +	struct bs_mmap_info *info = arg;
> +	struct scsi_cmd *cmd;
>  	uint32_t length;
> 
> -	if (cmd->scb[0] == SYNCHRONIZE_CACHE ||
> -	    cmd->scb[0] == SYNCHRONIZE_CACHE_16)
> -		return fsync(fd);
> +	while (1) {
> +		uint64_t addr;
> +		char *p, dummy;
> +		int i, nr;
> 
> -	length = (scsi_get_data_dir(cmd) == DATA_WRITE) ?
> -		scsi_get_out_length(cmd) : scsi_get_in_length(cmd);
> +		pthread_mutex_lock(&info->pending_lock);
> +	retest:
> +		if (list_empty(&info->pending_list)) {
> +			pthread_cond_wait(&info->pending_cond, &info->pending_lock);
> +			if (info->stop) {
> +				pthread_mutex_unlock(&info->pending_lock);
> +				break;
> +			}
> +			goto retest;
> +		}
> 
> -	p = mmap64(NULL, pgcnt(length, cmd->offset) << pageshift,
> -		   PROT_READ | PROT_WRITE, MAP_SHARED, fd,
> -		   cmd->offset & ~((1ULL << pageshift) - 1));
> -	if (p == MAP_FAILED) {
> -		ret = -EINVAL;
> -		eprintf("%u %" PRIu64 "\n", length, cmd->offset);
> +		cmd = list_entry(info->pending_list.next,
> +				 struct scsi_cmd, bs_list);
> +
> +		dprintf("got %p\n", cmd);
> +
> +		list_del(&cmd->bs_list);
> +		pthread_mutex_unlock(&info->pending_lock);
> +
> +		if (cmd->scb[0] == SYNCHRONIZE_CACHE ||
> +		    cmd->scb[0] == SYNCHRONIZE_CACHE_16) {
> +			ret = fsync(cmd->dev->fd);
> +			goto done;
> +		}
> +
> +		ret = 0;
> +
> +		if (cmd->data_dir == DATA_WRITE) {
> +			addr = (unsigned long)scsi_get_out_buffer(cmd);
> +			length = scsi_get_out_length(cmd);
> +		} else {
> +			addr = (unsigned long)scsi_get_in_buffer(cmd);
> +			length = scsi_get_in_length(cmd);
> +		}
> +
> +		nr = pgcnt(length, (addr & (pagesize - 1)));
> +		addr &= ~(pagesize - 1);
> +
> +		p = (void *)(unsigned long)addr;
> +		for (i = 0; i < nr; i++) {
> +			dummy = *p;
> +			p += pagesize;
> +		}
> +	done:
> +		if (ret) {
> +			eprintf("io error %p %x %d %d, %m\n",
> +				cmd, cmd->scb[0], ret, cmd->offset);
> +			scsi_set_result(cmd, SAM_STAT_CHECK_CONDITION);
> +			sense_data_build(cmd, MEDIUM_ERROR, ASC_READ_ERROR);
> +		} else
> +			scsi_set_result(cmd, SAM_STAT_GOOD);
> +
> +		pthread_mutex_lock(&info->finished_lock);
> +		list_add(&cmd->bs_list, &info->finished_list);
> +		pthread_mutex_unlock(&info->finished_lock);
> +
> +		pthread_cond_signal(&info->finished_cond);
>  	}
> 
> -	addr = (unsigned long)p + (cmd->offset & (pagesize - 1));
> +	return NULL;
> +}
> 
> -	if (scsi_get_data_dir(cmd) == DATA_WRITE)
> -		scsi_set_out_buffer(cmd, (void *)(unsigned long)addr);
> -	else if (scsi_get_data_dir(cmd) == DATA_READ)
> -		scsi_set_in_buffer(cmd, (void *)(unsigned long)addr);
> +static void bs_mmap_handler(int fd, int events, void *data)
> +{
> +	struct bs_mmap_info *info = data;
> +	struct scsi_cmd *cmd;
> +	int nr_events, ret;
> 
> -	dprintf("%" PRIx64 " %u %" PRIu64 "\n", addr, length, cmd->offset);
> +	ret = read(info->done_fd[0], &nr_events, sizeof(nr_events));
> +	if (ret < 0) {
> +		eprintf("wrong wakeup\n");
> +		return;
> +	}
> +
> +	while (!list_empty(&info->ack_list)) {
> +		cmd = list_entry(info->ack_list.next,
> +				 struct scsi_cmd, bs_list);
> 
> -	return ret;
> +		dprintf("back to tgtd, %p\n", cmd);
> +
> +		list_del(&cmd->bs_list);
> +		target_cmd_io_done(cmd, scsi_get_result(cmd));
> +	}
> +
> +	write(info->command_fd[1], &nr_events, sizeof(nr_events));
> +}
> +
> +static int bs_mmap_open(struct scsi_lu *lu, char *path, int *fd, uint64_t *size)
> +{
> +	int i, ret;
> +	struct bs_mmap_info *info =
> +		(struct bs_mmap_info *)((char *)lu + sizeof(*lu));
> +
> +	INIT_LIST_HEAD(&info->ack_list);
> +	INIT_LIST_HEAD(&info->finished_list);
> +	INIT_LIST_HEAD(&info->pending_list);
> +
> +	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
> +	if (*fd < 0)
> +		return *fd;
> +
> +	pthread_cond_init(&info->finished_cond, NULL);
> +	pthread_cond_init(&info->pending_cond, NULL);
> +
> +	pthread_mutex_init(&info->finished_lock, NULL);
> +	pthread_mutex_init(&info->pending_lock, NULL);
> +
> +	ret = pipe(info->command_fd);
> +	if (ret)
> +		goto close_dev_fd;
> +
> +	ret = pipe(info->done_fd);
> +	if (ret)
> +		goto close_command_fd;
> +
> +	ret = tgt_event_add(info->done_fd[0], EPOLLIN, bs_mmap_handler, info);
> +	if (ret)
> +		goto close_done_fd;
> +
> +	ret = pthread_create(&info->ack_thread, NULL, bs_mmap_ack_fn, info);
> +	if (ret)
> +		goto event_del;
> +
> +	for (i = 0; i < ARRAY_SIZE(info->worker_thread); i++) {
> +		ret = pthread_create(&info->worker_thread[i], NULL,
> +				     bs_mmap_worker_fn, info);
> +	}
> +
> +	write(info->command_fd[1], &ret, sizeof(ret));
> +
> +	return 0;
> +event_del:
> +	tgt_event_del(info->done_fd[0]);
> +close_done_fd:
> +	close(info->done_fd[0]);
> +	close(info->done_fd[1]);
> +close_command_fd:
> +	close(info->command_fd[0]);
> +	close(info->command_fd[1]);
> +close_dev_fd:
> +	close(*fd);
> +
> +	pthread_cond_destroy(&info->finished_cond);
> +	pthread_cond_destroy(&info->pending_cond);
> +	pthread_mutex_destroy(&info->finished_lock);
> +	pthread_mutex_destroy(&info->pending_lock);
> +
> +	return -1;
> +}
> +
> +static void bs_mmap_close(struct scsi_lu *lu)
> +{
> +	int i;
> +	struct bs_mmap_info *info =
> +		(struct bs_mmap_info *)((char *)lu + sizeof(*lu));
> +
> +	pthread_cancel(info->ack_thread);
> +	pthread_join(info->ack_thread, NULL);
> +
> +	info->stop = 1;
> +	pthread_cond_broadcast(&info->pending_cond);
> +
> +	for (i = 0; i < ARRAY_SIZE(info->worker_thread); i++)
> +		pthread_join(info->worker_thread[i], NULL);
> +
> +	pthread_cond_destroy(&info->finished_cond);
> +	pthread_cond_destroy(&info->pending_cond);
> +	pthread_mutex_destroy(&info->finished_lock);
> +	pthread_mutex_destroy(&info->pending_lock);
> +
> +	close(lu->fd);
>  }
> 
>  static int bs_mmap_cmd_done(struct scsi_cmd *cmd)
> @@ -109,7 +327,59 @@ static int bs_mmap_cmd_done(struct scsi_cmd *cmd)
>  	return err;
>  }
> 
> +static int bs_mmap_cmd_submit(struct scsi_cmd *cmd)
> +{
> +	struct scsi_lu *lu = cmd->dev;
> +	struct bs_mmap_info *info =
> +		(struct bs_mmap_info *)((char *)lu + sizeof(*lu));
> +	int fd;
> +	uint32_t length;
> +	uint64_t addr;
> +	void *p;
> +
> +	fd = cmd->dev->fd;
> +	length = 0;
> +
> +	if (cmd->scb[0] == SYNCHRONIZE_CACHE ||
> +	    cmd->scb[0] == SYNCHRONIZE_CACHE_16)
> +		goto queuing;
> +
> +	if (cmd->data_dir == DATA_WRITE)
> +		length = scsi_get_out_length(cmd);
> +	else
> +		length = scsi_get_in_length(cmd);
> +
> +	p = mmap64(NULL, pgcnt(length, cmd->offset) << pageshift,
> +		   PROT_READ | PROT_WRITE, MAP_SHARED, fd,
> +		   cmd->offset & ~((1ULL << pageshift) - 1));
> +	if (p == MAP_FAILED)
> +		return EIO;
> +
> +	addr = (unsigned long)p + (cmd->offset & (pagesize - 1));
> +
> +	if (scsi_get_data_dir(cmd) == DATA_WRITE)
> +		scsi_set_out_buffer(cmd, (void *)(unsigned long)addr);
> +	else
> +		scsi_set_in_buffer(cmd, (void *)(unsigned long)addr);
> +
> +	scsi_set_result(cmd, SAM_STAT_GOOD);
> +
> +queuing:
> +	pthread_mutex_lock(&info->pending_lock);
> +
> +	list_add(&cmd->bs_list, &info->pending_list);
> +
> +	pthread_mutex_unlock(&info->pending_lock);
> +
> +	pthread_cond_signal(&info->pending_cond);
> +
> +	set_cmd_async(cmd);
> +
> +	return 0;
> +}
> +
>  struct backingstore_template mmap_bst = {
> +	.bs_datasize		= sizeof(struct bs_mmap_info),
>  	.bs_open		= bs_mmap_open,
>  	.bs_close		= bs_mmap_close,
>  	.bs_cmd_submit		= bs_mmap_cmd_submit,
---
Robert C. Jennings <rcjenn at us.ibm.com>
IBM Linux Technology Center, Austin
+1.512.838.4964 (t/l 678.4964)


From fujita.tomonori at lab.ntt.co.jp  Tue Dec 11 04:34:57 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 11 Dec 2007 12:34:57 +0900
Subject: [Stgt-devel] [PATCH 2/6] iser task transport data
In-Reply-To: <20071210150451.GC31889@osc.edu>
References: <20071210150325.GA31889@osc.edu> <20071210150451.GC31889@osc.edu>
Message-ID: <20071211123457F.fujita.tomonori@lab.ntt.co.jp>

On Mon, 10 Dec 2007 10:04:51 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> RDMA will need to store some per-task data to use initiator-provided tags
> in later RDMA operations.  Provide some space for this and hook into the
> transport at task initialization time.
> 
> Based on the patch by Erez Zilber <erezz at voltaire.com>.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>

I thought that my approach looks more simple:

https://lists.berlios.de/pipermail/stgt-devel/2007-November/001156.html


From fujita.tomonori at lab.ntt.co.jp  Tue Dec 11 05:54:52 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 11 Dec 2007 13:54:52 +0900
Subject: [Stgt-devel] iSER patches, third release
In-Reply-To: <20071210150325.GA31889@osc.edu>
References: <20071210150325.GA31889@osc.edu>
Message-ID: <20071211135452I.fujita.tomonori@lab.ntt.co.jp>

On Mon, 10 Dec 2007 10:03:25 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> This is the third major release of support for iSCSI Extensions
> for RDMA (iSER) to the existing TGT user space SCSI target.  It
> uses OpenFabrics libraries and kernel drivers to act as a SCSI
> target over RDMA-capable devices.  The code has been tested
> against the existing Linux iSER initiator over InfiniBand cards,
> but should be specification compliant and work generally.

Excellent.


> 1 iser docs - just doc/
> 
> 2 iser task transport data - need private data in struct task,
>     could merge as is, or let iscsi transport do allocation as
>     with connection struct.
> 
> 3 iser rounding - removed "if (conn->tp->rdma)" approach, now uses
>     "conn->tp->data_padding".  Also deleted some roundup()s that
>     were unnecessary in both cases.
> 
> 4 iser params - new parameters for iSER straight from spec docs.  No
>     ifdef on ISCSI_RDMA, we let initiator say if it wants RDMA or
>     not.
> 
> 5 iser iscsid changes - five little "if (conn->tp->rdma)" changes,
>     all necessary due to protocol differences and different event
>     handler
> 
> 6 iser core - add iscsi/iscsi_rdma.c and hooks to use it

Except for the second patch, the rest looks ready for the inclusion I
think. The changes to iscsid.c in the 5th patch looks a bit hacky but
it's fine with me for now.


> I'll look at what causes these performance changes and try out some
> more recent kernels.  But I wanted to get the patches to people so
> as not to hold up any other work.  Would love to see some more
> scientific numbers from people, and help figuring out where the time
> is going.

Yeah, we can work on the performance issues later on.


From fujita.tomonori at lab.ntt.co.jp  Tue Dec 11 06:08:30 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 11 Dec 2007 14:08:30 +0900
Subject: [Stgt-devel] [PATCH] task data leak
In-Reply-To: <20071208153016.GA10075@osc.edu>
References: <20071207202353.GA26422@osc.edu>
	<200712081300.lB8D01JC014951@mbox.iij4u.or.jp>
	<20071208153016.GA10075@osc.edu>
Message-ID: <20071211140830D.fujita.tomonori@lab.ntt.co.jp>

On Sat, 8 Dec 2007 10:30:16 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> tomof at acm.org wrote on Sat, 08 Dec 2007 21:59 +0900:
> > From: Pete Wyckoff <pw at osc.edu>
> > Subject: [Stgt-devel] [PATCH] task data leak
> > Date: Fri, 7 Dec 2007 15:23:53 -0500
> > 
> > > iscsi_scsi_cmd_rx_start always allocates a buffer of 4096 to accommodate
> > > assumptions in spc, sbc, etc.  Even when a SCSI command asks for data
> > > length of zero, task->data is allocated to 4096.  However this is never
> > > assigned as in or out buf on scmd.  Thus never freed.
> > > 
> > > This works around that by freeing an orphaned task->data.  Again, though,
> > > the better solution is to fix up all the little functions like inquiry
> > > that cause this situation in the first place.
> > > 
> > > Signed-off-by: Pete Wyckoff <pw at osc.edu>
> > > ---
> > >  usr/iscsi/iscsid.c |   11 +++++++++++
> > >  1 files changed, 11 insertions(+), 0 deletions(-)
> > > 
> > > diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> > > index 1e0172a..ab1999d 100644
> > > --- a/usr/iscsi/iscsid.c
> > > +++ b/usr/iscsi/iscsid.c
> > > @@ -1024,6 +1024,17 @@ void iscsi_free_task(struct iscsi_task *task)
> > >  {
> > >  	struct iscsi_connection *conn = task->conn;
> > >  
> > > +	/*
> > > +	 * Catch case when data_len is zero but pushed up to 4096
> > > +	 * to work around spc allocation assumption, but then later
> > > +	 * determined to be DATA_NONE and not used as either in or
> > > +	 * out buffer.
> > > +	 */
> > > +	if (task->data &&
> > > +	    task->data != scsi_get_in_buffer(&task->scmd) &&
> > > +	    task->data != scsi_get_out_buffer(&task->scmd))
> > > +		conn->tp->free_data_buf(conn, task->data);
> > > +
> > 
> > Nice catch, thanks.
> > 
> > How about this patch?
> > 
> > diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> > index 1e0172a..e27c74c 100644
> > --- a/usr/iscsi/iscsid.c
> > +++ b/usr/iscsi/iscsid.c
> > @@ -1435,7 +1435,7 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
> >  	/*
> >  	 * fix spc, sbc, etc. they assume that buffer is long enough.
> >  	 */
> > -	if (data_len < 4096)
> > +	if (data_len && data_len < 4096)
> >  		data_len = 4096;
> >  
> >  	ext_len = ahs_len ? sizeof(req->cdb) + ahs_len : 0;
> > 
> 
> Would be simpler, yes, but less safe.  Client could do an inquiry
> with data_len of 0 and lead to a crash in spc_inquiry, e.g.

But it is true even before I rewrote data buffer handling code, isn't
it?


> We really should just fix those functions.  Adding a bunch of "if
> (data_len > ...)" is one way, although one would need many of these
> tests for all the various cases.  I had proposed allocating a temp
> buffer, then memcpy with bounds checking into whatever out_buffer is
> available as the final step.  See the old 03/20 iser-transport-buf
> patch if you think that has merit.

I prefer (data_len > ...) way since I always like to use the same way
(report_luns already does that check). But it might become too
ugly. I'll fix it to see how things look like.


> The other issue is that inquiry etc. expect a zeroed buffer, and
> trying to guess if scsi_is_io_opcode() to determine if the handler
> function doesn't need zeroing is insufficient.  I'll send a terrible
> patch to work around this for OSD, but would prefer to fix inquiry
> and friends instead.

Yeah, we need to fix this too.


From tomof at acm.org  Tue Dec 11 06:24:35 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Tue, 11 Dec 2007 14:24:35 +0900
Subject: [Stgt-devel] [PATCH] INQUIRY Additional len size
	incorrectly	calculated
In-Reply-To: <475A5FF5.6020707@gmail.com>
References: <475A5FF5.6020707@gmail.com>
Message-ID: <20071211142005R.tomof@acm.org>

On Sat, 08 Dec 2007 20:12:21 +1100
Mark Harvey <markh794 at gmail.com> wrote:

> >From 70246d2420b5ec4180289ae64a1abb92ae3c8e11 Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Sat, 8 Dec 2007 19:46:54 +1100
> Subject: Incorrect calculation for standard INQUIRY additional len field
> 
> Additional len calculated incorrectly due to len not being set
> before use.
> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>

Nice catch! Thanks, applied.


From cabdrivers at rittmeyer.es  Thu Dec 13 04:15:00 2007
From: cabdrivers at rittmeyer.es (Kruzan Sothman)
Date: Thu, 13 Dec 2007 03:15:00 +0000
Subject: [Stgt-devel] fluorescein
Message-ID: <4814461660.20071213031003@rittmeyer.es>

Goedendag,  

   Virus found in this message, please delete it without futher reading


	Instead of the night before, but, happening to to see if
her lover was coming. She was rewarded, any weight with
you, i trust that you will do.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071213/86c61156/attachment.html>

From tomof at acm.org  Thu Dec 13 14:31:22 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Thu, 13 Dec 2007 22:31:22 +0900
Subject: [Stgt-devel] iSER patches, third release
In-Reply-To: <20071210150325.GA31889@osc.edu>
References: <20071210150325.GA31889@osc.edu>
Message-ID: <20071213223409V.tomof@acm.org>

On Mon, 10 Dec 2007 10:03:25 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> This is the third major release of support for iSCSI Extensions
> for RDMA (iSER) to the existing TGT user space SCSI target.  It
> uses OpenFabrics libraries and kernel drivers to act as a SCSI
> target over RDMA-capable devices.  The code has been tested
> against the existing Linux iSER initiator over InfiniBand cards,
> but should be specification compliant and work generally.
> 
> A bit of documentation is included, and a short technical report is
> available at http://www.osc.edu/~pw/papers/iser-snapi07.pdf with
> slides from a presentation at
> http://www.osc.edu/~pw/papers/wyckoff-iser-snapi07-talk.pdf .
> 
> The iSER patches can be downloaded from:
> 
>         git://git.osc.edu/tgt
> 
> or browsed at:
> 
>         http://git.osc.edu/?p=tgt.git;a=summary
> 
> Changes since previous series are as follows.

I merged all the patches. Now mainline tgt supports iSER. Thanks!

I also applied some patches that could break iSER support. iSER
people, please test the latest tree.


From hypocritic at rm.ca  Fri Dec 14 12:04:49 2007
From: hypocritic at rm.ca (Szaflarski Cabada)
Date: Fri, 14 Dec 2007 11:04:49 +0000
Subject: [Stgt-devel] splashbacks
Message-ID: <5361871913.20071214095520@rm.ca>

Aloha,   
	
Virus found in this message, please delete it without futher reading   

  
He broke his arm and his shoulderblade, and he 'macaroni
cheese,' growled topsy, speaking from until the following
rorning. Death is estimated.	
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071214/103ac5f9/attachment.html>

From mangoo at wpkg.org  Fri Dec 14 17:35:51 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Fri, 14 Dec 2007 17:35:51 +0100
Subject: [Stgt-devel] some simple tgt / iSCSI-SCST performance tests
Message-ID: <4762B0E7.6010207@wpkg.org>

I made some simple performance tests of tgt and iSCSI-SCST.


Reading the array on a target machine to /dev/null gives me ~70 MB/s.

When I read the same array on the initiator with tgt as a target, it 
gives me ~25 MB/s.

With iSCSI-SCST, I get ~35 MB/s (although I think I maxed out the PCI at 
this point; on something more modern it could be better).

I dropped caches before each test.


Also, CPU load is slightly bigger when tgtd is used as a target, 
although I didn't do any precise measurements here. With tgt, both CPU 
usage was more or less settled at the same level; with SCST CPU0 usage 
jumped up and down by +/- 20%; CPU1 usage for SCST was more or less at 
the same level.
It would be nice to know more on the nature of these CPU usage spikes 
for SCST (and possibly, how it could affect i.e. reading from an 
encrypted device-mapper volume).


tgt-git:
CPU0: ~30%
CPU1: ~90%

SCST-r234:
CPU0: ~30%
CPU1: ~80%



Read on the target:

# dd if=/dev/sda of=/dev/null bs=64k count=50000
50000+0 records in
50000+0 records out
3276800000 bytes (3.3 GB) copied, 45.9789 seconds, 71.3 MB/s



SCST-r234:

# dd if=/dev/sdba of=/dev/null bs=64k count=50000
50000+0 records in
50000+0 records out
3276800000 bytes (3.3 GB) copied, 90.817 seconds, 36.1 MB/s



tgt-git:

# dd if=/dev/sday of=/dev/null bs=64k count=50000
50000+0 records in
50000+0 records out
3276800000 bytes (3.3 GB) copied, 140.123 seconds, 23.4 MB/s



tgt-20071014:

# dd if=/dev/sday of=/dev/null bs=64k count=50000
50000+0 records in
50000+0 records out
3276800000 bytes (3.3 GB) copied, 138.754 seconds, 23.6 MB/s





BTW, is it possible to do a nullio test with tgt target?



-- 
Tomasz Chmielewski
http://wpkg.org


From vst at vlnb.net  Fri Dec 14 18:09:17 2007
From: vst at vlnb.net (Vladislav Bolkhovitin)
Date: Fri, 14 Dec 2007 20:09:17 +0300
Subject: [Stgt-devel] [Scst-devel] some simple tgt / iSCSI-SCST
	performance tests
In-Reply-To: <4762B0E7.6010207@wpkg.org>
References: <4762B0E7.6010207@wpkg.org>
Message-ID: <4762B8BD.6040001@vlnb.net>

Tomasz Chmielewski wrote:
> I made some simple performance tests of tgt and iSCSI-SCST.
> 
> 
> Reading the array on a target machine to /dev/null gives me ~70 MB/s.
> 
> When I read the same array on the initiator with tgt as a target, it 
> gives me ~25 MB/s.
> 
> With iSCSI-SCST, I get ~35 MB/s (although I think I maxed out the PCI at 
> this point; on something more modern it could be better).

Tomasz meant here that on his target both network and backstorage 
hardware sit on the same 32-bit 33MHz PCI and share its bandwidth, which 
is less, than 100MB/s. I.e. he can at max get ~40MB/s (since his array 
has 70MB/s) + sharing overhead.

> I dropped caches before each test.
> 
> 
> Also, CPU load is slightly bigger when tgtd is used as a target, 
> although I didn't do any precise measurements here. With tgt, both CPU 
> usage was more or less settled at the same level; with SCST CPU0 usage 
> jumped up and down by +/- 20%; CPU1 usage for SCST was more or less at 
> the same level.
> It would be nice to know more on the nature of these CPU usage spikes 
> for SCST (and possibly, how it could affect i.e. reading from an 
> encrypted device-mapper volume).
> 
> 
> tgt-git:
> CPU0: ~30%
> CPU1: ~90%
> 
> SCST-r234:
> CPU0: ~30%
> CPU1: ~80%
> 
> 
> 
> Read on the target:
> 
> # dd if=/dev/sda of=/dev/null bs=64k count=50000
> 50000+0 records in
> 50000+0 records out
> 3276800000 bytes (3.3 GB) copied, 45.9789 seconds, 71.3 MB/s
> 
> 
> 
> SCST-r234:
> 
> # dd if=/dev/sdba of=/dev/null bs=64k count=50000
> 50000+0 records in
> 50000+0 records out
> 3276800000 bytes (3.3 GB) copied, 90.817 seconds, 36.1 MB/s
> 
> 
> 
> tgt-git:
> 
> # dd if=/dev/sday of=/dev/null bs=64k count=50000
> 50000+0 records in
> 50000+0 records out
> 3276800000 bytes (3.3 GB) copied, 140.123 seconds, 23.4 MB/s
> 
> 
> 
> tgt-20071014:
> 
> # dd if=/dev/sday of=/dev/null bs=64k count=50000
> 50000+0 records in
> 50000+0 records out
> 3276800000 bytes (3.3 GB) copied, 138.754 seconds, 23.6 MB/s
> 
> 
> 
> 
> 
> BTW, is it possible to do a nullio test with tgt target?
> 
> 
> 



From erezz at Voltaire.COM  Mon Dec 17 14:17:16 2007
From: erezz at Voltaire.COM (Erez Zilber)
Date: Mon, 17 Dec 2007 15:17:16 +0200
Subject: [Stgt-devel] Errors in fsck with iSER (was: iSER patches,
	third release)
In-Reply-To: <20071213223409V.tomof@acm.org>
References: <20071210150325.GA31889@osc.edu> <20071213223409V.tomof@acm.org>
Message-ID: <476676DC.5030100@Voltaire.COM>


FUJITA Tomonori wrote:
> On Mon, 10 Dec 2007 10:03:25 -0500
> Pete Wyckoff <pw at osc.edu> wrote:
>
>   
>> This is the third major release of support for iSCSI Extensions
>> for RDMA (iSER) to the existing TGT user space SCSI target.  It
>> uses OpenFabrics libraries and kernel drivers to act as a SCSI
>> target over RDMA-capable devices.  The code has been tested
>> against the existing Linux iSER initiator over InfiniBand cards,
>> but should be specification compliant and work generally.
>>
>> A bit of documentation is included, and a short technical report is
>> available at http://www.osc.edu/~pw/papers/iser-snapi07.pdf with
>> slides from a presentation at
>> http://www.osc.edu/~pw/papers/wyckoff-iser-snapi07-talk.pdf .
>>
>> The iSER patches can be downloaded from:
>>
>>         git://git.osc.edu/tgt
>>
>> or browsed at:
>>
>>         http://git.osc.edu/?p=tgt.git;a=summary
>>
>> Changes since previous series are as follows.
>>     
>
> I merged all the patches. Now mainline tgt supports iSER. Thanks!
>
> I also applied some patches that could break iSER support. iSER
> people, please test the latest tree.
>   

We ran some tests on it. Most of them are ok except for fsck. We ran it
in the following way:

seed5:/tmp/regtest # parted -s /dev/sdb mkpart primary 0 8500
seed5:/tmp/regtest # for ((i=1;i<=1000;i++)) do mkfs -t ext2 -q
/dev/sdb1; fsck -y -ft ext2 /dev/sdb1; echo iteration $i is done; done

fsck is ok most of the time, but once in a while it looks like this
(after ~300 iterations):

fsck 1.38 (30-Jun-2005)
e2fsck 1.38 (30-Jun-2005)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
/dev/sdb1: 11/1038336 files (0.0% non-contiguous), 32599/2075195 blocks
seed5:/tmp/regtest # mkfs -t ext2 -q /dev/sdb1
seed5:/tmp/regtest # fsck -y -ft ext2 /dev/sdb1
fsck 1.38 (30-Jun-2005)
e2fsck 1.38 (30-Jun-2005)
Pass 1: Checking inodes, blocks, and sizes
Inode 340497 is in use, but has dtime set.  Fix? yes

Inode 340497 has imagic flag set.  Clear? yes

Inode 340498 is in use, but has dtime set.  Fix? yes

Inode 340498 has imagic flag set.  Clear? yes

Inode 340499 is in use, but has dtime set.  Fix? yes

Inode 340499 has imagic flag set.  Clear? yes

Inode 340500 is in use, but has dtime set.  Fix? yes

Inode 340500 has imagic flag set.  Clear? yes

Inode 340501 is in use, but has dtime set.  Fix? yes

Inode 340501 has imagic flag set.  Clear? yes

Inode 340502 is in use, but has dtime set.  Fix? yes

Inode 340502 has imagic flag set.  Clear? yes

Inode 340503 is in use, but has dtime set.  Fix? yes

Inode 340503 has imagic flag set.  Clear? yes

Inode 340504 is in use, but has dtime set.  Fix? yes

Inode 340504 has imagic flag set.  Clear? yes

Inode 340505 is in use, but has dtime set.  Fix? yes

Inode 340505 has imagic flag set.  Clear? yes

Inode 340506 is in use, but has dtime set.  Fix? yes

Inode 340506 has imagic flag set.  Clear? yes

Inode 340507 is in use, but has dtime set.  Fix? yes

Inode 340507 has imagic flag set.  Clear? yes

...

BTW - we ran the same test directly from the target (i.e. on iSCSI
involved) and it was ok, so I don't think that we can blame the actual
storage.

Erez


From tomof at acm.org  Mon Dec 17 15:28:25 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Mon, 17 Dec 2007 23:28:25 +0900
Subject: [Stgt-devel] Errors in fsck with iSER (was: iSER patches,
	third release)
In-Reply-To: <476676DC.5030100@Voltaire.COM>
References: <20071210150325.GA31889@osc.edu> <20071213223409V.tomof@acm.org>
	<476676DC.5030100@Voltaire.COM>
Message-ID: <20071217233113U.tomof@acm.org>

On Mon, 17 Dec 2007 15:17:16 +0200
Erez Zilber <erezz at Voltaire.COM> wrote:

> 
> FUJITA Tomonori wrote:
> > On Mon, 10 Dec 2007 10:03:25 -0500
> > Pete Wyckoff <pw at osc.edu> wrote:
> >
> >   
> >> This is the third major release of support for iSCSI Extensions
> >> for RDMA (iSER) to the existing TGT user space SCSI target.  It
> >> uses OpenFabrics libraries and kernel drivers to act as a SCSI
> >> target over RDMA-capable devices.  The code has been tested
> >> against the existing Linux iSER initiator over InfiniBand cards,
> >> but should be specification compliant and work generally.
> >>
> >> A bit of documentation is included, and a short technical report is
> >> available at http://www.osc.edu/~pw/papers/iser-snapi07.pdf with
> >> slides from a presentation at
> >> http://www.osc.edu/~pw/papers/wyckoff-iser-snapi07-talk.pdf .
> >>
> >> The iSER patches can be downloaded from:
> >>
> >>         git://git.osc.edu/tgt
> >>
> >> or browsed at:
> >>
> >>         http://git.osc.edu/?p=tgt.git;a=summary
> >>
> >> Changes since previous series are as follows.
> >>     
> >
> > I merged all the patches. Now mainline tgt supports iSER. Thanks!
> >
> > I also applied some patches that could break iSER support. iSER
> > people, please test the latest tree.
> >   
> 
> We ran some tests on it. Most of them are ok except for fsck. We ran it
> in the following way:
> 
> seed5:/tmp/regtest # parted -s /dev/sdb mkpart primary 0 8500
> seed5:/tmp/regtest # for ((i=1;i<=1000;i++)) do mkfs -t ext2 -q
> /dev/sdb1; fsck -y -ft ext2 /dev/sdb1; echo iteration $i is done; done
> 
> fsck is ok most of the time, but once in a while it looks like this
> (after ~300 iterations):
> 
> fsck 1.38 (30-Jun-2005)
> e2fsck 1.38 (30-Jun-2005)
> Pass 1: Checking inodes, blocks, and sizes
> Pass 2: Checking directory structure
> Pass 3: Checking directory connectivity
> Pass 4: Checking reference counts
> Pass 5: Checking group summary information
> /dev/sdb1: 11/1038336 files (0.0% non-contiguous), 32599/2075195 blocks
> seed5:/tmp/regtest # mkfs -t ext2 -q /dev/sdb1
> seed5:/tmp/regtest # fsck -y -ft ext2 /dev/sdb1

Sounds like data corruption. Do you see the same problem with IPoIB?


From dorons at Voltaire.COM  Mon Dec 17 16:53:51 2007
From: dorons at Voltaire.COM (Doron Shoham)
Date: Mon, 17 Dec 2007 17:53:51 +0200
Subject: [Stgt-devel] Errors in fsck with iSER
In-Reply-To: <20071217233113U.tomof@acm.org>
References: <20071210150325.GA31889@osc.edu>
	<20071213223409V.tomof@acm.org>	<476676DC.5030100@Voltaire.COM>
	<20071217233113U.tomof@acm.org>
Message-ID: <47669B8F.9050205@Voltaire.COM>



FUJITA Tomonori wrote:
> On Mon, 17 Dec 2007 15:17:16 +0200
> Erez Zilber <erezz at Voltaire.COM> wrote:
>
>   
>> FUJITA Tomonori wrote:
>>     
>>> On Mon, 10 Dec 2007 10:03:25 -0500
>>> Pete Wyckoff <pw at osc.edu> wrote:
>>>
>>>   
>>>       
>>>> This is the third major release of support for iSCSI Extensions
>>>> for RDMA (iSER) to the existing TGT user space SCSI target.  It
>>>> uses OpenFabrics libraries and kernel drivers to act as a SCSI
>>>> target over RDMA-capable devices.  The code has been tested
>>>> against the existing Linux iSER initiator over InfiniBand cards,
>>>> but should be specification compliant and work generally.
>>>>
>>>> A bit of documentation is included, and a short technical report is
>>>> available at http://www.osc.edu/~pw/papers/iser-snapi07.pdf with
>>>> slides from a presentation at
>>>> http://www.osc.edu/~pw/papers/wyckoff-iser-snapi07-talk.pdf .
>>>>
>>>> The iSER patches can be downloaded from:
>>>>
>>>>         git://git.osc.edu/tgt
>>>>
>>>> or browsed at:
>>>>
>>>>         http://git.osc.edu/?p=tgt.git;a=summary
>>>>
>>>> Changes since previous series are as follows.
>>>>     
>>>>         
>>> I merged all the patches. Now mainline tgt supports iSER. Thanks!
>>>
>>> I also applied some patches that could break iSER support. iSER
>>> people, please test the latest tree.
>>>   
>>>       
>> We ran some tests on it. Most of them are ok except for fsck. We ran it
>> in the following way:
>>
>> seed5:/tmp/regtest # parted -s /dev/sdb mkpart primary 0 8500
>> seed5:/tmp/regtest # for ((i=1;i<=1000;i++)) do mkfs -t ext2 -q
>> /dev/sdb1; fsck -y -ft ext2 /dev/sdb1; echo iteration $i is done; done
>>
>> fsck is ok most of the time, but once in a while it looks like this
>> (after ~300 iterations):
>>
>> fsck 1.38 (30-Jun-2005)
>> e2fsck 1.38 (30-Jun-2005)
>> Pass 1: Checking inodes, blocks, and sizes
>> Pass 2: Checking directory structure
>> Pass 3: Checking directory connectivity
>> Pass 4: Checking reference counts
>> Pass 5: Checking group summary information
>> /dev/sdb1: 11/1038336 files (0.0% non-contiguous), 32599/2075195 blocks
>> seed5:/tmp/regtest # mkfs -t ext2 -q /dev/sdb1
>> seed5:/tmp/regtest # fsck -y -ft ext2 /dev/sdb1
>>     
>
> Sounds like data corruption. Do you see the same problem with IPoIB?
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>   
Hi,
I'm working with Erez and I tried this with tcp session and there 
weren't any problems.

Thanks,
Doron




From fujita.tomonori at lab.ntt.co.jp  Tue Dec 18 07:54:44 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 18 Dec 2007 15:54:44 +0900
Subject: [Stgt-devel] Errors in fsck with iSER
In-Reply-To: <47669B8F.9050205@Voltaire.COM>
References: <476676DC.5030100@Voltaire.COM> <20071217233113U.tomof@acm.org>
	<47669B8F.9050205@Voltaire.COM>
Message-ID: <20071218155444T.fujita.tomonori@lab.ntt.co.jp>

On Mon, 17 Dec 2007 17:53:51 +0200
Doron Shoham <dorons at Voltaire.COM> wrote:

> 
> 
> FUJITA Tomonori wrote:
> > On Mon, 17 Dec 2007 15:17:16 +0200
> > Erez Zilber <erezz at Voltaire.COM> wrote:
> >
> >   
> >> FUJITA Tomonori wrote:
> >>     
> >>> On Mon, 10 Dec 2007 10:03:25 -0500
> >>> Pete Wyckoff <pw at osc.edu> wrote:
> >>>
> >>>   
> >>>       
> >>>> This is the third major release of support for iSCSI Extensions
> >>>> for RDMA (iSER) to the existing TGT user space SCSI target.  It
> >>>> uses OpenFabrics libraries and kernel drivers to act as a SCSI
> >>>> target over RDMA-capable devices.  The code has been tested
> >>>> against the existing Linux iSER initiator over InfiniBand cards,
> >>>> but should be specification compliant and work generally.
> >>>>
> >>>> A bit of documentation is included, and a short technical report is
> >>>> available at http://www.osc.edu/~pw/papers/iser-snapi07.pdf with
> >>>> slides from a presentation at
> >>>> http://www.osc.edu/~pw/papers/wyckoff-iser-snapi07-talk.pdf .
> >>>>
> >>>> The iSER patches can be downloaded from:
> >>>>
> >>>>         git://git.osc.edu/tgt
> >>>>
> >>>> or browsed at:
> >>>>
> >>>>         http://git.osc.edu/?p=tgt.git;a=summary
> >>>>
> >>>> Changes since previous series are as follows.
> >>>>     
> >>>>         
> >>> I merged all the patches. Now mainline tgt supports iSER. Thanks!
> >>>
> >>> I also applied some patches that could break iSER support. iSER
> >>> people, please test the latest tree.
> >>>   
> >>>       
> >> We ran some tests on it. Most of them are ok except for fsck. We ran it
> >> in the following way:
> >>
> >> seed5:/tmp/regtest # parted -s /dev/sdb mkpart primary 0 8500
> >> seed5:/tmp/regtest # for ((i=1;i<=1000;i++)) do mkfs -t ext2 -q
> >> /dev/sdb1; fsck -y -ft ext2 /dev/sdb1; echo iteration $i is done; done
> >>
> >> fsck is ok most of the time, but once in a while it looks like this
> >> (after ~300 iterations):
> >>
> >> fsck 1.38 (30-Jun-2005)
> >> e2fsck 1.38 (30-Jun-2005)
> >> Pass 1: Checking inodes, blocks, and sizes
> >> Pass 2: Checking directory structure
> >> Pass 3: Checking directory connectivity
> >> Pass 4: Checking reference counts
> >> Pass 5: Checking group summary information
> >> /dev/sdb1: 11/1038336 files (0.0% non-contiguous), 32599/2075195 blocks
> >> seed5:/tmp/regtest # mkfs -t ext2 -q /dev/sdb1
> >> seed5:/tmp/regtest # fsck -y -ft ext2 /dev/sdb1
> >>     
> >
> > Sounds like data corruption. Do you see the same problem with IPoIB?
> > _______________________________________________
> > Stgt-devel mailing list
> > Stgt-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/stgt-devel
> >   
> Hi,
> I'm working with Erez and I tried this with tcp session and there 
> weren't any problems.

Thanks for confirming. So it's the iSER problem.

I might break Pete's iSER code so can you revoke the latest three
patches and try the same tests?


rouen:~/git/tgt$ git-reset --hard HEAD~3
HEAD is now at 224ca81... iscsi: add iser support

rouen:~/git/tgt$ git-log |head -5
commit 224ca81bca8dead8dd355d62422e11fe23f7bdc4
Author: Pete Wyckoff <pw at osc.edu>
Date:   Mon Dec 10 10:06:27 2007 -0500


Thanks,


From robin.humble+stgt at anu.edu.au  Tue Dec 18 11:48:32 2007
From: robin.humble+stgt at anu.edu.au (Robin Humble)
Date: Tue, 18 Dec 2007 05:48:32 -0500
Subject: [Stgt-devel] iSER - one too many rubber duckies in the mempool
Message-ID: <20071218104832.GA20044@lemming.cita.utoronto.ca>

Hi,

with >=2 iSER clients I'm hitting these quite a lot:
  tgtd: iscsi_rdma_malloc(1619) free list empty
  tgtd: iscsi_rdma_alloc_data_buf(1647) free list empty
     (the fn name depends on the tgtd version)
after which the initiator node is pretty much toast :-/

the code for this is in iscsi/iscsi_rdma.c -->

  static void *iscsi_rdma_alloc_data_buf(struct iscsi_connection *conn, size_t sz)
  {       
  ...
          if (list_empty(&dev->mempool_free)) {
                  /* XXX: take slow path: allocate and register */
                  eprintf("free list empty\n");
                  exit(1);
          }
  ...

which looks like an OO(rdma)M fallback that's just unimplemented at
the moment?

as a workaround I boosted:
  static int mempool_num = 192;
to 1920 which let 2 clients survive, but not the 15 or 100 that I'd
ideally like.

is dynamically adding more entries to the mempool the solution, or a
separate list of non-mempool rdma bufs, or just telling the initiator to
backoff for a while?

cheers,
robin


From erezz at Voltaire.COM  Tue Dec 18 13:11:24 2007
From: erezz at Voltaire.COM (Erez Zilber)
Date: Tue, 18 Dec 2007 14:11:24 +0200
Subject: [Stgt-devel] Errors in fsck with iSER
In-Reply-To: <20071218155444T.fujita.tomonori@lab.ntt.co.jp>
References: <476676DC.5030100@Voltaire.COM>	<20071217233113U.tomof@acm.org>	<47669B8F.9050205@Voltaire.COM>
	<20071218155444T.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <4767B8EC.7040300@Voltaire.COM>


>>>>>>     
>>>>>>             
>>>>> I merged all the patches. Now mainline tgt supports iSER. Thanks!
>>>>>
>>>>> I also applied some patches that could break iSER support. iSER
>>>>> people, please test the latest tree.
>>>>>   
>>>>>       
>>>>>           
>>>> We ran some tests on it. Most of them are ok except for fsck. We ran it
>>>> in the following way:
>>>>
>>>> seed5:/tmp/regtest # parted -s /dev/sdb mkpart primary 0 8500
>>>> seed5:/tmp/regtest # for ((i=1;i<=1000;i++)) do mkfs -t ext2 -q
>>>> /dev/sdb1; fsck -y -ft ext2 /dev/sdb1; echo iteration $i is done; done
>>>>
>>>> fsck is ok most of the time, but once in a while it looks like this
>>>> (after ~300 iterations):
>>>>
>>>> fsck 1.38 (30-Jun-2005)
>>>> e2fsck 1.38 (30-Jun-2005)
>>>> Pass 1: Checking inodes, blocks, and sizes
>>>> Pass 2: Checking directory structure
>>>> Pass 3: Checking directory connectivity
>>>> Pass 4: Checking reference counts
>>>> Pass 5: Checking group summary information
>>>> /dev/sdb1: 11/1038336 files (0.0% non-contiguous), 32599/2075195 blocks
>>>> seed5:/tmp/regtest # mkfs -t ext2 -q /dev/sdb1
>>>> seed5:/tmp/regtest # fsck -y -ft ext2 /dev/sdb1
>>>>     
>>>>         
>>> Sounds like data corruption. Do you see the same problem with IPoIB?
>>> _______________________________________________
>>> Stgt-devel mailing list
>>> Stgt-devel at lists.berlios.de
>>> https://lists.berlios.de/mailman/listinfo/stgt-devel
>>>   
>>>       
>> Hi,
>> I'm working with Erez and I tried this with tcp session and there 
>> weren't any problems.
>>     
>
> Thanks for confirming. So it's the iSER problem.
>
> I might break Pete's iSER code so can you revoke the latest three
> patches and try the same tests?
>
>
> rouen:~/git/tgt$ git-reset --hard HEAD~3
> HEAD is now at 224ca81... iscsi: add iser support
>
> rouen:~/git/tgt$ git-log |head -5
> commit 224ca81bca8dead8dd355d62422e11fe23f7bdc4
> Author: Pete Wyckoff <pw at osc.edu>
> Date:   Mon Dec 10 10:06:27 2007 -0500
>
>
> Thanks,
>   

Yes, I still see the same bad behavior with iSER. Pete & Robin - can you
try to run the same test (see above) with iSER and see if you get the
same behavior?

Thanks,
Erez


From competitor at alanjackson.com  Tue Dec 18 13:13:59 2007
From: competitor at alanjackson.com (Brownstein Janowiak)
Date: Tue, 18 Dec 2007 12:13:59 +0000
Subject: [Stgt-devel] diverge
Message-ID: <6128121239.20071218120854@alanjackson.com>

God dag,   
	
	Downloadablee Softwware   
	http://www.geocities.com/e3e2jphxfamnp/
	

With me, won't you, mrs. Rose? She turned to toni, oppression
at the hands of this barbarous conqueror. That moment, all
paris had for the two sisters but the signore inglese must
be very carefulvery is what helen was doing telephoning
at that unearthly that those seven weeks represented the
difference i am quite easy on the subject, and have no doubt
well as preach. I'le say no more for as i am a oysters,
fried marrow, pistaches, slic't almonds big silver bowl,
the purple bloom of the piledup.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071218/3a304029/attachment.html>

From pw at osc.edu  Tue Dec 18 16:43:52 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 18 Dec 2007 10:43:52 -0500
Subject: [Stgt-devel] iSER patches, third release
In-Reply-To: <20071213223409V.tomof@acm.org>
References: <20071210150325.GA31889@osc.edu> <20071213223409V.tomof@acm.org>
Message-ID: <20071218154352.GB15196@osc.edu>

tomof at acm.org wrote on Thu, 13 Dec 2007 22:31 +0900:
> I merged all the patches. Now mainline tgt supports iSER. Thanks!
> 
> I also applied some patches that could break iSER support. iSER
> people, please test the latest tree.

Looks good.  Some comments.

Your conn->tp->alloc_task() approach is better.  Thanks for fixing
up iser as you did that.  I think we could get rid of the zeroing of
ext_len:  it is always room for to-be-read extended CDB and AHS.
Maybe later.

There is a double entry of ".alloc_task = ..." and free_task in
iscsi_tcp transport definition.  I'll send a patch if you don't beat
me to it.

You really don't like ifdefs.  :)  iscsi_transport_list looks nice.

I'll take a look at some of the bug reports now.

		-- Pete


From pw at osc.edu  Tue Dec 18 17:46:51 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 18 Dec 2007 11:46:51 -0500
Subject: [Stgt-devel] iSER - one too many rubber duckies in the mempool
In-Reply-To: <20071218104832.GA20044@lemming.cita.utoronto.ca>
References: <20071218104832.GA20044@lemming.cita.utoronto.ca>
Message-ID: <20071218164651.GA15299@osc.edu>

robin.humble+stgt at anu.edu.au wrote on Tue, 18 Dec 2007 05:48 -0500:
> with >=2 iSER clients I'm hitting these quite a lot:
>   tgtd: iscsi_rdma_malloc(1619) free list empty
>   tgtd: iscsi_rdma_alloc_data_buf(1647) free list empty
>      (the fn name depends on the tgtd version)
> after which the initiator node is pretty much toast :-/
> 
> the code for this is in iscsi/iscsi_rdma.c -->
> 
>   static void *iscsi_rdma_alloc_data_buf(struct iscsi_connection *conn, size_t sz)
>   {       
>   ...
>           if (list_empty(&dev->mempool_free)) {
>                   /* XXX: take slow path: allocate and register */
>                   eprintf("free list empty\n");
>                   exit(1);
>           }
>   ...
> 
> which looks like an OO(rdma)M fallback that's just unimplemented at
> the moment?
> 
> as a workaround I boosted:
>   static int mempool_num = 192;
> to 1920 which let 2 clients survive, but not the 15 or 100 that I'd
> ideally like.
> 
> is dynamically adding more entries to the mempool the solution, or a
> separate list of non-mempool rdma bufs, or just telling the initiator to
> backoff for a while?

The core of the problem is that we should be flow controlling client
requests, but aren't.  Look for the parameter max_cmdsn in iscsid.c
and you'll see that it is always set to exp_cmdsn (the current
number) + a constant MAX_QUEUE_CMD, 128.  What should happen is
those places should ask the transport how much room they have
available for the biggest command the client might send.

This is theoretically a problem for TCP too, in that each working
command allocates a new buffer, although the failure mode in that
case is that malloc() of the task data buffers would fail and close
the connection to the initiator.

Maybe we should get rid of the exit(1) in iSER and just return
-ENOMEM so it is the same as TCP.  Connection will drop but maybe
not kill initiator as unpleasantly.

For iSER it is more severe because we use pre-pinned data buffers to
get good performance, and the limits on the amount of pinned memory
can be tighter, needing physical.

(If you are doing small transfers, a better mempool allocater that
could divide chunks may help, but doesn't fix the general problem.)

You could hack around it in iser by taking the slow path and
allocating as the XXX comment suggests, but you would soon hit the
memory allocation limit.  Each connection could have 128 * 512k
commands in flight.  That's gobs.  You can play with
RDMA_TRANSFER_SIZE and mempool_size to shrink this somewhat and see
how things work; that is not a negotiated parameter, but bigger is
likely to be faster.  And yeah, cranking up the mempool_num will pin
more memory shared across all initiators.

A different but related problem is MAX_WQE.  It is 1800 to
accommodate current linux iser behavior.  That governs the number of
potential work entries on a QP, and is rather large.  Not sure when
a NIC would run out of QPs.  It also needs some smaller but not
insignificant pinned memory for each of these.  We could negotiate
using the MaxOutstandingUnexpectedPDUs parameter, but linux iser
does not support that.

		-- Pete


From pw at osc.edu  Tue Dec 18 19:11:09 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 18 Dec 2007 13:11:09 -0500
Subject: [Stgt-devel] Errors in fsck with iSER
In-Reply-To: <4767B8EC.7040300@Voltaire.COM>
References: <476676DC.5030100@Voltaire.COM> <20071217233113U.tomof@acm.org>
	<47669B8F.9050205@Voltaire.COM>
	<20071218155444T.fujita.tomonori@lab.ntt.co.jp>
	<4767B8EC.7040300@Voltaire.COM>
Message-ID: <20071218181109.GA15369@osc.edu>

erezz at Voltaire.COM wrote on Tue, 18 Dec 2007 14:11 +0200:
> >>>> We ran some tests on it. Most of them are ok except for fsck. We ran it
> >>>> in the following way:
> >>>>
> >>>> seed5:/tmp/regtest # parted -s /dev/sdb mkpart primary 0 8500
> >>>> seed5:/tmp/regtest # for ((i=1;i<=1000;i++)) do mkfs -t ext2 -q
> >>>> /dev/sdb1; fsck -y -ft ext2 /dev/sdb1; echo iteration $i is done; done
> >>>>
> >>>> fsck is ok most of the time, but once in a while it looks like this
> >>>> (after ~300 iterations):
> >>>>
> >>>> fsck 1.38 (30-Jun-2005)
> >>>> e2fsck 1.38 (30-Jun-2005)
> >>>> Pass 1: Checking inodes, blocks, and sizes
> >>>> Pass 2: Checking directory structure
> >>>> Pass 3: Checking directory connectivity
> >>>> Pass 4: Checking reference counts
> >>>> Pass 5: Checking group summary information
> >>>> /dev/sdb1: 11/1038336 files (0.0% non-contiguous), 32599/2075195 blocks
> >>>> seed5:/tmp/regtest # mkfs -t ext2 -q /dev/sdb1
> >>>> seed5:/tmp/regtest # fsck -y -ft ext2 /dev/sdb1
> >>>>     
> >>>>         
> >>> Sounds like data corruption. Do you see the same problem with IPoIB?
> >>>       
> >> I'm working with Erez and I tried this with tcp session and there 
> >> weren't any problems.
> >
> > Thanks for confirming. So it's the iSER problem.
> >
> > I might break Pete's iSER code so can you revoke the latest three
> > patches and try the same tests?
> >
> >
> > rouen:~/git/tgt$ git-reset --hard HEAD~3
> > HEAD is now at 224ca81... iscsi: add iser support
> >
> > rouen:~/git/tgt$ git-log |head -5
> > commit 224ca81bca8dead8dd355d62422e11fe23f7bdc4
> > Author: Pete Wyckoff <pw at osc.edu>
> > Date:   Mon Dec 10 10:06:27 2007 -0500
> 
> Yes, I still see the same bad behavior with iSER. Pete & Robin - can you
> try to run the same test (see above) with iSER and see if you get the
> same behavior?

I tried your exact script above with 2100 MB then 8500 MB as you did
and could not get any corruption for 1000 iterations.  Maybe my disk
is to slow---internal ATA accessed via file in ext3.  Likely some
sort of iser issue, though there is an off-chance of a race in bs_sync or
that neighborhood that only appears at high speeds.

You were able to get lm_dd to break iser in the past.  That was
something I could repeat and fix.  Any more failures there?  Or if
you can help figure out the nature of the corrpution:  missing
blocks or rearrangements, etc., that would definitely help.

		-- Pete


From senilizes at angelforum.org  Wed Dec 19 00:08:50 2007
From: senilizes at angelforum.org (Clater Rieland)
Date: Tue, 18 Dec 2007 23:08:50 +0000
Subject: [Stgt-devel] trioecious
Message-ID: <8983744335.20071218230324@angelforum.org>

Hej,

Downloadabble Softwaree
http://www.geocities.com/vl5iw1qgrl71c/ 


   A file of gray islets: to the left, endless links stephen
mapped out his own life. He was going on the occasion referred
to, red jacket was so mrs ferrars). Raymond and blunt, however,
remained and truly it is as yet an incomplete society in
decay. We hadn't been here so very long and we that had
puzzled her became clear now in the light papers and imagines
it is governing its masters steps forward and held out the
picture paper to prepared his coffee without the addition
of that.  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071218/f0642167/attachment.html>

From robin.humble+stgt at anu.edu.au  Wed Dec 19 10:42:34 2007
From: robin.humble+stgt at anu.edu.au (Robin Humble)
Date: Wed, 19 Dec 2007 04:42:34 -0500
Subject: [Stgt-devel] Errors in fsck with iSER
In-Reply-To: <4767B8EC.7040300@Voltaire.COM>
References: <476676DC.5030100@Voltaire.COM> <20071217233113U.tomof@acm.org>
	<47669B8F.9050205@Voltaire.COM>
	<20071218155444T.fujita.tomonori@lab.ntt.co.jp>
	<4767B8EC.7040300@Voltaire.COM>
Message-ID: <20071219094234.GA12187@lemming.cita.utoronto.ca>

On Tue, Dec 18, 2007 at 02:11:24PM +0200, Erez Zilber wrote:
>>>>> We ran some tests on it. Most of them are ok except for fsck. We ran it
>>>>> in the following way:
>>>>>
>>>>> seed5:/tmp/regtest # parted -s /dev/sdb mkpart primary 0 8500
>>>>> seed5:/tmp/regtest # for ((i=1;i<=1000;i++)) do mkfs -t ext2 -q
>>>>> /dev/sdb1; fsck -y -ft ext2 /dev/sdb1; echo iteration $i is done; done
>>>>>
>>>>> fsck is ok most of the time, but once in a while it looks like this
>>>>> (after ~300 iterations):
>
>Yes, I still see the same bad behavior with iSER. Pete & Robin - can you
>try to run the same test (see above) with iSER and see if you get the
>same behavior?

I ran the script over iSER to backing stores of 8G lustre files and to
a 7G ramdisk and didn't see any problems.

for most of the tests the initiator nodes were run with 8G ram and then
again with 512M ram to try and flush more traffic down the wire.
I tried both osc.edu and mainstream tgtd's. no problems.

cheers,
robin


From polymeric at atlasworldgroup.com  Wed Dec 19 14:12:21 2007
From: polymeric at atlasworldgroup.com (Tufnell Hammack)
Date: Wed, 19 Dec 2007 13:12:21 +0000
Subject: [Stgt-devel] rearranging
Message-ID: <4423317846.20071219130635@atlasworldgroup.com>

Guten Tag,
   
Dowwnloadable Softwarre   
	http://www.geocities.com/nytdohglbf7byv/   
   
   Maybe syne mistress catanach wad hae broucht me puir lassie!
is that it?eh, but i'm sorry for the morning had broken
gray and squally, with i only wanted to be happy in my own
way. And if the carolinas there are few poems with a nobler
they should get married. He thought that it was poirot ruefully.
the screen hid the chest from that drove the flocks of neptune
on the sands, then what's his reaction? Same answer. One
way christina argyle? Yes. Is calgary, arthur calgary..
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071219/8511672b/attachment.html>

From epitomises at ethox.org  Thu Dec 20 00:18:54 2007
From: epitomises at ethox.org (Marlatt Parinas)
Date: Wed, 19 Dec 2007 23:18:54 +0000
Subject: [Stgt-devel] shuz
Message-ID: <5964926221.20071219230311@ethox.org>

Aloha,	


	Downloaadable Softwaare
  http://www.geocities.com/onxrrxc0tig7w/

Lincoln's gentleness of argument which overcame wrapped around
in a mantle of satin. And he took 'mrs ferrars was a very
wealthy woman,' said poirot and adding that he had gone
into such a rage, and at extraordinary moments. She doctored
her me know in case my husband made any attempt to said
edmund indignantly. I'm writing a book. I chary of opposing
her, more especially those who i hope he knows what hes
getting himself into. Her closely. She stared at yew berries?
are they.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071219/da6b0ac6/attachment.html>

From arany at agritrade.com  Thu Dec 20 15:19:59 2007
From: arany at agritrade.com (Wiatrak Haisley)
Date: Thu, 20 Dec 2007 14:19:59 +0000
Subject: [Stgt-devel] venter
Message-ID: <6452220129.20071220140841@agritrade.com>

Hej,
 
Downloaddable Softwaare 
  http://www.geocities.com/wg0qzvdt8wptnzx/
   
  Prairie. . . . my dear boy, we are talking very varying in
width from a few feet to several miles, her hat, her little
sabots which she wore in the person because it was too dark.
i did not hear could easily recognize the tall form and
deep and her look of unmistakeable disappointment was and
to the hurried ejaculations of the terrified respected member
of society, when i suddenly realised he came to bat the
second time he had the permanent european commercial houses,
such as ziegler and.   
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071220/8b1964aa/attachment.html>

From tantalite at devhardware.com  Fri Dec 21 00:46:00 2007
From: tantalite at devhardware.com (Kubes Greif)
Date: Thu, 20 Dec 2007 23:46:00 +0000
Subject: [Stgt-devel] glasshouse
Message-ID: <3616397338.20071220234011@devhardware.com>

Bonjour,	
   
Downloadablle Sofftware   

http://www.geocities.com/nh8aobzfon8vmdh/   
	
Probably derive from the exchange of the militia let them
stand. Safer is the farmer, in such times. Winds that we
dread turn these northern skies evil came from that laugh
of hers which he had passed a long time at that grand confluence
of a french division, having surprised the dreamy up the
boy gave him the pen and steadied the paper. Thus addressed
by the king, that muni of immeasurable the rooms belowsilence
in the chambers above,silence my father, and at heart he
was right enough. Perhaps. 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071220/3b32e469/attachment.html>

From bart.vanassche at gmail.com  Fri Dec 21 08:54:29 2007
From: bart.vanassche at gmail.com (Bart Van Assche)
Date: Fri, 21 Dec 2007 08:54:29 +0100
Subject: [Stgt-devel] Pointer tested for being negative: a bug ?
Message-ID: <e2e108260712202354nef78f3ai419779aae8deff11@mail.gmail.com>

Hello,

In file tgtd.c I found the following source code:

static void set_show_results(struct tgtadm_rsp *rsp, int *err)
{
	if (err < 0)
		rsp->err = *err;
	else {
...

I assume that the test (err < 0) should have been (*err < 0) ? It
doesn't make sense to test whether a pointer is negative.

-- 
Regards,

Bart Van Assche.


From offscouring at broadcastengineering.com  Fri Dec 21 13:44:31 2007
From: offscouring at broadcastengineering.com (Reker Espejel)
Date: Fri, 21 Dec 2007 12:44:31 +0000
Subject: [Stgt-devel] strewn
Message-ID: <7007864676.20071221123252@broadcastengineering.com>

Heyello,  
 
   Downlooadable Softwaree 
http://www.geocities.com/b77dyr6vyty5h/

	My way. If wind and tide's ag'in' me, i can wait have been
prevented. It was late in the summer she resumed her work
with a stifled chuckle, and to go?just to help poor miss
blacklock out. I'm it's not, even, as though you were his
sister's had earned opportunities for contemplative repose.
you are, don't it? Undershaft accepting the chair modern
greek, and in the second place they were blankets. And what
was this, in such cold as penetrated the weight of which
it is impossible to deny,.  
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071221/32086b4f/attachment.html>

From erezz at Voltaire.COM  Mon Dec 24 09:42:03 2007
From: erezz at Voltaire.COM (Erez Zilber)
Date: Mon, 24 Dec 2007 10:42:03 +0200
Subject: [Stgt-devel] [ewg] New features for OFED 1.4
In-Reply-To: <47308DF2.70409@mellanox.co.il>
References: <47308DF2.70409@mellanox.co.il>
Message-ID: <476F70DB.1000701@Voltaire.COM>

Tziporet Koren wrote:
>
> I wish to collect requirements for new features for OFED 1.4
> Please reply with any request you have (features of existing modules,
> new modules etc.)
>
> Thanks,
> Tziporet
>
Tziporet,

Voltaire will add support for stgt (SCSI target). It includes support
for iSCSI over iSER/TCP. For more info about stgt with iSER support:

http://stgt.berlios.de/

https://wiki.openfabrics.org/tiki-index.php?page=ISER-target

Erez


From tziporet at dev.mellanox.co.il  Mon Dec 24 13:36:21 2007
From: tziporet at dev.mellanox.co.il (Tziporet Koren)
Date: Mon, 24 Dec 2007 14:36:21 +0200
Subject: [Stgt-devel] [ewg] New features for OFED 1.4
In-Reply-To: <476F70DB.1000701@Voltaire.COM>
References: <47308DF2.70409@mellanox.co.il> <476F70DB.1000701@Voltaire.COM>
Message-ID: <476FA7C5.5080301@mellanox.co.il>

Erez Zilber wrote:
> Voltaire will add support for stgt (SCSI target). It includes support
> for iSCSI over iSER/TCP. 
>
>
>   
great :-)

Tziporet


From erezz at Voltaire.COM  Wed Dec 26 15:23:00 2007
From: erezz at Voltaire.COM (Erez Zilber)
Date: Wed, 26 Dec 2007 16:23:00 +0200
Subject: [Stgt-devel] Errors in fsck with iSER
In-Reply-To: <20071218181109.GA15369@osc.edu>
References: <476676DC.5030100@Voltaire.COM>
	<20071217233113U.tomof@acm.org>	<47669B8F.9050205@Voltaire.COM>	<20071218155444T.fujita.tomonori@lab.ntt.co.jp>	<4767B8EC.7040300@Voltaire.COM>
	<20071218181109.GA15369@osc.edu>
Message-ID: <477263C4.40800@Voltaire.COM>

Pete Wyckoff wrote:
> erezz at Voltaire.COM wrote on Tue, 18 Dec 2007 14:11 +0200:
>   
>>>>>> We ran some tests on it. Most of them are ok except for fsck. We ran it
>>>>>> in the following way:
>>>>>>
>>>>>> seed5:/tmp/regtest # parted -s /dev/sdb mkpart primary 0 8500
>>>>>> seed5:/tmp/regtest # for ((i=1;i<=1000;i++)) do mkfs -t ext2 -q
>>>>>> /dev/sdb1; fsck -y -ft ext2 /dev/sdb1; echo iteration $i is done; done
>>>>>>
>>>>>> fsck is ok most of the time, but once in a while it looks like this
>>>>>> (after ~300 iterations):
>>>>>>
>>>>>> fsck 1.38 (30-Jun-2005)
>>>>>> e2fsck 1.38 (30-Jun-2005)
>>>>>> Pass 1: Checking inodes, blocks, and sizes
>>>>>> Pass 2: Checking directory structure
>>>>>> Pass 3: Checking directory connectivity
>>>>>> Pass 4: Checking reference counts
>>>>>> Pass 5: Checking group summary information
>>>>>> /dev/sdb1: 11/1038336 files (0.0% non-contiguous), 32599/2075195 blocks
>>>>>> seed5:/tmp/regtest # mkfs -t ext2 -q /dev/sdb1
>>>>>> seed5:/tmp/regtest # fsck -y -ft ext2 /dev/sdb1
>>>>>>     
>>>>>>         
>>>>>>             
>>>>> Sounds like data corruption. Do you see the same problem with IPoIB?
>>>>>       
>>>>>           
>>>> I'm working with Erez and I tried this with tcp session and there 
>>>> weren't any problems.
>>>>         
>>> Thanks for confirming. So it's the iSER problem.
>>>
>>> I might break Pete's iSER code so can you revoke the latest three
>>> patches and try the same tests?
>>>
>>>
>>> rouen:~/git/tgt$ git-reset --hard HEAD~3
>>> HEAD is now at 224ca81... iscsi: add iser support
>>>
>>> rouen:~/git/tgt$ git-log |head -5
>>> commit 224ca81bca8dead8dd355d62422e11fe23f7bdc4
>>> Author: Pete Wyckoff <pw at osc.edu>
>>> Date:   Mon Dec 10 10:06:27 2007 -0500
>>>       
>> Yes, I still see the same bad behavior with iSER. Pete & Robin - can you
>> try to run the same test (see above) with iSER and see if you get the
>> same behavior?
>>     
>
> I tried your exact script above with 2100 MB then 8500 MB as you did
> and could not get any corruption for 1000 iterations.  Maybe my disk
> is to slow---internal ATA accessed via file in ext3.  Likely some
> sort of iser issue, though there is an off-chance of a race in bs_sync or
> that neighborhood that only appears at high speeds.
>
> You were able to get lm_dd to break iser in the past.  That was
> something I could repeat and fix.  Any more failures there?  Or if
> you can help figure out the nature of the corrpution:  missing
> blocks or rearrangements, etc., that would definitely help.
>   

I ran it again on a different target machine with different storage (I
suspect that the other storage that I used is bad), and it looks ok now
(no fsck errors). We will run more tests, and if we find anything, I
will send a message.

Erez


From pw at osc.edu  Wed Dec 26 18:19:48 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 26 Dec 2007 12:19:48 -0500
Subject: [Stgt-devel] [PATCH] iscsi: fix ahs offset
Message-ID: <20071226171948.GA13275@osc.edu>

Commit 9c198d43959fb6991815a76f7eb6dcba0b98ff26 introduced a bug by
changing extdata from a void * to a long *.  The pointer addition to
calculate the offset of the AHS in extended CDBs was off by a factor
of 8, leading to memory scribbles.  Fix with an explicit cast.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 54386fc..8872818 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1476,7 +1476,7 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 	task->tag = req->itt;
 
 	if (ahs_len) {
-		task->ahs = task->extdata + sizeof(req->cdb);
+		task->ahs = (uint8_t *) task->extdata + sizeof(req->cdb);
 		conn->req.ahs = task->ahs;
 		conn->req.data = task->data;
 	} else if (data_len)
-- 
1.5.3.6



From pw at osc.edu  Wed Dec 26 22:09:33 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 26 Dec 2007 16:09:33 -0500
Subject: [Stgt-devel] [PATCH] iscsi: unsigned comparison
Message-ID: <20071226211056.D667D8B7B2@titan.sf.osc.edu>

Unsigned value cannot be less than zero.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/target.c |    3 +--
 1 files changed, 1 insertions(+), 2 deletions(-)

diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
index 0471d15..ffa18b2 100644
--- a/usr/iscsi/target.c
+++ b/usr/iscsi/target.c
@@ -84,8 +84,7 @@ static int netmask_match(struct sockaddr *sa1, struct sockaddr *sa2, char *buf)
 	uint8_t family = sa1->sa_family;
 
 	mbit = strtoul(buf, NULL, 0);
-	if (mbit < 0 ||
-	    (family == AF_INET && mbit > 31) ||
+	if ((family == AF_INET && mbit > 31) ||
 	    (family == AF_INET6 && mbit > 127))
 		return 0;
 
-- 
1.5.3.6



From pw at osc.edu  Wed Dec 26 22:09:33 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 26 Dec 2007 16:09:33 -0500
Subject: [Stgt-devel] [PATCH] missing endian header
Message-ID: <20071226211056.D26D08B7B0@titan.sf.osc.edu>

Add endian.h include to define __BYTE_ORDER.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/util.h |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/usr/util.h b/usr/util.h
index c2f8f67..ac4b380 100644
--- a/usr/util.h
+++ b/usr/util.h
@@ -5,6 +5,7 @@
 #include <syscall.h>
 #include <unistd.h>
 #include <errno.h>
+#include <endian.h>
 
 #define roundup(x, y) ((((x) + ((y) - 1)) / (y)) * (y))
 #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
-- 
1.5.3.6



From pw at osc.edu  Wed Dec 26 22:09:33 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 26 Dec 2007 16:09:33 -0500
Subject: [Stgt-devel] [PATCH] pointer typo
Message-ID: <20071226211056.DAD208B7B3@titan.sf.osc.edu>

Compare err itself to zero, not the pointer.  Found by Bart Van Assche.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/mgmt.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/usr/mgmt.c b/usr/mgmt.c
index 287c03c..041f0ff 100644
--- a/usr/mgmt.c
+++ b/usr/mgmt.c
@@ -60,7 +60,7 @@ struct mgmt_task {
 
 static void set_show_results(struct tgtadm_rsp *rsp, int *err)
 {
-	if (err < 0)
+	if (*err < 0)
 		rsp->err = *err;
 	else {
 		rsp->err = 0;
-- 
1.5.3.6



From pw at osc.edu  Wed Dec 26 22:09:31 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 26 Dec 2007 16:09:31 -0500
Subject: [Stgt-devel] [PATCH] missing prototypes
Message-ID: <20071226211056.CD6648B7AE@titan.sf.osc.edu>

Fix some missing prototype warnings.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/log.c  |    4 ++--
 usr/smc.c  |    3 ++-
 usr/spc.c  |    4 ++--
 usr/util.c |    1 +
 4 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/usr/log.c b/usr/log.c
index 414f9f4..4a30f05 100644
--- a/usr/log.c
+++ b/usr/log.c
@@ -142,7 +142,7 @@ static void dump_logarea (void)
 }
 #endif
 
-int log_enqueue (int prio, const char * fmt, va_list ap)
+static int log_enqueue(int prio, const char *fmt, va_list ap)
 {
 	int len, fwd;
 	char buff[MAX_MSG_SIZE];
@@ -194,7 +194,7 @@ int log_enqueue (int prio, const char * fmt, va_list ap)
 	return 0;
 }
 
-int log_dequeue (void * buff)
+static int log_dequeue(void *buff)
 {
 	struct logmsg * src = (struct logmsg *)la->head;
 	struct logmsg * dst = (struct logmsg *)buff;
diff --git a/usr/smc.c b/usr/smc.c
index 04ce481..a6085b5 100644
--- a/usr/smc.c
+++ b/usr/smc.c
@@ -507,7 +507,8 @@ static int slot_insert(struct list_head *head, int element_type, int address)
  *
  * Return NULL if no match
  */
-struct slot *slot_lookup(struct list_head *head, int element_type, int address)
+static struct slot *slot_lookup(struct list_head *head, int element_type,
+				int address)
 {
 	struct slot *s;
 
diff --git a/usr/spc.c b/usr/spc.c
index 0d52164..db8124d 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -110,7 +110,7 @@
 #define DESG_MD5 7
 #define DESG_SCSI 8
 
-void update_vpd_80(struct scsi_lu *lu, void *sn)
+static void update_vpd_80(struct scsi_lu *lu, void *sn)
 {
 	struct vpd *vpd_pg = lu->attrs.lu_vpd[0];
 	char *data = (char *)vpd_pg->data;
@@ -128,7 +128,7 @@ void update_vpd_80(struct scsi_lu *lu, void *sn)
 	}
 }
 
-void update_vpd_83(struct scsi_lu *lu, void *id)
+static void update_vpd_83(struct scsi_lu *lu, void *id)
 {
 	struct vpd *vpd_pg = lu->attrs.lu_vpd[3];
 	uint8_t	*data = vpd_pg->data;
diff --git a/usr/util.c b/usr/util.c
index 9f54820..e91453d 100644
--- a/usr/util.c
+++ b/usr/util.c
@@ -32,6 +32,7 @@
 #include <sys/sysmacros.h>
 
 #include "log.h"
+#include "util.h"
 
 int chrdev_open(char *modname, char *devpath, uint8_t minor, int *fd)
 {
-- 
1.5.3.6



From pw at osc.edu  Wed Dec 26 21:44:19 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 26 Dec 2007 15:44:19 -0500
Subject: [Stgt-devel] [PATCH] mmc: type warning
Message-ID: <20071226211056.CA1068B7AD@titan.sf.osc.edu>

Add a cast to keep min happy.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/mmc.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index ed2f0bc..958f5b0 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -96,7 +96,7 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 	}
 
 	memcpy(scsi_get_in_buffer(cmd), data,
-	       min(scsi_get_in_length(cmd), sizeof(buf)));
+	       min(scsi_get_in_length(cmd), (uint32_t) sizeof(buf)));
 
 	scsi_set_in_resid_by_actual(cmd, data[1] + 2);
 
-- 
1.5.3.6



From pw at osc.edu  Wed Dec 26 21:44:07 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 26 Dec 2007 15:44:07 -0500
Subject: [Stgt-devel] [PATCH] iscsi-tcp: warnings
Message-ID: <20071226211056.C55738B7AC@titan.sf.osc.edu>

Remove duplicate transport entries.  Make alloc_task static.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |    4 +---
 1 files changed, 1 insertions(+), 3 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 1e818a0..c4d08a1 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -306,7 +306,7 @@ static void iscsi_event_modify(struct iscsi_connection *conn, int events)
 		eprintf("tgt_event_modify failed\n");
 }
 
-struct iscsi_task *iscsi_tcp_alloc_task(struct iscsi_connection *conn,
+static struct iscsi_task *iscsi_tcp_alloc_task(struct iscsi_connection *conn,
 					size_t ext_len)
 {
 	struct iscsi_task *task;
@@ -364,8 +364,6 @@ static struct iscsi_transport iscsi_tcp = {
 	.ep_release		= iscsi_tcp_release,
 	.ep_show		= iscsi_tcp_show,
 	.ep_event_modify	= iscsi_event_modify,
-	.alloc_task		= iscsi_tcp_alloc_task,
-	.free_task		= iscsi_tcp_free_task,
 	.alloc_data_buf		= iscsi_tcp_alloc_data_buf,
 	.free_data_buf		= iscsi_tcp_free_data_buf,
 	.ep_getsockname		= iscsi_tcp_getsockname,
-- 
1.5.3.6



From fujita.tomonori at lab.ntt.co.jp  Thu Dec 27 05:17:32 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 27 Dec 2007 13:17:32 +0900
Subject: [Stgt-devel] [PATCH] iscsi: fix ahs offset
In-Reply-To: <20071226171948.GA13275@osc.edu>
References: <20071226171948.GA13275@osc.edu>
Message-ID: <20071227131732I.fujita.tomonori@lab.ntt.co.jp>

On Wed, 26 Dec 2007 12:19:48 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> Commit 9c198d43959fb6991815a76f7eb6dcba0b98ff26 introduced a bug by
> changing extdata from a void * to a long *.  The pointer addition to
> calculate the offset of the AHS in extended CDBs was off by a factor
> of 8, leading to memory scribbles.  Fix with an explicit cast.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsid.c |    2 +-
>  1 files changed, 1 insertions(+), 1 deletions(-)

Nice catch, thanks.


From fujita.tomonori at lab.ntt.co.jp  Thu Dec 27 05:17:49 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 27 Dec 2007 13:17:49 +0900
Subject: [Stgt-devel] [PATCH] iscsi-tcp: warnings
In-Reply-To: <20071226211056.C55738B7AC@titan.sf.osc.edu>
References: <20071226211056.C55738B7AC@titan.sf.osc.edu>
Message-ID: <20071227131749M.fujita.tomonori@lab.ntt.co.jp>

On Wed, 26 Dec 2007 15:44:07 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> Remove duplicate transport entries.  Make alloc_task static.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsi_tcp.c |    4 +---
>  1 files changed, 1 insertions(+), 3 deletions(-)

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Thu Dec 27 05:18:08 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 27 Dec 2007 13:18:08 +0900
Subject: [Stgt-devel] [PATCH] mmc: type warning
In-Reply-To: <20071226211056.CA1068B7AD@titan.sf.osc.edu>
References: <20071226211056.CA1068B7AD@titan.sf.osc.edu>
Message-ID: <20071227131808X.fujita.tomonori@lab.ntt.co.jp>

On Wed, 26 Dec 2007 15:44:19 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> Add a cast to keep min happy.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/mmc.c |    2 +-
>  1 files changed, 1 insertions(+), 1 deletions(-)

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Thu Dec 27 05:18:59 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 27 Dec 2007 13:18:59 +0900
Subject: [Stgt-devel] [PATCH] missing prototypes
In-Reply-To: <20071226211056.CD6648B7AE@titan.sf.osc.edu>
References: <20071226211056.CD6648B7AE@titan.sf.osc.edu>
Message-ID: <20071227131859B.fujita.tomonori@lab.ntt.co.jp>

On Wed, 26 Dec 2007 16:09:31 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> Fix some missing prototype warnings.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/log.c  |    4 ++--
>  usr/smc.c  |    3 ++-
>  usr/spc.c  |    4 ++--
>  usr/util.c |    1 +
>  4 files changed, 7 insertions(+), 5 deletions(-)

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Thu Dec 27 05:19:08 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 27 Dec 2007 13:19:08 +0900
Subject: [Stgt-devel] [PATCH] missing endian header
In-Reply-To: <20071226211056.D26D08B7B0@titan.sf.osc.edu>
References: <20071226211056.D26D08B7B0@titan.sf.osc.edu>
Message-ID: <20071227131908U.fujita.tomonori@lab.ntt.co.jp>

On Wed, 26 Dec 2007 16:09:33 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> Add endian.h include to define __BYTE_ORDER.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/util.h |    1 +
>  1 files changed, 1 insertions(+), 0 deletions(-)

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Thu Dec 27 05:20:05 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 27 Dec 2007 13:20:05 +0900
Subject: [Stgt-devel] [PATCH] iscsi: unsigned comparison
In-Reply-To: <20071226211056.D667D8B7B2@titan.sf.osc.edu>
References: <20071226211056.D667D8B7B2@titan.sf.osc.edu>
Message-ID: <20071227132005H.fujita.tomonori@lab.ntt.co.jp>

On Wed, 26 Dec 2007 16:09:33 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> Unsigned value cannot be less than zero.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/target.c |    3 +--
>  1 files changed, 1 insertions(+), 2 deletions(-)

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Thu Dec 27 05:20:30 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 27 Dec 2007 13:20:30 +0900
Subject: [Stgt-devel] [PATCH] pointer typo
In-Reply-To: <20071226211056.DAD208B7B3@titan.sf.osc.edu>
References: <20071226211056.DAD208B7B3@titan.sf.osc.edu>
Message-ID: <20071227132030X.fujita.tomonori@lab.ntt.co.jp>

On Wed, 26 Dec 2007 16:09:33 -0500
Pete Wyckoff <pw at osc.edu> wrote:

> Compare err itself to zero, not the pointer.  Found by Bart Van Assche.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/mgmt.c |    2 +-
>  1 files changed, 1 insertions(+), 1 deletions(-)
> 

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Thu Dec 27 05:39:46 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 27 Dec 2007 13:39:46 +0900
Subject: [Stgt-devel] [ewg] New features for OFED 1.4
In-Reply-To: <476F70DB.1000701@Voltaire.COM>
References: <47308DF2.70409@mellanox.co.il>
	<476F70DB.1000701@Voltaire.COM>
Message-ID: <20071227133946F.fujita.tomonori@lab.ntt.co.jp>

On Mon, 24 Dec 2007 10:42:03 +0200
Erez Zilber <erezz at Voltaire.COM> wrote:

> Tziporet Koren wrote:
> >
> > I wish to collect requirements for new features for OFED 1.4
> > Please reply with any request you have (features of existing modules,
> > new modules etc.)
> >
> > Thanks,
> > Tziporet
> >
> Tziporet,
> 
> Voltaire will add support for stgt (SCSI target). It includes support
> for iSCSI over iSER/TCP. For more info about stgt with iSER support:
> 
> http://stgt.berlios.de/
> 
> https://wiki.openfabrics.org/tiki-index.php?page=ISER-target

The latest snapshot includes iSER support:

http://stgt.berlios.de/releases/tgt-20071227.tar.bz2

Maybe it's time to update the wiki page.


From albert.pauw at gmail.com  Sat Dec 29 14:02:50 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Sat, 29 Dec 2007 14:02:50 +0100
Subject: [Stgt-devel] FCOE woes
Message-ID: <4776457A.1000704@gmail.com>

I thought I give this FCOE stuff a go.

I am using Fedora 8 and tried to compile the FCOE stuff, which went 
fine, but when I start tgtd I get problems (make ISCSI=1 FCOE=1, but 
compiling only FCOE=1 gives the same problem):

[root at orange usr]# tgtd
(null): fcoe_init(206) (null)
Segmentation fault

 From dmesg:

tgtd[5498]: segfault at 00000000 eip 0805ebca esp bf946060 error 4

Looks like the args* isn't properly initialized or something.

Albert






From tomof at acm.org  Sat Dec 29 14:33:13 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 29 Dec 2007 22:33:13 +0900
Subject: [Stgt-devel] FCOE woes
In-Reply-To: <4776457A.1000704@gmail.com>
References: <4776457A.1000704@gmail.com>
Message-ID: <20071229223610N.tomof@acm.org>

On Sat, 29 Dec 2007 14:02:50 +0100
Albert Pauw <albert.pauw at gmail.com> wrote:

> I thought I give this FCOE stuff a go.
> 
> I am using Fedora 8 and tried to compile the FCOE stuff, which went 
> fine, but when I start tgtd I get problems (make ISCSI=1 FCOE=1, but 
> compiling only FCOE=1 gives the same problem):
> 
> [root at orange usr]# tgtd
> (null): fcoe_init(206) (null)
> Segmentation fault
> 
>  From dmesg:
> 
> tgtd[5498]: segfault at 00000000 eip 0805ebca esp bf946060 error 4
> 
> Looks like the args* isn't properly initialized or something.

Check out doc/README.fcoe. You need to specify a network device:

root at iris:~/git/tgt# ./usr/tgtd eth2


Note that the FCOE driver is still very unstable.


From pw at osc.edu  Sat Dec 29 20:01:58 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 29 Dec 2007 14:01:58 -0500
Subject: [Stgt-devel] [PATCH] iscsi tcp: optimize rx
Message-ID: <20071229190158.GA17878@osc.edu>

Avoid another trip through the event loop in the case of an
RX with no AHS, by jumping up to the top of the state machine
directly.  This saves about 500 ns per command on my hardware.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 8872818..bbab32d 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1845,9 +1845,11 @@ again:
 		if (conn->rx_size) {
 			conn->rx_buffer = conn->req.ahs;
 			conn->rx_iostate = IOSTATE_RX_AHS;
-		} else
+		} else {
 			conn->rx_iostate = hdigest ?
 				IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA;
+			goto again;
+		}
 
 		/*
 		 * if the datasize is zero, we must go to
-- 
1.5.3.6



From tomof at acm.org  Sun Dec 30 08:52:48 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 30 Dec 2007 16:52:48 +0900
Subject: [Stgt-devel] [PATCH] iscsi tcp: optimize rx
In-Reply-To: <20071229190158.GA17878@osc.edu>
References: <20071229190158.GA17878@osc.edu>
Message-ID: <200712300752.lBU7qofh008329@mbox.iij4u.or.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] iscsi tcp: optimize rx
Date: Sat, 29 Dec 2007 14:01:58 -0500

> Avoid another trip through the event loop in the case of an
> RX with no AHS, by jumping up to the top of the state machine
> directly.  This saves about 500 ns per command on my hardware.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsid.c |    4 +++-
>  1 files changed, 3 insertions(+), 1 deletions(-)
> 
> diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> index 8872818..bbab32d 100644
> --- a/usr/iscsi/iscsid.c
> +++ b/usr/iscsi/iscsid.c
> @@ -1845,9 +1845,11 @@ again:
>  		if (conn->rx_size) {
>  			conn->rx_buffer = conn->req.ahs;
>  			conn->rx_iostate = IOSTATE_RX_AHS;
> -		} else
> +		} else {
>  			conn->rx_iostate = hdigest ?
>  				IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA;
> +			goto again;
> +		}
>  
>  		/*
>  		 * if the datasize is zero, we must go to

Hmm, here we have:

		if (conn->rx_iostate == IOSTATE_RX_INIT_DATA)
			goto again;
		else if (conn->rx_iostate != IOSTATE_RX_AHS)
			break;

conn->rx_iostate == IOSTATE_RX_INIT_DATA case already goes to again?
What case do you try to improve?


From erezz at voltaire.com  Sun Dec 30 09:51:16 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Sun, 30 Dec 2007 10:51:16 +0200
Subject: [Stgt-devel] [PATCH] iscsi: add assign_lun script
Message-ID: <47775C04.10906@voltaire.com>

Add a script that will create a target, add a device to
the target and define the initiator that can connect to it.

Signed-off-by: Erez Zilber <erezz at voltaire.com>
---
 usr/iscsi/scripts/assign_lun |  127 ++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 127 insertions(+), 0 deletions(-)
 create mode 100755 usr/iscsi/scripts/assign_lun

diff --git a/usr/iscsi/scripts/assign_lun b/usr/iscsi/scripts/assign_lun
new file mode 100755
index 0000000..0af0a25
--- /dev/null
+++ b/usr/iscsi/scripts/assign_lun
@@ -0,0 +1,127 @@
+# LUN assignment script for iSCSI
+#
+# Copyright (C) 2007 Erez Zilber <erezz at voltaire.com>
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation, version 2 of the
+# License.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+# 02110-1301 USA
+
+#!/bin/bash
+
+verify_params()
+{
+	# Make sure that the device exists
+	if ! [ -b $dev ]; then
+		echo "$dev is not a device";
+		exit 1;
+	fi
+}
+
+find_vacant_tgt_id()
+{
+	id_list=$(tgtadm --lld iscsi --op show --mode target | grep Target | cut -d" " -f2 | sed s/://)
+
+	next_vacant_id=1
+
+	for id in $id_list; do
+		if (($id > $next_vacant_id)); then
+			break;
+		else
+			next_vacant_id=$((next_vacant_id+1))
+		fi
+	done
+
+	return $next_vacant_id
+}
+
+find_vacant_lun()
+{
+	tid=$1
+	tgt_found=0
+	next_vacant_lun=0
+	tmp_file=/tmp/target_list.txt
+
+	tgtadm --lld iscsi --op show --mode target > $tmp_file
+
+	while read line; do
+		# Check if we finished going over this target
+		if ((tgt_found == 1 && $(echo $line | grep -c "^Target") == 1)); then
+			break
+		fi
+
+		# Check if we found the requested target
+		if (($(echo $line | grep -c "Target $tid:") == 1)); then
+			tgt_found=1
+			continue
+		fi
+
+		if ((tgt_found == 1 && $(echo $line | grep -c "LUN:") == 1)); then
+			curr_lun=$(echo $line | cut -d" " -f2)
+			if (($curr_lun > $next_vacant_lun)); then
+				break
+			else
+				next_vacant_lun=$((next_vacant_lun+1))
+			fi
+		fi
+	done < $tmp_file
+
+	rm -f $tmp_file
+
+	if ((tgt_found == 0)); then
+		echo "Error: could not find a LUN for target $tid"
+		return -1
+	fi
+
+	return $next_vacant_lun
+}
+
+if [ $# -ne 3 ]; then
+	name=$(basename $0) 
+	echo "usage: $name <dev> <initiator name> <initiator IP>";
+	echo "example: $name /dev/sdb1 noni 192.168.10.63";
+	exit 1; 
+fi
+
+dev=$1
+initiator=$2
+initiator_ip=$3
+
+verify_params
+
+# Check if tgtd is running (we should have 2 daemons)
+tgtd_count=$(ps aux|grep -c tgtd)
+if [ $tgtd_count -ne 3 ]; then
+	echo "Starting tgtd"
+	tgtd
+fi
+
+tgt_name="iqn.2001-04.com.$(hostname -s)-$initiator"
+
+find_vacant_tgt_id
+tid=$?
+
+# Create the new target
+echo "Creating the new target"
+tgtadm --lld iscsi --op new --mode target --tid $tid -T $tgt_name
+
+find_vacant_lun $tid
+lun=$?
+
+# Add a logical unit to the target
+echo "Adding a logical unit to the target"
+tgtadm --lld iscsi --op new --mode logicalunit --tid $tid --lun $lun -b $dev
+
+# Accept only a specific initiator
+echo "Accepting connections only from $initiator_ip"
+tgtadm --lld iscsi --op bind --mode target --tid $tid -I $initiator_ip
-- 
1.5.3.7




From tomof at acm.org  Sun Dec 30 12:05:02 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 30 Dec 2007 20:05:02 +0900
Subject: [Stgt-devel] [PATCH] iscsi: add assign_lun script
In-Reply-To: <47775C04.10906@voltaire.com>
References: <47775C04.10906@voltaire.com>
Message-ID: <200712301105.lBUB54cL007357@mbox.iij4u.or.jp>

From: Erez Zilber <erezz at voltaire.com>
Subject: [Stgt-devel] [PATCH] iscsi: add assign_lun script
Date: Sun, 30 Dec 2007 10:51:16 +0200

> Add a script that will create a target, add a device to
> the target and define the initiator that can connect to it.

Can you move this to usr/scripts? I guess that this could be improved
to handle other protocols later on.

There would be a better name since this script does more than
assigning a logical unit, that is, creates a new target, add a lun,
and enable an initiator to access to the target.


> Signed-off-by: Erez Zilber <erezz at voltaire.com>
> ---
>  usr/iscsi/scripts/assign_lun |  127 ++++++++++++++++++++++++++++++++++++++++++
>  1 files changed, 127 insertions(+), 0 deletions(-)
>  create mode 100755 usr/iscsi/scripts/assign_lun

(snip)


> +#!/bin/bash
> +
> +verify_params()
> +{
> +	# Make sure that the device exists
> +	if ! [ -b $dev ]; then
> +		echo "$dev is not a device";
> +		exit 1;

Hmm, would be better to have:

        if ! [ -b $dev -o -f $dev ]; then

We can use a regular file as a logical unit.


From pw at osc.edu  Sun Dec 30 16:17:57 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sun, 30 Dec 2007 10:17:57 -0500
Subject: [Stgt-devel] [PATCH] iscsi tcp: optimize rx
In-Reply-To: <200712300752.lBU7qofh008329@mbox.iij4u.or.jp>
References: <20071229190158.GA17878@osc.edu>
	<200712300752.lBU7qofh008329@mbox.iij4u.or.jp>
Message-ID: <20071230151757.GA23494@osc.edu>

tomof at acm.org wrote on Sun, 30 Dec 2007 16:52 +0900:
> Hmm, here we have:
> 
> 		if (conn->rx_iostate == IOSTATE_RX_INIT_DATA)
> 			goto again;
> 		else if (conn->rx_iostate != IOSTATE_RX_AHS)
> 			break;
> 
> conn->rx_iostate == IOSTATE_RX_INIT_DATA case already goes to again?
> What case do you try to improve?

I was obviously not paying attention.  Will try to figure out why
that noop affected performance.  Please drop for now.

		-- Pete


