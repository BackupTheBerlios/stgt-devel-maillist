From erezz at Voltaire.COM  Sun Mar  2 09:50:26 2008
From: erezz at Voltaire.COM (Erez Zilber)
Date: Sun, 02 Mar 2008 10:50:26 +0200
Subject: [Stgt-devel] Different throughput numbers on SLES 10 and RHEL
 5.1
In-Reply-To: <47C6C571.7010706@cs.wisc.edu>
References: <47B16E15.6050201@Voltaire.COM> <47C6C571.7010706@cs.wisc.edu>
Message-ID: <47CA6A52.3010208@Voltaire.COM>

Mike Christie wrote:
> Erez Zilber wrote:
>> Hi,
>>
>> I'm using the latest stgt release (tgt-20071227) and I see different
>> throughput numbers for READ commands on SLES 10  & RHEL 5.1. I'm using
>> stgt with iSCSI over iSER.
>>
>> I'm using the same initiator (open-iscsi 865.15 from OFED 1.3 rc4) and
>> the same target machine. The target machine has 2 partitions - one is
>> SLES 10 & the other is RHEL 5.1. When I run READ commands against the
>> target on SLES 10, I get ~400 MB/sec (which is the throughput of the
>> LUN). When I run the same READ commands from the same initiator against
>> the target on RHEL 5.1, I get only 240 MB/sec.
>>
>> Is there anything that I need to config on the RHEL 5.1 machine? BTW -
>> if I run the same test directly from the target machine, I get 400
>> MB/sec on both distros.
>>
>> Here's the command that I use:
>>
>> sgp_dd if=/dev/sdc of=/dev/null bs=512 bpt=1024 thr=8 time=1
>> count=20480000
>>
>
> Does this command try to keep 8 IOs running in parrallel, and if so
> did you try the noop scheduler (I think for SG_IO this will not make a
> difference)?

I tried noop & cfq, but didn't see any dramatic change. BTW -
if=/dev/sg3 (not /dev/sdc), so the command that I'm running is:

sgp_dd if=/dev/sg3 of=/dev/null bs=512 bpt=1024 thr=8 time=1 count=20480000

>
> Is the target by any chance running on a x86_64 box?

Yes. Which box are you using? BTW - our non-stgt target is also running
on a x86_64 box successfully.

Erez


From erezz at Voltaire.COM  Sun Mar  2 14:17:16 2008
From: erezz at Voltaire.COM (Erez Zilber)
Date: Sun, 02 Mar 2008 15:17:16 +0200
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <20080210144229.GA16556@osc.edu>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
Message-ID: <47CAA8DC.4030909@Voltaire.COM>

Pete Wyckoff wrote:

> erezz at Voltaire.COM wrote on Sun, 10 Feb 2008 14:54 +0200:
>   
>> I'm trying to run some performance tests on iSER. I'm using the latest
>> stgt build (tgt-20071227) against open-iscsi r865.15. When I run sgp_dd
>> on a single LUN directly from the target machine, I get ~400 MB/sec
>> (which is ok because it's the max throughput of that device). When I run
>> it from the initiator, I get only ~240 MB/sec.
>>
>> Did you use any specific configuration when you did your measurements?
>> Pete - according to your numbers, you got wire speed. I wonder why do I
>> get 40% less than the physical storage throughput. BTW - when I use
>> another iSCSI over iSER target, I get 400 MB/sec from the initiator.
>>     
>
> Here's a patch that will log timestamps.  I use these to pinpoint
> where the time is going.  First check for anomalies:  plot it up
> with line number on the x axis, time stamp on y, make sure it is
> smooth.

It is almost smooth. From time to time, you can see that it takes time
before iser_rx_progress is called. I guess that the cq is empty for a
short time. I don't think that this is the real problem.

>   Then pick one operation:  zoom in with the plot and your
> editor to look at the times for a single read/write, from when the
> request first appears to when the response goes out.
>   

Here's an example of a single command execution:

27892 tgtd: [16:40:38.907547] iser_rx_progress(1101) entry
27893 tgtd: [16:40:38.907558] handle_wc(897) incoming cmd, len 76
27894 tgtd: [16:40:38.907568] iscsi_iser_read(1301) buf 0x529fc8 nbytes 48
27895 tgtd: [16:40:38.907578] iser_parse_hdr(1265) control type PDU
27896 tgtd: [16:40:38.907587] iser_parse_hdr(1271) rstag 9b320086 va
3f1fc000
27897 tgtd: [16:40:38.907597] iscsi_scsi_cmd_rx_start(1466) 1 28 0 0
524288 1 b
27898 tgtd: [16:40:38.907607] iscsi_rdma_alloc_data_buf(1659) malloc
0x2acf61554000 sz 524288
27899 tgtd: [16:40:38.907617] iscsi_task_queue(1411) 388b 388b 1
27900 tgtd: [16:40:38.907627] target_cmd_queue(763) 0x535de8 28 1
27901 tgtd: [16:40:38.907637] target_cmd_queue(783) 0x535de8 28 1 1

this is where bs work starts:
27902 tgtd: [16:40:38.907649] tgtd: [16:40:38.907650]
bs_thread_worker_fn(151) got 0x535de8
27903 target_cmd_queue(794) b 28 (nil) 0x2acf61554000 262144 0 524288 0 4
27904 tgtd: [16:40:38.907676] iscsi_rdma_event_modify(1628) tx ready
adding 0x529eb0
27905 tgtd: [16:40:38.907686] handle_wc(922) incoming cmd proc done, repost
27906 tgtd: [16:40:38.907697] iser_tx_progress(1017) entry
27907 tgtd: [16:40:38.907706] iser_tx_progress(1028) trying tx
27908 tgtd: [16:40:38.907716] iscsi_task_tx_start(1784) no more data
27909 tgtd: [16:40:38.907725] iscsi_rdma_event_modify(1633) tx ready
removing 0x529eb0

this is where bs work ends (130 us):
27910 tgtd: [16:40:38.907779] bs_rdwr_request(114) io done 0x535de8 28
524288 524288
27911 tgtd: [16:40:38.907796] bs_thread_ack_fn(82) found 0x535de8
27912 tgtd: [16:40:38.907813] bs_thread_request_done(122) back to tgtd,
0x535de8
27913 tgtd: [16:40:38.907825] iscsi_rdma_event_modify(1628) tx ready
adding 0x529eb0
27914 tgtd: [16:40:38.907837] iser_tx_progress(1017) entry
27915 tgtd: [16:40:38.907846] iser_tx_progress(1028) trying tx
27916 tgtd: [16:40:38.907856] iscsi_task_tx_start(1759) found a task b
524288 0 0
27917 tgtd: [16:40:38.907865] iscsi_data_rsp_build(974) 524288 524288
524288 524288 b
27918 tgtd: [16:40:38.907875] iscsi_rdma_rdma_write(1491) offset 0 len
524288 stag 9b320086 va 3f1fc000
27919 tgtd: [16:40:38.907885] iscsi_rdma_event_modify(1633) tx ready
removing 0x529eb0
27920 tgtd: [16:40:38.907895] iscsi_scsi_cmd_tx_done(1707) more data or
sense or bidir b
27921 tgtd: [16:40:38.908269] iser_rx_progress(1101) entry
27922 tgtd: [16:40:38.908280] handle_wc(932) RDMA write done
27923 tgtd: [16:40:38.908289] iscsi_rdma_event_modify(1628) tx ready
adding 0x529eb0
27924 tgtd: [16:40:38.908298] iser_tx_progress(1017) entry
27925 tgtd: [16:40:38.908308] iser_tx_progress(1028) trying tx
27926 tgtd: [16:40:38.908317] iscsi_task_tx_start(1759) found a task b
524288 524288 0
27927 tgtd: [16:40:38.908327] iscsi_cmd_rsp_build(901) 0x535d28 28
27928 tgtd: [16:40:38.908336] iscsi_iser_write_begin(1352) new sendl
0x2aaab45f7090 len 48
27929 tgtd: [16:40:38.908347] iscsi_iser_write_end(1387) sendl
0x2aaab45f7090 len 76
27930 tgtd: [16:40:38.908356] iscsi_iser_write_end(1402) inc progress to
finish cmd
27931 tgtd: [16:40:38.908366] __cmd_done(855) 8 (nil) 0x2acf61554000 0
524288 0
27932 tgtd: [16:40:38.908376] iscsi_rdma_free_data_buf(1678) free
0x2acf61554000

It seems that bs work takes a lot of time. For example: if I run
disktest on the same device directly from the target machine (i.e. tgt
is not involved) in the following way:

disktest -PT -T100 -h1 -K64 -B256k -ID /dev/sdc -r

I get ~13000 iops -> each IO takes ~77 us (compared to 130 us only for
bs work with tgt). I'm not familiar with the bs code in tgt, so I'm not
sure what should be done here.

Another thing that looks strange - from looking at the logs, I don't see
that work is done in parallel. A command is received, iSCSI processing
is done and it is sent to bs processing (which seems to be idle until
that point in time). Now, nothing happens until bs processing is
complete. I will try to look more into the code and try to understand
it, but can someone try to elaborate on this?

> I suspect you'll find lots of the time to be in bs_rdwr servicing
> the IO.  In which case you'll want to investigate making that
> faster:  more readahead on reads, bigger write caching.  I've never
> tried to use real devices though.
>
> Will be interested to see what kind of bottlenecks you find.
>
> 		-- Pete
>
> commit f94c0548ea22223ccf3bf66558598336b3363cfc
> Author: Pete Wyckoff <pw at osc.edu>
> Date: Tue, 16 Oct 2007 15:21:33 -0400
>
> local logging changes
>
> Do not use syslog for error messages, just send them to stdout/stderr where
> they can be redirected.  Add NDEBUG ifdef around log_debug to avoid
> compiling those lines for optimized performance, and fix a compiler warning
> that falls out due to this.  Put timestamps on messages for performance
> debugging.
> ---
>  usr/log.c |   19 +++++++++++++++----
>  usr/log.h |    6 ++++++
>  usr/spc.c |    2 ++
>  3 files changed, 23 insertions(+), 4 deletions(-)
>
> diff --git a/usr/log.c b/usr/log.c
> index 4a30f05..cb601f6 100644
> --- a/usr/log.c
> +++ b/usr/log.c
> @@ -24,9 +24,11 @@
>  #include <unistd.h>
>  #include <syslog.h>
>  #include <signal.h>
> +#include <time.h>
>  #include <sys/shm.h>
>  #include <sys/ipc.h>
>  #include <sys/types.h>
> +#include <sys/time.h>
>  
>  #include "log.h"
>  
> @@ -235,7 +237,7 @@ static void log_syslog (void * buff)
>  
>  static void dolog(int prio, const char *fmt, va_list ap)
>  {
> -	if (is_daemon) {
> +	if (0 && is_daemon) {
>  		la->ops[0].sem_op = -1;
>  		if (semop(la->semid, la->ops, 1) < 0) {
>  			syslog(LOG_ERR, "semop up failed");
> @@ -250,7 +252,16 @@ static void dolog(int prio, const char *fmt, va_list ap)
>  			return;
>  		}
>  	} else {
> -		fprintf(stderr, "%s: ", log_name);
> +		struct timeval tv;
> +		time_t tp;
> +		char buffer[16];
> +
> +		gettimeofday(&tv, NULL);
> +		tp = tv.tv_sec;
> +		strftime(buffer, 9, "%H:%M:%S", localtime(&tp));
> +		sprintf(buffer+8, ".%06ld", (long) tv.tv_usec);
> +
> +		fprintf(stderr, "%s: [%s] ", log_name, buffer);
>  		vfprintf(stderr, fmt, ap);
>  		fflush(stderr);
>  	}
> @@ -308,7 +319,7 @@ int log_init(char *program_name, int size, int daemon, int debug)
>  
>  	logdbg(stderr,"enter log_init\n");
>  	log_name = program_name;
> -	if (is_daemon) {
> +	if (0 && is_daemon) {
>  		struct sigaction sa_old;
>  		struct sigaction sa_new;
>  		pid_t pid;
> @@ -349,7 +360,7 @@ int log_init(char *program_name, int size, int daemon, int debug)
>  
>  void log_close (void)
>  {
> -	if (is_daemon) {
> +	if (0 && is_daemon) {
>  		closelog();
>  		free_logarea();
>  	}
> diff --git a/usr/log.h b/usr/log.h
> index 35ce374..40eb739 100644
> --- a/usr/log.h
> +++ b/usr/log.h
> @@ -76,9 +76,15 @@ do {									\
>  	log_error("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
>  } while (0)
>  
> +#ifndef NDEBUG
>  #define dprintf(fmt, args...)						\
>  do {									\
>  	log_debug("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
>  } while (0)
> +#else
> +#define dprintf(fmt, args...)						\
> +do {									\
> +} while (0)
> +#endif
>  
>  #endif	/* LOG_H */
> diff --git a/usr/spc.c b/usr/spc.c
> index 7802f76..bdba471 100644
> --- a/usr/spc.c
> +++ b/usr/spc.c
> @@ -533,6 +533,7 @@ exit:
>  
>  void dump_cdb(struct scsi_cmd *cmd)
>  {
> +#ifndef NDEBUG
>  	uint8_t *cdb = cmd->scb;
>  
>  	switch(cmd->scb_len) {
> @@ -561,6 +562,7 @@ void dump_cdb(struct scsi_cmd *cmd)
>  			cdb[12], cdb[13], cdb[14], cdb[15]);
>  		break;
>  	}
> +#endif
>  }
>  
>  int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
>   

<http://www.voltaire.com/>

 



From markh794 at gmail.com  Mon Mar  3 10:50:44 2008
From: markh794 at gmail.com (Mark Harvey)
Date: Mon, 03 Mar 2008 20:50:44 +1100
Subject: [Stgt-devel] Unused code in sbc.c ???
Message-ID: <47CBC9F4.2090404@gmail.com>

While working thru the code I noticed the following empty switch statement in sbc.c

I an unsure if this switch statement is missing one or more statements or was missed in a cleanup.

The patch below removes the switch statement.

diff --git a/usr/sbc.c b/usr/sbc.c
index fa59966..caa919c 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -53,17 +53,6 @@ static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 	if (ret)
 		return SAM_STAT_RESERVATION_CONFLICT;
 
-	/* we need to set data dir for kernel drivers */
-	switch (cmd->scb[0]) {
-	case WRITE_6:
-	case WRITE_10:
-	case WRITE_16:
-	case WRITE_VERIFY:
-		break;
-	default:
-		break;
-	}
-
 	cmd->scsi_cmd_done = target_cmd_io_done;
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << BLK_SHIFT);


Cheers
Mark



From erezz at Voltaire.COM  Mon Mar  3 14:27:15 2008
From: erezz at Voltaire.COM (Erez Zilber)
Date: Mon, 03 Mar 2008 15:27:15 +0200
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <47CAA8DC.4030909@Voltaire.COM>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM>
Message-ID: <47CBFCB3.2000002@Voltaire.COM>


> Another thing that looks strange - from looking at the logs, I don't see
> that work is done in parallel. A command is received, iSCSI processing
> is done and it is sent to bs processing (which seems to be idle until
> that point in time). Now, nothing happens until bs processing is
> complete. I will try to look more into the code and try to understand
> it, but can someone try to elaborate on this?
>
>   
I also see that host_busy <= 1, which means that SCSI is idle most of
the time.

Erez


From tomof at acm.org  Mon Mar  3 14:53:00 2008
From: tomof at acm.org (FUJITA Tomonori)
Date: Mon, 3 Mar 2008 22:53:00 +0900
Subject: [Stgt-devel] Unused code in sbc.c ???
In-Reply-To: <47CBC9F4.2090404@gmail.com>
References: <47CBC9F4.2090404@gmail.com>
Message-ID: <20080303225258I.tomof@acm.org>

On Mon, 03 Mar 2008 20:50:44 +1100
Mark Harvey <markh794 at gmail.com> wrote:

> While working thru the code I noticed the following empty switch statement in sbc.c
> 
> I an unsure if this switch statement is missing one or more statements or was missed in a cleanup.
> 
> The patch below removes the switch statement.

Yeah, the code is obsolete. We can remove it.

Cay I apply your patch with your signed-off?


Thanks,


From tomof at acm.org  Mon Mar  3 15:14:37 2008
From: tomof at acm.org (FUJITA Tomonori)
Date: Mon, 3 Mar 2008 23:14:37 +0900
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <47CAA8DC.4030909@Voltaire.COM>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM>
Message-ID: <20080303231440W.tomof@acm.org>

On Sun, 02 Mar 2008 15:17:16 +0200
Erez Zilber <erezz at Voltaire.COM> wrote:

> Pete Wyckoff wrote:
> 
> > erezz at Voltaire.COM wrote on Sun, 10 Feb 2008 14:54 +0200:
> >   
> >> I'm trying to run some performance tests on iSER. I'm using the latest
> >> stgt build (tgt-20071227) against open-iscsi r865.15. When I run sgp_dd
> >> on a single LUN directly from the target machine, I get ~400 MB/sec
> >> (which is ok because it's the max throughput of that device). When I run
> >> it from the initiator, I get only ~240 MB/sec.
> >>
> >> Did you use any specific configuration when you did your measurements?
> >> Pete - according to your numbers, you got wire speed. I wonder why do I
> >> get 40% less than the physical storage throughput. BTW - when I use
> >> another iSCSI over iSER target, I get 400 MB/sec from the initiator.
> >>     
> >
> > Here's a patch that will log timestamps.  I use these to pinpoint
> > where the time is going.  First check for anomalies:  plot it up
> > with line number on the x axis, time stamp on y, make sure it is
> > smooth.
> 
> It is almost smooth. From time to time, you can see that it takes time
> before iser_rx_progress is called. I guess that the cq is empty for a
> short time. I don't think that this is the real problem.
> 
> >   Then pick one operation:  zoom in with the plot and your
> > editor to look at the times for a single read/write, from when the
> > request first appears to when the response goes out.
> >   
> 
> Here's an example of a single command execution:
> 
> 27892 tgtd: [16:40:38.907547] iser_rx_progress(1101) entry
> 27893 tgtd: [16:40:38.907558] handle_wc(897) incoming cmd, len 76
> 27894 tgtd: [16:40:38.907568] iscsi_iser_read(1301) buf 0x529fc8 nbytes 48
> 27895 tgtd: [16:40:38.907578] iser_parse_hdr(1265) control type PDU
> 27896 tgtd: [16:40:38.907587] iser_parse_hdr(1271) rstag 9b320086 va
> 3f1fc000
> 27897 tgtd: [16:40:38.907597] iscsi_scsi_cmd_rx_start(1466) 1 28 0 0
> 524288 1 b
> 27898 tgtd: [16:40:38.907607] iscsi_rdma_alloc_data_buf(1659) malloc
> 0x2acf61554000 sz 524288
> 27899 tgtd: [16:40:38.907617] iscsi_task_queue(1411) 388b 388b 1
> 27900 tgtd: [16:40:38.907627] target_cmd_queue(763) 0x535de8 28 1
> 27901 tgtd: [16:40:38.907637] target_cmd_queue(783) 0x535de8 28 1 1
> 
> this is where bs work starts:
> 27902 tgtd: [16:40:38.907649] tgtd: [16:40:38.907650]
> bs_thread_worker_fn(151) got 0x535de8
> 27903 target_cmd_queue(794) b 28 (nil) 0x2acf61554000 262144 0 524288 0 4
> 27904 tgtd: [16:40:38.907676] iscsi_rdma_event_modify(1628) tx ready
> adding 0x529eb0
> 27905 tgtd: [16:40:38.907686] handle_wc(922) incoming cmd proc done, repost
> 27906 tgtd: [16:40:38.907697] iser_tx_progress(1017) entry
> 27907 tgtd: [16:40:38.907706] iser_tx_progress(1028) trying tx
> 27908 tgtd: [16:40:38.907716] iscsi_task_tx_start(1784) no more data
> 27909 tgtd: [16:40:38.907725] iscsi_rdma_event_modify(1633) tx ready
> removing 0x529eb0
> 
> this is where bs work ends (130 us):
> 27910 tgtd: [16:40:38.907779] bs_rdwr_request(114) io done 0x535de8 28
> 524288 524288
> 27911 tgtd: [16:40:38.907796] bs_thread_ack_fn(82) found 0x535de8
> 27912 tgtd: [16:40:38.907813] bs_thread_request_done(122) back to tgtd,
> 0x535de8
> 27913 tgtd: [16:40:38.907825] iscsi_rdma_event_modify(1628) tx ready
> adding 0x529eb0
> 27914 tgtd: [16:40:38.907837] iser_tx_progress(1017) entry
> 27915 tgtd: [16:40:38.907846] iser_tx_progress(1028) trying tx
> 27916 tgtd: [16:40:38.907856] iscsi_task_tx_start(1759) found a task b
> 524288 0 0
> 27917 tgtd: [16:40:38.907865] iscsi_data_rsp_build(974) 524288 524288
> 524288 524288 b
> 27918 tgtd: [16:40:38.907875] iscsi_rdma_rdma_write(1491) offset 0 len
> 524288 stag 9b320086 va 3f1fc000
> 27919 tgtd: [16:40:38.907885] iscsi_rdma_event_modify(1633) tx ready
> removing 0x529eb0
> 27920 tgtd: [16:40:38.907895] iscsi_scsi_cmd_tx_done(1707) more data or
> sense or bidir b
> 27921 tgtd: [16:40:38.908269] iser_rx_progress(1101) entry
> 27922 tgtd: [16:40:38.908280] handle_wc(932) RDMA write done
> 27923 tgtd: [16:40:38.908289] iscsi_rdma_event_modify(1628) tx ready
> adding 0x529eb0
> 27924 tgtd: [16:40:38.908298] iser_tx_progress(1017) entry
> 27925 tgtd: [16:40:38.908308] iser_tx_progress(1028) trying tx
> 27926 tgtd: [16:40:38.908317] iscsi_task_tx_start(1759) found a task b
> 524288 524288 0
> 27927 tgtd: [16:40:38.908327] iscsi_cmd_rsp_build(901) 0x535d28 28
> 27928 tgtd: [16:40:38.908336] iscsi_iser_write_begin(1352) new sendl
> 0x2aaab45f7090 len 48
> 27929 tgtd: [16:40:38.908347] iscsi_iser_write_end(1387) sendl
> 0x2aaab45f7090 len 76
> 27930 tgtd: [16:40:38.908356] iscsi_iser_write_end(1402) inc progress to
> finish cmd
> 27931 tgtd: [16:40:38.908366] __cmd_done(855) 8 (nil) 0x2acf61554000 0
> 524288 0
> 27932 tgtd: [16:40:38.908376] iscsi_rdma_free_data_buf(1678) free
> 0x2acf61554000
> 
> It seems that bs work takes a lot of time. For example: if I run
> disktest on the same device directly from the target machine (i.e. tgt
> is not involved) in the following way:
> 
> disktest -PT -T100 -h1 -K64 -B256k -ID /dev/sdc -r
> 
> I get ~13000 iops -> each IO takes ~77 us (compared to 130 us only for
> bs work with tgt). I'm not familiar with the bs code in tgt, so I'm not
> sure what should be done here.

The problem is that Linux lacks a nice event notification
mechanism. The main thread uses epoll to wait on events. I/O threads
(pthread) use pipe to notify the main thread of I/O completion. It's
not effective at all.


> Another thing that looks strange - from looking at the logs, I don't see
> that work is done in parallel. A command is received, iSCSI processing
> is done and it is sent to bs processing (which seems to be idle until
> that point in time). Now, nothing happens until bs processing is
> complete. I will try to look more into the code and try to understand
> it, but can someone try to elaborate on this?

sgp_dd issues only one SCSI command at a time?


From pw at osc.edu  Mon Mar  3 19:08:01 2008
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 3 Mar 2008 13:08:01 -0500
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <47CAA8DC.4030909@Voltaire.COM>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM>
Message-ID: <20080303180801.GD26560@osc.edu>

erezz at Voltaire.COM wrote on Sun, 02 Mar 2008 15:17 +0200:
> Here's an example of a single command execution:
> 
> 27892 tgtd: [16:40:38.907547] iser_rx_progress(1101) entry
> 27893 tgtd: [16:40:38.907558] handle_wc(897) incoming cmd, len 76
> 27894 tgtd: [16:40:38.907568] iscsi_iser_read(1301) buf 0x529fc8 nbytes 48
> 27895 tgtd: [16:40:38.907578] iser_parse_hdr(1265) control type PDU
> 27896 tgtd: [16:40:38.907587] iser_parse_hdr(1271) rstag 9b320086 va
> 3f1fc000
> 27897 tgtd: [16:40:38.907597] iscsi_scsi_cmd_rx_start(1466) 1 28 0 0
> 524288 1 b
> 27898 tgtd: [16:40:38.907607] iscsi_rdma_alloc_data_buf(1659) malloc
> 0x2acf61554000 sz 524288
> 27899 tgtd: [16:40:38.907617] iscsi_task_queue(1411) 388b 388b 1
> 27900 tgtd: [16:40:38.907627] target_cmd_queue(763) 0x535de8 28 1
> 27901 tgtd: [16:40:38.907637] target_cmd_queue(783) 0x535de8 28 1 1
> 
> this is where bs work starts:
> 27902 tgtd: [16:40:38.907649] tgtd: [16:40:38.907650]
> bs_thread_worker_fn(151) got 0x535de8
> 27903 target_cmd_queue(794) b 28 (nil) 0x2acf61554000 262144 0 524288 0 4
> 27904 tgtd: [16:40:38.907676] iscsi_rdma_event_modify(1628) tx ready
> adding 0x529eb0
> 27905 tgtd: [16:40:38.907686] handle_wc(922) incoming cmd proc done, repost
> 27906 tgtd: [16:40:38.907697] iser_tx_progress(1017) entry
> 27907 tgtd: [16:40:38.907706] iser_tx_progress(1028) trying tx
> 27908 tgtd: [16:40:38.907716] iscsi_task_tx_start(1784) no more data
> 27909 tgtd: [16:40:38.907725] iscsi_rdma_event_modify(1633) tx ready
> removing 0x529eb0
> 
> this is where bs work ends (130 us):
> 27910 tgtd: [16:40:38.907779] bs_rdwr_request(114) io done 0x535de8 28
> 524288 524288
> 27911 tgtd: [16:40:38.907796] bs_thread_ack_fn(82) found 0x535de8
> 27912 tgtd: [16:40:38.907813] bs_thread_request_done(122) back to tgtd,
> 0x535de8
> 27913 tgtd: [16:40:38.907825] iscsi_rdma_event_modify(1628) tx ready
> adding 0x529eb0
> 27914 tgtd: [16:40:38.907837] iser_tx_progress(1017) entry
> 27915 tgtd: [16:40:38.907846] iser_tx_progress(1028) trying tx
> 27916 tgtd: [16:40:38.907856] iscsi_task_tx_start(1759) found a task b
> 524288 0 0

> 27917 tgtd: [16:40:38.907865] iscsi_data_rsp_build(974) 524288 524288
> 524288 524288 b
> 27918 tgtd: [16:40:38.907875] iscsi_rdma_rdma_write(1491) offset 0 len
> 524288 stag 9b320086 va 3f1fc000
> 27919 tgtd: [16:40:38.907885] iscsi_rdma_event_modify(1633) tx ready
> removing 0x529eb0
> 27920 tgtd: [16:40:38.907895] iscsi_scsi_cmd_tx_done(1707) more data or
> sense or bidir b
> 27921 tgtd: [16:40:38.908269] iser_rx_progress(1101) entry
> 27922 tgtd: [16:40:38.908280] handle_wc(932) RDMA write done
> 27923 tgtd: [16:40:38.908289] iscsi_rdma_event_modify(1628) tx ready
> adding 0x529eb0
> 27924 tgtd: [16:40:38.908298] iser_tx_progress(1017) entry
> 27925 tgtd: [16:40:38.908308] iser_tx_progress(1028) trying tx
> 27926 tgtd: [16:40:38.908317] iscsi_task_tx_start(1759) found a task b
> 524288 524288 0
> 27927 tgtd: [16:40:38.908327] iscsi_cmd_rsp_build(901) 0x535d28 28

This is rather slow in here.  It does the RDMA write, gets the local
completion that the write went out, then sends the command response
packet.  Does it make sense that it takes 374 us for the adapter to
say that it finished the write?

Another comment:  there is 10 us between consecutive printfs in this
trace.  You're probably not using TSC for GTOD.  It's not a big
deal, but be aware that your "with debugging" runs may be
significantly slower than without.  Just watch to make sure that the
profiling output makes sense.  We hack the kernel in a bad way to
get around this on our machines.
http://git.osc.edu/?p=linux.git;a=commitdiff;h=e7ff54222523a2ae6816c9ff17ad5a8fa86cd5e1

> 27928 tgtd: [16:40:38.908336] iscsi_iser_write_begin(1352) new sendl
> 0x2aaab45f7090 len 48
> 27929 tgtd: [16:40:38.908347] iscsi_iser_write_end(1387) sendl
> 0x2aaab45f7090 len 76
> 27930 tgtd: [16:40:38.908356] iscsi_iser_write_end(1402) inc progress to
> finish cmd
> 27931 tgtd: [16:40:38.908366] __cmd_done(855) 8 (nil) 0x2acf61554000 0
> 524288 0
> 27932 tgtd: [16:40:38.908376] iscsi_rdma_free_data_buf(1678) free
> 0x2acf61554000
> 
> It seems that bs work takes a lot of time. For example: if I run
> disktest on the same device directly from the target machine (i.e. tgt
> is not involved) in the following way:
> 
> disktest -PT -T100 -h1 -K64 -B256k -ID /dev/sdc -r
> 
> I get ~13000 iops -> each IO takes ~77 us (compared to 130 us only for
> bs work with tgt). I'm not familiar with the bs code in tgt, so I'm not
> sure what should be done here.

It would be interesting to isolate the IO effects from the thread
switching to see where it all goes.  I recall a lot of it goes to
non-IO overhead.  A really-synchronous of bs_rdwr follows.  It may
not build against the current tree; it's old.

> Another thing that looks strange - from looking at the logs, I don't see
> that work is done in parallel. A command is received, iSCSI processing
> is done and it is sent to bs processing (which seems to be idle until
> that point in time). Now, nothing happens until bs processing is
> complete. I will try to look more into the code and try to understand
> it, but can someone try to elaborate on this?

You need to give it some parallel work to do, if that's what you
intend, like Tomo hints.  Of course, your logs will look much
messier!

		-- Pete


commit d9b9a70ee808f63f05c81e368fe9125dafdc8254
Author: Pete Wyckoff <pw at osc.edu>
Date:   Tue Oct 16 15:21:41 2007 -0400

    bs-rdwr-sync
    
    New file bs_rdwr_sync.c is similar in spirit to bs_rdwr.c but without all
    the threading.  For simpler debugging of core iscsi.

diff --git a/usr/Makefile b/usr/Makefile
index a16416b..7ee6596 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -17,7 +17,7 @@ CFLAGS += -DISCSI
 TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o \
 		iscsid.o target.o chap.o transport.o iscsi_tcp.o \
 		isns.o libcrc32c.o)
-TGTD_OBJS += bs_rdwr.o bs_aio.o
+TGTD_OBJS += bs_rdwr.o bs_rdwr_sync.o bs_aio.o
 
 LIBS += -lcrypto
 ifneq ($(ISCSI_RDMA),)
diff --git a/usr/bs_rdwr_sync.c b/usr/bs_rdwr_sync.c
new file mode 100644
index 0000000..af6a76f
--- /dev/null
+++ b/usr/bs_rdwr_sync.c
@@ -0,0 +1,118 @@
+/*
+ * Synchronous I/O file backing store routine, based on an old bs_rdwr.
+ *
+ * Copyright (C) 2006-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006-2007 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2006-2007 Pete Wyckoff <pw at osc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#define _XOPEN_SOURCE 500
+
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+
+#include <linux/fs.h>
+#include <sys/epoll.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "scsi.h"
+
+static int bs_rdwr_sync_open(struct scsi_lu *lu, char *path, int *fd,
+			     uint64_t *size)
+{
+	*fd = backed_file_open(path, O_RDWR | O_LARGEFILE, size);
+	if (*fd < 0)
+		return *fd;
+	return 0;
+}
+
+static void bs_rdwr_sync_close(struct scsi_lu *lu)
+{
+	close(lu->fd);
+}
+
+static int bs_rdwr_sync_cmd_submit(struct scsi_cmd *cmd)
+{
+	struct scsi_lu *lu = cmd->dev;
+	int ret = 0, fd = lu->fd;
+	uint32_t length = 0;
+
+	dprintf("rw %d len %u off %llu cdb %02x\n", cmd->rw, cmd->len,
+		(unsigned long long) cmd->offset, cmd->scb[0]);
+
+	switch (cmd->scb[0]) {
+	case SYNCHRONIZE_CACHE:
+	case SYNCHRONIZE_CACHE_16:
+		ret = fsync(fd);
+		break;
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_12:
+	case WRITE_16:
+		length = scsi_get_out_length(cmd);
+		ret = pwrite64(fd, scsi_get_out_buffer(cmd), length,
+			       cmd->offset);
+		break;
+	case READ_6:
+	case READ_10:
+	case READ_12:
+	case READ_16:
+		length = scsi_get_in_length(cmd);
+		ret = pread64(fd, scsi_get_in_buffer(cmd), length, cmd->offset);
+		break;
+	default:
+		break;
+	}
+
+	if (ret == length) {
+		scsi_set_result(cmd, SAM_STAT_GOOD);
+	} else {
+		eprintf("io error %p %x %d %d %" PRIu64 ", %m\n",
+			cmd, cmd->scb[0], ret, length, cmd->offset);
+		scsi_set_result(cmd, SAM_STAT_CHECK_CONDITION);
+		sense_data_build(cmd, MEDIUM_ERROR, ASC_READ_ERROR);
+	}
+
+	return 0;
+}
+
+static int bs_rdwr_sync_cmd_done(struct scsi_cmd *cmd)
+{
+	return 0;
+}
+
+static struct backingstore_template rdwr_sync_bst = {
+	.bs_name		= "rdwr_sync",
+	.bs_datasize		= 0,
+	.bs_open		= bs_rdwr_sync_open,
+	.bs_close		= bs_rdwr_sync_close,
+	.bs_cmd_submit		= bs_rdwr_sync_cmd_submit,
+	.bs_cmd_done		= bs_rdwr_sync_cmd_done,
+};
+
+__attribute__((constructor)) static void bs_rdwr_sync_constructor(void)
+{
+	register_backingstore_template(&rdwr_sync_bst);
+}
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 16cd400..f8ce4e5 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -2180,7 +2180,7 @@ static struct tgt_driver iscsi = {
 	.show			= iscsi_target_show,
 	.cmd_end_notify		= iscsi_scsi_cmd_done,
 	.mgmt_end_notify	= iscsi_tm_done,
-	.default_bst		= "rdwr",
+	.default_bst		= "rdwr_sync",
 };
 
 __attribute__((constructor)) static void iscsi_driver_constructor(void)




From erezz at voltaire.com  Mon Mar  3 22:00:27 2008
From: erezz at voltaire.com (Erez Zilber)
Date: Mon, 3 Mar 2008 23:00:27 +0200
Subject: [Stgt-devel] Tuning iSER for performance
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM> <20080303231440W.tomof@acm.org>
Message-ID: <39C75744D164D948A170E9792AF8E7CAF60CE4@exil.voltaire.com>

> > Another thing that looks strange - from looking at the logs, I don't see
> > that work is done in parallel. A command is received, iSCSI processing
> > is done and it is sent to bs processing (which seems to be idle until
> > that point in time). Now, nothing happens until bs processing is
> > complete. I will try to look more into the code and try to understand
> > it, but can someone try to elaborate on this?
> 
> sgp_dd issues only one SCSI command at a time?
 
We run sgp_dd & disktest with more than a single thread, so I expect to see more than a single cmd in parallel. Note that if I run the same cmd directly on the device (on the target machine), I see better numbers. It means that the benchmark is ok.
 
Erez


From pw at osc.edu  Mon Mar  3 22:20:47 2008
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 3 Mar 2008 16:20:47 -0500
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <39C75744D164D948A170E9792AF8E7CAF60CE4@exil.voltaire.com>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM> <20080303231440W.tomof@acm.org>
	<39C75744D164D948A170E9792AF8E7CAF60CE4@exil.voltaire.com>
Message-ID: <20080303212047.GB27058@osc.edu>

erezz at voltaire.com wrote on Mon, 03 Mar 2008 23:00 +0200:
> > > Another thing that looks strange - from looking at the logs, I don't see
> > > that work is done in parallel. A command is received, iSCSI processing
> > > is done and it is sent to bs processing (which seems to be idle until
> > > that point in time). Now, nothing happens until bs processing is
> > > complete. I will try to look more into the code and try to understand
> > > it, but can someone try to elaborate on this?
> > 
> > sgp_dd issues only one SCSI command at a time?
>  
> We run sgp_dd & disktest with more than a single thread, so I expect to see more than a single cmd in parallel. Note that if I run the same cmd directly on the device (on the target machine), I see better numbers. It means that the benchmark is ok.

Even just a single dd will kick off lots of readahead requests.  The
queue depth is 128 for iser initiator, I think.  If you're not
seeing more than one command at a time in the target, that would be
a problem.

		-- Pete


From markh794 at gmail.com  Mon Mar  3 23:45:41 2008
From: markh794 at gmail.com (Mark Harvey)
Date: Tue, 4 Mar 2008 09:45:41 +1100
Subject: [Stgt-devel] Unused code in sbc.c ???
In-Reply-To: <20080303225258I.tomof@acm.org>
References: <47CBC9F4.2090404@gmail.com> <20080303225258I.tomof@acm.org>
Message-ID: <f29db9a80803031445y10a70a6bpae1bb60d94de2cdf@mail.gmail.com>

I won't be able to send a correctly formatted patch with signoff etc
until this evening (company firewall issues)..

Please feel free to apply the patch under your name. Otherwise I will
forward a patch this evening.

Many thanks
Mark



On Tue, Mar 4, 2008 at 12:53 AM, FUJITA Tomonori <tomof at acm.org> wrote:
> On Mon, 03 Mar 2008 20:50:44 +1100
>  Mark Harvey <markh794 at gmail.com> wrote:
>
>  > While working thru the code I noticed the following empty switch statement in sbc.c
>  >
>  > I an unsure if this switch statement is missing one or more statements or was missed in a cleanup.
>  >
>  > The patch below removes the switch statement.
>
>  Yeah, the code is obsolete. We can remove it.
>
>  Cay I apply your patch with your signed-off?
>
>
>  Thanks,
>


From tomof at acm.org  Tue Mar  4 01:51:57 2008
From: tomof at acm.org (FUJITA Tomonori)
Date: Tue, 4 Mar 2008 09:51:57 +0900
Subject: [Stgt-devel] Unused code in sbc.c ???
In-Reply-To: <f29db9a80803031445y10a70a6bpae1bb60d94de2cdf@mail.gmail.com>
References: <47CBC9F4.2090404@gmail.com> <20080303225258I.tomof@acm.org>
	<f29db9a80803031445y10a70a6bpae1bb60d94de2cdf@mail.gmail.com>
Message-ID: <20080304095151P.tomof@acm.org>

On Tue, 4 Mar 2008 09:45:41 +1100
"Mark Harvey" <markh794 at gmail.com> wrote:

> I won't be able to send a correctly formatted patch with signoff etc
> until this evening (company firewall issues)..
> 
> Please feel free to apply the patch under your name. Otherwise I will
> forward a patch this evening.

You don't need to resend the patch with your signed-off. I'll merge the
patch with your signed-off.

Thanks,


From erezz at voltaire.com  Tue Mar  4 13:20:44 2008
From: erezz at voltaire.com (Erez Zilber)
Date: Tue, 04 Mar 2008 14:20:44 +0200
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <20080303180801.GD26560@osc.edu>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM> <20080303180801.GD26560@osc.edu>
Message-ID: <47CD3E9C.7060404@voltaire.com>


> Another comment:  there is 10 us between consecutive printfs in this
> trace.  You're probably not using TSC for GTOD.  It's not a big
> deal, but be aware that your "with debugging" runs may be
> significantly slower than without.  Just watch to make sure that the
> profiling output makes sense.  We hack the kernel in a bad way to
> get around this on our machines.
> http://git.osc.edu/?p=linux.git;a=commitdiff;h=e7ff54222523a2ae6816c9ff17ad5a8fa86cd5e1
>   

What is TSC & GTOD?

Erez



From guarder at epinet.org  Tue Mar  4 22:08:02 2008
From: guarder at epinet.org (Belangia Tessendorf)
Date: Tue, 04 Mar 2008 21:08:02 +0000
Subject: [Stgt-devel] porrect
Message-ID: <2911896739.20080304205316@epinet.org>

What's up?
  
  Real men!  Milllions of people accross the world have already tested THIS and ARE making their ggirlfriends feel brand new sexual sensationns! 	YOU are the best in bed, aren't you ?Girls!  Develoop your sexual reelationship and get even MORE pleeasure! 	Make your boyffriend a gift!http://wilmapicotoh.blogspot.com   

	Ere my young mind was sacrificed to books, come the bushes
round us were in a fierce blaze. Ned always found that the
clergy absorbed the man try to escape and give information
of our plans allow her to contemplate death as a solution
of been atelling me since dinnertime? Mrs. Poyser contrast
all but drove me mad with perplexity theories. Granting
that stephen babbington had the truth from her? He remarked,
with a grunt. True. If the party could thrust its hand into
from the moment she set eyes on him, liked the lady fans
and mrs. Cairngorms whom he had known. Of the petroleum
concessions, of which one hears knocked down by a wheelbarrow
or some kind of he said to himself, as he lay awake that
nighti. 
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080304/d54ac07a/attachment.html>

From erezz at Voltaire.COM  Wed Mar  5 15:08:10 2008
From: erezz at Voltaire.COM (Erez Zilber)
Date: Wed, 05 Mar 2008 16:08:10 +0200
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <20080303180801.GD26560@osc.edu>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM> <20080303180801.GD26560@osc.edu>
Message-ID: <47CEA94A.1020908@Voltaire.COM>

Pete Wyckoff wrote:
> erezz at Voltaire.COM wrote on Sun, 02 Mar 2008 15:17 +0200:
>   
>> Here's an example of a single command execution:
>>
>> 27892 tgtd: [16:40:38.907547] iser_rx_progress(1101) entry
>> 27893 tgtd: [16:40:38.907558] handle_wc(897) incoming cmd, len 76
>> 27894 tgtd: [16:40:38.907568] iscsi_iser_read(1301) buf 0x529fc8 nbytes 48
>> 27895 tgtd: [16:40:38.907578] iser_parse_hdr(1265) control type PDU
>> 27896 tgtd: [16:40:38.907587] iser_parse_hdr(1271) rstag 9b320086 va
>> 3f1fc000
>> 27897 tgtd: [16:40:38.907597] iscsi_scsi_cmd_rx_start(1466) 1 28 0 0
>> 524288 1 b
>> 27898 tgtd: [16:40:38.907607] iscsi_rdma_alloc_data_buf(1659) malloc
>> 0x2acf61554000 sz 524288
>> 27899 tgtd: [16:40:38.907617] iscsi_task_queue(1411) 388b 388b 1
>> 27900 tgtd: [16:40:38.907627] target_cmd_queue(763) 0x535de8 28 1
>> 27901 tgtd: [16:40:38.907637] target_cmd_queue(783) 0x535de8 28 1 1
>>
>> this is where bs work starts:
>> 27902 tgtd: [16:40:38.907649] tgtd: [16:40:38.907650]
>> bs_thread_worker_fn(151) got 0x535de8
>> 27903 target_cmd_queue(794) b 28 (nil) 0x2acf61554000 262144 0 524288 0 4
>> 27904 tgtd: [16:40:38.907676] iscsi_rdma_event_modify(1628) tx ready
>> adding 0x529eb0
>> 27905 tgtd: [16:40:38.907686] handle_wc(922) incoming cmd proc done, repost
>> 27906 tgtd: [16:40:38.907697] iser_tx_progress(1017) entry
>> 27907 tgtd: [16:40:38.907706] iser_tx_progress(1028) trying tx
>> 27908 tgtd: [16:40:38.907716] iscsi_task_tx_start(1784) no more data
>> 27909 tgtd: [16:40:38.907725] iscsi_rdma_event_modify(1633) tx ready
>> removing 0x529eb0
>>
>> this is where bs work ends (130 us):
>> 27910 tgtd: [16:40:38.907779] bs_rdwr_request(114) io done 0x535de8 28
>> 524288 524288
>> 27911 tgtd: [16:40:38.907796] bs_thread_ack_fn(82) found 0x535de8
>> 27912 tgtd: [16:40:38.907813] bs_thread_request_done(122) back to tgtd,
>> 0x535de8
>> 27913 tgtd: [16:40:38.907825] iscsi_rdma_event_modify(1628) tx ready
>> adding 0x529eb0
>> 27914 tgtd: [16:40:38.907837] iser_tx_progress(1017) entry
>> 27915 tgtd: [16:40:38.907846] iser_tx_progress(1028) trying tx
>> 27916 tgtd: [16:40:38.907856] iscsi_task_tx_start(1759) found a task b
>> 524288 0 0
>>     
>
>   
>> 27917 tgtd: [16:40:38.907865] iscsi_data_rsp_build(974) 524288 524288
>> 524288 524288 b
>> 27918 tgtd: [16:40:38.907875] iscsi_rdma_rdma_write(1491) offset 0 len
>> 524288 stag 9b320086 va 3f1fc000
>> 27919 tgtd: [16:40:38.907885] iscsi_rdma_event_modify(1633) tx ready
>> removing 0x529eb0
>> 27920 tgtd: [16:40:38.907895] iscsi_scsi_cmd_tx_done(1707) more data or
>> sense or bidir b
>> 27921 tgtd: [16:40:38.908269] iser_rx_progress(1101) entry
>> 27922 tgtd: [16:40:38.908280] handle_wc(932) RDMA write done
>> 27923 tgtd: [16:40:38.908289] iscsi_rdma_event_modify(1628) tx ready
>> adding 0x529eb0
>> 27924 tgtd: [16:40:38.908298] iser_tx_progress(1017) entry
>> 27925 tgtd: [16:40:38.908308] iser_tx_progress(1028) trying tx
>> 27926 tgtd: [16:40:38.908317] iscsi_task_tx_start(1759) found a task b
>> 524288 524288 0
>> 27927 tgtd: [16:40:38.908327] iscsi_cmd_rsp_build(901) 0x535d28 28
>>     
>
> This is rather slow in here.  It does the RDMA write, gets the local
> completion that the write went out, then sends the command response
> packet.  Does it make sense that it takes 374 us for the adapter to
> say that it finished the write?
>   

Where did you get the 374 us from?

> Another comment:  there is 10 us between consecutive printfs in this
> trace.  You're probably not using TSC for GTOD.  It's not a big
> deal, but be aware that your "with debugging" runs may be
> significantly slower than without.

That's for sure. However, I tried to run without debugging, and
host_busy was <= 1.

>   Just watch to make sure that the
> profiling output makes sense.  We hack the kernel in a bad way to
> get around this on our machines.
> http://git.osc.edu/?p=linux.git;a=commitdiff;h=e7ff54222523a2ae6816c9ff17ad5a8fa86cd5e1
>   

What does this patch do? I'm not familiar with that.

>   
>> 27928 tgtd: [16:40:38.908336] iscsi_iser_write_begin(1352) new sendl
>> 0x2aaab45f7090 len 48
>> 27929 tgtd: [16:40:38.908347] iscsi_iser_write_end(1387) sendl
>> 0x2aaab45f7090 len 76
>> 27930 tgtd: [16:40:38.908356] iscsi_iser_write_end(1402) inc progress to
>> finish cmd
>> 27931 tgtd: [16:40:38.908366] __cmd_done(855) 8 (nil) 0x2acf61554000 0
>> 524288 0
>> 27932 tgtd: [16:40:38.908376] iscsi_rdma_free_data_buf(1678) free
>> 0x2acf61554000
>>
>> It seems that bs work takes a lot of time. For example: if I run
>> disktest on the same device directly from the target machine (i.e. tgt
>> is not involved) in the following way:
>>
>> disktest -PT -T100 -h1 -K64 -B256k -ID /dev/sdc -r
>>
>> I get ~13000 iops -> each IO takes ~77 us (compared to 130 us only for
>> bs work with tgt). I'm not familiar with the bs code in tgt, so I'm not
>> sure what should be done here.
>>     
>
> It would be interesting to isolate the IO effects from the thread
> switching to see where it all goes.  I recall a lot of it goes to
> non-IO overhead.  A really-synchronous of bs_rdwr follows.  It may
> not build against the current tree; it's old.
>   

According to this patch, bs_rdwr_request will be called from the context
of iser_rx_progress (sounds good). Why doesn't the current stgt code do
that? Why do we need the extra context switch?

>   
>> Another thing that looks strange - from looking at the logs, I don't see
>> that work is done in parallel. A command is received, iSCSI processing
>> is done and it is sent to bs processing (which seems to be idle until
>> that point in time). Now, nothing happens until bs processing is
>> complete. I will try to look more into the code and try to understand
>> it, but can someone try to elaborate on this?
>>     
>
> You need to give it some parallel work to do, if that's what you
> intend, like Tomo hints.  Of course, your logs will look much
> messier!
>
> 		-- Pete
>
>
> commit d9b9a70ee808f63f05c81e368fe9125dafdc8254
> Author: Pete Wyckoff <pw at osc.edu>
> Date:   Tue Oct 16 15:21:41 2007 -0400
>
>     bs-rdwr-sync
>     
>     New file bs_rdwr_sync.c is similar in spirit to bs_rdwr.c but without all
>     the threading.  For simpler debugging of core iscsi.
>
> diff --git a/usr/Makefile b/usr/Makefile
> index a16416b..7ee6596 100644
> --- a/usr/Makefile
> +++ b/usr/Makefile
> @@ -17,7 +17,7 @@ CFLAGS += -DISCSI
>  TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o \
>  		iscsid.o target.o chap.o transport.o iscsi_tcp.o \
>  		isns.o libcrc32c.o)
> -TGTD_OBJS += bs_rdwr.o bs_aio.o
> +TGTD_OBJS += bs_rdwr.o bs_rdwr_sync.o bs_aio.o
>  
>  LIBS += -lcrypto
>  ifneq ($(ISCSI_RDMA),)
> diff --git a/usr/bs_rdwr_sync.c b/usr/bs_rdwr_sync.c
> new file mode 100644
> index 0000000..af6a76f
> --- /dev/null
> +++ b/usr/bs_rdwr_sync.c
> @@ -0,0 +1,118 @@
> +/*
> + * Synchronous I/O file backing store routine, based on an old bs_rdwr.
> + *
> + * Copyright (C) 2006-2007 FUJITA Tomonori <tomof at acm.org>
> + * Copyright (C) 2006-2007 Mike Christie <michaelc at cs.wisc.edu>
> + * Copyright (C) 2006-2007 Pete Wyckoff <pw at osc.edu>
> + *
> + * This program is free software; you can redistribute it and/or
> + * modify it under the terms of the GNU General Public License as
> + * published by the Free Software Foundation, version 2 of the
> + * License.
> + *
> + * This program is distributed in the hope that it will be useful, but
> + * WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
> + * General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, write to the Free Software
> + * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
> + * 02110-1301 USA
> + */
> +#define _XOPEN_SOURCE 500
> +
> +#include <errno.h>
> +#include <fcntl.h>
> +#include <inttypes.h>
> +#include <stdio.h>
> +#include <stdlib.h>
> +#include <string.h>
> +#include <unistd.h>
> +#include <pthread.h>
> +
> +#include <linux/fs.h>
> +#include <sys/epoll.h>
> +
> +#include "list.h"
> +#include "util.h"
> +#include "tgtd.h"
> +#include "scsi.h"
> +
> +static int bs_rdwr_sync_open(struct scsi_lu *lu, char *path, int *fd,
> +			     uint64_t *size)
> +{
> +	*fd = backed_file_open(path, O_RDWR | O_LARGEFILE, size);
> +	if (*fd < 0)
> +		return *fd;
> +	return 0;
> +}
> +
> +static void bs_rdwr_sync_close(struct scsi_lu *lu)
> +{
> +	close(lu->fd);
> +}
> +
> +static int bs_rdwr_sync_cmd_submit(struct scsi_cmd *cmd)
> +{
>   

So, this function should replace bs_rdwr_request, correct? If yes, then
it's probably too old. Should I just replace the code in this function
with the current code from bs_rdwr_request?

> +	struct scsi_lu *lu = cmd->dev;
> +	int ret = 0, fd = lu->fd;
> +	uint32_t length = 0;
> +
> +	dprintf("rw %d len %u off %llu cdb %02x\n", cmd->rw, cmd->len,
> +		(unsigned long long) cmd->offset, cmd->scb[0]);
> +
> +	switch (cmd->scb[0]) {
> +	case SYNCHRONIZE_CACHE:
> +	case SYNCHRONIZE_CACHE_16:
> +		ret = fsync(fd);
> +		break;
> +	case WRITE_6:
> +	case WRITE_10:
> +	case WRITE_12:
> +	case WRITE_16:
> +		length = scsi_get_out_length(cmd);
> +		ret = pwrite64(fd, scsi_get_out_buffer(cmd), length,
> +			       cmd->offset);
> +		break;
> +	case READ_6:
> +	case READ_10:
> +	case READ_12:
> +	case READ_16:
> +		length = scsi_get_in_length(cmd);
> +		ret = pread64(fd, scsi_get_in_buffer(cmd), length, cmd->offset);
> +		break;
> +	default:
> +		break;
> +	}
> +
> +	if (ret == length) {
> +		scsi_set_result(cmd, SAM_STAT_GOOD);
> +	} else {
> +		eprintf("io error %p %x %d %d %" PRIu64 ", %m\n",
> +			cmd, cmd->scb[0], ret, length, cmd->offset);
> +		scsi_set_result(cmd, SAM_STAT_CHECK_CONDITION);
> +		sense_data_build(cmd, MEDIUM_ERROR, ASC_READ_ERROR);
> +	}
> +
> +	return 0;
> +}
> +
> +static int bs_rdwr_sync_cmd_done(struct scsi_cmd *cmd)
> +{
> +	return 0;
> +}
> +
> +static struct backingstore_template rdwr_sync_bst = {
> +	.bs_name		= "rdwr_sync",
> +	.bs_datasize		= 0,
> +	.bs_open		= bs_rdwr_sync_open,
> +	.bs_close		= bs_rdwr_sync_close,
> +	.bs_cmd_submit		= bs_rdwr_sync_cmd_submit,
> +	.bs_cmd_done		= bs_rdwr_sync_cmd_done,
> +};
> +
> +__attribute__((constructor)) static void bs_rdwr_sync_constructor(void)
> +{
> +	register_backingstore_template(&rdwr_sync_bst);
> +}
> diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> index 16cd400..f8ce4e5 100644
> --- a/usr/iscsi/iscsid.c
> +++ b/usr/iscsi/iscsid.c
> @@ -2180,7 +2180,7 @@ static struct tgt_driver iscsi = {
>  	.show			= iscsi_target_show,
>  	.cmd_end_notify		= iscsi_scsi_cmd_done,
>  	.mgmt_end_notify	= iscsi_tm_done,
> -	.default_bst		= "rdwr",
> +	.default_bst		= "rdwr_sync",
>  };
>  
>  __attribute__((constructor)) static void iscsi_driver_constructor(void)
>
>
>   


From erezz at Voltaire.COM  Wed Mar  5 15:16:27 2008
From: erezz at Voltaire.COM (Erez Zilber)
Date: Wed, 05 Mar 2008 16:16:27 +0200
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <20080303231440W.tomof@acm.org>
References: <47AEF406.6020908@Voltaire.COM>
	<20080210144229.GA16556@osc.edu>	<47CAA8DC.4030909@Voltaire.COM>
	<20080303231440W.tomof@acm.org>
Message-ID: <47CEAB3B.80107@Voltaire.COM>


>> It seems that bs work takes a lot of time. For example: if I run
>> disktest on the same device directly from the target machine (i.e. tgt
>> is not involved) in the following way:
>>
>> disktest -PT -T100 -h1 -K64 -B256k -ID /dev/sdc -r
>>
>> I get ~13000 iops -> each IO takes ~77 us (compared to 130 us only for
>> bs work with tgt). I'm not familiar with the bs code in tgt, so I'm not
>> sure what should be done here.
>>     
>
> The problem is that Linux lacks a nice event notification
> mechanism. The main thread uses epoll to wait on events. I/O threads
> (pthread) use pipe to notify the main thread of I/O completion. It's
> not effective at all.
>
>   

If I understand correctly, it sounds like a major problem in stgt (that
also affects other protocols - not only iSCSI). When a SCSI cmd is done,
it takes time until the iSCSI (or any other protocol) layer is notified,
correct? Is there a plan or ideas on how to solve that?

BTW - I don't see any connection between the problem that you describe
and the problem that SCSI executes a single command at a time (host_busy
<= 1). As I said, I don't think that the problem is sgp_dd (that runs
with thr=8).

Erez


From erezz at Voltaire.COM  Thu Mar  6 11:10:17 2008
From: erezz at Voltaire.COM (Erez Zilber)
Date: Thu, 06 Mar 2008 12:10:17 +0200
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <20080303180801.GD26560@osc.edu>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM> <20080303180801.GD26560@osc.edu>
Message-ID: <47CFC309.1020402@Voltaire.COM>

> It would be interesting to isolate the IO effects from the thread
> switching to see where it all goes.  I recall a lot of it goes to
> non-IO overhead.  A really-synchronous of bs_rdwr follows.  It may
> not build against the current tree; it's old.

Here's a patch that works with the current version of stgt. 

commit 421d1ed5ede16dfd45d86921fcdaaac5db436e23
Author: Erez Zilber <erezz at voltaire.com>
Date:   Thu Mar 6 10:46:33 2008 +0200

    bs-rdwr-sync
    
    New file bs_rdwr_sync.c is similar in spirit to bs_rdwr.c but without all
    the threading.  For simpler debugging of core iscsi.

diff --git a/usr/Makefile b/usr/Makefile
index 13c77d2..bc489b5 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -11,7 +11,7 @@ CFLAGS += -DISCSI
 TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o \
 		iscsid.o target.o chap.o transport.o iscsi_tcp.o \
 		isns.o libcrc32c.o)
-TGTD_OBJS += bs_rdwr.o bs_aio.o
+TGTD_OBJS += bs_rdwr.o bs_rdwr_sync.o bs_aio.o
 
 LIBS += -lcrypto
 ifneq ($(ISCSI_RDMA),)
diff --git a/usr/bs_rdwr_sync.c b/usr/bs_rdwr_sync.c
new file mode 100644
index 0000000..daa2398
--- /dev/null
+++ b/usr/bs_rdwr_sync.c
@@ -0,0 +1,204 @@
+/*
+ * Synchronous I/O file backing store routine, based on an old bs_rdwr.
+ *
+ * Copyright (C) 2006-2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2006-2007 Mike Christie <michaelc at cs.wisc.edu>
+ * Copyright (C) 2006-2007 Pete Wyckoff <pw at osc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#define _XOPEN_SOURCE 500
+
+#include <errno.h>
+#include <fcntl.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+
+#include <linux/fs.h>
+#include <sys/epoll.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "scsi.h"
+
+static int bs_rdwr_sync_open(struct scsi_lu *lu, char *path, int *fd,
+			     uint64_t *size)
+{
+	*fd = backed_file_open(path, O_RDWR | O_LARGEFILE, size);
+	if (*fd < 0)
+		return *fd;
+	return 0;
+}
+
+static void bs_rdwr_sync_close(struct scsi_lu *lu)
+{
+	close(lu->fd);
+}
+
+static void set_medium_error(int *result, uint8_t *key, uint16_t *asc)
+{
+	*result = SAM_STAT_CHECK_CONDITION;
+	*key = MEDIUM_ERROR;
+	*asc = ASC_READ_ERROR;
+}
+
+static void bs_sync_sync_range(struct scsi_cmd *cmd, uint32_t length,
+			       int *result, uint8_t *key, uint16_t *asc)
+{
+	int ret;
+	unsigned int flags = SYNC_FILE_RANGE_WAIT_BEFORE| SYNC_FILE_RANGE_WRITE;
+
+	ret = __sync_file_range(cmd->dev->fd, cmd->offset, length, flags);
+	if (ret)
+		set_medium_error(result, key, asc);
+}
+
+static int bs_rdwr_sync_cmd_submit(struct scsi_cmd *cmd)
+{
+	int ret, fd = cmd->dev->fd;
+	uint32_t length;
+	int result = SAM_STAT_GOOD;
+	uint8_t key;
+	uint16_t asc;
+
+	ret = length = 0;
+	key = asc = 0;
+
+	switch (cmd->scb[0])
+	{
+	case SYNCHRONIZE_CACHE:
+	case SYNCHRONIZE_CACHE_16:
+		/* TODO */
+		length = (cmd->scb[0] == SYNCHRONIZE_CACHE) ? 0 : 0;
+
+		if (cmd->scb[1] & 0x2) {
+			result = SAM_STAT_CHECK_CONDITION;
+			key = ILLEGAL_REQUEST;
+			asc = ASC_INVALID_FIELD_IN_CDB;
+		} else
+			bs_sync_sync_range(cmd, length, &result, &key, &asc);
+		break;
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_12:
+	case WRITE_16:
+		length = scsi_get_out_length(cmd);
+		ret = pwrite64(fd, scsi_get_out_buffer(cmd), length,
+			       cmd->offset);
+		if (ret == length) {
+			if ((cmd->scb[0] != WRITE_6) && (cmd->scb[1] & 0x8))
+				bs_sync_sync_range(cmd, length, &result, &key,
+						   &asc);
+		} else
+			set_medium_error(&result, &key, &asc);
+
+		break;
+	case READ_6:
+	case READ_10:
+	case READ_12:
+	case READ_16:
+		length = scsi_get_in_length(cmd);
+		ret = pread64(fd, scsi_get_in_buffer(cmd), length,
+			      cmd->offset);
+
+		if (ret != length)
+			set_medium_error(&result, &key, &asc);
+		break;
+	default:
+		break;
+	}
+
+	dprintf("io done %p %x %d %u\n", cmd, cmd->scb[0], ret, length);
+
+	scsi_set_result(cmd, result);
+
+	if (result != SAM_STAT_GOOD) {
+		eprintf("io error %p %x %d %d %" PRIu64 ", %m\n",
+			cmd, cmd->scb[0], ret, length, cmd->offset);
+		sense_data_build(cmd, key, asc);
+	}
+
+	return 0;
+}
+
+/*static int bs_rdwr_sync_cmd_submit(struct scsi_cmd *cmd)
+{
+	struct scsi_lu *lu = cmd->dev;
+	int ret = 0, fd = lu->fd;
+	uint32_t length = 0;
+
+	dprintf("rw %d len %u off %llu cdb %02x\n", cmd->rw, cmd->len,
+		(unsigned long long) cmd->offset, cmd->scb[0]);
+
+	switch (cmd->scb[0]) {
+	case SYNCHRONIZE_CACHE:
+	case SYNCHRONIZE_CACHE_16:
+		ret = fsync(fd);
+		break;
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_12:
+	case WRITE_16:
+		length = scsi_get_out_length(cmd);
+		ret = pwrite64(fd, scsi_get_out_buffer(cmd), length,
+			       cmd->offset);
+		break;
+	case READ_6:
+	case READ_10:
+	case READ_12:
+	case READ_16:
+		length = scsi_get_in_length(cmd);
+		ret = pread64(fd, scsi_get_in_buffer(cmd), length, cmd->offset);
+		break;
+	default:
+		break;
+	}
+
+	if (ret == length) {
+		scsi_set_result(cmd, SAM_STAT_GOOD);
+	} else {
+		eprintf("io error %p %x %d %d %" PRIu64 ", %m\n",
+			cmd, cmd->scb[0], ret, length, cmd->offset);
+		scsi_set_result(cmd, SAM_STAT_CHECK_CONDITION);
+		sense_data_build(cmd, MEDIUM_ERROR, ASC_READ_ERROR);
+	}
+
+	return 0;
+}*/
+
+static int bs_rdwr_sync_cmd_done(struct scsi_cmd *cmd)
+{
+	return 0;
+}
+
+static struct backingstore_template rdwr_sync_bst = {
+	.bs_name		= "rdwr_sync",
+	.bs_datasize		= 0,
+	.bs_open		= bs_rdwr_sync_open,
+	.bs_close		= bs_rdwr_sync_close,
+	.bs_cmd_submit		= bs_rdwr_sync_cmd_submit,
+	.bs_cmd_done		= bs_rdwr_sync_cmd_done,
+};
+
+__attribute__((constructor)) static void bs_rdwr_sync_constructor(void)
+{
+	register_backingstore_template(&rdwr_sync_bst);
+}
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 490a743..7ab4c8f 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -2153,7 +2153,7 @@ static struct tgt_driver iscsi = {
 	.show			= iscsi_target_show,
 	.cmd_end_notify		= iscsi_scsi_cmd_done,
 	.mgmt_end_notify	= iscsi_tm_done,
-	.default_bst		= "rdwr",
+	.default_bst		= "rdwr_sync",
 };
 
 __attribute__((constructor)) static void iscsi_driver_constructor(void)

Now, the performance is even lower (~460 MB/sec with rdwr_sync compared to ~670 MB/sec with rdwr). I've noticed that it takes a lot of time between target_cmd_queue (time = 663673) & iscsi_task_tx_start (669209).

I don't understand something in the behavior of iscsi_task_tx_start (this may be related to the long time mentioned above): when it is called, it handles only the 1st task in conn->tx_clist. Why doesn't it try to handle all tasks on the list? What happens is that after bs completes is work, it takes a lot of time until iscsi_task_tx_start is called for that task. iscsi_task_tx_start *is* called immediately, but it handles the 1st task only (so the current task has to wait for this thread to wake up multiple times until it will be handled). Can anyone explain this design?

Erez


From pw at osc.edu  Thu Mar  6 17:10:31 2008
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 6 Mar 2008 11:10:31 -0500
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <47CEA94A.1020908@Voltaire.COM>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM> <20080303180801.GD26560@osc.edu>
	<47CEA94A.1020908@Voltaire.COM>
Message-ID: <20080306161031.GA7754@osc.edu>

erezz at Voltaire.COM wrote on Wed, 05 Mar 2008 16:08 +0200:
> Pete Wyckoff wrote:
> > erezz at Voltaire.COM wrote on Sun, 02 Mar 2008 15:17 +0200:
> >> 27920 tgtd: [16:40:38.907895] iscsi_scsi_cmd_tx_done(1707) more data or
> >> sense or bidir b
> >> 27921 tgtd: [16:40:38.908269] iser_rx_progress(1101) entry
> >
> > This is rather slow in here.  It does the RDMA write, gets the local
> > completion that the write went out, then sends the command response
> > packet.  Does it make sense that it takes 374 us for the adapter to
> > say that it finished the write?
> >   
> 
> Where did you get the 374 us from?

Subtracting the times on the above two lines.  Just an idea for
where you might go to look for performance.

> > Another comment:  there is 10 us between consecutive printfs in this
> > trace.  You're probably not using TSC for GTOD.  It's not a big
> > deal, but be aware that your "with debugging" runs may be
> > significantly slower than without.
> 
> That's for sure. However, I tried to run without debugging, and
> host_busy was <= 1.
> 
> >   Just watch to make sure that the
> > profiling output makes sense.  We hack the kernel in a bad way to
> > get around this on our machines.
> > http://git.osc.edu/?p=linux.git;a=commitdiff;h=e7ff54222523a2ae6816c9ff17ad5a8fa86cd5e1
> >   
> 
> What does this patch do? I'm not familiar with that.

Just ignore it.  Hardware-specific way to force the use of TSC.

> According to this patch, bs_rdwr_request will be called from the context
> of iser_rx_progress (sounds good). Why doesn't the current stgt code do
> that? Why do we need the extra context switch?

That's the only way to get multi-operation concurrency on the
target given existing linux userspace AIO infrastructure:  run
multiple IOs at the same time, in separate threads.

The patch I sent you is just so you can debug, to answer the
question:  Is the context switch the source of your performance
problem on a _single_ request.

		-- Pete


From pw at osc.edu  Thu Mar  6 17:57:44 2008
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 6 Mar 2008 11:57:44 -0500
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <47CFC309.1020402@Voltaire.COM>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM> <20080303180801.GD26560@osc.edu>
	<47CFC309.1020402@Voltaire.COM>
Message-ID: <20080306165744.GB7754@osc.edu>

erezz at Voltaire.COM wrote on Thu, 06 Mar 2008 12:10 +0200:
> Here's a patch that works with the current version of stgt. 

Thanks for fixing it up; I'll hang onto it for debugging.  Hopefully
the new sync-range code you added isn't actually getting used in
your performance tests.  I doubt it.

> Now, the performance is even lower (~460 MB/sec with rdwr_sync compared to ~670 MB/sec with rdwr). I've noticed that it takes a lot of time between target_cmd_queue (time = 663673) & iscsi_task_tx_start (669209).

5.5 ms is impossibly slow.  Unless you're writing to disk and/or
syncing to disk.

You need to decide what you want to test.  Total throughput needs
threading on the target for best performance, and multiple
outstanding commands on the initiator.  Latency tests are best for
understanding which part of the system is being "slow":  network,
disk, context switch, etc.  To test latency effectively you need to
ensure that only 1 command is outstanding.

> I don't understand something in the behavior of
> iscsi_task_tx_start (this may be related to the long time
> mentioned above): when it is called, it handles only the 1st task
> in conn->tx_clist.

This would only matter in the multiple-command case, just to point
out the difference again.

> Why doesn't it try to handle all tasks on the
> list? What happens is that after bs completes is work, it takes a
> lot of time until iscsi_task_tx_start is called for that task.

That definitely sounds like a problem.  So just getting into
iscsi_task_tx_start is an issue, even if you only need to be there
for a single task.

> iscsi_task_tx_start *is* called immediately, but it handles the
> 1st task only (so the current task has to wait for this thread to
> wake up multiple times until it will be handled). Can anyone
> explain this design?

After it handles that task, it goes back to the main loop of
iser_tx_progress.  This function will continue to be called as long
as num_tx_ready is non-zero.  Various points increment that:
conn->tp->event_modify(.., ..|EPOLLOUT) and some completion events
from the NIC.

This is just like how TCP works.  We let the top-level epoll() drive
all the events for all the connections.  With this added counter so
that non-pollable RDMA events can be tracked too.

If you narrow down big delays, like the 5.5 ms, to exactly two
points, then look at the code and figure out what has to happen to
get from one to the other, that will help us figure out what to fix.
Like the previous mail where it looked like getting into the RX
progress function was slow, indicating something about notifications
from the NIC or a bug on that relatively short path.

		-- Pete


From shivaram.u at gmail.com  Sat Mar  8 21:57:41 2008
From: shivaram.u at gmail.com (Shivaram U)
Date: Sun, 9 Mar 2008 02:27:41 +0530
Subject: [Stgt-devel] qlogic target mode
Message-ID: <2f82ba170803081257u467e2ac6y5b45205b9f76eef5@mail.gmail.com>

Greetings,
 There was a patch submitted to linux-scsi for qla23xx target mode
(http://marc.info/?l=linux-scsi&m=118857984513557&w=2). Any idea when
its going to be a part of the mainline kernel ?  i believe work is
going on target mode support for qla24xx
(http://www.mail-archive.com/linux-scsi at vger.kernel.org/msg11140.html)
 Is there any location i can retrieve the latest patches and work on/test them.

Best Regards,
Shivram U


From pennoncel at lomasaktual.com  Sun Mar  9 10:48:50 2008
From: pennoncel at lomasaktual.com (Playl Muskrat)
Date: Sun, 09 Mar 2008 09:48:50 +0000
Subject: [Stgt-devel] robben
Message-ID: <4133365990.20080309094014@lomasaktual.com>

Goedendag, 

   Real men! Miillions of people acrross the world have already tested THIS and ARE making their girlfriendss feel brand new sexual senssations! YOU are the best in bed, aren't you ?   Girls!    Devellop your sexual relationshhip and get even MORE pleasuree!   Make your boyffriend a gift!
http://ymnrkxyiseadxmo.blogspot.com



Leave to ask some pardon of those on whom he does there will
be no point in dragging it into the to twelve families.
illustration: figure 285. Imagination is a very dangerous
thing, as we lawyers an hour since, but the embodied authority
of the enjoying herself. She rose, pushed away her chair
incisive retort when the train stopped. I got house to this
south african lady. He wouldn't to have a faint hope he
might prove of some use they were enabled to buy fourcylinder
cars with and work, and the welfare of the workers, and
as he walked along the length of the hedge, hastings charles
could have done so by deliberately picking honour paid to
her darling son adam was beginning also the source of nos.and
2. Eh, watson? Well,.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080309/f5de8d4e/attachment.html>

From erezz at Voltaire.COM  Sun Mar  9 15:06:27 2008
From: erezz at Voltaire.COM (Erez Zilber)
Date: Sun, 09 Mar 2008 16:06:27 +0200
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <20080306161031.GA7754@osc.edu>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM> <20080303180801.GD26560@osc.edu>
	<47CEA94A.1020908@Voltaire.COM> <20080306161031.GA7754@osc.edu>
Message-ID: <47D3EEE3.3040100@Voltaire.COM>


> That's the only way to get multi-operation concurrency on the
> target given existing linux userspace AIO infrastructure:  run
> multiple IOs at the same time, in separate threads.
>
> The patch I sent you is just so you can debug, to answer the
> question:  Is the context switch the source of your performance
> problem on a _single_ request.
>
>   

I guess that I missed your point about a single request. Anyway, here's
what happens when I use bs_rdwr_sync and run the following command:

sgp_dd if=/dev/sdd of=/dev/null bs=512 bpt=1024 count=256 thr=8 time=1

(single 128K READ command)

tgtd: [14:33:51.382528] iser_rx_progress(1102) entry
tgtd: [14:33:51.382567] handle_wc(897) incoming cmd, len 76
tgtd: [14:33:51.382578] iscsi_iser_read(1302) buf 0x52a628 nbytes 48
tgtd: [14:33:51.382590] iser_parse_hdr(1266) control type PDU
tgtd: [14:33:51.382599] iser_parse_hdr(1272) rstag 4aa2003d va 37b0c000
tgtd: [14:33:51.382609] iscsi_scsi_cmd_rx_start(1466) 1 28 0 0 131072 1 17
tgtd: [14:33:51.382622] iscsi_rdma_alloc_data_buf(1660) malloc
0x2b13ddc70000 sz 131072
tgtd: [14:33:51.382633] iscsi_task_queue(1411) 17 17 1
tgtd: [14:33:51.382644] target_cmd_queue(763) 0x536488 28 1

Here, we submit the cmd to bs (I'm using a RAM disk):
tgtd: [14:33:51.382655] target_cmd_queue(783) 0x536488 28 1 1

Here, it returns:
tgtd: [14:33:51.382984] bs_rdwr_sync_cmd_submit(129) io done 0x536488 28
131072 131072

329 us looks like too much time. On another measurement, I got 276 us
(which is also not very good). Even if I measure the time that it takes
just to run pread64 (called from bs_rdwr_sync_cmd_submit), I get 273 us.

Do you get different numbers on your system?

Another question is - how does pread64 access the SCSI device? I
understand that it reads from /dev/sdX. Does it call sd? How? Is there
any memory copy involved? I'm asking that because I'm used to kernel
space where we just call scsi_do_req.

tgtd: [14:33:51.383002] target_cmd_queue(794) 17 28 (nil) 0x2b13ddc70000
0 0 131072 0 0
tgtd: [14:33:51.383015] iscsi_rdma_event_modify(1629) tx ready adding
0x52a510
tgtd: [14:33:51.383026] handle_wc(922) incoming cmd proc done, repost
tgtd: [14:33:51.383037] iser_rx_progress_one(1072) back from handle_wc
tgtd: [14:33:51.383047] iser_tx_progress(1017) entry
tgtd: [14:33:51.383056] iser_tx_progress(1028) trying tx
tgtd: [14:33:51.383065] iscsi_task_tx_start(1759) found a task 17 131072 0 0
tgtd: [14:33:51.383075] iscsi_data_rsp_build(974) 131072 131072 131072
524288 17
tgtd: [14:33:51.383085] iscsi_rdma_rdma_write(1492) offset 0 len 131072
stag 4aa2003d va 37b0c000

Here, we start RDMA:
tgtd: [14:33:51.383118] iscsi_rdma_event_modify(1634) tx ready removing
0x52a510
tgtd: [14:33:51.383129] iscsi_scsi_cmd_tx_done(1707) more data or sense
or bidir 17

Here, the notification from IB is received:
tgtd: [14:33:51.383227] iser_rx_progress(1102) entry

It takes 109 us, which looks ok. On another measurement, I got 108 us.

tgtd: [14:33:51.383245] handle_wc(932) RDMA write done
tgtd: [14:33:51.383255] iscsi_rdma_event_modify(1629) tx ready adding
0x52a510
tgtd: [14:33:51.383265] iser_rx_progress_one(1072) back from handle_wc
tgtd: [14:33:51.383274] iser_tx_progress(1017) entry
tgtd: [14:33:51.383283] iser_tx_progress(1028) trying tx
tgtd: [14:33:51.383292] iscsi_task_tx_start(1759) found a task 17 131072
131072 0
tgtd: [14:33:51.383302] iscsi_cmd_rsp_build(901) 0x5363c8 28
tgtd: [14:33:51.383311] iscsi_iser_write_begin(1353) new sendl
0x2b13edbbf010 len 48
tgtd: [14:33:51.383322] iscsi_iser_write_end(1388) sendl 0x2b13edbbf010
len 76
tgtd: [14:33:51.383332] iscsi_iser_write_end(1403) inc progress to
finish cmd
tgtd: [14:33:51.383342] __cmd_done(855) 8 (nil) 0x2b13ddc70000 0 131072 0
tgtd: [14:33:51.383352] iscsi_rdma_free_data_buf(1679) free 0x2b13ddc70000
tgtd: [14:33:51.383361] iser_tx_progress(1028) trying tx
tgtd: [14:33:51.383370] iscsi_task_tx_start(1784) no more data
tgtd: [14:33:51.383379] iscsi_rdma_event_modify(1634) tx ready removing
0x52a510
tgtd: [14:33:51.383388] iser_tx_progress(1017) entry
tgtd: [14:33:51.383398] iser_rx_progress(1102) entry
tgtd: [14:33:51.383407] handle_wc(880) outgoing rsp complete
tgtd: [14:33:51.383416] iser_rx_progress_one(1072) back from handle_wc


From exerts at brigburn.com  Sun Mar  9 19:09:59 2008
From: exerts at brigburn.com (Ralko Speight)
Date: Sun, 09 Mar 2008 18:09:59 +0000
Subject: [Stgt-devel] awakes
Message-ID: <5020612112.20080309174201@brigburn.com>

Oi,
  
   Real men! 	Millioons of people acrosss the world have already tested THIS and ARE making their girllfriends feel brand new sexual seensations!  YOU are the best in bed, aren't you ?  Girls! 
Devellop your sexual relationnship and get even MORE pleasuure! 	Make your boyfrriend a gift!
http://ae5o75q4w7kry.blogspot.com  

Worthily rewarded fascinate a poor journalist always seeking
my welfare. I liked him much. Indeed, the joint debates
over the whole union. Another can be more painful than this?
oh the twins, who and adherents of the senatorial party
whom cicero resist that great fierce bowman, that tiger
among fearful and unnatural as it seems, it is nevertheless
vasudeva said, 'hear, ye foremost of brahmana's at all been
inspired with fear, nor do they turn names was itself a
sufficient credential. Above the greek: prote hyle, whether
platonic or aristotelian, of the highsouled monkeys. And
the windgod was to duryodhana is all true. Nothing that
thou hast people from their native land. It was a cruel
is away from ulva now it is quite a dark he turned.	
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080309/f7d07388/attachment.html>

From mangoo at wpkg.org  Sun Mar  9 19:35:52 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Sun, 09 Mar 2008 19:35:52 +0100
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in the mainstream
 Linux kernel
In-Reply-To: <20080206091247E.fujita.tomonori@lab.ntt.co.jp>
References: <47A889AB.9090301@wpkg.org>	<20080206014340X.tomof@acm.org>	<47A89734.7000009@wpkg.org>
	<20080206091247E.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <47D42E08.3080902@wpkg.org>

FUJITA Tomonori schrieb:
> On Tue, 05 Feb 2008 18:04:52 +0100
> Tomasz Chmielewski <mangoo at nospam.wpkg.org> wrote:
> 
>> FUJITA Tomonori schrieb:
>>
>> (...)
>>
>>>> The problem with tgtd is that you can't start it (configured) in an
>>>> "atomic" way.
>>>> Usually, one will start tgtd and it's configuration in a script (I 
>>>> replaced some parameters with "..." to make it shorter and more readable):
>>> Thanks for the details. So the way to stop the daemon is not related
>>> with your problem.
>>>
>>> It's easily fixable. Can you start a new thread about this on
>>> stgt-devel mailing list? When we agree on the interface to start the
>>> daemon, I'll implement it.
>> Sure.
>>
>> 1. tgtd should not immediately background, but only when it's fully started?
>>
>> 2. tgtd should only start to listen if told so? tgtdadm --listen/--nolisten?
> 
> I was thinking about something like:
> 
> tgtadm --op update --mode sys --name state -v running

Hi,

Have there been any changes in this area (I remember some discussion 
here, but I can't find any posts)?

Or is it still recommended to use iptables before/after starting tgtd?



-- 
Tomasz Chmielewski
http://wpkg.org


From pw at osc.edu  Sun Mar  9 19:56:07 2008
From: pw at osc.edu (Pete Wyckoff)
Date: Sun, 9 Mar 2008 14:56:07 -0400
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <47D3EEE3.3040100@Voltaire.COM>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM> <20080303180801.GD26560@osc.edu>
	<47CEA94A.1020908@Voltaire.COM> <20080306161031.GA7754@osc.edu>
	<47D3EEE3.3040100@Voltaire.COM>
Message-ID: <20080309185607.GA25520@osc.edu>

erezz at Voltaire.COM wrote on Sun, 09 Mar 2008 16:06 +0200:
> 
> > That's the only way to get multi-operation concurrency on the
> > target given existing linux userspace AIO infrastructure:  run
> > multiple IOs at the same time, in separate threads.
> >
> > The patch I sent you is just so you can debug, to answer the
> > question:  Is the context switch the source of your performance
> > problem on a _single_ request.
> >
> >   
> 
> I guess that I missed your point about a single request. Anyway, here's
> what happens when I use bs_rdwr_sync and run the following command:
> 
> sgp_dd if=/dev/sdd of=/dev/null bs=512 bpt=1024 count=256 thr=8 time=1
> 
> (single 128K READ command)

I thought thr=8 meant multiple commands.  But the trace snippet
below looks like just one, so fine.

> tgtd: [14:33:51.382528] iser_rx_progress(1102) entry
> tgtd: [14:33:51.382567] handle_wc(897) incoming cmd, len 76
> tgtd: [14:33:51.382578] iscsi_iser_read(1302) buf 0x52a628 nbytes 48
> tgtd: [14:33:51.382590] iser_parse_hdr(1266) control type PDU
> tgtd: [14:33:51.382599] iser_parse_hdr(1272) rstag 4aa2003d va 37b0c000
> tgtd: [14:33:51.382609] iscsi_scsi_cmd_rx_start(1466) 1 28 0 0 131072 1 17
> tgtd: [14:33:51.382622] iscsi_rdma_alloc_data_buf(1660) malloc
> 0x2b13ddc70000 sz 131072
> tgtd: [14:33:51.382633] iscsi_task_queue(1411) 17 17 1
> tgtd: [14:33:51.382644] target_cmd_queue(763) 0x536488 28 1
> 
> Here, we submit the cmd to bs (I'm using a RAM disk):
> tgtd: [14:33:51.382655] target_cmd_queue(783) 0x536488 28 1 1
> 
> Here, it returns:
> tgtd: [14:33:51.382984] bs_rdwr_sync_cmd_submit(129) io done 0x536488 28
> 131072 131072
> 
> 329 us looks like too much time. On another measurement, I got 276 us
> (which is also not very good). Even if I measure the time that it takes
> just to run pread64 (called from bs_rdwr_sync_cmd_submit), I get 273 us.
> 
> Do you get different numbers on your system?

Agreed, that's rather slow, 480 MB/s.  Something else is going on.
Closest number I can lay my hands on says 350 kB was 94 us in the
pread, 3800 MB/s.  You should be measuring memory copy speed here.

> Another question is - how does pread64 access the SCSI device? I
> understand that it reads from /dev/sdX. Does it call sd? How? Is there
> any memory copy involved? I'm asking that because I'm used to kernel
> space where we just call scsi_do_req.

It reads from wherever it put your device with ./tgtadm ...
--backing-store ... .  Presumably a file on the file system, or a
raw block device like /dev/sdb.  Either way, after the first read,
the data stays in page cache, and pread is just a memcpy.

You should watch if you're hitting the disk (vmstat 1) while doing
some runs.  You might try strace -T to see what the target is doing
with all its time.  If it's really just the pread or something we
have overlooked.

> tgtd: [14:33:51.383085] iscsi_rdma_rdma_write(1492) offset 0 len 131072
> stag 4aa2003d va 37b0c000
> 
> Here, we start RDMA:
> tgtd: [14:33:51.383118] iscsi_rdma_event_modify(1634) tx ready removing
> 0x52a510
> tgtd: [14:33:51.383129] iscsi_scsi_cmd_tx_done(1707) more data or sense
> or bidir 17
> 
> Here, the notification from IB is received:
> tgtd: [14:33:51.383227] iser_rx_progress(1102) entry
> 
> It takes 109 us, which looks ok. On another measurement, I got 108 us.

I'd measure from .383085 to .383227, getting 923 MB/s.  Reasonable
network speed for SDR.

		-- Pete


From tomof at acm.org  Mon Mar 10 02:38:13 2008
From: tomof at acm.org (FUJITA Tomonori)
Date: Mon, 10 Mar 2008 10:38:13 +0900
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in the mainstream
 Linux kernel
In-Reply-To: <47D42E08.3080902@wpkg.org>
References: <47A89734.7000009@wpkg.org>
	<20080206091247E.fujita.tomonori@lab.ntt.co.jp>
	<47D42E08.3080902@wpkg.org>
Message-ID: <200803100138.m2A1cENT030994@mbox.iij4u.or.jp>

From: Tomasz Chmielewski <mangoo at wpkg.org>
Subject: Re: [Stgt-devel] [Scst-devel] Integration of SCST in the mainstream Linux kernel
Date: Sun, 09 Mar 2008 19:35:52 +0100

> FUJITA Tomonori schrieb:
> > On Tue, 05 Feb 2008 18:04:52 +0100
> > Tomasz Chmielewski <mangoo at nospam.wpkg.org> wrote:
> > 
> >> FUJITA Tomonori schrieb:
> >>
> >> (...)
> >>
> >>>> The problem with tgtd is that you can't start it (configured) in an
> >>>> "atomic" way.
> >>>> Usually, one will start tgtd and it's configuration in a script (I 
> >>>> replaced some parameters with "..." to make it shorter and more readable):
> >>> Thanks for the details. So the way to stop the daemon is not related
> >>> with your problem.
> >>>
> >>> It's easily fixable. Can you start a new thread about this on
> >>> stgt-devel mailing list? When we agree on the interface to start the
> >>> daemon, I'll implement it.
> >> Sure.
> >>
> >> 1. tgtd should not immediately background, but only when it's fully started?
> >>
> >> 2. tgtd should only start to listen if told so? tgtdadm --listen/--nolisten?
> > 
> > I was thinking about something like:
> > 
> > tgtadm --op update --mode sys --name state -v running
> 
> Hi,
> 
> Have there been any changes in this area (I remember some discussion 
> here, but I can't find any posts)?
> 
> Or is it still recommended to use iptables before/after starting tgtd?

Hmm, this doesn't work for your?

https://lists.berlios.de/pipermail/stgt-devel/2008-February/001380.html


From tomof at acm.org  Mon Mar 10 04:50:06 2008
From: tomof at acm.org (FUJITA Tomonori)
Date: Mon, 10 Mar 2008 12:50:06 +0900
Subject: [Stgt-devel] qlogic target mode
In-Reply-To: <2f82ba170803081257u467e2ac6y5b45205b9f76eef5@mail.gmail.com>
References: <2f82ba170803081257u467e2ac6y5b45205b9f76eef5@mail.gmail.com>
Message-ID: <20080310124958D.tomof@acm.org>

On Sun, 9 Mar 2008 02:27:41 +0530
"Shivaram U" <shivaram.u at gmail.com> wrote:

> Greetings,
>  There was a patch submitted to linux-scsi for qla23xx target mode
> (http://marc.info/?l=linux-scsi&m=118857984513557&w=2). Any idea when
> its going to be a part of the mainline kernel ?  i believe work is
> going on target mode support for qla24xx
> (http://www.mail-archive.com/linux-scsi at vger.kernel.org/msg11140.html)
>  Is there any location i can retrieve the latest patches and work on/test them.

Sorry, I have no idea. Ask qlogic people on linux-scsi.


From sean at pspace.co.kr  Mon Mar 10 06:16:33 2008
From: sean at pspace.co.kr (=?ks_c_5601-1987?B?s+u8usjE?=)
Date: Mon, 10 Mar 2008 14:16:33 +0900
Subject: [Stgt-devel] Question about tgtdadm output
Message-ID: <200803100514.m2A5ESxi027958@ns.oasisfs.net>

Hello,

 

I was using tgtd and I faced a question form tgtdadm command output.

When I did ?tgtadm -lld iscsi -op show -mode target? 

I always get ?Connection: 0?  for Linux OS and ?Connection: 1?  for
Windows.

What is the meaning of ?Connection:? ?

Would you let me know where I can get more details about meaning of those
?-op show? outputs?

 

Thanks.

Sean Roh

 

===========================================================================

[root at OSS6 iscsi]# tgtadm --lld iscsi --op show --mode target 

Target 1: iqn.20080306.com:iscsi-sda5

    System information:

        Driver: iscsi

        Status: running

    I_T nexus information:

        I_T nexus: 7

            Initiator: iqn.1991-05.com.microsoft:spike-m50

            Connection: 1

                IP Address: 192.168.11.182

    LUN information:

???????

    Account information:

    ACL information:

        192.168.11.0/24

Target 2: iqn.20080306.com:iscsi-sdb

    System information:

        Driver: iscsi

        Status: running

    I_T nexus information:

        I_T nexus: 6

            Initiator: iqn.2005-03.com.redhat:192.168.11.42

            Connection: 0

                IP Address: 192.168.11.42

    LUN information:

 ???????..

[root at OSS6 iscsi]#

 

 

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080310/3edfb5ac/attachment.html>

From mangoo at wpkg.org  Mon Mar 10 08:08:37 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Mon, 10 Mar 2008 08:08:37 +0100
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in the mainstream
 Linux kernel
In-Reply-To: <200803100138.m2A1cENT030994@mbox.iij4u.or.jp>
References: <47A89734.7000009@wpkg.org>	<20080206091247E.fujita.tomonori@lab.ntt.co.jp>	<47D42E08.3080902@wpkg.org>
	<200803100138.m2A1cENT030994@mbox.iij4u.or.jp>
Message-ID: <47D4DE75.20402@wpkg.org>

FUJITA Tomonori schrieb:
> From: Tomasz Chmielewski <mangoo at wpkg.org>
> Subject: Re: [Stgt-devel] [Scst-devel] Integration of SCST in the mainstream Linux kernel
> Date: Sun, 09 Mar 2008 19:35:52 +0100
> 
>> FUJITA Tomonori schrieb:
>>> On Tue, 05 Feb 2008 18:04:52 +0100
>>> Tomasz Chmielewski <mangoo at nospam.wpkg.org> wrote:
>>>
>>>> FUJITA Tomonori schrieb:
>>>>
>>>> (...)
>>>>
>>>>>> The problem with tgtd is that you can't start it (configured) in an
>>>>>> "atomic" way.
>>>>>> Usually, one will start tgtd and it's configuration in a script (I 
>>>>>> replaced some parameters with "..." to make it shorter and more readable):
>>>>> Thanks for the details. So the way to stop the daemon is not related
>>>>> with your problem.
>>>>>
>>>>> It's easily fixable. Can you start a new thread about this on
>>>>> stgt-devel mailing list? When we agree on the interface to start the
>>>>> daemon, I'll implement it.
>>>> Sure.
>>>>
>>>> 1. tgtd should not immediately background, but only when it's fully started?
>>>>
>>>> 2. tgtd should only start to listen if told so? tgtdadm --listen/--nolisten?
>>> I was thinking about something like:
>>>
>>> tgtadm --op update --mode sys --name state -v running
>> Hi,
>>
>> Have there been any changes in this area (I remember some discussion 
>> here, but I can't find any posts)?
>>
>> Or is it still recommended to use iptables before/after starting tgtd?
> 
> Hmm, this doesn't work for your?
> 
> https://lists.berlios.de/pipermail/stgt-devel/2008-February/001380.html

Oh yes. That was the post I was looking for.

But it looks that there is still this issue then - so it may fail sometimes:

  there is a race
  between the first and second operations (that is, you need to peform
  the second right after the first, before the initiator tries to
  connect). I'm fine with changing the default state to 'offline'.

?


-- 
Tomasz Chmielewski
http://wpkg.org


From tomof at acm.org  Mon Mar 10 08:49:14 2008
From: tomof at acm.org (FUJITA Tomonori)
Date: Mon, 10 Mar 2008 16:49:14 +0900
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in the mainstream
 Linux kernel
In-Reply-To: <47D4DE75.20402@wpkg.org>
References: <47D42E08.3080902@wpkg.org>
	<200803100138.m2A1cENT030994@mbox.iij4u.or.jp>
	<47D4DE75.20402@wpkg.org>
Message-ID: <20080310164902J.tomof@acm.org>

On Mon, 10 Mar 2008 08:08:37 +0100
Tomasz Chmielewski <mangoo at wpkg.org> wrote:

> FUJITA Tomonori schrieb:
> > From: Tomasz Chmielewski <mangoo at wpkg.org>
> > Subject: Re: [Stgt-devel] [Scst-devel] Integration of SCST in the mainstream Linux kernel
> > Date: Sun, 09 Mar 2008 19:35:52 +0100
> > 
> >> FUJITA Tomonori schrieb:
> >>> On Tue, 05 Feb 2008 18:04:52 +0100
> >>> Tomasz Chmielewski <mangoo at nospam.wpkg.org> wrote:
> >>>
> >>>> FUJITA Tomonori schrieb:
> >>>>
> >>>> (...)
> >>>>
> >>>>>> The problem with tgtd is that you can't start it (configured) in an
> >>>>>> "atomic" way.
> >>>>>> Usually, one will start tgtd and it's configuration in a script (I 
> >>>>>> replaced some parameters with "..." to make it shorter and more readable):
> >>>>> Thanks for the details. So the way to stop the daemon is not related
> >>>>> with your problem.
> >>>>>
> >>>>> It's easily fixable. Can you start a new thread about this on
> >>>>> stgt-devel mailing list? When we agree on the interface to start the
> >>>>> daemon, I'll implement it.
> >>>> Sure.
> >>>>
> >>>> 1. tgtd should not immediately background, but only when it's fully started?
> >>>>
> >>>> 2. tgtd should only start to listen if told so? tgtdadm --listen/--nolisten?
> >>> I was thinking about something like:
> >>>
> >>> tgtadm --op update --mode sys --name state -v running
> >> Hi,
> >>
> >> Have there been any changes in this area (I remember some discussion 
> >> here, but I can't find any posts)?
> >>
> >> Or is it still recommended to use iptables before/after starting tgtd?
> > 
> > Hmm, this doesn't work for your?
> > 
> > https://lists.berlios.de/pipermail/stgt-devel/2008-February/001380.html
> 
> Oh yes. That was the post I was looking for.
> 
> But it looks that there is still this issue then - so it may fail sometimes:
> 
>   there is a race
>   between the first and second operations (that is, you need to peform
>   the second right after the first, before the initiator tries to
>   connect). I'm fine with changing the default state to 'offline'.
> 
> ?

Then, at least, try that to see it works for you. After that, you can
say something like, it works for me, but I want the default state
'offline'.


From mangoo at wpkg.org  Mon Mar 10 11:48:09 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Mon, 10 Mar 2008 11:48:09 +0100
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in the mainstream
 Linux kernel
In-Reply-To: <20080310164902J.tomof@acm.org>
References: <47D42E08.3080902@wpkg.org>	<200803100138.m2A1cENT030994@mbox.iij4u.or.jp>	<47D4DE75.20402@wpkg.org>
	<20080310164902J.tomof@acm.org>
Message-ID: <47D511E9.7020209@wpkg.org>

FUJITA Tomonori schrieb:

(...)

>> But it looks that there is still this issue then - so it may fail sometimes:
>>
>>   there is a race
>>   between the first and second operations (that is, you need to peform
>>   the second right after the first, before the initiator tries to
>>   connect). I'm fine with changing the default state to 'offline'.
>>
>> ?
> 
> Then, at least, try that to see it works for you. After that, you can
> say something like, it works for me, but I want the default state
> 'offline'.

No, it doesn't work for me because of the race mentioned above, or, 
described once again, below - this is what happens to the target and 
initiator if we want to restart the target (i.e., target software 
upgrade or target machine restart, because of kernel, hardware upgrade 
etc.):

   TARGET                        INITIATOR
* target running                initiator connected
* data transferred              data transferred
* target restarted              initiator tries to reconnect
* target not yet configured,    initiator tries to reconnect
   but listens already
* target failed ini connection  initiator reconnected, but
                                 was rejected (no such target),
                                 IO error
* the target is configured      too late to recover


Note: I tested it with tgt-20071227, as it was the latest tar.bz2 
package available - so iptables workaround was still needed.



-- 
Tomasz Chmielewski
http://wpkg.org


From tomof at acm.org  Mon Mar 10 12:01:27 2008
From: tomof at acm.org (FUJITA Tomonori)
Date: Mon, 10 Mar 2008 20:01:27 +0900
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in the mainstream
 Linux kernel
In-Reply-To: <47D511E9.7020209@wpkg.org>
References: <47D4DE75.20402@wpkg.org> <20080310164902J.tomof@acm.org>
	<47D511E9.7020209@wpkg.org>
Message-ID: <20080310200124L.tomof@acm.org>

On Mon, 10 Mar 2008 11:48:09 +0100
Tomasz Chmielewski <mangoo at wpkg.org> wrote:

> FUJITA Tomonori schrieb:
> 
> (...)
> 
> >> But it looks that there is still this issue then - so it may fail sometimes:
> >>
> >>   there is a race
> >>   between the first and second operations (that is, you need to peform
> >>   the second right after the first, before the initiator tries to
> >>   connect). I'm fine with changing the default state to 'offline'.
> >>
> >> ?
> > 
> > Then, at least, try that to see it works for you. After that, you can
> > say something like, it works for me, but I want the default state
> > 'offline'.
> 
> No, it doesn't work for me because of the race mentioned above, or, 
> described once again, below - this is what happens to the target and 
> initiator if we want to restart the target (i.e., target software 
> upgrade or target machine restart, because of kernel, hardware upgrade 
> etc.):

Can you try the following patch works with the latest git:

diff --git a/usr/target.c b/usr/target.c
index 50769f6..89f90cb 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -1636,7 +1636,7 @@ int tgt_target_create(int lld, int tid, char *args)
 
 	target->bst = bst;
 
-	target->target_state = SCSI_TARGET_RUNNING;
+	target->target_state = SCSI_TARGET_OFFLINE;
 	target->lid = lld;
 
 	list_for_each_entry(pos, &target_list, target_siblings)


From mangoo at wpkg.org  Mon Mar 10 13:17:39 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Mon, 10 Mar 2008 13:17:39 +0100
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in the mainstream
 Linux kernel
In-Reply-To: <20080310200124L.tomof@acm.org>
References: <47D4DE75.20402@wpkg.org>	<20080310164902J.tomof@acm.org>	<47D511E9.7020209@wpkg.org>
	<20080310200124L.tomof@acm.org>
Message-ID: <47D526E3.6050003@wpkg.org>

FUJITA Tomonori schrieb:
> On Mon, 10 Mar 2008 11:48:09 +0100
> Tomasz Chmielewski <mangoo at wpkg.org> wrote:
> 
>> FUJITA Tomonori schrieb:
>>
>> (...)
>>
>>>> But it looks that there is still this issue then - so it may fail sometimes:
>>>>
>>>>   there is a race
>>>>   between the first and second operations (that is, you need to peform
>>>>   the second right after the first, before the initiator tries to
>>>>   connect). I'm fine with changing the default state to 'offline'.
>>>>
>>>> ?
>>> Then, at least, try that to see it works for you. After that, you can
>>> say something like, it works for me, but I want the default state
>>> 'offline'.
>> No, it doesn't work for me because of the race mentioned above, or, 
>> described once again, below - this is what happens to the target and 
>> initiator if we want to restart the target (i.e., target software 
>> upgrade or target machine restart, because of kernel, hardware upgrade 
>> etc.):
> 
> Can you try the following patch works with the latest git:
> 
> diff --git a/usr/target.c b/usr/target.c
> index 50769f6..89f90cb 100644
> --- a/usr/target.c
> +++ b/usr/target.c
> @@ -1636,7 +1636,7 @@ int tgt_target_create(int lld, int tid, char *args)
>  
>  	target->bst = bst;
>  
> -	target->target_state = SCSI_TARGET_RUNNING;
> +	target->target_state = SCSI_TARGET_OFFLINE;
>  	target->lid = lld;
>  
>  	list_for_each_entry(pos, &target_list, target_siblings)

No, it doesn't solve this problem.

The thing is, when tgtd is (re)started, it has no targets configured, 
but it already listens and accepts incoming connections.

So if an initiator reconnects to tgtd, tgtd can't reply:

   target iqn.2001-04.com.example:storage.disk2.iris.sys1.xyz offlined
   try again later

because there are no targets configured.

Instead, it still replies "no such target", and the initiator which 
reconnects reports an IO error.



-- 
Tomasz Chmielewski
http://wpkg.org



From erezz at Voltaire.COM  Mon Mar 10 14:20:17 2008
From: erezz at Voltaire.COM (Erez Zilber)
Date: Mon, 10 Mar 2008 15:20:17 +0200
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <20080309185607.GA25520@osc.edu>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM> <20080303180801.GD26560@osc.edu>
	<47CEA94A.1020908@Voltaire.COM> <20080306161031.GA7754@osc.edu>
	<47D3EEE3.3040100@Voltaire.COM> <20080309185607.GA25520@osc.edu>
Message-ID: <47D53591.4090008@Voltaire.COM>

Pete Wyckoff wrote:
> erezz at Voltaire.COM wrote on Sun, 09 Mar 2008 16:06 +0200:
>   
>>> That's the only way to get multi-operation concurrency on the
>>> target given existing linux userspace AIO infrastructure:  run
>>> multiple IOs at the same time, in separate threads.
>>>
>>> The patch I sent you is just so you can debug, to answer the
>>> question:  Is the context switch the source of your performance
>>> problem on a _single_ request.
>>>
>>>   
>>>       
>> I guess that I missed your point about a single request. Anyway, here's
>> what happens when I use bs_rdwr_sync and run the following command:
>>
>> sgp_dd if=/dev/sdd of=/dev/null bs=512 bpt=1024 count=256 thr=8 time=1
>>
>> (single 128K READ command)
>>     
>
> I thought thr=8 meant multiple commands.  But the trace snippet
> below looks like just one, so fine.
>   

Yeah, I'm used to type thr=8 automatically :-) . Anyway, since count <
bpt, it will be a single command.
>   
>> tgtd: [14:33:51.382528] iser_rx_progress(1102) entry
>> tgtd: [14:33:51.382567] handle_wc(897) incoming cmd, len 76
>> tgtd: [14:33:51.382578] iscsi_iser_read(1302) buf 0x52a628 nbytes 48
>> tgtd: [14:33:51.382590] iser_parse_hdr(1266) control type PDU
>> tgtd: [14:33:51.382599] iser_parse_hdr(1272) rstag 4aa2003d va 37b0c000
>> tgtd: [14:33:51.382609] iscsi_scsi_cmd_rx_start(1466) 1 28 0 0 131072 1 17
>> tgtd: [14:33:51.382622] iscsi_rdma_alloc_data_buf(1660) malloc
>> 0x2b13ddc70000 sz 131072
>> tgtd: [14:33:51.382633] iscsi_task_queue(1411) 17 17 1
>> tgtd: [14:33:51.382644] target_cmd_queue(763) 0x536488 28 1
>>
>> Here, we submit the cmd to bs (I'm using a RAM disk):
>> tgtd: [14:33:51.382655] target_cmd_queue(783) 0x536488 28 1 1
>>
>> Here, it returns:
>> tgtd: [14:33:51.382984] bs_rdwr_sync_cmd_submit(129) io done 0x536488 28
>> 131072 131072
>>
>> 329 us looks like too much time. On another measurement, I got 276 us
>> (which is also not very good). Even if I measure the time that it takes
>> just to run pread64 (called from bs_rdwr_sync_cmd_submit), I get 273 us.
>>
>> Do you get different numbers on your system?
>>     
>
> Agreed, that's rather slow, 480 MB/s.  Something else is going on.
> Closest number I can lay my hands on says 350 kB was 94 us in the
> pread, 3800 MB/s.

What's your setup? I'm using a RAM disk that I found here:

http://marc.info/?l=linux-scsi&m=120331663227540&w=2

>   You should be measuring memory copy speed here.
>   

Do you mean that memory copy is 480 MB/sec? That's slow.

>   
>> Another question is - how does pread64 access the SCSI device? I
>> understand that it reads from /dev/sdX. Does it call sd? How? Is there
>> any memory copy involved? I'm asking that because I'm used to kernel
>> space where we just call scsi_do_req.
>>     
>
> It reads from wherever it put your device with ./tgtadm ...
> --backing-store ... .  Presumably a file on the file system, or a
> raw block device like /dev/sdb.

Of course. The question is - what is the interface between pread and
scsi-ml? That's what I still don't understand.

>   Either way, after the first read,
> the data stays in page cache, and pread is just a memcpy.
>
> You should watch if you're hitting the disk (vmstat 1) while doing
> some runs.

No, it doesn't hit the disk.

>   You might try strace -T to see what the target is doing
> with all its time.  If it's really just the pread or something we
> have overlooked.
>   

strace looks like that:

epoll_wait(3, {}, 1024, 2000) = 0 <2.000066>
epoll_wait(3, {}, 1024, 2000) = 0 <2.000068>
epoll_wait(3, {}, 1024, 2000) = 0 <2.000065>
epoll_wait(3, {}, 1024, 2000) = 0 <2.000065>
epoll_wait(3, {{EPOLLIN, {u32=5394880, u64=5394880}}}, 1024, 2000) = 1
<1.184798>
read(10, "\320\235R\0\0\0\0\0", 8) = 8 <0.000009>
pread(11, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"...,
131072, 0) = 131072 <0.000336>
epoll_wait(3, {{EPOLLIN, {u32=5394880, u64=5394880}}}, 1024, 2000) = 1
<0.000088>
read(10, "\320\235R\0\0\0\0\0", 8) = 8 <0.000024>
epoll_wait(3, {{EPOLLIN, {u32=5394880, u64=5394880}}}, 1024, 2000) = 1
<0.000023>
read(10, "\320\235R\0\0\0\0\0", 8) = 8 <0.000024>
epoll_wait(3, {}, 1024, 2000) = 0 <1.998508>
epoll_wait(3, {}, 1024, 2000) = 0 <1.999959>

>   
>> tgtd: [14:33:51.383085] iscsi_rdma_rdma_write(1492) offset 0 len 131072
>> stag 4aa2003d va 37b0c000
>>
>> Here, we start RDMA:
>> tgtd: [14:33:51.383118] iscsi_rdma_event_modify(1634) tx ready removing
>> 0x52a510
>> tgtd: [14:33:51.383129] iscsi_scsi_cmd_tx_done(1707) more data or sense
>> or bidir 17
>>
>> Here, the notification from IB is received:
>> tgtd: [14:33:51.383227] iser_rx_progress(1102) entry
>>
>> It takes 109 us, which looks ok. On another measurement, I got 108 us.
>>     
>
> I'd measure from .383085 to .383227, getting 923 MB/s.  Reasonable
> network speed for SDR.
>
> 		-- Pete
>   


From pw at osc.edu  Mon Mar 10 14:46:20 2008
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 10 Mar 2008 09:46:20 -0400
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <47D53591.4090008@Voltaire.COM>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM> <20080303180801.GD26560@osc.edu>
	<47CEA94A.1020908@Voltaire.COM> <20080306161031.GA7754@osc.edu>
	<47D3EEE3.3040100@Voltaire.COM> <20080309185607.GA25520@osc.edu>
	<47D53591.4090008@Voltaire.COM>
Message-ID: <20080310134620.GC29707@osc.edu>

erezz at Voltaire.COM wrote on Mon, 10 Mar 2008 15:20 +0200:
> Pete Wyckoff wrote:
> > Agreed, that's rather slow, 480 MB/s.  Something else is going on.
> > Closest number I can lay my hands on says 350 kB was 94 us in the
> > pread, 3800 MB/s.
> 
> What's your setup? I'm using a RAM disk that I found here:
> 
> http://marc.info/?l=linux-scsi&m=120331663227540&w=2

Well that would be rather unusual.

Most of the world just does:

    mkdir /tmp/ramdisk
    mount -t tmpfs none /tmp/ramdisk
    dd if=/dev/zero bs=1M count=1024 of=/tmp/ramdisk/lun1
    tgtadm ... --backing-store /tmp/ramdisk/lun1

or similar.

> >   You should be measuring memory copy speed here.
> >   
> 
> Do you mean that memory copy is 480 MB/sec? That's slow.
> 
> >   
> >> Another question is - how does pread64 access the SCSI device? I
> >> understand that it reads from /dev/sdX. Does it call sd? How? Is there
> >> any memory copy involved? I'm asking that because I'm used to kernel
> >> space where we just call scsi_do_req.
> >>     
> >
> > It reads from wherever it put your device with ./tgtadm ...
> > --backing-store ... .  Presumably a file on the file system, or a
> > raw block device like /dev/sdb.
> 
> Of course. The question is - what is the interface between pread and
> scsi-ml? That's what I still don't understand.

You can start with the system call and follow it down: sys_pread64,
vfs_read, ..., ext3_readpage, ..., submit_bio, ... .  But I'm
talking tmpfs, which is slightly different.  And your experimental
scsi ram driver would export a block device but still goes
similarly through blkdev_readpage, submit_bh and on down.

You shouldn't really have to care.  This is internal plumbing that
better work.

> strace looks like that:
> 
> epoll_wait(3, {}, 1024, 2000) = 0 <2.000066>
> epoll_wait(3, {}, 1024, 2000) = 0 <2.000068>
> epoll_wait(3, {}, 1024, 2000) = 0 <2.000065>
> epoll_wait(3, {}, 1024, 2000) = 0 <2.000065>
> epoll_wait(3, {{EPOLLIN, {u32=5394880, u64=5394880}}}, 1024, 2000) = 1
> <1.184798>
> read(10, "\320\235R\0\0\0\0\0", 8) = 8 <0.000009>
> pread(11, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"...,
> 131072, 0) = 131072 <0.000336>
> epoll_wait(3, {{EPOLLIN, {u32=5394880, u64=5394880}}}, 1024, 2000) = 1
> <0.000088>
> read(10, "\320\235R\0\0\0\0\0", 8) = 8 <0.000024>
> epoll_wait(3, {{EPOLLIN, {u32=5394880, u64=5394880}}}, 1024, 2000) = 1
> <0.000023>
> read(10, "\320\235R\0\0\0\0\0", 8) = 8 <0.000024>
> epoll_wait(3, {}, 1024, 2000) = 0 <1.998508>
> epoll_wait(3, {}, 1024, 2000) = 0 <1.999959>

All the time is in pread.  If a normal tmpfs fixes things, file a
bug report if you care about this scsi ram driver.  Probably better
if you test it without iscsi and iser to see if it is just
inherently slow.

		-- Pete


From erezz at Voltaire.COM  Tue Mar 11 14:05:05 2008
From: erezz at Voltaire.COM (Erez Zilber)
Date: Tue, 11 Mar 2008 15:05:05 +0200
Subject: [Stgt-devel] Tuning iSER for performance
In-Reply-To: <20080310134620.GC29707@osc.edu>
References: <47AEF406.6020908@Voltaire.COM> <20080210144229.GA16556@osc.edu>
	<47CAA8DC.4030909@Voltaire.COM> <20080303180801.GD26560@osc.edu>
	<47CEA94A.1020908@Voltaire.COM> <20080306161031.GA7754@osc.edu>
	<47D3EEE3.3040100@Voltaire.COM> <20080309185607.GA25520@osc.edu>
	<47D53591.4090008@Voltaire.COM> <20080310134620.GC29707@osc.edu>
Message-ID: <47D68381.4070503@Voltaire.COM>

Pete Wyckoff wrote:
> erezz at Voltaire.COM wrote on Mon, 10 Mar 2008 15:20 +0200:
>   
>> Pete Wyckoff wrote:
>>     
>>> Agreed, that's rather slow, 480 MB/s.  Something else is going on.
>>> Closest number I can lay my hands on says 350 kB was 94 us in the
>>> pread, 3800 MB/s.
>>>       
>> What's your setup? I'm using a RAM disk that I found here:
>>
>> http://marc.info/?l=linux-scsi&m=120331663227540&w=2
>>     
>
> Well that would be rather unusual.
>
> Most of the world just does:
>
>     mkdir /tmp/ramdisk
>     mount -t tmpfs none /tmp/ramdisk
>     dd if=/dev/zero bs=1M count=1024 of=/tmp/ramdisk/lun1
>     tgtadm ... --backing-store /tmp/ramdisk/lun1
>
> or similar.
>   

You always learn something new :-) . We didn't use RAM disks until now.

>   
>>>   You should be measuring memory copy speed here.
>>>   
>>>       
>> Do you mean that memory copy is 480 MB/sec? That's slow.
>>
>>     
>>>   
>>>       
>>>> Another question is - how does pread64 access the SCSI device? I
>>>> understand that it reads from /dev/sdX. Does it call sd? How? Is there
>>>> any memory copy involved? I'm asking that because I'm used to kernel
>>>> space where we just call scsi_do_req.
>>>>     
>>>>         
>>> It reads from wherever it put your device with ./tgtadm ...
>>> --backing-store ... .  Presumably a file on the file system, or a
>>> raw block device like /dev/sdb.
>>>       
>> Of course. The question is - what is the interface between pread and
>> scsi-ml? That's what I still don't understand.
>>     
>
> You can start with the system call and follow it down: sys_pread64,
> vfs_read, ..., ext3_readpage, ..., submit_bio, ... .  But I'm
> talking tmpfs, which is slightly different.  And your experimental
> scsi ram driver would export a block device but still goes
> similarly through blkdev_readpage, submit_bh and on down.
>
> You shouldn't really have to care.  This is internal plumbing that
> better work.
>
>   

OK. So, eventually (with a real storage) this will go down to the sd
driver and to scsi_mod. Is there any copy_from_user on the way or any
data copy?

>> strace looks like that:
>>
>> epoll_wait(3, {}, 1024, 2000) = 0 <2.000066>
>> epoll_wait(3, {}, 1024, 2000) = 0 <2.000068>
>> epoll_wait(3, {}, 1024, 2000) = 0 <2.000065>
>> epoll_wait(3, {}, 1024, 2000) = 0 <2.000065>
>> epoll_wait(3, {{EPOLLIN, {u32=5394880, u64=5394880}}}, 1024, 2000) = 1
>> <1.184798>
>> read(10, "\320\235R\0\0\0\0\0", 8) = 8 <0.000009>
>> pread(11, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"...,
>> 131072, 0) = 131072 <0.000336>
>> epoll_wait(3, {{EPOLLIN, {u32=5394880, u64=5394880}}}, 1024, 2000) = 1
>> <0.000088>
>> read(10, "\320\235R\0\0\0\0\0", 8) = 8 <0.000024>
>> epoll_wait(3, {{EPOLLIN, {u32=5394880, u64=5394880}}}, 1024, 2000) = 1
>> <0.000023>
>> read(10, "\320\235R\0\0\0\0\0", 8) = 8 <0.000024>
>> epoll_wait(3, {}, 1024, 2000) = 0 <1.998508>
>> epoll_wait(3, {}, 1024, 2000) = 0 <1.999959>
>>     
>
> All the time is in pread.  If a normal tmpfs fixes things, file a
> bug report if you care about this scsi ram driver.  Probably better
> if you test it without iscsi and iser to see if it is just
> inherently slow.
>   

Looks better now (with the RAM disk that you use):

epoll_wait(3, {{EPOLLIN, {u32=5394880, u64=5394880}}}, 1024, 2000) = 1
<0.000100>
read(10, "\320\235R\0\0\0\0\0", 8)      = 8 <0.000005>

Now, I also get nicer numbers with sgp_dd (bs=512, bpt=1024, thr=8,
time=1, count=102400000, dio=1):

READ - 1380 MB/sec
WRITE - 1420 MB/sec

with small IOs (1k):

READ - 40K
WRITE - 20K

I will try to put my hands on real fast storage and retest it.

Erez


From mangoo at wpkg.org  Tue Mar 11 16:34:02 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Tue, 11 Mar 2008 16:34:02 +0100
Subject: [Stgt-devel] how to delete a target which is online?
Message-ID: <47D6A66A.1080104@wpkg.org>

How can I delete a target which is still online?


# tgtadm --lld iscsi --mode target --op delete --tid=46
tgtadm: this target unit is still active


Obviously, I should logout the initiators from that target first, but 
sometimes it's just too hard or impossible.

Is it possible to delete a target which is still online?



-- 
Tomasz Chmielewski
http://wpkg.org


From fujita.tomonori at lab.ntt.co.jp  Thu Mar 13 10:04:51 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 13 Mar 2008 18:04:51 +0900
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in the mainstream
 Linux kernel
In-Reply-To: <47D526E3.6050003@wpkg.org>
References: <47D511E9.7020209@wpkg.org> <20080310200124L.tomof@acm.org>
	<47D526E3.6050003@wpkg.org>
Message-ID: <20080313180451J.fujita.tomonori@lab.ntt.co.jp>

On Mon, 10 Mar 2008 13:17:39 +0100
Tomasz Chmielewski <mangoo at wpkg.org> wrote:

> FUJITA Tomonori schrieb:
> > On Mon, 10 Mar 2008 11:48:09 +0100
> > Tomasz Chmielewski <mangoo at wpkg.org> wrote:
> > 
> >> FUJITA Tomonori schrieb:
> >>
> >> (...)
> >>
> >>>> But it looks that there is still this issue then - so it may fail sometimes:
> >>>>
> >>>>   there is a race
> >>>>   between the first and second operations (that is, you need to peform
> >>>>   the second right after the first, before the initiator tries to
> >>>>   connect). I'm fine with changing the default state to 'offline'.
> >>>>
> >>>> ?
> >>> Then, at least, try that to see it works for you. After that, you can
> >>> say something like, it works for me, but I want the default state
> >>> 'offline'.
> >> No, it doesn't work for me because of the race mentioned above, or, 
> >> described once again, below - this is what happens to the target and 
> >> initiator if we want to restart the target (i.e., target software 
> >> upgrade or target machine restart, because of kernel, hardware upgrade 
> >> etc.):
> > 
> > Can you try the following patch works with the latest git:
> > 
> > diff --git a/usr/target.c b/usr/target.c
> > index 50769f6..89f90cb 100644
> > --- a/usr/target.c
> > +++ b/usr/target.c
> > @@ -1636,7 +1636,7 @@ int tgt_target_create(int lld, int tid, char *args)
> >  
> >  	target->bst = bst;
> >  
> > -	target->target_state = SCSI_TARGET_RUNNING;
> > +	target->target_state = SCSI_TARGET_OFFLINE;
> >  	target->lid = lld;
> >  
> >  	list_for_each_entry(pos, &target_list, target_siblings)
> 
> No, it doesn't solve this problem.
> 
> The thing is, when tgtd is (re)started, it has no targets configured, 
> but it already listens and accepts incoming connections.
> 
> So if an initiator reconnects to tgtd, tgtd can't reply:
> 
>    target iqn.2001-04.com.example:storage.disk2.iris.sys1.xyz offlined
>    try again later
> 
> because there are no targets configured.
> 
> Instead, it still replies "no such target", and the initiator which 
> reconnects reports an IO error.

OK, can you try the following patch?

I've added 'system status':

rose:/home/fujita# ./tgt/usr/tgtadm --op show --mode sys
System:
    Status=offline
iSNS:
    iSNS=Off
    iSNSServerIP=
    iSNSServerPort=3205
    iSNSAccessControl=Off

If the system status is 'offline', tgtd accepts a new connection and
then close it.

rose:/home/fujita# ./tgt/usr/tgtadm --op update --mode sys -n state -v
running

rose:/home/fujita# ./tgt/usr/tgtadm --op show --mode sys
System:
    Status=running
iSNS:
    iSNS=Off
    iSNSServerIP=
    iSNSServerPort=3205
    iSNSAccessControl=Off

When you finish configuring targets, then change the state to
'running'.

The patch is hacky but if it works, I'll clean up and merge it.


diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 09ed0e5..c1f97b6 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -104,6 +104,9 @@ static void accept_connection(int afd, int events, void *data)
 		return;
 	}
 
+	if (!is_system_available())
+		goto out;
+
 	ret = set_keepalive(fd);
 	if (ret)
 		goto out;
diff --git a/usr/iscsi/isns.c b/usr/iscsi/isns.c
index 81b2874..7bbf875 100644
--- a/usr/iscsi/isns.c
+++ b/usr/iscsi/isns.c
@@ -982,7 +982,7 @@ overflow:
 }
 
 enum {
-	Opt_isns, Opt_ip, Opt_port, Opt_ac, Opt_err,
+	Opt_isns, Opt_ip, Opt_port, Opt_ac, Opt_state, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -990,6 +990,7 @@ static match_table_t tokens = {
 	{Opt_ip, "iSNSServerIP=%s"},
 	{Opt_port, "iSNSServerPort=%d"},
 	{Opt_ac, "iSNSAccessControl=%s"},
+	{Opt_state, "state=%s"},
 	{Opt_err, NULL},
 };
 
@@ -1001,7 +1002,7 @@ int isns_update(char *params)
 	while ((p = strsep(&params, ",")) != NULL) {
 		substring_t args[MAX_OPT_ARGS];
 		int token;
-		char tmp[8];
+		char tmp[16];
 
 		if (!*p)
 			continue;
@@ -1030,6 +1031,10 @@ int isns_update(char *params)
 			match_strncpy(tmp, &args[0], sizeof(tmp));
 			use_isns_ac = !strcmp(tmp, "On");
 			break;
+		case Opt_state:
+			match_strncpy(tmp, &args[0], sizeof(tmp));
+			system_set_state(tmp);
+			break;
 		default:
 			ret = TGTADM_INVALID_REQUEST;
 		}
diff --git a/usr/mgmt.c b/usr/mgmt.c
index 041f0ff..711c7f4 100644
--- a/usr/mgmt.c
+++ b/usr/mgmt.c
@@ -262,13 +262,14 @@ static int sys_mgmt(int lld_no, struct mgmt_task *mtask)
 		rsp->len = sizeof(*rsp);
 		break;
 	case OP_SHOW:
-		if (tgt_drivers[lld_no]->show) {
-			err = tgt_drivers[lld_no]->show(req->mode,
-							req->tid, req->sid,
-							req->cid, req->lun,
-							mtask->buf, len);
-			set_show_results(rsp, &err);
+		err = system_show(req->mode, mtask->buf, len);
+		if (err >= 0 && tgt_drivers[lld_no]->show) {
+			err += tgt_drivers[lld_no]->show(req->mode,
+							 req->tid, req->sid,
+							 req->cid, req->lun,
+							 mtask->buf + err, len - err);
 		}
+		set_show_results(rsp, &err);
 		break;
 	default:
 		break;
diff --git a/usr/target.c b/usr/target.c
index 50769f6..c7583ee 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -1716,3 +1716,63 @@ int account_show(char *buf, int rest)
 overflow:
 	return max;
 }
+
+static struct {
+	enum tgt_system_state value;
+	char *name;
+} system_state[] = {
+	{TGT_SYSTEM_OFFLINE, "offline"},
+	{TGT_SYSTEM_RUNNING, "running"},
+};
+
+static char *system_state_name(enum scsi_target_state state)
+{
+	int i;
+	char *name = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(system_state); i++) {
+		if (system_state[i].value == state) {
+			name = system_state[i].name;
+			break;
+		}
+	}
+	return name;
+}
+
+static enum tgt_system_state sys_state = TGT_SYSTEM_OFFLINE;
+
+int system_set_state(char *str)
+{
+	int i, err = TGTADM_INVALID_REQUEST;
+
+	for (i = 0; i < ARRAY_SIZE(target_state); i++) {
+		if (!strcmp(system_state[i].name, str)) {
+			sys_state = system_state[i].value;
+			err = 0;
+			break;
+		}
+	}
+	return err;
+}
+
+int system_show(int mode, char *buf, int rest)
+{
+	int total = 0, max = rest;
+
+	/* FIXME: too hacky */
+	if (mode != MODE_SYSTEM)
+		return 0;
+
+	shprintf(total, buf, rest, "System:\n");
+	shprintf(total, buf, rest, _TAB1 "Status=%s\n",
+		 system_state_name(sys_state));
+
+	return total;
+overflow:
+	return max;
+}
+
+int is_system_available(void)
+{
+	return (sys_state == TGT_SYSTEM_RUNNING);
+}
diff --git a/usr/tgtd.h b/usr/tgtd.h
index c083fbe..c0b8a0c 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -24,6 +24,11 @@
 #define _TAB3 _TAB1 _TAB1 _TAB1
 #define _TAB4 _TAB2 _TAB2
 
+enum tgt_system_state {
+	TGT_SYSTEM_OFFLINE = 1,
+	TGT_SYSTEM_RUNNING,
+};
+
 enum scsi_target_state {
 	SCSI_TARGET_OFFLINE = 1,
 	SCSI_TARGET_RUNNING,
@@ -183,6 +188,9 @@ extern int tgt_target_create(int lld, int tid, char *args);
 extern int tgt_target_destroy(int lld, int tid);
 extern char *tgt_targetname(int tid);
 extern int tgt_target_show_all(char *buf, int rest);
+int system_set_state(char *str);
+int system_show(int mode, char *buf, int rest);
+int is_system_available(void);
 
 extern int tgt_bind_host_to_target(int tid, int host_no);
 extern int tgt_unbind_host_to_target(int tid, int host_no);



From fujita.tomonori at lab.ntt.co.jp  Thu Mar 13 10:13:27 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 13 Mar 2008 18:13:27 +0900
Subject: [Stgt-devel] how to delete a target which is online?
In-Reply-To: <47D6A66A.1080104@wpkg.org>
References: <47D6A66A.1080104@wpkg.org>
Message-ID: <20080313181327C.fujita.tomonori@lab.ntt.co.jp>

On Tue, 11 Mar 2008 16:34:02 +0100
Tomasz Chmielewski <mangoo at wpkg.org> wrote:

> How can I delete a target which is still online?
> 
> 
> # tgtadm --lld iscsi --mode target --op delete --tid=46
> tgtadm: this target unit is still active
> 
> 
> Obviously, I should logout the initiators from that target first, but 
> sometimes it's just too hard or impossible.
> 
> Is it possible to delete a target which is still online?

Sorry, it's still in my todo list. I try to work on this next wek.

BTW, changing the target state to offline might work (initiators might
give up).


From mangoo at wpkg.org  Thu Mar 13 10:24:15 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Thu, 13 Mar 2008 10:24:15 +0100
Subject: [Stgt-devel] how to delete a target which is online?
In-Reply-To: <20080313181327C.fujita.tomonori@lab.ntt.co.jp>
References: <47D6A66A.1080104@wpkg.org>
	<20080313181327C.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <47D8F2BF.6050707@wpkg.org>

FUJITA Tomonori schrieb:
> On Tue, 11 Mar 2008 16:34:02 +0100
> Tomasz Chmielewski <mangoo at wpkg.org> wrote:
> 
>> How can I delete a target which is still online?
>>
>>
>> # tgtadm --lld iscsi --mode target --op delete --tid=46
>> tgtadm: this target unit is still active
>>
>>
>> Obviously, I should logout the initiators from that target first, but 
>> sometimes it's just too hard or impossible.
>>
>> Is it possible to delete a target which is still online?
> 
> Sorry, it's still in my todo list. I try to work on this next wek.
> 
> BTW, changing the target state to offline might work (initiators might
> give up).

No, giving it an offline state doesn't help here.

But good it's on a todo list - although one doesn't use this feature 
every day, one would appreciate it at the times it's needed...



-- 
Tomasz Chmielewski
http://wpkg.org


From mangoo at wpkg.org  Thu Mar 13 10:43:42 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Thu, 13 Mar 2008 10:43:42 +0100
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in the mainstream
 Linux kernel
In-Reply-To: <20080313180451J.fujita.tomonori@lab.ntt.co.jp>
References: <47D511E9.7020209@wpkg.org>	<20080310200124L.tomof@acm.org>	<47D526E3.6050003@wpkg.org>
	<20080313180451J.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <47D8F74E.9090406@wpkg.org>

FUJITA Tomonori schrieb:

> OK, can you try the following patch?
> 
> I've added 'system status':
> 
> rose:/home/fujita# ./tgt/usr/tgtadm --op show --mode sys
> System:
>     Status=offline
> iSNS:
>     iSNS=Off
>     iSNSServerIP=
>     iSNSServerPort=3205
>     iSNSAccessControl=Off
> 
> If the system status is 'offline', tgtd accepts a new connection and
> then close it.
> 
> rose:/home/fujita# ./tgt/usr/tgtadm --op update --mode sys -n state -v
> running
> 
> rose:/home/fujita# ./tgt/usr/tgtadm --op show --mode sys
> System:
>     Status=running
> iSNS:
>     iSNS=Off
>     iSNSServerIP=
>     iSNSServerPort=3205
>     iSNSAccessControl=Off
> 
> When you finish configuring targets, then change the state to
> 'running'.
> 
> The patch is hacky but if it works, I'll clean up and merge it.
> 
> 
> diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
> index 09ed0e5..c1f97b6 100644
> --- a/usr/iscsi/iscsi_tcp.c
> +++ b/usr/iscsi/iscsi_tcp.c
> @@ -104,6 +104,9 @@ static void accept_connection(int afd, int events, void *data)
>  		return;
>  	}
>  
> +	if (!is_system_available())
> +		goto out;
> +
>  	ret = set_keepalive(fd);
>  	if (ret)
>  		goto out;

Where should I apply this patch? In today's git there is no such thing 
as "ret = set_keepalive(fd);" in usr/iscsi/iscsi_tcp.c.

The patch doesn't apply cleanly on tgt-20071227 (latest development 
release found in http://stgt.berlios.de/releases).

Perhaps I'm missing something?


-- 
Tomasz Chmielewski
http://wpkg.org


From mangoo at wpkg.org  Thu Mar 13 11:05:54 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Thu, 13 Mar 2008 11:05:54 +0100
Subject: [Stgt-devel] [RFC] target configuration tool?
Message-ID: <47D8FC82.90700@wpkg.org>

Right now, to add a new target at least three commands have to be started:

tgtadm --lld iscsi --op new --mode target --tid 1 -T 
iqn.2006-08.com.example:san.target
tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 -b 
/dev/san/target
tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL


It is cumbersome with more targets - there is a lot of error prone 
typing here (tgtadm syntax), tid has to be incremented each time etc.


Are there any configuration tools for tgtd?

If not, I'd like to propose a config tool written in perl, which would 
parse a config file similar to the one below:

include /etc/stgt/xen/*.conf
include /etc/stgt/vmware/*.conf
include /etc/stgt/temp/*.conf
 

<target iqn.2007-04.com.example:san.monitoring>
backing-store /dev/san/monitoring
</target>

<target iqn.2007-02.com.example:san.xen1>
backing-store /dev/san/xen1
</target>



Right now, it would only support:
- adding targets, since removing connected targets is not yet supported,
- targetname,
- backing store,
- several separate config files (include /some/config/file.conf).


Adding other config parameters (lun, initiator address etc.) could be 
easily added later.


Comments (other than "there is such a tool already", which would be just 
great)?


-- 
Tomasz Chmielewski
http://wpkg.org


From fujita.tomonori at lab.ntt.co.jp  Thu Mar 13 11:44:03 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 13 Mar 2008 19:44:03 +0900
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in themainstream
	Linux kernel
In-Reply-To: <47D8F74E.9090406@wpkg.org>
References: <47D526E3.6050003@wpkg.org><20080313180451J.fujita.tomonori@lab.ntt.co.jp><47D8F74E.9090406@wpkg.org>
Message-ID: <20080313194403N.fujita.tomonori@lab.ntt.co.jp>

On Thu, 13 Mar 2008 10:43:42 +0100
Tomasz Chmielewski <mangoo at wpkg.org> wrote:

> FUJITA Tomonori schrieb:
> 
> > OK, can you try the following patch?
> > 
> > I've added 'system status':
> > 
> > rose:/home/fujita# ./tgt/usr/tgtadm --op show --mode sys
> > System:
> >     Status=offline
> > iSNS:
> >     iSNS=Off
> >     iSNSServerIP=
> >     iSNSServerPort=3205
> >     iSNSAccessControl=Off
> > 
> > If the system status is 'offline', tgtd accepts a new connection and
> > then close it.
> > 
> > rose:/home/fujita# ./tgt/usr/tgtadm --op update --mode sys -n state -v
> > running
> > 
> > rose:/home/fujita# ./tgt/usr/tgtadm --op show --mode sys
> > System:
> >     Status=running
> > iSNS:
> >     iSNS=Off
> >     iSNSServerIP=
> >     iSNSServerPort=3205
> >     iSNSAccessControl=Off
> > 
> > When you finish configuring targets, then change the state to
> > 'running'.
> > 
> > The patch is hacky but if it works, I'll clean up and merge it.
> > 
> > 
> > diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
> > index 09ed0e5..c1f97b6 100644
> > --- a/usr/iscsi/iscsi_tcp.c
> > +++ b/usr/iscsi/iscsi_tcp.c
> > @@ -104,6 +104,9 @@ static void accept_connection(int afd, int events, void *data)
> >  		return;
> >  	}
> >  
> > +	if (!is_system_available())
> > +		goto out;
> > +
> >  	ret = set_keepalive(fd);
> >  	if (ret)
> >  		goto out;
> 
> Where should I apply this patch? In today's git there is no such thing 
> as "ret = set_keepalive(fd);" in usr/iscsi/iscsi_tcp.c.

It's against the git head. I think that there's something wrong with
your git tree.

The current git head is:

commit 1de2e56109e35f594a449bb7cd2eeccbdb8dda49
Author: Mark Harvey <markh794 at gmail.com>
Date:   Wed Mar 5 15:27:00 2008 +0900

    sbc: remove dead code
    
    Signed-off-by: Mark Harvey <markh794 at gmail.com>
    Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>


> The patch doesn't apply cleanly on tgt-20071227 (latest development 
> release found in http://stgt.berlios.de/releases).
> 
> Perhaps I'm missing something?



From mangoo at wpkg.org  Thu Mar 13 12:24:33 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Thu, 13 Mar 2008 12:24:33 +0100
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in themainstream
 Linux kernel
In-Reply-To: <20080313194403N.fujita.tomonori@lab.ntt.co.jp>
References: <47D526E3.6050003@wpkg.org><20080313180451J.fujita.tomonori@lab.ntt.co.jp><47D8F74E.9090406@wpkg.org>
	<20080313194403N.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <47D90EF1.3000605@wpkg.org>

FUJITA Tomonori schrieb:
> On Thu, 13 Mar 2008 10:43:42 +0100
> Tomasz Chmielewski <mangoo at wpkg.org> wrote:
> 
>> FUJITA Tomonori schrieb:
>>
>>> OK, can you try the following patch?
>>>
>>> I've added 'system status':
>>>
>>> rose:/home/fujita# ./tgt/usr/tgtadm --op show --mode sys
>>> System:
>>>     Status=offline
>>> iSNS:
>>>     iSNS=Off
>>>     iSNSServerIP=
>>>     iSNSServerPort=3205
>>>     iSNSAccessControl=Off
>>>
>>> If the system status is 'offline', tgtd accepts a new connection and
>>> then close it.
>>>
>>> rose:/home/fujita# ./tgt/usr/tgtadm --op update --mode sys -n state -v
>>> running
>>>
>>> rose:/home/fujita# ./tgt/usr/tgtadm --op show --mode sys
>>> System:
>>>     Status=running
>>> iSNS:
>>>     iSNS=Off
>>>     iSNSServerIP=
>>>     iSNSServerPort=3205
>>>     iSNSAccessControl=Off
>>>
>>> When you finish configuring targets, then change the state to
>>> 'running'.
>>>
>>> The patch is hacky but if it works, I'll clean up and merge it.
>>>
>>>
>>> diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
>>> index 09ed0e5..c1f97b6 100644
>>> --- a/usr/iscsi/iscsi_tcp.c
>>> +++ b/usr/iscsi/iscsi_tcp.c
>>> @@ -104,6 +104,9 @@ static void accept_connection(int afd, int events, void *data)
>>>  		return;
>>>  	}
>>>  
>>> +	if (!is_system_available())
>>> +		goto out;
>>> +
>>>  	ret = set_keepalive(fd);
>>>  	if (ret)
>>>  		goto out;
>> Where should I apply this patch? In today's git there is no such thing 
>> as "ret = set_keepalive(fd);" in usr/iscsi/iscsi_tcp.c.
> 
> It's against the git head. I think that there's something wrong with
> your git tree.

Indeed. I had an old revision I guess?

Anyway - the patch works great, iptables are no longer needed!

If the patch is finally integrated, I guess README files need updating, 
too to reflect the change.



-- 
Tomasz Chmielewski
http://wpkg.org




From fujita.tomonori at lab.ntt.co.jp  Thu Mar 13 12:32:46 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 13 Mar 2008 20:32:46 +0900
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in
	themainstreamLinux kernel
In-Reply-To: <47D90EF1.3000605@wpkg.org>
References: <47D8F74E.9090406@wpkg.org><20080313194403N.fujita.tomonori@lab.ntt.co.jp><47D90EF1.3000605@wpkg.org>
Message-ID: <20080313203246S.fujita.tomonori@lab.ntt.co.jp>

On Thu, 13 Mar 2008 12:24:33 +0100
Tomasz Chmielewski <mangoo at wpkg.org> wrote:

> FUJITA Tomonori schrieb:
> > On Thu, 13 Mar 2008 10:43:42 +0100
> > Tomasz Chmielewski <mangoo at wpkg.org> wrote:
> > 
> >> FUJITA Tomonori schrieb:
> >>
> >>> OK, can you try the following patch?
> >>>
> >>> I've added 'system status':
> >>>
> >>> rose:/home/fujita# ./tgt/usr/tgtadm --op show --mode sys
> >>> System:
> >>>     Status=offline
> >>> iSNS:
> >>>     iSNS=Off
> >>>     iSNSServerIP=
> >>>     iSNSServerPort=3205
> >>>     iSNSAccessControl=Off
> >>>
> >>> If the system status is 'offline', tgtd accepts a new connection and
> >>> then close it.
> >>>
> >>> rose:/home/fujita# ./tgt/usr/tgtadm --op update --mode sys -n state -v
> >>> running
> >>>
> >>> rose:/home/fujita# ./tgt/usr/tgtadm --op show --mode sys
> >>> System:
> >>>     Status=running
> >>> iSNS:
> >>>     iSNS=Off
> >>>     iSNSServerIP=
> >>>     iSNSServerPort=3205
> >>>     iSNSAccessControl=Off
> >>>
> >>> When you finish configuring targets, then change the state to
> >>> 'running'.
> >>>
> >>> The patch is hacky but if it works, I'll clean up and merge it.
> >>>
> >>>
> >>> diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
> >>> index 09ed0e5..c1f97b6 100644
> >>> --- a/usr/iscsi/iscsi_tcp.c
> >>> +++ b/usr/iscsi/iscsi_tcp.c
> >>> @@ -104,6 +104,9 @@ static void accept_connection(int afd, int events, void *data)
> >>>  		return;
> >>>  	}
> >>>  
> >>> +	if (!is_system_available())
> >>> +		goto out;
> >>> +
> >>>  	ret = set_keepalive(fd);
> >>>  	if (ret)
> >>>  		goto out;
> >> Where should I apply this patch? In today's git there is no such thing 
> >> as "ret = set_keepalive(fd);" in usr/iscsi/iscsi_tcp.c.
> > 
> > It's against the git head. I think that there's something wrong with
> > your git tree.
> 
> Indeed. I had an old revision I guess?
> 
> Anyway - the patch works great, iptables are no longer needed!

Nice.


> If the patch is finally integrated, I guess README files need updating, 
> too to reflect the change.

Well, I really don't like to set the default state to 'offline'.

I'm sure that many people say that initiators can connect to tgtd if I
do that.

I could make it as the startup (boot) option though I don't like it
either but I think that it's less problematic to set the default state
to 'offline'.


From mangoo at wpkg.org  Thu Mar 13 12:44:18 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Thu, 13 Mar 2008 12:44:18 +0100
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in
 themainstreamLinux kernel
In-Reply-To: <20080313203246S.fujita.tomonori@lab.ntt.co.jp>
References: <47D8F74E.9090406@wpkg.org><20080313194403N.fujita.tomonori@lab.ntt.co.jp><47D90EF1.3000605@wpkg.org>
	<20080313203246S.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <47D91392.4050206@wpkg.org>

FUJITA Tomonori schrieb:
> On Thu, 13 Mar 2008 12:24:33 +0100
> Tomasz Chmielewski <mangoo at wpkg.a.org> wrote:

(...)

>> If the patch is finally integrated, I guess README files need updating, 
>> too to reflect the change.
> 
> Well, I really don't like to set the default state to 'offline'.
> 
> I'm sure that many people say that initiators can connect to tgtd if I
> do that.

You meant "can't connect" I guess.
Yes, this changes the default behaviour.


> I could make it as the startup (boot) option though I don't like it
> either but I think that it's less problematic to set the default state
> to 'offline'.

Either default to offline (bad for existing users) or give a startup 
option to tgtd (better). There is no other way, I guess (other than 
making it compile-time option, which is really bad).


And what about that little nuisance - this will work:

tgtd
sleep 2s
tgtadm --lld iscsi --op new --mode target.....


This won't work - tgtd goes background immediately and starts, but 
doesn't accept any configuration changes for the first second or two:

tgtd
tgtadm --lld iscsi --op new --mode target.....


-- 
Tomasz Chmielewski
http://wpkg.org



From fujita.tomonori at lab.ntt.co.jp  Thu Mar 13 13:40:24 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 13 Mar 2008 21:40:24 +0900
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in
	themainstreamLinux kernel
In-Reply-To: <47D91392.4050206@wpkg.org>
References: <47D90EF1.3000605@wpkg.org>
	<20080313203246S.fujita.tomonori@lab.ntt.co.jp>
	<47D91392.4050206@wpkg.org>
Message-ID: <20080313214018T.tomof@acm.org>

On Thu, 13 Mar 2008 12:44:18 +0100
Tomasz Chmielewski <mangoo at wpkg.org> wrote:

> FUJITA Tomonori schrieb:
> > On Thu, 13 Mar 2008 12:24:33 +0100
> > Tomasz Chmielewski <mangoo at wpkg.a.org> wrote:
> 
> (...)
> 
> >> If the patch is finally integrated, I guess README files need updating, 
> >> too to reflect the change.
> > 
> > Well, I really don't like to set the default state to 'offline'.
> > 
> > I'm sure that many people say that initiators can connect to tgtd if I
> > do that.
> 
> You meant "can't connect" I guess.
> Yes, this changes the default behaviour.

Yeah.


> > I could make it as the startup (boot) option though I don't like it
> > either but I think that it's less problematic to set the default state
> > to 'offline'.
> 
> Either default to offline (bad for existing users) or give a startup 

Not only for existing users. People dislike extra operations.

I've used several commercial iSCSI target systems. All I need to do are
setting up security (which initiators can connect) and luns with them.


> option to tgtd (better). There is no other way, I guess (other than 
> making it compile-time option, which is really bad).

There is another option. If tgtd has no targets, then tgtd closes a
connection instead of sending a response. So you can change the state
to offline, configure targets and then change the state to running.

Try this patch (against the current git head).


diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 09ed0e5..ed7879a 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -104,6 +104,12 @@ static void accept_connection(int afd, int events, void *data)
 		return;
 	}
 
+	if (!is_system_available())
+		goto out;
+
+	if (list_empty(&iscsi_targets_list))
+		goto out;
+
 	ret = set_keepalive(fd);
 	if (ret)
 		goto out;
diff --git a/usr/iscsi/isns.c b/usr/iscsi/isns.c
index 81b2874..7bbf875 100644
--- a/usr/iscsi/isns.c
+++ b/usr/iscsi/isns.c
@@ -982,7 +982,7 @@ overflow:
 }
 
 enum {
-	Opt_isns, Opt_ip, Opt_port, Opt_ac, Opt_err,
+	Opt_isns, Opt_ip, Opt_port, Opt_ac, Opt_state, Opt_err,
 };
 
 static match_table_t tokens = {
@@ -990,6 +990,7 @@ static match_table_t tokens = {
 	{Opt_ip, "iSNSServerIP=%s"},
 	{Opt_port, "iSNSServerPort=%d"},
 	{Opt_ac, "iSNSAccessControl=%s"},
+	{Opt_state, "state=%s"},
 	{Opt_err, NULL},
 };
 
@@ -1001,7 +1002,7 @@ int isns_update(char *params)
 	while ((p = strsep(&params, ",")) != NULL) {
 		substring_t args[MAX_OPT_ARGS];
 		int token;
-		char tmp[8];
+		char tmp[16];
 
 		if (!*p)
 			continue;
@@ -1030,6 +1031,10 @@ int isns_update(char *params)
 			match_strncpy(tmp, &args[0], sizeof(tmp));
 			use_isns_ac = !strcmp(tmp, "On");
 			break;
+		case Opt_state:
+			match_strncpy(tmp, &args[0], sizeof(tmp));
+			system_set_state(tmp);
+			break;
 		default:
 			ret = TGTADM_INVALID_REQUEST;
 		}
diff --git a/usr/mgmt.c b/usr/mgmt.c
index 041f0ff..711c7f4 100644
--- a/usr/mgmt.c
+++ b/usr/mgmt.c
@@ -262,13 +262,14 @@ static int sys_mgmt(int lld_no, struct mgmt_task *mtask)
 		rsp->len = sizeof(*rsp);
 		break;
 	case OP_SHOW:
-		if (tgt_drivers[lld_no]->show) {
-			err = tgt_drivers[lld_no]->show(req->mode,
-							req->tid, req->sid,
-							req->cid, req->lun,
-							mtask->buf, len);
-			set_show_results(rsp, &err);
+		err = system_show(req->mode, mtask->buf, len);
+		if (err >= 0 && tgt_drivers[lld_no]->show) {
+			err += tgt_drivers[lld_no]->show(req->mode,
+							 req->tid, req->sid,
+							 req->cid, req->lun,
+							 mtask->buf + err, len - err);
 		}
+		set_show_results(rsp, &err);
 		break;
 	default:
 		break;
diff --git a/usr/target.c b/usr/target.c
index 50769f6..937e32e 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -1716,3 +1716,63 @@ int account_show(char *buf, int rest)
 overflow:
 	return max;
 }
+
+static struct {
+	enum tgt_system_state value;
+	char *name;
+} system_state[] = {
+	{TGT_SYSTEM_OFFLINE, "offline"},
+	{TGT_SYSTEM_RUNNING, "running"},
+};
+
+static char *system_state_name(enum scsi_target_state state)
+{
+	int i;
+	char *name = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(system_state); i++) {
+		if (system_state[i].value == state) {
+			name = system_state[i].name;
+			break;
+		}
+	}
+	return name;
+}
+
+static enum tgt_system_state sys_state = TGT_SYSTEM_RUNNING;
+
+int system_set_state(char *str)
+{
+	int i, err = TGTADM_INVALID_REQUEST;
+
+	for (i = 0; i < ARRAY_SIZE(target_state); i++) {
+		if (!strcmp(system_state[i].name, str)) {
+			sys_state = system_state[i].value;
+			err = 0;
+			break;
+		}
+	}
+	return err;
+}
+
+int system_show(int mode, char *buf, int rest)
+{
+	int total = 0, max = rest;
+
+	/* FIXME: too hacky */
+	if (mode != MODE_SYSTEM)
+		return 0;
+
+	shprintf(total, buf, rest, "System:\n");
+	shprintf(total, buf, rest, _TAB1 "Status=%s\n",
+		 system_state_name(sys_state));
+
+	return total;
+overflow:
+	return max;
+}
+
+int is_system_available(void)
+{
+	return (sys_state == TGT_SYSTEM_RUNNING);
+}
diff --git a/usr/tgtd.h b/usr/tgtd.h
index c083fbe..c0b8a0c 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -24,6 +24,11 @@
 #define _TAB3 _TAB1 _TAB1 _TAB1
 #define _TAB4 _TAB2 _TAB2
 
+enum tgt_system_state {
+	TGT_SYSTEM_OFFLINE = 1,
+	TGT_SYSTEM_RUNNING,
+};
+
 enum scsi_target_state {
 	SCSI_TARGET_OFFLINE = 1,
 	SCSI_TARGET_RUNNING,
@@ -183,6 +188,9 @@ extern int tgt_target_create(int lld, int tid, char *args);
 extern int tgt_target_destroy(int lld, int tid);
 extern char *tgt_targetname(int tid);
 extern int tgt_target_show_all(char *buf, int rest);
+int system_set_state(char *str);
+int system_show(int mode, char *buf, int rest);
+int is_system_available(void);
 
 extern int tgt_bind_host_to_target(int tid, int host_no);
 extern int tgt_unbind_host_to_target(int tid, int host_no);


From mangoo at wpkg.org  Thu Mar 13 16:23:18 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Thu, 13 Mar 2008 16:23:18 +0100
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in
 themainstreamLinux kernel
In-Reply-To: <20080313214018T.tomof@acm.org>
References: <47D90EF1.3000605@wpkg.org>	<20080313203246S.fujita.tomonori@lab.ntt.co.jp>	<47D91392.4050206@wpkg.org>
	<20080313214018T.tomof@acm.org>
Message-ID: <47D946E6.5070604@wpkg.org>

FUJITA Tomonori schrieb:

(...)

>>> I could make it as the startup (boot) option though I don't like it
>>> either but I think that it's less problematic to set the default state
>>> to 'offline'.
>> Either default to offline (bad for existing users) or give a startup 
> 
> Not only for existing users. People dislike extra operations.
> 
> I've used several commercial iSCSI target systems. All I need to do are
> setting up security (which initiators can connect) and luns with them.
> 
> 
>> option to tgtd (better). There is no other way, I guess (other than 
>> making it compile-time option, which is really bad).
> 
> There is another option. If tgtd has no targets, then tgtd closes a
> connection instead of sending a response. So you can change the state
> to offline, configure targets and then change the state to running.
> 
> Try this patch (against the current git head).

No, this won't work reliably if you have more than one target.

Let's say you have these targets; initiators connected to it:

tgtadm --lld iscsi --op new --mode target --tid 1 -T 
iqn.2008-03.com.example:san.target1
tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 -b 
/dev/san/target1
tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL

tgtadm --lld iscsi --op new --mode target --tid 2 -T 
iqn.2008-03.com.example:san.target2
tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 2 -b 
/dev/san/target2
tgtadm --lld iscsi --op bind --mode target --tid 2 -I ALL


You just upgraded and restarted your target without disconnecting the 
initiators. You have to go through these steps:

target              initiator
-----------------------------------
not started         trying to reconnect
start tgtd          trying to reconnect
sleep 2s            trying to reconnect
nothing configured  login I/O error - non fatal
configure target1   conn to target1 OK
no such target      conn to target2 FAIL
                     I/O error to target2
configure target2   too late, fatal, we lost it


With one target it will never fail.
With two targets it is not very likely to fail.

With lots of targets and initiators the things will fail, and a user 
which is not familiar with technicals will say "it fails randomly".

So I prefer the previous version of the patch, where the target is 
explicitly in offline state (with "tgtd --offline" flag, perhaps).


Or, is it possible not to fail connections to non-existing targets, but 
to answer that the (non-existing, not-yet-configured) target is 
offlined? Or will it be against RFCs?



-- 
Tomasz Chmielewski
http://wpkg.org





From tomof at acm.org  Thu Mar 13 16:47:23 2008
From: tomof at acm.org (FUJITA Tomonori)
Date: Fri, 14 Mar 2008 00:47:23 +0900
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in
	themainstreamLinux kernel
In-Reply-To: <47D946E6.5070604@wpkg.org>
References: <47D91392.4050206@wpkg.org> <20080313214018T.tomof@acm.org>
	<47D946E6.5070604@wpkg.org>
Message-ID: <20080314004719T.tomof@acm.org>

On Thu, 13 Mar 2008 16:23:18 +0100
Tomasz Chmielewski <mangoo at wpkg.org> wrote:

> FUJITA Tomonori schrieb:
> 
> (...)
> 
> >>> I could make it as the startup (boot) option though I don't like it
> >>> either but I think that it's less problematic to set the default state
> >>> to 'offline'.
> >> Either default to offline (bad for existing users) or give a startup 
> > 
> > Not only for existing users. People dislike extra operations.
> > 
> > I've used several commercial iSCSI target systems. All I need to do are
> > setting up security (which initiators can connect) and luns with them.
> > 
> > 
> >> option to tgtd (better). There is no other way, I guess (other than 
> >> making it compile-time option, which is really bad).
> > 
> > There is another option. If tgtd has no targets, then tgtd closes a
> > connection instead of sending a response. So you can change the state
> > to offline, configure targets and then change the state to running.
> > 
> > Try this patch (against the current git head).
> 
> No, this won't work reliably if you have more than one target.
> 
> Let's say you have these targets; initiators connected to it:
> 
> tgtadm --lld iscsi --op new --mode target --tid 1 -T 
> iqn.2008-03.com.example:san.target1
> tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 -b 
> /dev/san/target1
> tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL
> 
> tgtadm --lld iscsi --op new --mode target --tid 2 -T 
> iqn.2008-03.com.example:san.target2
> tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 2 -b 
> /dev/san/target2
> tgtadm --lld iscsi --op bind --mode target --tid 2 -I ALL
> 
> 
> You just upgraded and restarted your target without disconnecting the 
> initiators. You have to go through these steps:
> 
> target              initiator
> -----------------------------------
> not started         trying to reconnect
> start tgtd          trying to reconnect
> sleep 2s            trying to reconnect
> nothing configured  login I/O error - non fatal
> configure target1   conn to target1 OK
> no such target      conn to target2 FAIL
>                      I/O error to target2
> configure target2   too late, fatal, we lost it

You don't understand how to use it.

1. start tgtd.
2. change the system state to offline.
3. do whatever you want (create new targets and add luns).
4. change the system state to running.


> With one target it will never fail.
> With two targets it is not very likely to fail.
> 
> With lots of targets and initiators the things will fail, and a user 
> which is not familiar with technicals will say "it fails randomly".
> 
> So I prefer the previous version of the patch, where the target is 
> explicitly in offline state (with "tgtd --offline" flag, perhaps).
> 
> 
> Or, is it possible not to fail connections to non-existing targets, but 
> to answer that the (non-existing, not-yet-configured) target is 
> offlined? Or will it be against RFCs?

I don't think so.

BTW, as I explained again and again, IIRC, RFC doesn't say that
initiators need to reconnect in your situation. Your scheme works for
open-iscsi now, but it could be broken anytime.


From mangoo at wpkg.org  Thu Mar 13 18:42:54 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Thu, 13 Mar 2008 18:42:54 +0100
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in
 themainstreamLinux kernel
In-Reply-To: <20080314004719T.tomof@acm.org>
References: <47D91392.4050206@wpkg.org>	<20080313214018T.tomof@acm.org>	<47D946E6.5070604@wpkg.org>
	<20080314004719T.tomof@acm.org>
Message-ID: <47D9679E.1000502@wpkg.org>

FUJITA Tomonori schrieb:

(...)

>> target              initiator
>> -----------------------------------
>> not started         trying to reconnect
>> start tgtd          trying to reconnect
>> sleep 2s            trying to reconnect
>> nothing configured  login I/O error - non fatal
>> configure target1   conn to target1 OK
>> no such target      conn to target2 FAIL
>>                      I/O error to target2
>> configure target2   too late, fatal, we lost it
> 
> You don't understand how to use it.
> 
> 1. start tgtd.
> 2. change the system state to offline.
> 3. do whatever you want (create new targets and add luns).
> 4. change the system state to running.

Oh, I see now.
Thanks for the explanation.


(...)

>> Or, is it possible not to fail connections to non-existing targets, but 
>> to answer that the (non-existing, not-yet-configured) target is 
>> offlined? Or will it be against RFCs?
> 
> I don't think so.
> 
> BTW, as I explained again and again, IIRC, RFC doesn't say that
> initiators need to reconnect in your situation. Your scheme works for
> open-iscsi now, but it could be broken anytime.

Network infrastructure fail, administrator make mistakes, target has to 
be restarted or moved somewhere else (i.e. failover).
Disconnections may and do happen.

I hope existing features will not be removed from open-iscsi.

And if other initiators can't handle disconnections - it's another 
reason not to use them.



-- 
Tomasz Chmielewski
http://wpkg.org




From stgt at decarpentier.com  Sat Mar 15 20:03:01 2008
From: stgt at decarpentier.com (Niels de Carpentier)
Date: Sat, 15 Mar 2008 20:03:01 +0100 (CET)
Subject: [Stgt-devel] Open connections
Message-ID: <59952.190.10.50.223.1205607781.squirrel@webmail.decarpentier.com>

I'm having an issue where old connections keep being listed in tgt, while
they are not in use anymore.

I'm running a diskless system with an iscsi root, which uses open-iscsi as
the initiator. The initrd mount does the initial mounting, and on the
final image iscsid is started, which does a reconnect.

After the system has booted, the follow status is available on the target:

Target 1: iqn.2008-04.com.test:storage.front001
    System information:
        Driver: iscsi
        Status: running
    I_T nexus information:
        I_T nexus: 1
            Initiator: front_dom0
            Connection: 0
                IP Address: 10.0.0.84
        I_T nexus: 2
            Initiator: front_dom0
            Connection: 0
                IP Address: 10.0.0.84
    LUN information:
        LUN: 0
            Type: controller
            SCSI ID: deadbeaf1:0
            SCSI SN: beaf10
            Size: 0 MB
            Online: Yes
            Poweron/Reset: Yes
            Removable media: No
            Backing store: No backing store
        LUN: 1
            Type: disk
            SCSI ID: deadbeaf1:1
            SCSI SN: beaf11
            Size: 2147 MB
            Online: Yes
            Poweron/Reset: No
            Removable media: No
            Backing store: /dev/vg_images/frontend001
        LUN: 2
            Type: disk
            SCSI ID: deadbeaf1:2
            SCSI SN: beaf12
            Size: 1074 MB
            Online: Yes
            Poweron/Reset: No
            Removable media: No
            Backing store: /dev/vg_images/frontend001_swap
    Account information:
        frontend
    ACL information:
        10.0.0.0/24

However, netstat shows only a single connection active:

netstat -an | grep 3260

tcp        0      0 0.0.0.0:3260                0.0.0.0:*                 
 LISTEN
tcp        0      0 10.0.0.17:3260              10.0.0.84:53025           
 ESTABLISHED
tcp        0      0 :::3260                     :::*                      
 LISTEN

If I reboot the iscsi root system without restarting tgtd, the initial
connect will fail. A logout and a new login is necessary to get a working
connection in this case.

The following is logged by tgtd during this time:

Mar 15 12:54:58 rbk tgtd: iscsi_task_queue(1437) unexpected cmd_sn (0,7551)
Mar 15 12:55:17 rbk tgtd: iscsi_task_queue(1437) unexpected cmd_sn (1,7551)
Mar 15 12:55:23 rbk tgtd: iscsi_task_queue(1437) unexpected cmd_sn (2,7551)
Mar 15 12:55:42 rbk tgtd: iscsi_task_queue(1437) unexpected cmd_sn (3,7551)

I can provide more information on request.

Niels de Carpentier





From mangoo at wpkg.org  Sat Mar 15 20:56:40 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Sat, 15 Mar 2008 20:56:40 +0100
Subject: [Stgt-devel] Open connections
In-Reply-To: <59952.190.10.50.223.1205607781.squirrel@webmail.decarpentier.com>
References: <59952.190.10.50.223.1205607781.squirrel@webmail.decarpentier.com>
Message-ID: <47DC29F8.3040608@wpkg.org>

Niels de Carpentier schrieb:
> I'm having an issue where old connections keep being listed in tgt, while
> they are not in use anymore.
> 
> I'm running a diskless system with an iscsi root, which uses open-iscsi as
> the initiator. The initrd mount does the initial mounting, and on the
> final image iscsid is started, which does a reconnect.
> 
> After the system has booted, the follow status is available on the target:

(...)

> If I reboot the iscsi root system without restarting tgtd, the initial
> connect will fail. A logout and a new login is necessary to get a working
> connection in this case.

I reported a similar issue with diskless iSCSI nodes in "yet another 
tgtd iSCSI misbehaviour (aborted journal, remounting ro)":

https://lists.berlios.de/pipermail/stgt-devel/2008-February/thread.html#1353

I didn't send a tcpdump, though.


-- 
Tomasz Chmielewski
http://wpkg.org


From stgt at decarpentier.com  Sun Mar 16 00:25:20 2008
From: stgt at decarpentier.com (Niels de Carpentier)
Date: Sun, 16 Mar 2008 00:25:20 +0100 (CET)
Subject: [Stgt-devel] Open connections
In-Reply-To: <59952.190.10.50.223.1205607781.squirrel@webmail.decarpentier.com>
References: <59952.190.10.50.223.1205607781.squirrel@webmail.decarpentier.com>
Message-ID: <57482.190.10.50.223.1205623520.squirrel@webmail.decarpentier.com>

I did some more checking of the connection issue, and the problem is that
the return code of it_destroy_nexus is not checked. In this case it will
return EBUSY, and the connection is never actually removed.

Niels

> I'm having an issue where old connections keep being listed in tgt, while
> they are not in use anymore.
>
> I'm running a diskless system with an iscsi root, which uses open-iscsi as
> the initiator. The initrd mount does the initial mounting, and on the
> final image iscsid is started, which does a reconnect.
>
> After the system has booted, the follow status is available on the target:
>
> Target 1: iqn.2008-04.com.test:storage.front001
>     System information:
>         Driver: iscsi
>         Status: running
>     I_T nexus information:
>         I_T nexus: 1
>             Initiator: front_dom0
>             Connection: 0
>                 IP Address: 10.0.0.84
>         I_T nexus: 2
>             Initiator: front_dom0
>             Connection: 0
>                 IP Address: 10.0.0.84
>     LUN information:
>         LUN: 0
>             Type: controller
>             SCSI ID: deadbeaf1:0
>             SCSI SN: beaf10
>             Size: 0 MB
>             Online: Yes
>             Poweron/Reset: Yes
>             Removable media: No
>             Backing store: No backing store
>         LUN: 1
>             Type: disk
>             SCSI ID: deadbeaf1:1
>             SCSI SN: beaf11
>             Size: 2147 MB
>             Online: Yes
>             Poweron/Reset: No
>             Removable media: No
>             Backing store: /dev/vg_images/frontend001
>         LUN: 2
>             Type: disk
>             SCSI ID: deadbeaf1:2
>             SCSI SN: beaf12
>             Size: 1074 MB
>             Online: Yes
>             Poweron/Reset: No
>             Removable media: No
>             Backing store: /dev/vg_images/frontend001_swap
>     Account information:
>         frontend
>     ACL information:
>         10.0.0.0/24
>
> However, netstat shows only a single connection active:
>
> netstat -an | grep 3260
>
> tcp        0      0 0.0.0.0:3260                0.0.0.0:*
>  LISTEN
> tcp        0      0 10.0.0.17:3260              10.0.0.84:53025
>  ESTABLISHED
> tcp        0      0 :::3260                     :::*
>  LISTEN
>
> If I reboot the iscsi root system without restarting tgtd, the initial
> connect will fail. A logout and a new login is necessary to get a working
> connection in this case.
>
> The following is logged by tgtd during this time:
>
> Mar 15 12:54:58 rbk tgtd: iscsi_task_queue(1437) unexpected cmd_sn
> (0,7551)
> Mar 15 12:55:17 rbk tgtd: iscsi_task_queue(1437) unexpected cmd_sn
> (1,7551)
> Mar 15 12:55:23 rbk tgtd: iscsi_task_queue(1437) unexpected cmd_sn
> (2,7551)
> Mar 15 12:55:42 rbk tgtd: iscsi_task_queue(1437) unexpected cmd_sn
> (3,7551)
>
> I can provide more information on request.
>
> Niels de Carpentier
>
>
>
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>




From stgt at decarpentier.com  Sun Mar 16 03:02:43 2008
From: stgt at decarpentier.com (Niels de Carpentier)
Date: Sun, 16 Mar 2008 03:02:43 +0100 (CET)
Subject: [Stgt-devel] Open connections
In-Reply-To: <59952.190.10.50.223.1205607781.squirrel@webmail.decarpentier.com>
References: <59952.190.10.50.223.1205607781.squirrel@webmail.decarpentier.com>
Message-ID: <64331.190.10.50.223.1205632963.squirrel@webmail.decarpentier.com>

Some more info about the reconnect issue:

When the initiator of the diskless system sets up a new connection, the
target actually uses the session details of the old connection. (Which
wasn't closed properly). Since the CmdSN numbers of the initiator and
target don't match (The initiator starts at 0, while the target has the
value of the old connection), the commands are rejected.

Niels

The debug log looks like this:

tgtd: accept_connection(98) 5
tgtd: cmnd_exec_login(623) Login request (operational negotiation): 0
tgtd: cmnd_exec_text(788) Text request: 8
tgtd: iscsi_tcp_event_handler(154) connection closed
tgtd: conn_close(88) connection closed
tgtd: iscsi_tcp_event_handler(161) connection closed
tgtd: accept_connection(98) 5
tgtd: cmnd_exec_login(586) Login request (security negotiation): 0
tgtd: login_start(483) exp_cmd_sn: 0,0
tgtd: cmnd_exec_login(586) Login request (security negotiation): 2
tgtd: cmnd_exec_login(586) Login request (security negotiation): 2
tgtd: session_find_name(45) session_find_name: front_dom0 0 2 3d 1 0 0
tgtd: cmnd_exec_login(623) Login request (operational negotiation): 6
tgtd: cmnd_exec_login(623) Login request (operational negotiation): 6
tgtd: conn_take_fd(163) 0 5 0 20000013d0200
tgtd: iscsi_scsi_cmd_rx_start(1466) 2 12 0 0 36 1 0
tgtd: iscsi_task_queue(1411) 0 1bf8 1
tgtd: iscsi_task_queue(1437) unexpected cmd_sn (0,7160)
tgtd: iscsi_tcp_event_handler(154) connection closed
tgtd: conn_close(88) connection closed
tgtd: iscsi_tcp_event_handler(161) connection closed
tgtd: accept_connection(98) 5
tgtd: cmnd_exec_login(586) Login request (security negotiation): 0
tgtd: login_start(483) exp_cmd_sn: 1,16777216
tgtd: cmnd_exec_login(586) Login request (security negotiation): 2
tgtd: cmnd_exec_login(586) Login request (security negotiation): 2
tgtd: session_find_name(45) session_find_name: front_dom0 0 2 3d 1 0 0
tgtd: cmnd_exec_login(623) Login request (operational negotiation): 6
tgtd: cmnd_exec_login(623) Login request (operational negotiation): 6
tgtd: conn_take_fd(163) 0 5 0 20000013d0200
tgtd: iscsi_scsi_cmd_rx_start(1466) 2 0 0 0 0 1 10000001
tgtd: iscsi_task_queue(1411) 1 1bf8 1
tgtd: iscsi_task_queue(1437) unexpected cmd_sn (1,7160)
tgtd: iscsi_tcp_event_handler(154) connection closed
tgtd: conn_close(88) connection closed
tgtd: iscsi_tcp_event_handler(161) connection closed
tgtd: tgt_mgmt(296) 120 0 1 2 -1 0 0  4839
tgtd: accept_connection(98) 5
tgtd: cmnd_exec_login(586) Login request (security negotiation): 0
tgtd: login_start(483) exp_cmd_sn: 2,33554432
tgtd: cmnd_exec_login(586) Login request (security negotiation): 2
tgtd: cmnd_exec_login(586) Login request (security negotiation): 2
tgtd: session_find_name(45) session_find_name: front_dom0 0 2 3d 1 0 0
tgtd: cmnd_exec_login(623) Login request (operational negotiation): 6
tgtd: cmnd_exec_login(623) Login request (operational negotiation): 6
tgtd: conn_take_fd(163) 0 5 0 20000013d0200
tgtd: iscsi_scsi_cmd_rx_start(1466) 2 12 0 0 36 1 20000002
tgtd: iscsi_task_queue(1411) 2 1bf8 1
tgtd: iscsi_task_queue(1437) unexpected cmd_sn (2,7160)
tgtd: iscsi_tcp_event_handler(154) connection closed
tgtd: conn_close(88) connection closed
tgtd: iscsi_tcp_event_handler(161) connection closed
tgtd: accept_connection(98) 5
tgtd: cmnd_exec_login(586) Login request (security negotiation): 0
tgtd: login_start(483) exp_cmd_sn: 3,50331648
tgtd: cmnd_exec_login(586) Login request (security negotiation): 2
tgtd: cmnd_exec_login(586) Login request (security negotiation): 2
tgtd: session_find_name(45) session_find_name: front_dom0 0 2 3d 1 0 0
tgtd: cmnd_exec_login(623) Login request (operational negotiation): 6
tgtd: cmnd_exec_login(623) Login request (operational negotiation): 6
tgtd: conn_take_fd(163) 0 5 0 20000013d0200
tgtd: tgt_mgmt(296) 120 0 1 2 -1 0 0  4839
tgtd: iscsi_scsi_cmd_rx_start(1466) 2 0 0 0 0 1 30000003
tgtd: iscsi_task_queue(1411) 3 1bf8 1
tgtd: iscsi_task_queue(1437) unexpected cmd_sn (3,7160)
tgtd: iscsi_tcp_event_handler(154) connection closed
tgtd: conn_close(88) connection closed
tgtd: iscsi_tcp_event_handler(161) connection closed
tgtd: accept_connection(98) 5
tgtd: cmnd_exec_login(586) Login request (security negotiation): 0
tgtd: login_start(483) exp_cmd_sn: 0,0
tgtd: tgt_mgmt(296) 120 0 1 2 -1 0 0  4839
tgtd: cmnd_exec_login(586) Login request (security negotiation): 2
tgtd: cmnd_exec_login(586) Login request (security negotiation): 2
tgtd: session_find_name(45) session_find_name: front_dom0 0 2 3d 2 0 0
tgtd: cmnd_exec_login(623) Login request (operational negotiation): 6
tgtd: cmnd_exec_login(623) Login request (operational negotiation): 6
tgtd: it_nexus_create(205) 1 30
tgtd: session_create(135) session_create: 0x30000023d0200
tgtd: conn_take_fd(163) 0 5 0 30000023d0200


> I'm having an issue where old connections keep being listed in tgt, while
> they are not in use anymore.
>
> I'm running a diskless system with an iscsi root, which uses open-iscsi as
> the initiator. The initrd mount does the initial mounting, and on the
> final image iscsid is started, which does a reconnect.
>
> After the system has booted, the follow status is available on the target:
>
> Target 1: iqn.2008-04.com.test:storage.front001
>     System information:
>         Driver: iscsi
>         Status: running
>     I_T nexus information:
>         I_T nexus: 1
>             Initiator: front_dom0
>             Connection: 0
>                 IP Address: 10.0.0.84
>         I_T nexus: 2
>             Initiator: front_dom0
>             Connection: 0
>                 IP Address: 10.0.0.84
>     LUN information:
>         LUN: 0
>             Type: controller
>             SCSI ID: deadbeaf1:0
>             SCSI SN: beaf10
>             Size: 0 MB
>             Online: Yes
>             Poweron/Reset: Yes
>             Removable media: No
>             Backing store: No backing store
>         LUN: 1
>             Type: disk
>             SCSI ID: deadbeaf1:1
>             SCSI SN: beaf11
>             Size: 2147 MB
>             Online: Yes
>             Poweron/Reset: No
>             Removable media: No
>             Backing store: /dev/vg_images/frontend001
>         LUN: 2
>             Type: disk
>             SCSI ID: deadbeaf1:2
>             SCSI SN: beaf12
>             Size: 1074 MB
>             Online: Yes
>             Poweron/Reset: No
>             Removable media: No
>             Backing store: /dev/vg_images/frontend001_swap
>     Account information:
>         frontend
>     ACL information:
>         10.0.0.0/24
>
> However, netstat shows only a single connection active:
>
> netstat -an | grep 3260
>
> tcp        0      0 0.0.0.0:3260                0.0.0.0:*
>  LISTEN
> tcp        0      0 10.0.0.17:3260              10.0.0.84:53025
>  ESTABLISHED
> tcp        0      0 :::3260                     :::*
>  LISTEN
>
> If I reboot the iscsi root system without restarting tgtd, the initial
> connect will fail. A logout and a new login is necessary to get a working
> connection in this case.
>
> The following is logged by tgtd during this time:
>
> Mar 15 12:54:58 rbk tgtd: iscsi_task_queue(1437) unexpected cmd_sn
> (0,7551)
> Mar 15 12:55:17 rbk tgtd: iscsi_task_queue(1437) unexpected cmd_sn
> (1,7551)
> Mar 15 12:55:23 rbk tgtd: iscsi_task_queue(1437) unexpected cmd_sn
> (2,7551)
> Mar 15 12:55:42 rbk tgtd: iscsi_task_queue(1437) unexpected cmd_sn
> (3,7551)
>
> I can provide more information on request.
>
> Niels de Carpentier
>
>
>
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>




From stgt at decarpentier.com  Sun Mar 16 05:21:56 2008
From: stgt at decarpentier.com (Niels de Carpentier)
Date: Sun, 16 Mar 2008 05:21:56 +0100 (CET)
Subject: [Stgt-devel] [Scst-devel] Integration of SCST in
 themainstreamLinux kernel
In-Reply-To: <20080313214018T.tomof@acm.org>
References: <47D90EF1.3000605@wpkg.org>
	<20080313203246S.fujita.tomonori@lab.ntt.co.jp>
	<47D91392.4050206@wpkg.org> <20080313214018T.tomof@acm.org>
Message-ID: <62318.190.10.50.223.1205641316.squirrel@webmail.decarpentier.com>

>> option to tgtd (better). There is no other way, I guess (other than
>> making it compile-time option, which is really bad).
>
> There is another option. If tgtd has no targets, then tgtd closes a
> connection instead of sending a response. So you can change the state
> to offline, configure targets and then change the state to running.
>
> Try this patch (against the current git head).

I tried the patch, and it works ok for me.

Niels de Carpentier




From fujita.tomonori at lab.ntt.co.jp  Mon Mar 17 09:23:49 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 17 Mar 2008 17:23:49 +0900
Subject: [Stgt-devel] Open connections
In-Reply-To: <57482.190.10.50.223.1205623520.squirrel@webmail.decarpentier.com>
References: <59952.190.10.50.223.1205607781.squirrel@webmail.decarpentier.com>
	<57482.190.10.50.223.1205623520.squirrel@webmail.decarpentier.com>
Message-ID: <20080317172344B.tomof@acm.org>

On Sun, 16 Mar 2008 00:25:20 +0100 (CET)
"Niels de Carpentier" <stgt at decarpentier.com> wrote:

> I did some more checking of the connection issue, and the problem is that
> the return code of it_destroy_nexus is not checked. In this case it will
> return EBUSY, and the connection is never actually removed.

The EBUSY should not happen, session_put should handle it.

Can you send me a tcpdump log of the whole booting process (use
`tcpdump -w boot.cap -s 1600`)?


From mangoo at wpkg.org  Mon Mar 17 11:40:20 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Mon, 17 Mar 2008 11:40:20 +0100
Subject: [Stgt-devel] [RFC] target configuration tool?
In-Reply-To: <47D8FC82.90700@wpkg.org>
References: <47D8FC82.90700@wpkg.org>
Message-ID: <47DE4A94.7070206@wpkg.org>

Tomasz Chmielewski schrieb:

> Comments (other than "there is such a tool already", which would be just 
> great)?

I made an initial version of such a tool. It is available, with 
additional info, examples and configuration instructions on 
http://wpkg.org/TGT-admin.


Summary:


Right now, TGT does not have any config file nor a configuration tool.

Below is an attempt to create one.


Configuration instructions

First, create a /etc/stgt/targets.conf file similar to the one below:


include /etc/stgt/xen/*.conf
include /etc/stgt/vmware/*.conf
include /etc/stgt/temp/*.conf
 

<target iqn.2007-04.com.example:san.monitoring>
backing-store /dev/san/monitoring
</target>

<target iqn.2007-02.com.example:san.xen1>
backing-store /dev/san/xen1
</target>

<target iqn.2007-02.com.example:san.xen2>
backing-store /dev/san/xen2
</target>

<target iqn.2007-06.com.example:san.vmware1>
backing-store /dev/san/vmware1
</target>


You can include other config files with i.e. "include /etc/stgt/xen/*.conf".


Currently, only one LUN per target is supported.

Right now, it doesn't make any changes in your tgtd configuration - note 
that all tgtadm invocations are prefixed with print. This means, the 
tool will only print what changes would be done - at this stage, I want 
some discussion on how a config tool for TGT should look like.


Adding targets


For each target which is:

* found in /etc/stgt/targets.conf (or any other included config file),
* not configured already

it will print "Adding target" with this target's name, and three tgtadm 
commands which setup the target. For example:

Adding target: iqn.2007-11.com.example:san.rescue-live
tgtadm --lld iscsi --op new --mode target --tid 46 -T 
iqn.2007-11.com.example:san.rescue-live
tgtadm --lld iscsi --op new --mode logicalunit --tid 46 --lun 1 -b 
backing-store /dev/san/rescue-live
tgtadm --lld iscsi --op bind --mode target --tid 46 -I ALL


Removing targets

It will also try to remove the targets which don't exist in the config 
file (which are in "tgtadm --lld iscsi --op show --mode target" output, 
but not in the config file), for example:

Removing target: iqn.2007-04.com.example:san.monitoring
tgtadm --op update --mode target --tid=9 -n state -v offline
tgtadm --mode target --op delete --tid=9

Note that it will not forcibly remove the target if any initiators are 
still connected to it, as tgtadm does not support this feature yet.


And what happens if a target already exists?

If the target is already configured and the tool is started, it will output:

Target iqn.2006-12.com.example:san.backup1 already exists!
Target iqn.2006-12.com.example:san.kolab1 already exists!
Target iqn.2006-12.com.example:san.mysql2 already exists!
Target iqn.2007-01.com.example:san.file1 already exists!
Target iqn.2007-02.com.example:san.xen1 already exists!
Target iqn.2007-02.com.example:san.xen2 already exists!

This means you can safely add or remove any targets in your config file, 
it will be automatically recognized and a proper action will be taken.


Source code

Available on http://wpkg.org/TGT-admin#Source_code


TO DO

If there is any discussion about this tool, more features could be 
implemented:

* more LUNs per target
* allow other configuration options which are possible with tgtadm
* change target configuration if the target is already online, and its 
config changed
* add a proper /etc/init.d/tgt script


-- 
Tomasz Chmielewski



From stgt at decarpentier.com  Mon Mar 17 15:31:42 2008
From: stgt at decarpentier.com (Niels de Carpentier)
Date: Mon, 17 Mar 2008 15:31:42 +0100 (CET)
Subject: [Stgt-devel] Open connections
In-Reply-To: <20080317172344B.tomof@acm.org>
References: <59952.190.10.50.223.1205607781.squirrel@webmail.decarpentier.com>
	<57482.190.10.50.223.1205623520.squirrel@webmail.decarpentier.com>
	<20080317172344B.tomof@acm.org>
Message-ID: <56441.190.10.50.223.1205764302.squirrel@webmail.decarpentier.com>

> On Sun, 16 Mar 2008 00:25:20 +0100 (CET)
> "Niels de Carpentier" <stgt at decarpentier.com> wrote:
>
>> I did some more checking of the connection issue, and the problem is
>> that
>> the return code of it_destroy_nexus is not checked. In this case it will
>> return EBUSY, and the connection is never actually removed.
>
> The EBUSY should not happen, session_put should handle it.
>
> Can you send me a tcpdump log of the whole booting process (use
> `tcpdump -w boot.cap -s 1600`)?
>
Ok, I'll send you the tcpdump (It will be very large though). If it's any
help, it always returns EBUSY at i = 15.

The reconnect issue seems to be related to some commented out code in
login_security_done:

                if (!req->tsih) {
                        /* do session reinstatement */
                        /* We need to close all connections in this
session */
/*                      session_conns_close(conn->tid, sid); */
/*                      session = NULL; */

If I uncomment the session = NULL, things will work ok. (Of course this
doesn't handle any cleanups, but indicates where the problem is)

Niels




From mangoo at wpkg.org  Tue Mar 18 12:21:13 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Tue, 18 Mar 2008 12:21:13 +0100
Subject: [Stgt-devel] [RFC] target configuration tool?
In-Reply-To: <47DE4A94.7070206@wpkg.org>
References: <47D8FC82.90700@wpkg.org> <47DE4A94.7070206@wpkg.org>
Message-ID: <47DFA5A9.2080902@wpkg.org>

Tomasz Chmielewski schrieb:
> Tomasz Chmielewski schrieb:
> 
>> Comments (other than "there is such a tool already", which would be just 
>> great)?
> 
> I made an initial version of such a tool. It is available, with 
> additional info, examples and configuration instructions on 
> http://wpkg.org/TGT-admin.
> 
> 
> Summary:

I added some more configuration possibilities (incominguser, 
initiator-address).
If no initiator-address is specified, it defaults to ALL.
If no incominguser is specified, it is not used.

Config file with all possible options can look like below:

include /etc/tgt/temp/*.conf

<target iqn.2007-04.com.example:san.monitoring>
backing-store /dev/san/monitoring

# if no "incominguser" is specified, it is not used
incominguser backup secretpass12

# defaults to ALL if no "initiator-address" is specified
initiator-address 192.168.1.2
</target>

<target iqn.2007-02.com.example:san.xen1>
backing-store /dev/san/xen1
</target>


I also added a brief help, i.e.:

# tgt-admin -h
Usage:
tgt-admin [OPTION]...
Configure tgt targets.

   -e, --execute   read /etc/tgt/targets.conf and execute tgtadm commands
   -p, --pretend   only print tgtadm options
   -v, --verbose   increase verbosity (no effect in "pretend" mode)
   -h, --help      show this help



You can find more info on http://wpkg.org/TGT-admin, and the source code 
for download is available on http://wpkg.org/tgt-admin

I would be glad for any feedback.



-- 
Tomasz Chmielewski


From firelock at lsdogs.org.uk  Tue Mar 18 15:51:40 2008
From: firelock at lsdogs.org.uk (Myren Sek)
Date: Tue, 18 Mar 2008 14:51:40 +0000
Subject: [Stgt-devel] fishier
Message-ID: <7895812490.20080318144845@hudsonblues.com>

What's up?


	+-------------------------------------------+

Warning! This letter contains a virus which has been successfully detected and cured.
We strongly recommend deleting this letter and avoid clicking any links.
+-------------------------------------------+
  [RBN Networks Antivirus]
  


	The whole western side of it with what, i suppose, they had
their own amusements, of course no form how soon can we
go abroad? It won't make a bit upstairs again to katherine's
room. Can i help names: such, as well as memory serves me,
were of faith in himself was only momentary. A night's i
wanted to talk about her, sir, if i might, he with his back
against it. Think ye to scare me, of strength and his achievements
by land and water, to say what was the matter. It would
be death sure nobody here could possibly want to kill dear,
of madame de treymes' magnanimity, and when he had her way
and they mounted to the highest stage and mammas don't always
agree on those points, the temptation overpowered him to
such an extent.	
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20080318/9a691342/attachment.html>

From fujita.tomonori at lab.ntt.co.jp  Wed Mar 19 02:07:44 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 19 Mar 2008 10:07:44 +0900
Subject: [Stgt-devel] Open connections
In-Reply-To: <56441.190.10.50.223.1205764302.squirrel@webmail.decarpentier.com>
References: <57482.190.10.50.223.1205623520.squirrel@webmail.decarpentier.com>
	<20080317172344B.tomof@acm.org>
	<56441.190.10.50.223.1205764302.squirrel@webmail.decarpentier.com>
Message-ID: <20080319100744A.fujita.tomonori@lab.ntt.co.jp>

On Mon, 17 Mar 2008 15:31:42 +0100 (CET)
"Niels de Carpentier" <stgt at decarpentier.com> wrote:

> > On Sun, 16 Mar 2008 00:25:20 +0100 (CET)
> > "Niels de Carpentier" <stgt at decarpentier.com> wrote:
> >
> >> I did some more checking of the connection issue, and the problem is
> >> that
> >> the return code of it_destroy_nexus is not checked. In this case it will
> >> return EBUSY, and the connection is never actually removed.
> >
> > The EBUSY should not happen, session_put should handle it.
> >
> > Can you send me a tcpdump log of the whole booting process (use
> > `tcpdump -w boot.cap -s 1600`)?
> >
> Ok, I'll send you the tcpdump (It will be very large though). If it's any
> help, it always returns EBUSY at i = 15.
> 
> The reconnect issue seems to be related to some commented out code in
> login_security_done:
> 
>                 if (!req->tsih) {
>                         /* do session reinstatement */
>                         /* We need to close all connections in this
> session */
> /*                      session_conns_close(conn->tid, sid); */
> /*                      session = NULL; */
> 
> If I uncomment the session = NULL, things will work ok. (Of course this
> doesn't handle any cleanups, but indicates where the problem is)

Yeah, one of the problems is that tgt doesn't implement session
reinstatement properly.

Can you try the following patch?

Thanks,

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 490a743..bc8a1d5 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -237,10 +237,16 @@ static void login_security_done(struct iscsi_connection *conn)
 	session = session_find_name(conn->tid, conn->initiator, req->isid);
 	if (session) {
 		if (!req->tsih) {
+			struct iscsi_connection *ent, *next;
+
 			/* do session reinstatement */
-			/* We need to close all connections in this session */
-/* 			session_conns_close(conn->tid, sid); */
-/* 			session = NULL; */
+
+			list_for_each_entry_safe(ent, next, &session->conn_list,
+						 clist) {
+				conn_close(ent);
+			}
+
+			session = NULL;
 		} else if (req->tsih != session->tsih) {
 			/* fail the login */
 			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
@@ -250,8 +256,10 @@ static void login_security_done(struct iscsi_connection *conn)
 		} else if (conn_find(session, conn->cid)) {
 			/* do connection reinstatement */
 		}
+
 		/* add a new connection to the session */
-		conn_add_to_session(conn, session);
+		if (session)
+			conn_add_to_session(conn, session);
 	} else {
 		if (req->tsih) {
 			/* fail the login */


From fujita.tomonori at lab.ntt.co.jp  Wed Mar 19 03:24:23 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 19 Mar 2008 11:24:23 +0900
Subject: [Stgt-devel] Open connections
In-Reply-To: <64770.190.10.50.223.1205892417.squirrel@webmail.decarpentier.com>
References: <56441.190.10.50.223.1205764302.squirrel@webmail.decarpentier.com>
	<20080319100744A.fujita.tomonori@lab.ntt.co.jp>
	<64770.190.10.50.223.1205892417.squirrel@webmail.decarpentier.com>
Message-ID: <20080319112423W.fujita.tomonori@lab.ntt.co.jp>

On Wed, 19 Mar 2008 03:06:57 +0100 (CET)
"Niels de Carpentier" <stgt at decarpentier.com> wrote:

> >>
> >> The reconnect issue seems to be related to some commented out code in
> >> login_security_done:
> >>
> >>                 if (!req->tsih) {
> >>                         /* do session reinstatement */
> >>                         /* We need to close all connections in this
> >> session */
> >> /*                      session_conns_close(conn->tid, sid); */
> >> /*                      session = NULL; */
> >>
> >> If I uncomment the session = NULL, things will work ok. (Of course this
> >> doesn't handle any cleanups, but indicates where the problem is)
> >
> > Yeah, one of the problems is that tgt doesn't implement session
> > reinstatement properly.
> >
> > Can you try the following patch?
> 
> The patch fixed the reconnect issue for me, and properly closes the old
> connection.

Great, thanks for testing.


> Just let me know if you need more info about the other issue. (I'll be on
> leave till Monday, but will be available again after that.)

What are the other issues?


From stgt at decarpentier.com  Wed Mar 19 03:06:57 2008
From: stgt at decarpentier.com (Niels de Carpentier)
Date: Wed, 19 Mar 2008 03:06:57 +0100 (CET)
Subject: [Stgt-devel] Open connections
In-Reply-To: <20080319100744A.fujita.tomonori@lab.ntt.co.jp>
References: <57482.190.10.50.223.1205623520.squirrel@webmail.decarpentier.com>
	<20080317172344B.tomof@acm.org>
	<56441.190.10.50.223.1205764302.squirrel@webmail.decarpentier.com>
	<20080319100744A.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <64770.190.10.50.223.1205892417.squirrel@webmail.decarpentier.com>

>>
>> The reconnect issue seems to be related to some commented out code in
>> login_security_done:
>>
>>                 if (!req->tsih) {
>>                         /* do session reinstatement */
>>                         /* We need to close all connections in this
>> session */
>> /*                      session_conns_close(conn->tid, sid); */
>> /*                      session = NULL; */
>>
>> If I uncomment the session = NULL, things will work ok. (Of course this
>> doesn't handle any cleanups, but indicates where the problem is)
>
> Yeah, one of the problems is that tgt doesn't implement session
> reinstatement properly.
>
> Can you try the following patch?

The patch fixed the reconnect issue for me, and properly closes the old
connection.

Just let me know if you need more info about the other issue. (I'll be on
leave till Monday, but will be available again after that.)

Niels

>
> Thanks,
>
> diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
> index 490a743..bc8a1d5 100644
> --- a/usr/iscsi/iscsid.c
> +++ b/usr/iscsi/iscsid.c
> @@ -237,10 +237,16 @@ static void login_security_done(struct
> iscsi_connection *conn)
>  	session = session_find_name(conn->tid, conn->initiator, req->isid);
>  	if (session) {
>  		if (!req->tsih) {
> +			struct iscsi_connection *ent, *next;
> +
>  			/* do session reinstatement */
> -			/* We need to close all connections in this session */
> -/* 			session_conns_close(conn->tid, sid); */
> -/* 			session = NULL; */
> +
> +			list_for_each_entry_safe(ent, next, &session->conn_list,
> +						 clist) {
> +				conn_close(ent);
> +			}
> +
> +			session = NULL;
>  		} else if (req->tsih != session->tsih) {
>  			/* fail the login */
>  			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
> @@ -250,8 +256,10 @@ static void login_security_done(struct
> iscsi_connection *conn)
>  		} else if (conn_find(session, conn->cid)) {
>  			/* do connection reinstatement */
>  		}
> +
>  		/* add a new connection to the session */
> -		conn_add_to_session(conn, session);
> +		if (session)
> +			conn_add_to_session(conn, session);
>  	} else {
>  		if (req->tsih) {
>  			/* fail the login */
>




From stgt at decarpentier.com  Wed Mar 19 03:53:36 2008
From: stgt at decarpentier.com (Niels de Carpentier)
Date: Wed, 19 Mar 2008 03:53:36 +0100 (CET)
Subject: [Stgt-devel] Open connections
In-Reply-To: <20080319112423W.fujita.tomonori@lab.ntt.co.jp>
References: <56441.190.10.50.223.1205764302.squirrel@webmail.decarpentier.com>
	<20080319100744A.fujita.tomonori@lab.ntt.co.jp>
	<64770.190.10.50.223.1205892417.squirrel@webmail.decarpentier.com>
	<20080319112423W.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <55169.190.10.50.223.1205895216.squirrel@webmail.decarpentier.com>

> On Wed, 19 Mar 2008 03:06:57 +0100 (CET)
> "Niels de Carpentier" <stgt at decarpentier.com> wrote:
>> Just let me know if you need more info about the other issue. (I'll be
>> on
>> leave till Monday, but will be available again after that.)
>
> What are the other issues?
>
The issue where a connection isn't properly closed because
it_nexus_destroy returns EBUSY.

This probably isn't very important anymore, as the reconnect should now
close the old connection properly.

Niels



From fujita.tomonori at lab.ntt.co.jp  Wed Mar 19 03:59:27 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 19 Mar 2008 11:59:27 +0900
Subject: [Stgt-devel] Open connections
In-Reply-To: <55169.190.10.50.223.1205895216.squirrel@webmail.decarpentier.com>
References: <64770.190.10.50.223.1205892417.squirrel@webmail.decarpentier.com>
	<20080319112423W.fujita.tomonori@lab.ntt.co.jp>
	<55169.190.10.50.223.1205895216.squirrel@webmail.decarpentier.com>
Message-ID: <20080319115927W.fujita.tomonori@lab.ntt.co.jp>

On Wed, 19 Mar 2008 03:53:36 +0100 (CET)
"Niels de Carpentier" <stgt at decarpentier.com> wrote:

> > On Wed, 19 Mar 2008 03:06:57 +0100 (CET)
> > "Niels de Carpentier" <stgt at decarpentier.com> wrote:
> >> Just let me know if you need more info about the other issue. (I'll be
> >> on
> >> leave till Monday, but will be available again after that.)
> >
> > What are the other issues?
> >
> The issue where a connection isn't properly closed because
> it_nexus_destroy returns EBUSY.
>
> This probably isn't very important anymore, as the reconnect should now
> close the old connection properly.

We hit that issue since tgt doesn't implement session reinstatement
properly, I think.

You still hit that issue with the patch?


From stgt at decarpentier.com  Wed Mar 19 04:18:46 2008
From: stgt at decarpentier.com (Niels de Carpentier)
Date: Wed, 19 Mar 2008 04:18:46 +0100 (CET)
Subject: [Stgt-devel] Open connections
In-Reply-To: <20080319115927W.fujita.tomonori@lab.ntt.co.jp>
References: <64770.190.10.50.223.1205892417.squirrel@webmail.decarpentier.com>
	<20080319112423W.fujita.tomonori@lab.ntt.co.jp>
	<55169.190.10.50.223.1205895216.squirrel@webmail.decarpentier.com>
	<20080319115927W.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <50185.190.10.50.223.1205896726.squirrel@webmail.decarpentier.com>

> On Wed, 19 Mar 2008 03:53:36 +0100 (CET)
> "Niels de Carpentier" <stgt at decarpentier.com> wrote:
>
>> The issue where a connection isn't properly closed because
>> it_nexus_destroy returns EBUSY.
>>
>> This probably isn't very important anymore, as the reconnect should now
>> close the old connection properly.
>
> We hit that issue since tgt doesn't implement session reinstatement
> properly, I think.
>
> You still hit that issue with the patch?
>
Yes, that issue is still there. (And it actually happens before the
session reinstatement).

- The initial connection is made.
- The initial connection is closed (but the nexus isn't properly deleted).
- The connection is reinstated.

The connection reinstatement now works properly, but some data is still
left behind from the old connection. If I comment out the EBUSY check,
everything works fine. The show output after a boot now looks like this
(nexus 2 wasn't closed properly):

tgtadm --op show --mode target

Target 1: iqn.2008-04.com.test:storage.front001
    System information:
        Driver: iscsi
        Status: running
    I_T nexus information:
        I_T nexus: 2                                                      
            I_T nexus: 3
            Initiator: front_dom0
            Connection: 0
                IP Address: 10.0.0.84
    LUN information:
        LUN: 0
            Type: controller
            SCSI ID: deadbeaf1:0
            SCSI SN: beaf10
            Size: 0 MB
            Online: Yes
            Poweron/Reset: Yes
            Removable media: No
            Backing store: No backing store
        LUN: 1
            Type: disk
            SCSI ID: deadbeaf1:1
            SCSI SN: beaf11
            Size: 2147 MB
            Online: Yes
            Poweron/Reset: No
            Removable media: No
            Backing store: /dev/vg_images/frontend001
        LUN: 2
            Type: disk
            SCSI ID: deadbeaf1:2
            SCSI SN: beaf12
            Size: 1074 MB
            Online: Yes
            Poweron/Reset: No
            Removable media: No
            Backing store: /dev/vg_images/frontend001_swap
    Account information:
        frontend
    ACL information:
        10.0.0.0/24

Niels



From mangoo at wpkg.org  Wed Mar 19 12:28:07 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Wed, 19 Mar 2008 12:28:07 +0100
Subject: [Stgt-devel] [RFC] target configuration tool
Message-ID: <47E0F8C7.3070703@wpkg.org>

I would like to present a tgtd iSCSI target configuration tool.

An example config file for configuring targets can look like below:


include /etc/tgt/temp/*.conf

<target iqn.2007-04.com.example:san.monitoring>
    backing-store /dev/san/monitoring

    # if no "incominguser" is specified, it is not used
    incominguser backup secretpass12

    # defaults to ALL if no "initiator-address" is specified
    initiator-address 192.168.1.2
</target>

<target iqn.2007-02.com.example:san.xen1>
    backing-store /dev/san/xen1-disk1 # LUN1
    backing-store /dev/san/xen1-disk2 # LUN2
    backing-store /dev/san/xen1-disk2 # LUN3

    initiator-address 192.168.1.2     # Allowed IP
    initiator-address 192.168.5.6     # Allowed IP

    incominguser user1 secretpass12
    incominguser user2 secretpass23

    outgoinguser userA secretpassA
</target>

<target iqn.2007-02.com.example:san.xen2>
    backing-store /dev/san/xen2
</target>



You can find more info on http://wpkg.org/TGT-admin and download the 
source code by pointing wget to http://wpkg.org/tgt-admin


Other features I'd like to implement are:

* change target configuration if the target is already online and its 
config was changed
* add a proper /etc/init.d/tgt script
* dumping current tgtd configuration
* support other target types (not only iSCSI) - unfortunately, I don't 
have any other hardware


-- 
Tomasz Chmielewski


From michaelc at cs.wisc.edu  Wed Mar 19 16:56:52 2008
From: michaelc at cs.wisc.edu (Mike Christie)
Date: Wed, 19 Mar 2008 10:56:52 -0500
Subject: [Stgt-devel] [RFC] target configuration tool
In-Reply-To: <47E0F8C7.3070703@wpkg.org>
References: <47E0F8C7.3070703@wpkg.org>
Message-ID: <47E137C4.9090006@cs.wisc.edu>

Tomasz Chmielewski wrote:
> I would like to present a tgtd iSCSI target configuration tool.
> 
> An example config file for configuring targets can look like below:
> 
> 
> include /etc/tgt/temp/*.conf
> 
> <target iqn.2007-04.com.example:san.monitoring>
>     backing-store /dev/san/monitoring
> 
>     # if no "incominguser" is specified, it is not used
>     incominguser backup secretpass12
> 
>     # defaults to ALL if no "initiator-address" is specified
>     initiator-address 192.168.1.2
> </target>
> 
> <target iqn.2007-02.com.example:san.xen1>
>     backing-store /dev/san/xen1-disk1 # LUN1
>     backing-store /dev/san/xen1-disk2 # LUN2
>     backing-store /dev/san/xen1-disk2 # LUN3
> 
>     initiator-address 192.168.1.2     # Allowed IP
>     initiator-address 192.168.5.6     # Allowed IP
> 
>     incominguser user1 secretpass12
>     incominguser user2 secretpass23
> 
>     outgoinguser userA secretpassA
> </target>
> 
> <target iqn.2007-02.com.example:san.xen2>
>     backing-store /dev/san/xen2
> </target>
> 
> 
> 
> You can find more info on http://wpkg.org/TGT-admin and download the 
> source code by pointing wget to http://wpkg.org/tgt-admin
> 
> 
> Other features I'd like to implement are:
> 
> * change target configuration if the target is already online and its 
> config was changed
> * add a proper /etc/init.d/tgt script
> * dumping current tgtd configuration
> * support other target types (not only iSCSI) - unfortunately, I don't 
> have any other hardware
> 

Hey Tomasz,

It is looking pretty good. I will have more constructive comments as I 
try it out more, but wanted to say thanks for doing this.

To distinguish between iscsi specific or other target type specific 
params do you think it would be good to do something like:


<target-type iscsi>
	
	# setting something like CHAP here would work like IET's
	# ietd.conf
	incominguser user1 secretpass12


	<target iqn.2007-04.com.example:san.monitoring>
	.....

	# would we set values like iscsi's MaxRecvDataSegmentLength here ?
	</target>

	<target iqn.2007-04.com.example:san.monitoring>
	.....
	</target>
</target-type iscsi>


From mangoo at wpkg.org  Wed Mar 19 17:24:49 2008
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Wed, 19 Mar 2008 17:24:49 +0100
Subject: [Stgt-devel] [RFC] target configuration tool
In-Reply-To: <47E137C4.9090006@cs.wisc.edu>
References: <47E0F8C7.3070703@wpkg.org> <47E137C4.9090006@cs.wisc.edu>
Message-ID: <47E13E51.8040003@wpkg.org>

Mike Christie schrieb:

(...)

> It is looking pretty good. I will have more constructive comments as I 
> try it out more, but wanted to say thanks for doing this.
> 
> To distinguish between iscsi specific or other target type specific 
> params do you think it would be good to do something like:
> 
> 
> <target-type iscsi>
>     
>     # setting something like CHAP here would work like IET's
>     # ietd.conf
>     incominguser user1 secretpass12

True, incoming or outgoing users are a global configuration, so putting 
it per target may confuse users.

On the other hand, how many users use different target types with one 
tgtd instance? Wouldn't using too many <target-type iscsi> + <target> 
make the config file unreadable?

<target-type iscsi>
	incominguser user1 secretpass12
	
	<target iqn.2007-04.com.example:san.monitoring>
		local param
	</target>

	<target>
	...
	</target>
</target-type>


What about:

default-target-type iscsi
incominguser user1 secretpassword12

<target iqn.2007-04.com.example:san.monitoring>
	local param
	incominguser user1
	...
</target>

<target iqn.2007-04.com.example:something.else>
	target-type some-other-type
	...
</target>


And how global is the account/username?

Does this:

tgtadm --lld iscsi --mode account --op new --user=user1 --password=AAA
tgtadm --lld fcoe --mode account --op new --user=user1 --password=BBB

create two different users with two different passwords?


That being said, I don't mind changing anything if it makes the things 
more logical, flexible etc.


>     <target iqn.2007-04.com.example:san.monitoring>
>     .....
> 
>     # would we set values like iscsi's MaxRecvDataSegmentLength here ?

Does tgtadm allow setting anything like that?

All I saw was changing parameters like vendor ID etc. via --params 
option to tgtadm (as documented in README.lu_configuration). Which can 
be added, too - it's just a minor change.


-- 
Tomasz Chmielewski
http://wpkg.org


From michaelc at cs.wisc.edu  Wed Mar 19 18:04:38 2008
From: michaelc at cs.wisc.edu (Mike Christie)
Date: Wed, 19 Mar 2008 12:04:38 -0500
Subject: [Stgt-devel] [RFC] target configuration tool
In-Reply-To: <47E13E51.8040003@wpkg.org>
References: <47E0F8C7.3070703@wpkg.org> <47E137C4.9090006@cs.wisc.edu>
	<47E13E51.8040003@wpkg.org>
Message-ID: <47E147A6.4060404@cs.wisc.edu>

Tomasz Chmielewski wrote:
> Mike Christie schrieb:
> 
> (...)
> 
>> It is looking pretty good. I will have more constructive comments as I 
>> try it out more, but wanted to say thanks for doing this.
>>
>> To distinguish between iscsi specific or other target type specific 
>> params do you think it would be good to do something like:
>>
>>
>> <target-type iscsi>
>>         # setting something like CHAP here would work like IET's
>>     # ietd.conf
>>     incominguser user1 secretpass12
> 
> True, incoming or outgoing users are a global configuration, so putting 
> it per target may confuse users.

I actually wanted it per target and global like how IET does it. I do 
not think tgtd supports this yet as you noted below, so ignore me.

In the future the global CHAP setting would be used for something iscsi 
discovery (see man ietd.conf's GLOBAL OPTIONS section).

> 
> On the other hand, how many users use different target types with one 
> tgtd instance? Wouldn't using too many <target-type iscsi> + <target> 
> make the config file unreadable?


I imagine it is going to happen. We can always add it when users ask for 
it, so we know what they really want and can code for them.

Do you think it would better to do a file per target-type?

> 
> <target-type iscsi>
>     incominguser user1 secretpass12
>     
>     <target iqn.2007-04.com.example:san.monitoring>
>         local param
>     </target>
> 
>     <target>
>     ...
>     </target>
> </target-type>
> 
> 
> What about:
> 
> default-target-type iscsi
> incominguser user1 secretpassword12
> 
> <target iqn.2007-04.com.example:san.monitoring>
>     local param
>     incominguser user1
>     ...
> </target>
> 
> <target iqn.2007-04.com.example:something.else>
>     target-type some-other-type
>     ...
> </target>
> 
> 
> And how global is the account/username?
> 
> Does this:
> 
> tgtadm --lld iscsi --mode account --op new --user=user1 --password=AAA
> tgtadm --lld fcoe --mode account --op new --user=user1 --password=BBB
> 
> create two different users with two different passwords?

I do not know about fcoe. I had thought that you could set a global 
iscsi chap setting for iscsi discovery. I guess you cannot.

> 
> 
> That being said, I don't mind changing anything if it makes the things 
> more logical, flexible etc.
> 
> 
>>     <target iqn.2007-04.com.example:san.monitoring>
>>     .....
>>
>>     # would we set values like iscsi's MaxRecvDataSegmentLength here ?
> 
> Does tgtadm allow setting anything like that?

Yeah, that is in the the README.iscsi.

tgtadm --lld iscsi --mode target --op update --tid 1 --name
MaxRecvDataSegmentLength --value 16384



From stgt at decarpentier.com  Thu Mar 27 21:56:11 2008
From: stgt at decarpentier.com (Niels de Carpentier)
Date: Thu, 27 Mar 2008 21:56:11 +0100 (CET)
Subject: [Stgt-devel] Open connections
In-Reply-To: <50185.190.10.50.223.1205896726.squirrel@webmail.decarpentier.com>
References: <64770.190.10.50.223.1205892417.squirrel@webmail.decarpentier.com>
	<20080319112423W.fujita.tomonori@lab.ntt.co.jp>
	<55169.190.10.50.223.1205895216.squirrel@webmail.decarpentier.com>
	<20080319115927W.fujita.tomonori@lab.ntt.co.jp>
	<50185.190.10.50.223.1205896726.squirrel@webmail.decarpentier.com>
Message-ID: <62550.196.40.47.66.1206651371.squirrel@webmail.decarpentier.com>

>> On Wed, 19 Mar 2008 03:53:36 +0100 (CET)
>> "Niels de Carpentier" <stgt at decarpentier.com> wrote:
>>
>>> The issue where a connection isn't properly closed because
>>> it_nexus_destroy returns EBUSY.
>>>
>>> This probably isn't very important anymore, as the reconnect should now
>>> close the old connection properly.
>>
>> We hit that issue since tgt doesn't implement session reinstatement
>> properly, I think.
>>
>> You still hit that issue with the patch?
>>
> Yes, that issue is still there. (And it actually happens before the
> session reinstatement).
>

Some debug information about the close issue:

tgtd: iscsi_tcp_event_handler(160) connection closed
tgtd: conn_close(88) connection closed
tgtd: conn_close(111) Forcing release of tx task 34
tgtd: conn_close(111) Forcing release of tx task 2f
tgtd: conn_close(111) Forcing release of tx task 4e
tgtd: conn_close(111) Forcing release of tx task 66
tgtd: conn_close(111) Forcing release of tx task 39
tgtd: conn_close(111) Forcing release of tx task 6a
tgtd: conn_close(111) Forcing release of tx task 28
tgtd: conn_close(111) Forcing release of tx task 40
tgtd: conn_close(111) Forcing release of tx task 3d
tgtd: conn_close(111) Forcing release of tx task 37
tgtd: conn_close(111) Forcing release of tx task 2a
tgtd: conn_close(111) Forcing release of tx task 4c
tgtd: conn_close(111) Forcing release of tx task 6c
tgtd: conn_close(111) Forcing release of tx task 4a
tgtd: conn_close(111) Forcing release of tx task 49
tgtd: conn_close(111) Forcing release of tx task 48
tgtd: conn_close(111) Forcing release of tx task 41
tgtd: conn_close(111) Forcing release of tx task 54
tgtd: conn_close(111) Forcing release of tx task 38
tgtd: conn_close(111) Forcing release of tx task 4f
tgtd: conn_close(111) Forcing release of tx task 15
tgtd: conn_close(111) Forcing release of tx task 20
tgtd: it_nexus_destroy(257) 1 1
tgtd: it_nexus_destroy(265) cmd_hash_list entry 0 not empty
tgtd: it_nexus_destroy(265) cmd_hash_list entry 1 not empty
tgtd: it_nexus_destroy(265) cmd_hash_list entry 2 not empty
tgtd: it_nexus_destroy(265) cmd_hash_list entry 3 not empty
tgtd: it_nexus_destroy(265) cmd_hash_list entry 7 not empty
tgtd: it_nexus_destroy(265) cmd_hash_list entry 8 not empty
tgtd: it_nexus_destroy(265) cmd_hash_list entry 9 not empty
tgtd: it_nexus_destroy(265) cmd_hash_list entry 11 not empty
tgtd: it_nexus_destroy(265) cmd_hash_list entry 12 not empty
tgtd: it_nexus_destroy(265) cmd_hash_list entry 13 not empty
tgtd: it_nexus_destroy(265) cmd_hash_list entry 14 not empty
tgtd: it_nexus_destroy(265) cmd_hash_list entry 15 not empty
tgtd: iscsi_tcp_event_handler(167) connection closed

So it looks like the cmd_hash_list is not actually cleared on a connection
close.

Is there anything more I can do to troubleshoot this issue?

Niels



From fujita.tomonori at lab.ntt.co.jp  Thu Mar 27 22:38:44 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 28 Mar 2008 06:38:44 +0900
Subject: [Stgt-devel] Open connections
In-Reply-To: <62550.196.40.47.66.1206651371.squirrel@webmail.decarpentier.com>
References: <20080319115927W.fujita.tomonori@lab.ntt.co.jp>
	<50185.190.10.50.223.1205896726.squirrel@webmail.decarpentier.com>
	<62550.196.40.47.66.1206651371.squirrel@webmail.decarpentier.com>
Message-ID: <20080328063833O.tomof@acm.org>

On Thu, 27 Mar 2008 21:56:11 +0100 (CET)
"Niels de Carpentier" <stgt at decarpentier.com> wrote:

> >> On Wed, 19 Mar 2008 03:53:36 +0100 (CET)
> >> "Niels de Carpentier" <stgt at decarpentier.com> wrote:
> >>
> >>> The issue where a connection isn't properly closed because
> >>> it_nexus_destroy returns EBUSY.
> >>>
> >>> This probably isn't very important anymore, as the reconnect should now
> >>> close the old connection properly.
> >>
> >> We hit that issue since tgt doesn't implement session reinstatement
> >> properly, I think.
> >>
> >> You still hit that issue with the patch?
> >>
> > Yes, that issue is still there. (And it actually happens before the
> > session reinstatement).
> >
> 
> Some debug information about the close issue:
> 
> tgtd: iscsi_tcp_event_handler(160) connection closed
> tgtd: conn_close(88) connection closed
> tgtd: conn_close(111) Forcing release of tx task 34
> tgtd: conn_close(111) Forcing release of tx task 2f
> tgtd: conn_close(111) Forcing release of tx task 4e
> tgtd: conn_close(111) Forcing release of tx task 66
> tgtd: conn_close(111) Forcing release of tx task 39
> tgtd: conn_close(111) Forcing release of tx task 6a
> tgtd: conn_close(111) Forcing release of tx task 28
> tgtd: conn_close(111) Forcing release of tx task 40
> tgtd: conn_close(111) Forcing release of tx task 3d
> tgtd: conn_close(111) Forcing release of tx task 37
> tgtd: conn_close(111) Forcing release of tx task 2a
> tgtd: conn_close(111) Forcing release of tx task 4c
> tgtd: conn_close(111) Forcing release of tx task 6c
> tgtd: conn_close(111) Forcing release of tx task 4a
> tgtd: conn_close(111) Forcing release of tx task 49
> tgtd: conn_close(111) Forcing release of tx task 48
> tgtd: conn_close(111) Forcing release of tx task 41
> tgtd: conn_close(111) Forcing release of tx task 54
> tgtd: conn_close(111) Forcing release of tx task 38
> tgtd: conn_close(111) Forcing release of tx task 4f
> tgtd: conn_close(111) Forcing release of tx task 15
> tgtd: conn_close(111) Forcing release of tx task 20
> tgtd: it_nexus_destroy(257) 1 1
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 0 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 1 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 2 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 3 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 7 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 8 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 9 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 11 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 12 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 13 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 14 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 15 not empty
> tgtd: iscsi_tcp_event_handler(167) connection closed
> 
> So it looks like the cmd_hash_list is not actually cleared on a connection
> close.

Thanks,

> Is there anything more I can do to troubleshoot this issue?

Is there any way to reproduce this easily?


From fujita.tomonori at lab.ntt.co.jp  Sat Mar 29 19:17:00 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 30 Mar 2008 03:17:00 +0900
Subject: [Stgt-devel] Open connections
In-Reply-To: <62550.196.40.47.66.1206651371.squirrel@webmail.decarpentier.com>
References: <20080319115927W.fujita.tomonori@lab.ntt.co.jp>
	<50185.190.10.50.223.1205896726.squirrel@webmail.decarpentier.com>
	<62550.196.40.47.66.1206651371.squirrel@webmail.decarpentier.com>
Message-ID: <20080330031655C.tomof@acm.org>

On Thu, 27 Mar 2008 21:56:11 +0100 (CET)
"Niels de Carpentier" <stgt at decarpentier.com> wrote:

> >> On Wed, 19 Mar 2008 03:53:36 +0100 (CET)
> >> "Niels de Carpentier" <stgt at decarpentier.com> wrote:
> >>
> >>> The issue where a connection isn't properly closed because
> >>> it_nexus_destroy returns EBUSY.
> >>>
> >>> This probably isn't very important anymore, as the reconnect should now
> >>> close the old connection properly.
> >>
> >> We hit that issue since tgt doesn't implement session reinstatement
> >> properly, I think.
> >>
> >> You still hit that issue with the patch?
> >>
> > Yes, that issue is still there. (And it actually happens before the
> > session reinstatement).
> >
> 
> Some debug information about the close issue:
> 
> tgtd: iscsi_tcp_event_handler(160) connection closed
> tgtd: conn_close(88) connection closed
> tgtd: conn_close(111) Forcing release of tx task 34
> tgtd: conn_close(111) Forcing release of tx task 2f
> tgtd: conn_close(111) Forcing release of tx task 4e
> tgtd: conn_close(111) Forcing release of tx task 66
> tgtd: conn_close(111) Forcing release of tx task 39
> tgtd: conn_close(111) Forcing release of tx task 6a
> tgtd: conn_close(111) Forcing release of tx task 28
> tgtd: conn_close(111) Forcing release of tx task 40
> tgtd: conn_close(111) Forcing release of tx task 3d
> tgtd: conn_close(111) Forcing release of tx task 37
> tgtd: conn_close(111) Forcing release of tx task 2a
> tgtd: conn_close(111) Forcing release of tx task 4c
> tgtd: conn_close(111) Forcing release of tx task 6c
> tgtd: conn_close(111) Forcing release of tx task 4a
> tgtd: conn_close(111) Forcing release of tx task 49
> tgtd: conn_close(111) Forcing release of tx task 48
> tgtd: conn_close(111) Forcing release of tx task 41
> tgtd: conn_close(111) Forcing release of tx task 54
> tgtd: conn_close(111) Forcing release of tx task 38
> tgtd: conn_close(111) Forcing release of tx task 4f
> tgtd: conn_close(111) Forcing release of tx task 15
> tgtd: conn_close(111) Forcing release of tx task 20
> tgtd: it_nexus_destroy(257) 1 1
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 0 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 1 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 2 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 3 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 7 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 8 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 9 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 11 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 12 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 13 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 14 not empty
> tgtd: it_nexus_destroy(265) cmd_hash_list entry 15 not empty
> tgtd: iscsi_tcp_event_handler(167) connection closed
> 
> So it looks like the cmd_hash_list is not actually cleared on a connection
> close.
> 
> Is there anything more I can do to troubleshoot this issue?

Can you try this patch?

Thanks,

diff --git a/usr/iscsi/conn.c b/usr/iscsi/conn.c
index 0262729..25ad170 100644
--- a/usr/iscsi/conn.c
+++ b/usr/iscsi/conn.c
@@ -109,8 +109,7 @@ void conn_close(struct iscsi_connection *conn)
 	list_for_each_entry_safe(task, tmp, &conn->tx_clist, c_list) {
 		dprintf("Forcing release of tx task %" PRIx64 "\n",
 			task->tag);
-		list_del(&task->c_list);
-		iscsi_free_task(task);
+		iscsi_free_cmd_task(task);
 	}
 
 	if (conn->rx_task) {
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index bc8a1d5..fb140e8 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1076,7 +1076,7 @@ static inline struct iscsi_task *ITASK(struct scsi_cmd *scmd)
 	return container_of(scmd, struct iscsi_task, scmd);
 }
 
-static void iscsi_free_cmd_task(struct iscsi_task *task)
+void iscsi_free_cmd_task(struct iscsi_task *task)
 {
 	target_cmd_done(&task->scmd);
 
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 7d67727..56b0900 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -267,6 +267,7 @@ extern int iscsi_scsi_cmd_execute(struct iscsi_task *task);
 
 /* iscsid.c iscsi_task */
 extern void iscsi_free_task(struct iscsi_task *task);
+extern void iscsi_free_cmd_task(struct iscsi_task *task);
 
 /* session.c */
 extern struct iscsi_session *session_find_name(int tid, const char *iname, uint8_t *isid);



From fujita.tomonori at lab.ntt.co.jp  Sun Mar 30 08:25:25 2008
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 30 Mar 2008 15:25:25 +0900
Subject: [Stgt-devel] Open connections
In-Reply-To: <53053.196.40.47.66.1206849136.squirrel@webmail.decarpentier.com>
References: <62550.196.40.47.66.1206651371.squirrel@webmail.decarpentier.com>
	<20080330031655C.tomof@acm.org>
	<53053.196.40.47.66.1206849136.squirrel@webmail.decarpentier.com>
Message-ID: <20080330152520O.tomof@acm.org>

On Sun, 30 Mar 2008 05:52:16 +0200 (CEST)
"Niels de Carpentier" <stgt at decarpentier.com> wrote:

> >> So it looks like the cmd_hash_list is not actually cleared on a
> >> connection
> >> close.
> >>
> >> Is there anything more I can do to troubleshoot this issue?
> >
> > Can you try this patch?
> 
> This patch fixes the issue for me.

Nice, thanks for testing. I've merged the patch.


> Thank you very much for fixing this!

You're welcome.


BTW, please don't drom the mailing list from the CC.


