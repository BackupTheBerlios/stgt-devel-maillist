From mangoo at wpkg.org  Sat Sep  1 00:51:21 2007
From: mangoo at wpkg.org (Tomasz Chmielewski)
Date: Sat, 01 Sep 2007 00:51:21 +0200
Subject: [Stgt-devel] raw/pass-through support?
Message-ID: <46D89B69.5070302@wpkg.org>

Is raw/pass-through possible with stgt?

I have a SCSI tape drive which I'd like to make available to other 
initiators, is it possible to use raw/pass-through with stgt?


-- 
Tomasz Chmielewski
http://wpkg.org




From albert.pauw at gmail.com  Sat Sep  1 09:47:15 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Sat, 01 Sep 2007 09:47:15 +0200
Subject: [Stgt-devel] Can't compile the git version
In-Reply-To: <200708311914.l7VJEDTM032198@mbox.iij4u.or.jp>
References: <46D860F3.3060304@gmail.com>
	<200708311914.l7VJEDTM032198@mbox.iij4u.or.jp>
Message-ID: <46D91903.80409@gmail.com>

Sorry about the html part.

This fixed my compile thanks.

Albert
> Sorry, I messed up when I added fc target mode support. Please try
> this patch.
>
> BTW, please use a plain-text mail format. I ignore html mails unless I
> find an important subject.
>
> diff --git a/usr/Makefile b/usr/Makefile
> index 43565df..4c918d4 100644
> --- a/usr/Makefile
> +++ b/usr/Makefile
> @@ -39,8 +39,8 @@ TGTD_OBJS += bs_sync.o
>  LIBS += -lcrypto -lpthread
>  endif
>  
> -ifneq ($(FC),)
> -CFLAGS += -DFC -DUSE_KERNEL
> +ifneq ($(FCP),)
> +CFLAGS += -DFCP -DUSE_KERNEL
>  TGTD_OBJS += $(addprefix fc/, fc.o)
>  TGTD_OBJS += bs_mmap.o tgtif.o
>  endif
> diff --git a/usr/driver.c b/usr/driver.c
> index 2f6e154..068b410 100644
> --- a/usr/driver.c
> +++ b/usr/driver.c
> @@ -39,7 +39,7 @@ struct tgt_driver *tgt_drivers[] = {
>  #ifdef XEN
>  	&xen,
>  #endif
> -#ifdef FC
> +#ifdef FCP
>  	&fc,
>  #endif
>  	NULL,
>
>   



From nezhinsky at gmail.com  Sat Sep  1 10:14:07 2007
From: nezhinsky at gmail.com (Alexander Nezhinsky)
Date: Sat, 1 Sep 2007 10:14:07 +0200
Subject: [Stgt-devel] close completes before synchronize cache response
In-Reply-To: <20070831185345.GE5667@osc.edu>
References: <20070831170633.GA5667@osc.edu> <46D85491.9060002@cs.wisc.edu>
	<20070831185345.GE5667@osc.edu>
Message-ID: <5eb093080709010114p334f12a9rb35c45d33a4d6072@mail.gmail.com>

> Of course the initiatior should be waiting for the cache flush to
> complete on the target.  I just assumed it was something in the target.

In this case it was an initiator problem, as Mike explained, but regarding
your previous question:

> Can we delay the close until all command responses have been
> sent somehow?

it seems that we can't do it anyway, because it contradicts what iscsi
spec says (10.14):
"When receiving a Logout Request with the reason code of "close the
connection" or "close the session", the target MUST terminate all
pending commands".

Even in the case of a logout with connection recovery, when the target retains
some of the commands, it should not explicitly wait for their completion as it:
"MUST discard all requests not yet acknowledged via ExpCmdSN ...,
and suspend all data/status/R2T transfers on behalf of pending commands"


From tomof at acm.org  Sat Sep  1 21:53:32 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 2 Sep 2007 04:53:32 +0900
Subject: [Stgt-devel] [PATCH] Makefile auto dependencies
In-Reply-To: <Pine.LNX.4.64.0708311614280.11401@oldsony>
References: <Pine.LNX.4.64.0708311614280.11401@oldsony>
Message-ID: <20070901051856J.tomof@acm.org>

On Fri, 31 Aug 2007 16:21:53 +0300 (IDT)
Alexander Nezhinsky <nezhinsky at gmail.com> wrote:

> Resending Makefile patch for the current head. 
> 
> Dependency files generated using -MM flag of gcc and included to
> the Makefile itself.
> .PHONY target declarations added where appropriate.
> Few lines longer than 80 chars broken. 
> 
> Signed-off-by: Alexander Nezhinsky <nezhinsky at gmail.com>
> ---
>  usr/Makefile |   29 ++++++++++++++++++++++-------
>  1 files changed, 22 insertions(+), 7 deletions(-)
> 
> diff --git a/usr/Makefile b/usr/Makefile

Applied, thanks.

Next time, please take care about trailing whitespaces:


fujita at arbre:~/git/tgt$ git-am ~/Mail/iscsi/stgt/1990

Applying Makefile auto dependencies

Adds trailing whitespace.
.dotest/patch:27:CFLAGS += -D_LARGEFILE64_SOURCE
Adds trailing whitespace.
.dotest/patch:29:CFLAGS += -g -O2 -Wall -Wstrict-prototypes -fPIC
warning: 2 lines add trailing whitespaces.
Wrote tree f082e57831e208356bb4f5e8e07280e3f525bca6
Committed: 5374fe5723936bf58df951ca1a32d422c7006035


From tomof at acm.org  Sat Sep  1 21:53:37 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 2 Sep 2007 04:53:37 +0900
Subject: [Stgt-devel] raw/pass-through support?
In-Reply-To: <46D89B69.5070302@wpkg.org>
References: <46D89B69.5070302@wpkg.org>
Message-ID: <20070901054230Q.tomof@acm.org>

On Sat, 01 Sep 2007 00:51:21 +0200
Tomasz Chmielewski <mangoo at wpkg.org> wrote:

> Is raw/pass-through possible with stgt?
> 
> I have a SCSI tape drive which I'd like to make available to other 
> initiators, is it possible to use raw/pass-through with stgt?

Unfortunately, no. It's on my todo list but at the bottom of the list.


From tomof at acm.org  Sat Sep  1 21:53:39 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 2 Sep 2007 04:53:39 +0900
Subject: [Stgt-devel] [Patch 1/1] Add support for extra VPD pages
 within	INQUIRY op code
In-Reply-To: <46CE93B8.8000908@gmail.com>
References: <46CE93B8.8000908@gmail.com>
Message-ID: <20070901144153E.tomof@acm.org>

On Fri, 24 Aug 2007 18:15:52 +1000
Mark Harvey <markh794 at gmail.com> wrote:

Sorry about the delay.

> 
> As always, feedback welcome.
> 
> 
> Unfortunately I had to change the lu_init() interface so I could more 
> easily include the TID in the SCSI VPD page 80h and 83h
> 
> Hence the number of files touched with this patch.
> 
> As indicated in the patch, I am unsure from the osd2r01.pdf 
> documentation of what data should be included within VPD pages B0h and 
> B1h for the OSD module.
> 
> Regards
> Mark
> 
> 
> >From e752630bf3c33b9f4a0c22d4cc7af28b141c926b Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Fri, 24 Aug 2007 18:04:24 +1000
> Subject: Add support for VPD pages 0x80 - 0xff
> 
> Ability to add VPD pages between 80h and FFh per SCSI device type.
> 
> An array of 128 vpd structures added to ly_phy_attr struct.
> 
> Use alloc_vpd(data size) to pre-alloc data for custom VPD page.
> - This data is appended to the 4 byte VPD header at runtime
>   i.e. When an INQUIRY for the VPD page is received.
> 
> - A custom vpd_update(struct scsi_lu *lu, void *) is used to
>   set/change data pre-allocated by alloc_vpd()
> 
> - All modules except use default page 80h & 83h defined in spc.c
>   The osd module has two extra for VPD pages B0h and B1h
>   - Note: garbage values are set and should be reviewed/updated
>           by somebody who knows what should be set here.
> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>
> ---
>  scripts/tgt-core-test |   11 +++
>  usr/mmc.c             |    4 +-
>  usr/osd.c             |   42 +++++++++-
>  usr/sbc.c             |    4 +-
>  usr/scc.c             |    4 +-
>  usr/smc.c             |    4 +-
>  usr/spc.c             |  220 ++++++++++++++++++++++++++++++++++++++-----------
>  usr/spc.h             |    3 +-
>  usr/target.c          |    9 +--
>  usr/tgtd.h            |   16 +++-
>  10 files changed, 245 insertions(+), 72 deletions(-)
> 
> diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
> index 8c58972..cf92303 100755
> --- a/scripts/tgt-core-test
> +++ b/scripts/tgt-core-test
> @@ -184,6 +184,17 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>  	--params dump=1
>  
>  
> +# Create OSD LUN
> +LUN=6
> +tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/hd_block --device-type=osd
> +
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +	--params scsi_sn=FRED06,scsi_id=FredOSD
> +
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +	--params vendor_id=OSD,product_id=OSD00,product_rev=0010,removable=1,sense_format=1
> +
> +

OSD doesn't work now so you don't need to add an example.


>  # Allow ALL initiators to connect to this target
>  tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
>  
> diff --git a/usr/mmc.c b/usr/mmc.c
> index 7f70943..fffb2b7 100644
> --- a/usr/mmc.c
> +++ b/usr/mmc.c
> @@ -132,9 +132,9 @@ static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)
>  	return spc_mode_sense(host_no, cmd);
>  }
>  
> -static int mmc_lu_init(struct scsi_lu *lu)
> +static int mmc_lu_init(struct scsi_lu *lu, int tid)
>  {
> -	if (spc_lu_init(lu))
> +	if (spc_lu_init(lu, tid))
>  		return TGTADM_NOMEM;

Let's add a pointer to struct target to struct scsi_lu.


>  	strncpy(lu->attrs.product_id, "VIRTUAL-CDROM", sizeof(lu->attrs.product_id));
> diff --git a/usr/osd.c b/usr/osd.c
> index 189fba4..80ae9c5 100644
> --- a/usr/osd.c
> +++ b/usr/osd.c
> @@ -51,13 +51,35 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
>  	return cmd->dev->bst->bs_cmd_submit(cmd);
>  }
>  
> +static void update_vpd_b0(struct scsi_lu *lu, void *p)
> +{
> +	int pg = 0xb0 & 0x7f;
> +	struct vpd *vpd_pg = lu->attrs.vpd[pg];
> +
> +	memcpy(vpd_pg->data, p, vpd_pg->size);
> +}
> +
> +static void update_vpd_b1(struct scsi_lu *lu, void *p)
> +{
> +	int pg = 0xb1 & 0x7f;
> +	struct vpd *vpd_pg = lu->attrs.vpd[pg];
> +
> +	memcpy(vpd_pg->data, p, vpd_pg->size);
> +}
> +
>  /*
> - * XXX: missing support for b0 and b1, in page 0 and in inquiry code.
> - * Figure out how to make spc_inquiry handle extra mode pages.
> + * FIXME: I've made up the value for these params. Somebody who knows what
> + * should be in these + size of pages need to put sane vaues for pg B0 & B1
> + * markh794 at gmail.com
>   */
> -static int osd_lu_init(struct scsi_lu *lu)
> +#define OSD_INFORMATION_LEN 12
> +#define OSD_SECURITY_TOKEN_LEN 12

Let's leave OSD to Pete. And as I said, we don't support OSD now. So
no need to add 'FIXME' stuff.


> +static int osd_lu_init(struct scsi_lu *lu, int tid)
>  {
> -	if (spc_lu_init(lu))
> +	int pg;
> +	struct vpd **lu_vpd = lu->attrs.vpd;
> +
> +	if (spc_lu_init(lu, tid))
>  		return TGTADM_NOMEM;
>  
>  	strncpy(lu->attrs.product_id, "OSD", sizeof(lu->attrs.product_id));
> @@ -66,6 +88,18 @@ static int osd_lu_init(struct scsi_lu *lu)
>  	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
>  	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
>  
> +	/* VPD page 0xB0 */
> +	pg = 0xb0 & 0x7f;
> +	lu_vpd[pg] = alloc_vpd(OSD_INFORMATION_LEN);
> +	lu_vpd[pg]->vpd_update = update_vpd_b0;
> +	lu_vpd[pg]->vpd_update(lu, "Information");
> +
> +	/* VPD page 0xB1 */
> +	pg = 0xb1 & 0x7f;
> +	lu_vpd[pg] = alloc_vpd(OSD_SECURITY_TOKEN_LEN);
> +	lu_vpd[pg]->vpd_update = update_vpd_b1;
> +	lu_vpd[pg]->vpd_update(lu, "Security");
> +
>  	return 0;
>  }
>  
> diff --git a/usr/sbc.c b/usr/sbc.c
> index 33485e6..7d488fb 100644
> --- a/usr/sbc.c
> +++ b/usr/sbc.c
> @@ -170,12 +170,12 @@ sense:
>  	return SAM_STAT_CHECK_CONDITION;
>  }
>  
> -static int sbc_lu_init(struct scsi_lu *lu)
> +static int sbc_lu_init(struct scsi_lu *lu, int tid)
>  {
>  	uint64_t size;
>  	uint8_t *data;
>  
> -	if (spc_lu_init(lu))
> +	if (spc_lu_init(lu, tid))
>  		return TGTADM_NOMEM;
>  
>  	strncpy(lu->attrs.product_id, "VIRTUAL-DISK", sizeof(lu->attrs.product_id));
> diff --git a/usr/scc.c b/usr/scc.c
> index 0a154a5..c52d4f1 100644
> --- a/usr/scc.c
> +++ b/usr/scc.c
> @@ -36,9 +36,9 @@
>  #include "tgtadm_error.h"
>  #include "spc.h"
>  
> -static int scc_lu_init(struct scsi_lu *lu)
> +static int scc_lu_init(struct scsi_lu *lu, int tid)
>  {
> -	if (spc_lu_init(lu))
> +	if (spc_lu_init(lu, tid))
>  		return TGTADM_NOMEM;
>  
>  	strncpy(lu->attrs.product_id, "Controller",
> diff --git a/usr/smc.c b/usr/smc.c
> index 4f0ee4b..318cb4f 100644
> --- a/usr/smc.c
> +++ b/usr/smc.c
> @@ -435,7 +435,7 @@ sense:
>  	return SAM_STAT_CHECK_CONDITION;
>  }
>  
> -static int smc_lu_init(struct scsi_lu *lu)
> +static int smc_lu_init(struct scsi_lu *lu, int tid)
>  {
>  	struct smc_info *smc;
>  
> @@ -445,7 +445,7 @@ static int smc_lu_init(struct scsi_lu *lu)
>  	else
>  		return -ENOMEM;
>  
> -	spc_lu_init(lu);
> +	spc_lu_init(lu, tid);
>  
>  	strncpy(lu->attrs.product_id, "VIRTUAL-CHANGER",
>  						sizeof(lu->attrs.product_id));
> diff --git a/usr/spc.c b/usr/spc.c
> index b56c0b3..08a4bc5 100644
> --- a/usr/spc.c
> +++ b/usr/spc.c
> @@ -20,6 +20,7 @@
>   * 02110-1301 USA
>   */
>  #include <errno.h>
> +#include <inttypes.h>
>  #include <stdio.h>
>  #include <stdlib.h>
>  #include <string.h>
> @@ -38,6 +39,96 @@
>  #define PRODUCT_REV	"0"
>  #define BLK_SHIFT	9
>  
> +/** Protocol Identifier Values
> + * 0 Fibre Channel (FCP-2)
> + * 1 Parallel SCSI (SPI-5)
> + * 2 SSA (SSA-S3P)
> + * 3 IEEE 1394 (SBP-3)
> + * 4 SCSI Remote Direct Memory Access (SRP)
> + * 5 iSCSI
> + * 6 SAS Serial SCSI Protocol (SAS)
> + * 7 Automation/Drive Interface (ADT)
> + * 8 AT Attachment Interface (ATA/ATAPI-7)
> + */
> +#define PIV_FCP 0
> +#define PIV_SPI 1
> +#define PIV_S3P 2
> +#define PIV_SBP 3
> +#define PIV_SRP 4
> +#define PIV_ISCSI 5
> +#define PIV_SAS 6
> +#define PIV_ADT 7
> +#define PIV_ATA 8
> +
> +#define PIV_VALID 0x80

Would be better to use lengthy names for SCSI specification defines
and move them to scsi.h?


> +/** Code Set
> + *  1 - Designator fild contains binary values
> + *  2 - Designator field contains ASCII printable chars
> + *  3 - Designaotor field contains UTF-8
> + */
> +#define INQ_CODE_BIN 1
> +#define INQ_CODE_ASCII 2
> +#define INQ_CODE_UTF8 3
> +
> +/** Association field
> + * 00b - Associated with Logical Unit
> + * 01b - Associated with target port
> + * 10b - Associated with SCSI Target device
> + * 11b - Reserved
> + */
> +#define ASS_LU	0
> +#define ASS_TGT_PORT 0x10
> +#define ASS_TGT_DEV 0x20
> +
> +/** Designator type - SPC-4 Reference
> + * 0 - Vendor specific - 7.6.3.3
> + * 1 - T10 vendor ID - 7.6.3.4
> + * 2 - EUI-64 - 7.6.3.5
> + * 3 - NAA - 7.6.3.6
> + * 4 - Relative Target port identifier - 7.6.3.7
> + * 5 - Target Port group - 7.6.3.8
> + * 6 - Logical Unit group - 7.6.3.9
> + * 7 - MD5 logical unit identifier - 7.6.3.10
> + * 8 - SCSI name string - 7.6.3.11
> + */
> +#define DESG_VENDOR 0
> +#define DESG_T10 1
> +#define DESG_EUI64 2
> +#define DESG_NAA 3
> +#define DESG_REL_TGT_PORT 4
> +#define DESG_TGT_PORT_GRP 5
> +#define DESG_LU_GRP 6
> +#define DESG_MD5 7
> +#define DESG_SCSI 8
> +
> +static int valid_vpd(struct vpd **vpd, uint8_t page)
> +{
> +	if (vpd[page & 0x7f])
> +		return 1;
> +	return 0;
> +}
> +
> +void update_vpd_80(struct scsi_lu *lu, void *sn)
> +{
> +	struct vpd *vpd_pg = lu->attrs.vpd[0];
> +	char *data = (char *)vpd_pg->data;
> +
> +	snprintf(data, SCSI_SN_LEN, "%-8s", (char *)sn);
> +}
> +
> +void update_vpd_83(struct scsi_lu *lu, void *id)
> +{
> +	struct vpd *vpd_pg = lu->attrs.vpd[3];
> +	uint8_t	*data = vpd_pg->data;
> +
> +	data[0] = (PIV_ISCSI << 4) | INQ_CODE_ASCII;
> +	data[1] = PIV_VALID | ASS_TGT_PORT | DESG_VENDOR;
> +	data[3] = SCSI_ID_LEN;
> +
> +	strncpy((char *)data + 4, id, SCSI_ID_LEN);
> +}
> +
>  int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  {
>  	int len = 0, ret = SAM_STAT_CHECK_CONDITION;
> @@ -47,6 +138,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
>  	uint8_t devtype = 0;
>  	struct lu_phy_attr *attrs;
> +	struct vpd **vpd;
> +	struct vpd *vpd_pg;
>  
>  	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
>  		goto sense;
> @@ -97,44 +190,37 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  		ret = SAM_STAT_GOOD;
>  	} else if (scb[1] & 0x1) {
>  		/* EVPD bit set */
> +		vpd = attrs->vpd;
>  		if (scb[2] == 0x0) {
> +			int i, j, tmp;
> +
> +			i = 5;
> +			tmp = 1;
>  			data[0] = devtype;
> -			data[1] = 0x0;
> -			data[3] = 3;
> +			data[1] = 0;
> +			data[2] = 0;
> +			for (j = 0; j < 0x80; j++) {
> +				if (vpd[j]) {
> +					data[i] = j | 0x80;
> +					tmp++;
> +					i++;
> +				}
> +			}
> +			data[3] = tmp;
>  			data[4] = 0x0;
> -			data[5] = 0x80;
> -			data[6] = 0x83;
> -			len = 7;
> -			ret = SAM_STAT_GOOD;
> -		} else if (scb[2] == 0x80) {
> -			int tmp = SCSI_SN_LEN;
> -
> -			data[1] = 0x80;
> -			data[3] = SCSI_SN_LEN;
> -			memset(data + 4, 0x20, 4);
> -			len = 4 + SCSI_SN_LEN;
> +			len = tmp + 4;
>  			ret = SAM_STAT_GOOD;
> +		} else if (valid_vpd(vpd, scb[2])) {
> +			int tmp;
> +			vpd_pg = vpd[scb[2] & 0x7f];
> +			tmp = vpd_pg->size;
>  
> -			if (strlen(attrs->scsi_sn)) {
> -				uint8_t *p;
> -				char *q;
> -
> -				p = data + 4 + tmp - 1;
> -				q = attrs->scsi_sn + SCSI_SN_LEN - 1;
> -				for (; tmp > 0; tmp--, q)
> -					*(p--) = *(q--);
> -			}
> -		} else if (scb[2] == 0x83) {
> -			int tmp = SCSI_ID_LEN;
> -
> -			data[1] = 0x83;
> -			data[3] = tmp + 4;
> -			data[4] = 0x1;
> -			data[5] = 0x1;
> -			data[7] = tmp;
> -			strncpy((char *) data + 8, attrs->scsi_id, SCSI_ID_LEN);
> -
> -			len = tmp + 8;
> +			data[0] = devtype;
> +			data[1] = scb[2];
> +			data[2] = (tmp >> 8);
> +			data[3] = tmp & 0xff;
> +			memcpy(&data[4], vpd_pg->data, tmp);
> +			len = tmp + 4;
>  			ret = SAM_STAT_GOOD;
>  		}
>  	}
> @@ -358,6 +444,19 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
>  	return SAM_STAT_GOOD;
>  }
>  
> +struct vpd *alloc_vpd(uint16_t size)
> +{
> +	struct vpd *vpd;
> +
> +	vpd = zalloc(sizeof(struct vpd) + size);
> +	if (!vpd)
> +		return NULL;
> +
> +	vpd->size = size;
> +
> +	return vpd;
> +}

Where do you free vpd?


>  static struct mode_pg *alloc_mode_pg(uint8_t pcode, uint8_t subpcode,
>  				     uint16_t size)
>  {
> @@ -500,6 +599,11 @@ int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
>  	int err = TGTADM_SUCCESS;
>  	char *p;
>  	char buf[256];
> +	struct lu_phy_attr *attrs;
> +	struct vpd **vpd;
> +
> +	attrs = &lu->attrs;
> +	vpd = attrs->vpd;
>  
>  	if (!strncmp("targetOps", params, 9))
>  		params = params + 10;
> @@ -512,36 +616,38 @@ int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
>  		token = match_token(p, tokens, args);
>  		switch (token) {
>  		case Opt_scsi_id:
> -			match_strncpy(lu->attrs.scsi_id, &args[0],
> -				      sizeof(lu->attrs.scsi_id));
> +			match_strncpy(attrs->scsi_id, &args[0],
> +				      sizeof(attrs->scsi_id));
> +			vpd[3]->vpd_update(lu, attrs->scsi_id);
>  			break;
>  		case Opt_scsi_sn:
> -			match_strncpy(lu->attrs.scsi_sn, &args[0],
> -				      sizeof(lu->attrs.scsi_sn));
> +			match_strncpy(attrs->scsi_sn, &args[0],
> +				      sizeof(attrs->scsi_sn));
> +			vpd[0]->vpd_update(lu, attrs->scsi_sn);
>  			break;
>  		case Opt_vendor_id:
> -			match_strncpy(lu->attrs.vendor_id, &args[0],
> -				      sizeof(lu->attrs.vendor_id));
> +			match_strncpy(attrs->vendor_id, &args[0],
> +				      sizeof(attrs->vendor_id));
>  			break;
>  		case Opt_product_id:
> -			match_strncpy(lu->attrs.product_id, &args[0],
> -				      sizeof(lu->attrs.product_id));
> +			match_strncpy(attrs->product_id, &args[0],
> +				      sizeof(attrs->product_id));
>  			break;
>  		case Opt_product_rev:
> -			match_strncpy(lu->attrs.product_rev, &args[0],
> -				      sizeof(lu->attrs.product_rev));
> +			match_strncpy(attrs->product_rev, &args[0],
> +				      sizeof(attrs->product_rev));
>  			break;
>  		case Opt_sense_format:
>  			match_strncpy(buf, &args[0], sizeof(buf));
> -			lu->attrs.sense_format = atoi(buf);
> +			attrs->sense_format = atoi(buf);
>  			break;
>  		case Opt_removable:
>  			match_strncpy(buf, &args[0], sizeof(buf));
> -			lu->attrs.removable = atoi(buf);
> +			attrs->removable = atoi(buf);
>  			break;
>  		case Opt_online:
>  			match_strncpy(buf, &args[0], sizeof(buf));
> -			lu->attrs.online = atoi(buf);
> +			attrs->online = atoi(buf);
>  			break;
>  		case Opt_mode_page:
>  			match_strncpy(buf, &args[0], sizeof(buf));
> @@ -559,12 +665,32 @@ int spc_lu_config(struct scsi_lu *lu, char *params)
>  	return lu_config(lu, params, NULL);
>  }
>  
> -int spc_lu_init(struct scsi_lu *lu)
> +int spc_lu_init(struct scsi_lu *lu, int tid)
>  {
> +	struct vpd **lu_vpd = lu->attrs.vpd;
> +
> +	lu->attrs.device_type = lu->dev_type_template.type;
> +	lu->attrs.qualifier = 0x0;
> +
>  	snprintf(lu->attrs.vendor_id, sizeof(lu->attrs.vendor_id),
>  		 "%-16s", VENDOR_ID);
>  	snprintf(lu->attrs.product_rev, sizeof(lu->attrs.product_rev),
>  		 "%s", "0001");
> +	snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
> +		 "deadbeaf%d:%" PRIu64, tid, lu->lun);
> +	snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
> +		 "beaf%d%" PRIu64, tid, lu->lun);
> +
> +	/* VPD page 0x80 */
> +	lu_vpd[0] = alloc_vpd(SCSI_SN_LEN);
> +	lu_vpd[0]->vpd_update = update_vpd_80;
> +	update_vpd_80(lu, lu->attrs.scsi_sn);
> +
> +	/* VPD page 0x83 */
> +	lu_vpd[3] = alloc_vpd(SCSI_ID_LEN + 4); /* + Designator descriptor len*/
> +	lu_vpd[3]->vpd_update = update_vpd_83;
> +	update_vpd_83(lu, lu->attrs.scsi_id);
> +
>  	lu->attrs.removable = 0;
>  	lu->attrs.sense_format = 0;
>  	lu->attrs.online = 0;
> diff --git a/usr/spc.h b/usr/spc.h
> index 1cc8623..315b49e 100644
> --- a/usr/spc.h
> +++ b/usr/spc.h
> @@ -7,7 +7,7 @@ extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
>  extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
>  extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
>  extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
> -extern int spc_lu_init(struct scsi_lu *lu);
> +extern int spc_lu_init(struct scsi_lu *lu, int tid);
>  
>  typedef int (match_fn_t)(struct scsi_lu *lu, char *params);
>  extern int lu_config(struct scsi_lu *lu, char *params, match_fn_t *);
> @@ -15,5 +15,6 @@ extern int spc_lu_config(struct scsi_lu *lu, char *params);
>  extern void dump_cdb(struct scsi_cmd *cmd);
>  extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
>  extern int add_mode_page(struct scsi_lu *lu, char *params);
> +extern struct vpd *alloc_vpd(uint16_t size);
>  
>  #endif
> diff --git a/usr/target.c b/usr/target.c
> index 2474d05..b966579 100644
> --- a/usr/target.c
> +++ b/usr/target.c
> @@ -266,7 +266,7 @@ int tgt_device_create(int tid, int dev_type, uint64_t lun, char *args, int backi
>  	tgt_cmd_queue_init(&lu->cmd_queue);
>  
>   	if (lu->dev_type_template.lu_init) {
> - 		ret = lu->dev_type_template.lu_init(lu);
> +		ret = lu->dev_type_template.lu_init(lu, tid);
>  		if (ret)
>  			goto free_lu;
>  	}
> @@ -285,13 +285,6 @@ int tgt_device_create(int tid, int dev_type, uint64_t lun, char *args, int backi
>  			goto free_lu;
>  	}
>  
> -	lu->attrs.device_type = lu->dev_type_template.type;
> -	lu->attrs.qualifier = 0x0;
> -	snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
> -		 "deadbeaf%d:%" PRIu64, tid, lun);
> -	snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
> -		 "beaf%d%" PRIu64, tid, lun);
> -
>  	if (tgt_drivers[target->lid]->lu_create)
>  		tgt_drivers[target->lid]->lu_create(lu);
>  
> diff --git a/usr/tgtd.h b/usr/tgtd.h
> index c39b9c2..6fc38c4 100644
> --- a/usr/tgtd.h
> +++ b/usr/tgtd.h
> @@ -36,6 +36,15 @@ struct tgt_cmd_queue {
>  	struct list_head queue;
>  };
>  
> +struct scsi_lu;
> +struct scsi_cmd;
> +
> +struct vpd {
> +	uint16_t size;
> +	void (*vpd_update)(struct scsi_lu *lu, void *data);
> +	uint8_t data[0];
> +};

I prefer to avoid doing something like:

struct vpd *vpd;

Can we have a bit longer structure name like struct vp_data? Any
suggestions are welcome.


>  struct lu_phy_attr {
>  	char scsi_id[SCSI_ID_LEN + 1];
>  	char scsi_sn[SCSI_SN_LEN + 1];
> @@ -52,10 +61,9 @@ struct lu_phy_attr {
>  	char online;		/* Logical Unit online */
>  	char reset;		/* Power-on or reset has occured */
>  	char sense_format;	/* Descrptor format sense data supported */
> -};
>  
> -struct scsi_lu;
> -struct scsi_cmd;
> +	struct vpd *vpd[0x80];	/* VPD pages 0x80 -> 0xff masked with 0x80*/
> +};
>  
>  struct device_type_operations {
>  	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
> @@ -64,7 +72,7 @@ struct device_type_operations {
>  struct device_type_template {
>  	unsigned char type;
>  
> -	int (*lu_init)(struct scsi_lu *lu);
> +	int (*lu_init)(struct scsi_lu *lu, int tid);
>  	void (*lu_exit)(struct scsi_lu *lu);
>  	int (*lu_config)(struct scsi_lu *lu, char *args);
>  
> -- 
> 1.5.2.3
> 
> 
> 
> 
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel


From markh794 at gmail.com  Sun Sep  2 12:23:12 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sun, 2 Sep 2007 20:23:12 +1000
Subject: [Stgt-devel] [Patch 1/1] Add support for extra VPD pages within
	INQUIRY op code
In-Reply-To: <20070901144153E.tomof@acm.org>
References: <46CE93B8.8000908@gmail.com> <20070901144153E.tomof@acm.org>
Message-ID: <f29db9a80709020323k54469d87w73297ddd2bd33144@mail.gmail.com>

On 9/2/07, FUJITA Tomonori <tomof at acm.org> wrote:
> On Fri, 24 Aug 2007 18:15:52 +1000
> Mark Harvey <markh794 at gmail.com> wrote:
>
> Sorry about the delay.
>
> >
> > As always, feedback welcome.
> >
> >
> > Unfortunately I had to change the lu_init() interface so I could more
> > easily include the TID in the SCSI VPD page 80h and 83h
> >
> > Hence the number of files touched with this patch.
> >
> > As indicated in the patch, I am unsure from the osd2r01.pdf
> > documentation of what data should be included within VPD pages B0h and
> > B1h for the OSD module.
> >
> > Regards
> > Mark
> >
> >
> > >From e752630bf3c33b9f4a0c22d4cc7af28b141c926b Mon Sep 17 00:00:00 2001
> > From: Mark Harvey <markh794 at gmail.com>
> > Date: Fri, 24 Aug 2007 18:04:24 +1000
> > Subject: Add support for VPD pages 0x80 - 0xff
> >
> > Ability to add VPD pages between 80h and FFh per SCSI device type.
> >
> > An array of 128 vpd structures added to ly_phy_attr struct.
> >
> > Use alloc_vpd(data size) to pre-alloc data for custom VPD page.
> > - This data is appended to the 4 byte VPD header at runtime
> >   i.e. When an INQUIRY for the VPD page is received.
> >
> > - A custom vpd_update(struct scsi_lu *lu, void *) is used to
> >   set/change data pre-allocated by alloc_vpd()
> >
> > - All modules except use default page 80h & 83h defined in spc.c
> >   The osd module has two extra for VPD pages B0h and B1h
> >   - Note: garbage values are set and should be reviewed/updated
> >           by somebody who knows what should be set here.
> >
> > Signed-off-by: Mark Harvey <markh794 at gmail.com>
> > ---
> >  scripts/tgt-core-test |   11 +++
> >  usr/mmc.c             |    4 +-
> >  usr/osd.c             |   42 +++++++++-
> >  usr/sbc.c             |    4 +-
> >  usr/scc.c             |    4 +-
> >  usr/smc.c             |    4 +-
> >  usr/spc.c             |  220 ++++++++++++++++++++++++++++++++++++++-----------
> >  usr/spc.h             |    3 +-
> >  usr/target.c          |    9 +--
> >  usr/tgtd.h            |   16 +++-
> >  10 files changed, 245 insertions(+), 72 deletions(-)
> >
> > diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
> > index 8c58972..cf92303 100755
> > --- a/scripts/tgt-core-test
> > +++ b/scripts/tgt-core-test
> > @@ -184,6 +184,17 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> >       --params dump=1
> >
> >
> > +# Create OSD LUN
> > +LUN=6
> > +tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/hd_block --device-type=osd
> > +
> > +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> > +     --params scsi_sn=FRED06,scsi_id=FredOSD
> > +
> > +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> > +     --params vendor_id=OSD,product_id=OSD00,product_rev=0010,removable=1,sense_format=1
> > +
> > +
>
> OSD doesn't work now so you don't need to add an example.
>

OK.

>
> >  # Allow ALL initiators to connect to this target
> >  tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
> >
> > diff --git a/usr/mmc.c b/usr/mmc.c
> > index 7f70943..fffb2b7 100644
> > --- a/usr/mmc.c
> > +++ b/usr/mmc.c
> > @@ -132,9 +132,9 @@ static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)
> >       return spc_mode_sense(host_no, cmd);
> >  }
> >
> > -static int mmc_lu_init(struct scsi_lu *lu)
> > +static int mmc_lu_init(struct scsi_lu *lu, int tid)
> >  {
> > -     if (spc_lu_init(lu))
> > +     if (spc_lu_init(lu, tid))
> >               return TGTADM_NOMEM;
>
> Let's add a pointer to struct target to struct scsi_lu.

Sure.

>
>
> >       strncpy(lu->attrs.product_id, "VIRTUAL-CDROM", sizeof(lu->attrs.product_id));
> > diff --git a/usr/osd.c b/usr/osd.c
> > index 189fba4..80ae9c5 100644
> > --- a/usr/osd.c
> > +++ b/usr/osd.c
> > @@ -51,13 +51,35 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
> >       return cmd->dev->bst->bs_cmd_submit(cmd);
> >  }
> >
> > +static void update_vpd_b0(struct scsi_lu *lu, void *p)
> > +{
> > +     int pg = 0xb0 & 0x7f;
> > +     struct vpd *vpd_pg = lu->attrs.vpd[pg];
> > +
> > +     memcpy(vpd_pg->data, p, vpd_pg->size);
> > +}
> > +
> > +static void update_vpd_b1(struct scsi_lu *lu, void *p)
> > +{
> > +     int pg = 0xb1 & 0x7f;
> > +     struct vpd *vpd_pg = lu->attrs.vpd[pg];
> > +
> > +     memcpy(vpd_pg->data, p, vpd_pg->size);
> > +}
> > +
> >  /*
> > - * XXX: missing support for b0 and b1, in page 0 and in inquiry code.
> > - * Figure out how to make spc_inquiry handle extra mode pages.
> > + * FIXME: I've made up the value for these params. Somebody who knows what
> > + * should be in these + size of pages need to put sane vaues for pg B0 & B1
> > + * markh794 at gmail.com
> >   */
> > -static int osd_lu_init(struct scsi_lu *lu)
> > +#define OSD_INFORMATION_LEN 12
> > +#define OSD_SECURITY_TOKEN_LEN 12
>
> Let's leave OSD to Pete. And as I said, we don't support OSD now. So
> no need to add 'FIXME' stuff.
>

OK.

>
> > +static int osd_lu_init(struct scsi_lu *lu, int tid)
> >  {
> > -     if (spc_lu_init(lu))
> > +     int pg;
> > +     struct vpd **lu_vpd = lu->attrs.vpd;
> > +
> > +     if (spc_lu_init(lu, tid))
> >               return TGTADM_NOMEM;
> >
> >       strncpy(lu->attrs.product_id, "OSD", sizeof(lu->attrs.product_id));
> > @@ -66,6 +88,18 @@ static int osd_lu_init(struct scsi_lu *lu)
> >       lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
> >       lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
> >
> > +     /* VPD page 0xB0 */
> > +     pg = 0xb0 & 0x7f;
> > +     lu_vpd[pg] = alloc_vpd(OSD_INFORMATION_LEN);
> > +     lu_vpd[pg]->vpd_update = update_vpd_b0;
> > +     lu_vpd[pg]->vpd_update(lu, "Information");
> > +
> > +     /* VPD page 0xB1 */
> > +     pg = 0xb1 & 0x7f;
> > +     lu_vpd[pg] = alloc_vpd(OSD_SECURITY_TOKEN_LEN);
> > +     lu_vpd[pg]->vpd_update = update_vpd_b1;
> > +     lu_vpd[pg]->vpd_update(lu, "Security");
> > +
> >       return 0;
> >  }
> >
> > diff --git a/usr/sbc.c b/usr/sbc.c
> > index 33485e6..7d488fb 100644
> > --- a/usr/sbc.c
> > +++ b/usr/sbc.c
> > @@ -170,12 +170,12 @@ sense:
> >       return SAM_STAT_CHECK_CONDITION;
> >  }
> >
> > -static int sbc_lu_init(struct scsi_lu *lu)
> > +static int sbc_lu_init(struct scsi_lu *lu, int tid)
> >  {
> >       uint64_t size;
> >       uint8_t *data;
> >
> > -     if (spc_lu_init(lu))
> > +     if (spc_lu_init(lu, tid))
> >               return TGTADM_NOMEM;
> >
> >       strncpy(lu->attrs.product_id, "VIRTUAL-DISK", sizeof(lu->attrs.product_id));
> > diff --git a/usr/scc.c b/usr/scc.c
> > index 0a154a5..c52d4f1 100644
> > --- a/usr/scc.c
> > +++ b/usr/scc.c
> > @@ -36,9 +36,9 @@
> >  #include "tgtadm_error.h"
> >  #include "spc.h"
> >
> > -static int scc_lu_init(struct scsi_lu *lu)
> > +static int scc_lu_init(struct scsi_lu *lu, int tid)
> >  {
> > -     if (spc_lu_init(lu))
> > +     if (spc_lu_init(lu, tid))
> >               return TGTADM_NOMEM;
> >
> >       strncpy(lu->attrs.product_id, "Controller",
> > diff --git a/usr/smc.c b/usr/smc.c
> > index 4f0ee4b..318cb4f 100644
> > --- a/usr/smc.c
> > +++ b/usr/smc.c
> > @@ -435,7 +435,7 @@ sense:
> >       return SAM_STAT_CHECK_CONDITION;
> >  }
> >
> > -static int smc_lu_init(struct scsi_lu *lu)
> > +static int smc_lu_init(struct scsi_lu *lu, int tid)
> >  {
> >       struct smc_info *smc;
> >
> > @@ -445,7 +445,7 @@ static int smc_lu_init(struct scsi_lu *lu)
> >       else
> >               return -ENOMEM;
> >
> > -     spc_lu_init(lu);
> > +     spc_lu_init(lu, tid);
> >
> >       strncpy(lu->attrs.product_id, "VIRTUAL-CHANGER",
> >                                               sizeof(lu->attrs.product_id));
> > diff --git a/usr/spc.c b/usr/spc.c
> > index b56c0b3..08a4bc5 100644
> > --- a/usr/spc.c
> > +++ b/usr/spc.c
> > @@ -20,6 +20,7 @@
> >   * 02110-1301 USA
> >   */
> >  #include <errno.h>
> > +#include <inttypes.h>
> >  #include <stdio.h>
> >  #include <stdlib.h>
> >  #include <string.h>
> > @@ -38,6 +39,96 @@
> >  #define PRODUCT_REV  "0"
> >  #define BLK_SHIFT    9
> >
> > +/** Protocol Identifier Values
> > + * 0 Fibre Channel (FCP-2)
> > + * 1 Parallel SCSI (SPI-5)
> > + * 2 SSA (SSA-S3P)
> > + * 3 IEEE 1394 (SBP-3)
> > + * 4 SCSI Remote Direct Memory Access (SRP)
> > + * 5 iSCSI
> > + * 6 SAS Serial SCSI Protocol (SAS)
> > + * 7 Automation/Drive Interface (ADT)
> > + * 8 AT Attachment Interface (ATA/ATAPI-7)
> > + */
> > +#define PIV_FCP 0
> > +#define PIV_SPI 1
> > +#define PIV_S3P 2
> > +#define PIV_SBP 3
> > +#define PIV_SRP 4
> > +#define PIV_ISCSI 5
> > +#define PIV_SAS 6
> > +#define PIV_ADT 7
> > +#define PIV_ATA 8
> > +
> > +#define PIV_VALID 0x80
>
> Would be better to use lengthy names for SCSI specification defines
> and move them to scsi.h?

As these defines are only used by the SCSI Inquiry page, I kept them
in the spc module.

I can move them if you like.


>
>
> > +/** Code Set
> > + *  1 - Designator fild contains binary values
> > + *  2 - Designator field contains ASCII printable chars
> > + *  3 - Designaotor field contains UTF-8
> > + */
> > +#define INQ_CODE_BIN 1
> > +#define INQ_CODE_ASCII 2
> > +#define INQ_CODE_UTF8 3
> > +
> > +/** Association field
> > + * 00b - Associated with Logical Unit
> > + * 01b - Associated with target port
> > + * 10b - Associated with SCSI Target device
> > + * 11b - Reserved
> > + */
> > +#define ASS_LU       0
> > +#define ASS_TGT_PORT 0x10
> > +#define ASS_TGT_DEV 0x20
> > +
> > +/** Designator type - SPC-4 Reference
> > + * 0 - Vendor specific - 7.6.3.3
> > + * 1 - T10 vendor ID - 7.6.3.4
> > + * 2 - EUI-64 - 7.6.3.5
> > + * 3 - NAA - 7.6.3.6
> > + * 4 - Relative Target port identifier - 7.6.3.7
> > + * 5 - Target Port group - 7.6.3.8
> > + * 6 - Logical Unit group - 7.6.3.9
> > + * 7 - MD5 logical unit identifier - 7.6.3.10
> > + * 8 - SCSI name string - 7.6.3.11
> > + */
> > +#define DESG_VENDOR 0
> > +#define DESG_T10 1
> > +#define DESG_EUI64 2
> > +#define DESG_NAA 3
> > +#define DESG_REL_TGT_PORT 4
> > +#define DESG_TGT_PORT_GRP 5
> > +#define DESG_LU_GRP 6
> > +#define DESG_MD5 7
> > +#define DESG_SCSI 8
> > +
> > +static int valid_vpd(struct vpd **vpd, uint8_t page)
> > +{
> > +     if (vpd[page & 0x7f])
> > +             return 1;
> > +     return 0;
> > +}
> > +
> > +void update_vpd_80(struct scsi_lu *lu, void *sn)
> > +{
> > +     struct vpd *vpd_pg = lu->attrs.vpd[0];
> > +     char *data = (char *)vpd_pg->data;
> > +
> > +     snprintf(data, SCSI_SN_LEN, "%-8s", (char *)sn);
> > +}
> > +
> > +void update_vpd_83(struct scsi_lu *lu, void *id)
> > +{
> > +     struct vpd *vpd_pg = lu->attrs.vpd[3];
> > +     uint8_t *data = vpd_pg->data;
> > +
> > +     data[0] = (PIV_ISCSI << 4) | INQ_CODE_ASCII;
> > +     data[1] = PIV_VALID | ASS_TGT_PORT | DESG_VENDOR;
> > +     data[3] = SCSI_ID_LEN;
> > +
> > +     strncpy((char *)data + 4, id, SCSI_ID_LEN);
> > +}
> > +
> >  int spc_inquiry(int host_no, struct scsi_cmd *cmd)
> >  {
> >       int len = 0, ret = SAM_STAT_CHECK_CONDITION;
> > @@ -47,6 +138,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
> >       uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
> >       uint8_t devtype = 0;
> >       struct lu_phy_attr *attrs;
> > +     struct vpd **vpd;
> > +     struct vpd *vpd_pg;
> >
> >       if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
> >               goto sense;
> > @@ -97,44 +190,37 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
> >               ret = SAM_STAT_GOOD;
> >       } else if (scb[1] & 0x1) {
> >               /* EVPD bit set */
> > +             vpd = attrs->vpd;
> >               if (scb[2] == 0x0) {
> > +                     int i, j, tmp;
> > +
> > +                     i = 5;
> > +                     tmp = 1;
> >                       data[0] = devtype;
> > -                     data[1] = 0x0;
> > -                     data[3] = 3;
> > +                     data[1] = 0;
> > +                     data[2] = 0;
> > +                     for (j = 0; j < 0x80; j++) {
> > +                             if (vpd[j]) {
> > +                                     data[i] = j | 0x80;
> > +                                     tmp++;
> > +                                     i++;
> > +                             }
> > +                     }
> > +                     data[3] = tmp;
> >                       data[4] = 0x0;
> > -                     data[5] = 0x80;
> > -                     data[6] = 0x83;
> > -                     len = 7;
> > -                     ret = SAM_STAT_GOOD;
> > -             } else if (scb[2] == 0x80) {
> > -                     int tmp = SCSI_SN_LEN;
> > -
> > -                     data[1] = 0x80;
> > -                     data[3] = SCSI_SN_LEN;
> > -                     memset(data + 4, 0x20, 4);
> > -                     len = 4 + SCSI_SN_LEN;
> > +                     len = tmp + 4;
> >                       ret = SAM_STAT_GOOD;
> > +             } else if (valid_vpd(vpd, scb[2])) {
> > +                     int tmp;
> > +                     vpd_pg = vpd[scb[2] & 0x7f];
> > +                     tmp = vpd_pg->size;
> >
> > -                     if (strlen(attrs->scsi_sn)) {
> > -                             uint8_t *p;
> > -                             char *q;
> > -
> > -                             p = data + 4 + tmp - 1;
> > -                             q = attrs->scsi_sn + SCSI_SN_LEN - 1;
> > -                             for (; tmp > 0; tmp--, q)
> > -                                     *(p--) = *(q--);
> > -                     }
> > -             } else if (scb[2] == 0x83) {
> > -                     int tmp = SCSI_ID_LEN;
> > -
> > -                     data[1] = 0x83;
> > -                     data[3] = tmp + 4;
> > -                     data[4] = 0x1;
> > -                     data[5] = 0x1;
> > -                     data[7] = tmp;
> > -                     strncpy((char *) data + 8, attrs->scsi_id, SCSI_ID_LEN);
> > -
> > -                     len = tmp + 8;
> > +                     data[0] = devtype;
> > +                     data[1] = scb[2];
> > +                     data[2] = (tmp >> 8);
> > +                     data[3] = tmp & 0xff;
> > +                     memcpy(&data[4], vpd_pg->data, tmp);
> > +                     len = tmp + 4;
> >                       ret = SAM_STAT_GOOD;
> >               }
> >       }
> > @@ -358,6 +444,19 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
> >       return SAM_STAT_GOOD;
> >  }
> >
> > +struct vpd *alloc_vpd(uint16_t size)
> > +{
> > +     struct vpd *vpd;
> > +
> > +     vpd = zalloc(sizeof(struct vpd) + size);
> > +     if (!vpd)
> > +             return NULL;
> > +
> > +     vpd->size = size;
> > +
> > +     return vpd;
> > +}
>
> Where do you free vpd?

It's a one time allocation and stays set. i.e. There is no call to free().

>
>
> >  static struct mode_pg *alloc_mode_pg(uint8_t pcode, uint8_t subpcode,
> >                                    uint16_t size)
> >  {
> > @@ -500,6 +599,11 @@ int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
> >       int err = TGTADM_SUCCESS;
> >       char *p;
> >       char buf[256];
> > +     struct lu_phy_attr *attrs;
> > +     struct vpd **vpd;
> > +
> > +     attrs = &lu->attrs;
> > +     vpd = attrs->vpd;
> >
> >       if (!strncmp("targetOps", params, 9))
> >               params = params + 10;
> > @@ -512,36 +616,38 @@ int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
> >               token = match_token(p, tokens, args);
> >               switch (token) {
> >               case Opt_scsi_id:
> > -                     match_strncpy(lu->attrs.scsi_id, &args[0],
> > -                                   sizeof(lu->attrs.scsi_id));
> > +                     match_strncpy(attrs->scsi_id, &args[0],
> > +                                   sizeof(attrs->scsi_id));
> > +                     vpd[3]->vpd_update(lu, attrs->scsi_id);
> >                       break;
> >               case Opt_scsi_sn:
> > -                     match_strncpy(lu->attrs.scsi_sn, &args[0],
> > -                                   sizeof(lu->attrs.scsi_sn));
> > +                     match_strncpy(attrs->scsi_sn, &args[0],
> > +                                   sizeof(attrs->scsi_sn));
> > +                     vpd[0]->vpd_update(lu, attrs->scsi_sn);
> >                       break;
> >               case Opt_vendor_id:
> > -                     match_strncpy(lu->attrs.vendor_id, &args[0],
> > -                                   sizeof(lu->attrs.vendor_id));
> > +                     match_strncpy(attrs->vendor_id, &args[0],
> > +                                   sizeof(attrs->vendor_id));
> >                       break;
> >               case Opt_product_id:
> > -                     match_strncpy(lu->attrs.product_id, &args[0],
> > -                                   sizeof(lu->attrs.product_id));
> > +                     match_strncpy(attrs->product_id, &args[0],
> > +                                   sizeof(attrs->product_id));
> >                       break;
> >               case Opt_product_rev:
> > -                     match_strncpy(lu->attrs.product_rev, &args[0],
> > -                                   sizeof(lu->attrs.product_rev));
> > +                     match_strncpy(attrs->product_rev, &args[0],
> > +                                   sizeof(attrs->product_rev));
> >                       break;
> >               case Opt_sense_format:
> >                       match_strncpy(buf, &args[0], sizeof(buf));
> > -                     lu->attrs.sense_format = atoi(buf);
> > +                     attrs->sense_format = atoi(buf);
> >                       break;
> >               case Opt_removable:
> >                       match_strncpy(buf, &args[0], sizeof(buf));
> > -                     lu->attrs.removable = atoi(buf);
> > +                     attrs->removable = atoi(buf);
> >                       break;
> >               case Opt_online:
> >                       match_strncpy(buf, &args[0], sizeof(buf));
> > -                     lu->attrs.online = atoi(buf);
> > +                     attrs->online = atoi(buf);
> >                       break;
> >               case Opt_mode_page:
> >                       match_strncpy(buf, &args[0], sizeof(buf));
> > @@ -559,12 +665,32 @@ int spc_lu_config(struct scsi_lu *lu, char *params)
> >       return lu_config(lu, params, NULL);
> >  }
> >
> > -int spc_lu_init(struct scsi_lu *lu)
> > +int spc_lu_init(struct scsi_lu *lu, int tid)
> >  {
> > +     struct vpd **lu_vpd = lu->attrs.vpd;
> > +
> > +     lu->attrs.device_type = lu->dev_type_template.type;
> > +     lu->attrs.qualifier = 0x0;
> > +
> >       snprintf(lu->attrs.vendor_id, sizeof(lu->attrs.vendor_id),
> >                "%-16s", VENDOR_ID);
> >       snprintf(lu->attrs.product_rev, sizeof(lu->attrs.product_rev),
> >                "%s", "0001");
> > +     snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
> > +              "deadbeaf%d:%" PRIu64, tid, lu->lun);
> > +     snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
> > +              "beaf%d%" PRIu64, tid, lu->lun);
> > +
> > +     /* VPD page 0x80 */
> > +     lu_vpd[0] = alloc_vpd(SCSI_SN_LEN);
> > +     lu_vpd[0]->vpd_update = update_vpd_80;
> > +     update_vpd_80(lu, lu->attrs.scsi_sn);
> > +
> > +     /* VPD page 0x83 */
> > +     lu_vpd[3] = alloc_vpd(SCSI_ID_LEN + 4); /* + Designator descriptor len*/
> > +     lu_vpd[3]->vpd_update = update_vpd_83;
> > +     update_vpd_83(lu, lu->attrs.scsi_id);
> > +
> >       lu->attrs.removable = 0;
> >       lu->attrs.sense_format = 0;
> >       lu->attrs.online = 0;
> > diff --git a/usr/spc.h b/usr/spc.h
> > index 1cc8623..315b49e 100644
> > --- a/usr/spc.h
> > +++ b/usr/spc.h
> > @@ -7,7 +7,7 @@ extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
> >  extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
> >  extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
> >  extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
> > -extern int spc_lu_init(struct scsi_lu *lu);
> > +extern int spc_lu_init(struct scsi_lu *lu, int tid);
> >
> >  typedef int (match_fn_t)(struct scsi_lu *lu, char *params);
> >  extern int lu_config(struct scsi_lu *lu, char *params, match_fn_t *);
> > @@ -15,5 +15,6 @@ extern int spc_lu_config(struct scsi_lu *lu, char *params);
> >  extern void dump_cdb(struct scsi_cmd *cmd);
> >  extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
> >  extern int add_mode_page(struct scsi_lu *lu, char *params);
> > +extern struct vpd *alloc_vpd(uint16_t size);
> >
> >  #endif
> > diff --git a/usr/target.c b/usr/target.c
> > index 2474d05..b966579 100644
> > --- a/usr/target.c
> > +++ b/usr/target.c
> > @@ -266,7 +266,7 @@ int tgt_device_create(int tid, int dev_type, uint64_t lun, char *args, int backi
> >       tgt_cmd_queue_init(&lu->cmd_queue);
> >
> >       if (lu->dev_type_template.lu_init) {
> > -             ret = lu->dev_type_template.lu_init(lu);
> > +             ret = lu->dev_type_template.lu_init(lu, tid);
> >               if (ret)
> >                       goto free_lu;
> >       }
> > @@ -285,13 +285,6 @@ int tgt_device_create(int tid, int dev_type, uint64_t lun, char *args, int backi
> >                       goto free_lu;
> >       }
> >
> > -     lu->attrs.device_type = lu->dev_type_template.type;
> > -     lu->attrs.qualifier = 0x0;
> > -     snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
> > -              "deadbeaf%d:%" PRIu64, tid, lun);
> > -     snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
> > -              "beaf%d%" PRIu64, tid, lun);
> > -
> >       if (tgt_drivers[target->lid]->lu_create)
> >               tgt_drivers[target->lid]->lu_create(lu);
> >
> > diff --git a/usr/tgtd.h b/usr/tgtd.h
> > index c39b9c2..6fc38c4 100644
> > --- a/usr/tgtd.h
> > +++ b/usr/tgtd.h
> > @@ -36,6 +36,15 @@ struct tgt_cmd_queue {
> >       struct list_head queue;
> >  };
> >
> > +struct scsi_lu;
> > +struct scsi_cmd;
> > +
> > +struct vpd {
> > +     uint16_t size;
> > +     void (*vpd_update)(struct scsi_lu *lu, void *data);
> > +     uint8_t data[0];
> > +};
>
> I prefer to avoid doing something like:
>
> struct vpd *vpd;
>
> Can we have a bit longer structure name like struct vp_data? Any
> suggestions are welcome.

Another of my weaknesses.. Trying to think up valid & sensible names. :)

OK a better name coming..

>
>
> >  struct lu_phy_attr {
> >       char scsi_id[SCSI_ID_LEN + 1];
> >       char scsi_sn[SCSI_SN_LEN + 1];
> > @@ -52,10 +61,9 @@ struct lu_phy_attr {
> >       char online;            /* Logical Unit online */
> >       char reset;             /* Power-on or reset has occured */
> >       char sense_format;      /* Descrptor format sense data supported */
> > -};
> >
> > -struct scsi_lu;
> > -struct scsi_cmd;
> > +     struct vpd *vpd[0x80];  /* VPD pages 0x80 -> 0xff masked with 0x80*/
> > +};
> >
> >  struct device_type_operations {
> >       int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
> > @@ -64,7 +72,7 @@ struct device_type_operations {
> >  struct device_type_template {
> >       unsigned char type;
> >
> > -     int (*lu_init)(struct scsi_lu *lu);
> > +     int (*lu_init)(struct scsi_lu *lu, int tid);
> >       void (*lu_exit)(struct scsi_lu *lu);
> >       int (*lu_config)(struct scsi_lu *lu, char *args);
> >
> > --
> > 1.5.2.3
> >
> >
> >
> >
> > _______________________________________________
> > Stgt-devel mailing list
> > Stgt-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/stgt-devel
>

Cheers
Mark


From tomof at acm.org  Sun Sep  2 12:48:18 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 2 Sep 2007 19:48:18 +0900
Subject: [Stgt-devel] [Patch 1/1] Add support for extra VPD pages within
 INQUIRY op code
In-Reply-To: <f29db9a80709020323k54469d87w73297ddd2bd33144@mail.gmail.com>
References: <46CE93B8.8000908@gmail.com> <20070901144153E.tomof@acm.org>
	<f29db9a80709020323k54469d87w73297ddd2bd33144@mail.gmail.com>
Message-ID: <20070902114957P.tomof@acm.org>

On Sun, 2 Sep 2007 20:23:12 +1000
"Mark Harvey" <markh794 at gmail.com> wrote:

> > > diff --git a/usr/spc.c b/usr/spc.c
> > > index b56c0b3..08a4bc5 100644
> > > --- a/usr/spc.c
> > > +++ b/usr/spc.c
> > > @@ -20,6 +20,7 @@
> > >   * 02110-1301 USA
> > >   */
> > >  #include <errno.h>
> > > +#include <inttypes.h>
> > >  #include <stdio.h>
> > >  #include <stdlib.h>
> > >  #include <string.h>
> > > @@ -38,6 +39,96 @@
> > >  #define PRODUCT_REV  "0"
> > >  #define BLK_SHIFT    9
> > >
> > > +/** Protocol Identifier Values
> > > + * 0 Fibre Channel (FCP-2)
> > > + * 1 Parallel SCSI (SPI-5)
> > > + * 2 SSA (SSA-S3P)
> > > + * 3 IEEE 1394 (SBP-3)
> > > + * 4 SCSI Remote Direct Memory Access (SRP)
> > > + * 5 iSCSI
> > > + * 6 SAS Serial SCSI Protocol (SAS)
> > > + * 7 Automation/Drive Interface (ADT)
> > > + * 8 AT Attachment Interface (ATA/ATAPI-7)
> > > + */
> > > +#define PIV_FCP 0
> > > +#define PIV_SPI 1
> > > +#define PIV_S3P 2
> > > +#define PIV_SBP 3
> > > +#define PIV_SRP 4
> > > +#define PIV_ISCSI 5
> > > +#define PIV_SAS 6
> > > +#define PIV_ADT 7
> > > +#define PIV_ATA 8
> > > +
> > > +#define PIV_VALID 0x80
> >
> > Would be better to use lengthy names for SCSI specification defines
> > and move them to scsi.h?
> 
> As these defines are only used by the SCSI Inquiry page, I kept them
> in the spc module.
> 
> I can move them if you like.

OK, let's keep them in spc.c.


> > > +struct vpd *alloc_vpd(uint16_t size)
> > > +{
> > > +     struct vpd *vpd;
> > > +
> > > +     vpd = zalloc(sizeof(struct vpd) + size);
> > > +     if (!vpd)
> > > +             return NULL;
> > > +
> > > +     vpd->size = size;
> > > +
> > > +     return vpd;
> > > +}
> >
> > Where do you free vpd?
> 
> It's a one time allocation and stays set. i.e. There is no call to free().

When we remove a logical unit, what happens?



From robin.humble+stgt at anu.edu.au  Mon Sep  3 15:37:16 2007
From: robin.humble+stgt at anu.edu.au (Robin Humble)
Date: Mon, 3 Sep 2007 09:37:16 -0400
Subject: [Stgt-devel] patch for rhel4/centos4
Message-ID: <20070903133716.GA12004@lemming.cita.utoronto.ca>

BTW, here's a trivial patch against git://git.osc.edu/tgt or 
git://git.kernel.org/pub/scm/linux/kernel/git/tomo/tgt.git
to allow building of tgt on rhel4/centos4.

probably I picked the wrong .h file to put this into, but you get the
idea: <linux/fs.h> has no defines for READ or WRITE in rhel4/centos4 but
does in sles9/10, rhel5, fedora7, etc..

cheers,
robin
-------------- next part --------------
diff --git a/usr/scsi.h b/usr/scsi.h
index 425fcff..874997f 100644
--- a/usr/scsi.h
+++ b/usr/scsi.h
@@ -218,4 +218,11 @@
 #define ASC_WRITE_PROTECT			0x2700
 #define ASC_MEDIUM_OVERWRITE_ATTEMPTED		0x300c
 
+#ifndef READ
+#define READ 0
+#endif
+#ifndef WRITE
+#define WRITE 1
+#endif
+
 #endif

From robin.humble+stgt at anu.edu.au  Mon Sep  3 15:23:26 2007
From: robin.humble+stgt at anu.edu.au (Robin Humble)
Date: Mon, 3 Sep 2007 09:23:26 -0400
Subject: [Stgt-devel] iSER
Message-ID: <20070903132326.GA8441@lemming.cita.utoronto.ca>

Hi,

an iSER implementation is pretty exciting - thanks for all your
hard work!

I've been trying out git://git.osc.edu/tgt but I seem to have hit a
problem with larger i/o :-/ hopefully I'm just doing something silly as
I'm fairly new to iSCSI and even newer to tgtd.

so I can connect to an iSCSI/iSER target and small dd's to the device
work eg.
 # dd if=/dev/zero of=/dev/sdc bs=1M count=10
 10+0 records in
 10+0 records out
 10485760 bytes (10 MB) copied, 0.020379 seconds, 515 MB/s

however a slightly larger dd
  # dd if=/dev/zero of=/dev/sdc bs=1M count=100
hits troubles (it appears to eventually complete, albeit with speeds in
the kB/s range) and the iSCSI device is usually left in a non-working
state afterwards eg. "fdisk -l <device>" gives no output.

logs from tgtd -d 9 and from the initiator side are attached.

there are ~millions of these:
 tgtd: iscsi_iser_write_begin(1014) Unable to find send slot
 [iSER]:in iscsi_iser_write_begin nbytes 48.
at the end of the tgtd logs, so for brevity I truncated the file after
a few 100 of them.

dd works as expected when I use TCP or IPoIB instead of iSER.
I tried tgtd in iSER mode with both standard centos5 kernels and ofed
(1.1) and also 2.6.22.6 + ofed1.2. logs are from the latter.

if it matters:
the backing store for the iSER target is a file in a 7.1g ramfs.
the client is booted into a kernel with mem=512M.
centos5, x86_64, dual dual-core Xeon 5150.

target/server setup is:
 mount -t ramfs none -o rw,size=7100M,mode=755 /mnt/ramdisk
 dd if=/dev/zero of=/mnt/ramdisk/file bs=1M count=7000
 modprobe ib_iser
 tgtd
 tgtadm --lld iscsi --mode target --op new --tid 1 --targetname yo
 tgtadm --lld iscsi --mode target --op bind --tid 1 --initiator-address ALL
 tgtadm --lld iscsi --mode target --op update --tid 1 --name MaxRecvDataSegmentLength --value 262144
 tgtadm --lld iscsi --mode target --op update --tid 1 --name FirstBurstLength --value 262144
 tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 1 --backing-store /mnt/ramdisk/file

initiator/client setup is:
 /etc/iscsi/iscsid.conf:
   node.startup = manual
   node.session.timeo.replacement_timeout = 120
   node.conn[0].timeo.login_timeout = 15
   node.conn[0].timeo.logout_timeout = 15
   node.conn[0].timeo.noop_out_interval = 10
   node.conn[0].timeo.noop_out_timeout = 15
   node.session.iscsi.InitialR2T = No
   node.session.iscsi.ImmediateData = Yes
   node.conn[0].iscsi.HeaderDigest = None
   node.conn[0].iscsi.DataDigest = None

 modprobe ib_iser
 /etc/init.d/iscsid start
 iscsiadm --mode discovery --type sendtargets --portal $ip
 iscsiadm --mode node --targetname yo --portal $ip:3260 --op update -n node.transport_name -v iser
 iscsiadm --mode node --targetname yo --portal $ip:3260 --login

please let me know if you'd like more info or for me to try
something else out.

cheers,
robin
-------------- next part --------------
A non-text attachment was scrubbed...
Name: tgtd_log.100m.1.short.txt.gz
Type: application/x-gzip
Size: 12551 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070903/621e3312/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: initiator_log.1.txt.gz
Type: application/x-gzip
Size: 1159 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070903/621e3312/attachment-0001.bin>

From pw at osc.edu  Mon Sep  3 19:02:23 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 3 Sep 2007 13:02:23 -0400
Subject: [Stgt-devel] iSER
In-Reply-To: <20070903132326.GA8441@lemming.cita.utoronto.ca>
References: <20070903132326.GA8441@lemming.cita.utoronto.ca>
Message-ID: <20070903170223.GA28887@osc.edu>

robin.humble+stgt at anu.edu.au wrote on Mon, 03 Sep 2007 09:23 -0400:
> however a slightly larger dd
>   # dd if=/dev/zero of=/dev/sdc bs=1M count=100
> hits troubles (it appears to eventually complete, albeit with speeds in
> the kB/s range) and the iSCSI device is usually left in a non-working
> state afterwards eg. "fdisk -l <device>" gives no output.
> 
> logs from tgtd -d 9 and from the initiator side are attached.
> 
> there are ~millions of these:
>  tgtd: iscsi_iser_write_begin(1014) Unable to find send slot
>  [iSER]:in iscsi_iser_write_begin nbytes 48.
> at the end of the tgtd logs, so for brevity I truncated the file after
> a few 100 of them.

Yes, this was a major problem.  It seems to be fixed now in my
development tree, but I haven't published any of that yet.
Hopefully early this week once I get back from travel.  I'll
certainly be interested in knowing if it works for you.

The problem was two-fold:  not provisioning enough resources based
on negotiated connection settings, and not having a flow control
mechanism to slow down the TX state machine when RDMA ran out of
resources.

Your setup looks good except:

>  tgtadm --lld iscsi --mode target --op update --tid 1 --name MaxRecvDataSegmentLength --value 262144

will largely be ignored.  No harm done, though, just FYI.
Open-iscsi has no way to specify the RDMA parameters,
IntiatorRecvDataSegmentLength or TargetRDSL, that size the control
transfer sizes.  You can set them on the target similarly to how you
set MRDSL above, but the initiator will insist on 8k TRDSL.  I'll
try to generate patches for that some day.  Data sizes are
(recently) chosen by the target unilaterally.

		-- Pete


From robin.humble+stgt at anu.edu.au  Tue Sep  4 05:24:20 2007
From: robin.humble+stgt at anu.edu.au (Robin Humble)
Date: Mon, 3 Sep 2007 23:24:20 -0400
Subject: [Stgt-devel] iSER
In-Reply-To: <20070903170223.GA28887@osc.edu>
References: <20070903132326.GA8441@lemming.cita.utoronto.ca>
	<20070903170223.GA28887@osc.edu>
Message-ID: <20070904032420.GA20306@lemming.cita.utoronto.ca>

On Mon, Sep 03, 2007 at 01:02:23PM -0400, Pete Wyckoff wrote:
>robin.humble+stgt at anu.edu.au wrote on Mon, 03 Sep 2007 09:23 -0400:
>>  tgtd: iscsi_iser_write_begin(1014) Unable to find send slot
>>  [iSER]:in iscsi_iser_write_begin nbytes 48.
>The problem was two-fold:  not provisioning enough resources based
>on negotiated connection settings, and not having a flow control
>mechanism to slow down the TX state machine when RDMA ran out of
>resources.

ok - great. I'll be happy to try it out.

>Open-iscsi has no way to specify the RDMA parameters,
>IntiatorRecvDataSegmentLength or TargetRDSL, that size the control
>transfer sizes.  You can set them on the target similarly to how you
>set MRDSL above, but the initiator will insist on 8k TRDSL.  I'll
>try to generate patches for that some day.  Data sizes are
>(recently) chosen by the target unilaterally.

8k's pretty small. to get ~90% of max bandwidth out of single IB
messages (at least via verbs) something north of 50-100kB seems to be
required(*).
presumably you have multiple messages in flight though? if so then
maybe a total RDMA buffer of order this size would be enough. I guess
we'll find out :)

cheers,
robin

(*) http://www.cita.utoronto.ca/mediawiki/index.php/Image:Netpipe3.png


From pw at osc.edu  Tue Sep  4 22:02:45 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:02:45 -0400
Subject: [Stgt-devel] [PATCH] print newline
Message-ID: <20070904200245.GA6578@osc.edu>

Add newlines missing on some dprintf and eprintf.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/chap.c   |    2 +-
 usr/iscsi/iscsid.c |    3 ++-
 usr/xen/xenbus.c   |    2 +-
 3 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/usr/iscsi/chap.c b/usr/iscsi/chap.c
index fc6fd8f..7e42d5f 100644
--- a/usr/iscsi/chap.c
+++ b/usr/iscsi/chap.c
@@ -284,7 +284,7 @@ static int chap_decode_string(char *encoded, uint8_t *decode_buf, int buf_len, i
 
 	} else if (encoding_fmt == BASE64_FORMAT) {
 		if ((strlen(encoded) - 2) > ((buf_len - 1) / 3 + 1) * 4) {
-			eprintf("buf[%d] !sufficient to decode string[%d]",
+			eprintf("buf[%d] !sufficient to decode string[%d]\n",
 				buf_len, (int) strlen(encoded));
 			return CHAP_TARGET_ERROR;
 		}
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index cbedcf1..ab3bf53 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -529,7 +529,8 @@ static void cmnd_exec_login(struct iscsi_connection *conn)
 
 	switch (ISCSI_LOGIN_CURRENT_STAGE(req->flags)) {
 	case ISCSI_SECURITY_NEGOTIATION_STAGE:
-		dprintf("Login request (security negotiation): %d", conn->state);
+		dprintf("Login request (security negotiation): %d\n",
+			conn->state);
 		rsp->flags = ISCSI_SECURITY_NEGOTIATION_STAGE << 2;
 
 		switch (conn->state) {
diff --git a/usr/xen/xenbus.c b/usr/xen/xenbus.c
index d17d555..fc68b0b 100644
--- a/usr/xen/xenbus.c
+++ b/usr/xen/xenbus.c
@@ -194,7 +194,7 @@ static int tgt_device_setup(struct xs_handle *h, char *bepath)
 
 	err = xs_printf(h, be->backpath, "info", "%d", be->frontend_id);
 	if (!err)
-		dprintf("ERROR: Failed writing info");
+		dprintf("ERROR: Failed writing info\n");
 
 	dprintf("[SETUP] Complete\n\n");
 
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:03:06 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:03:06 -0400
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
Message-ID: <20070904200306.GB6578@osc.edu>

Repair one corner case in MaxRecvDataSegmentLength processing.  Default
target has always kept data segments at 8k, even if the initiator asks
for more.  Some target administrators may increase this by, e.g.:

    tgtadm --lld iscsi --mode target --op update --tid 1 \
	   --name MaxXmitDataSegmentLength --value 262144

so that target will generate up to min(initiator-specified RDSL, 256k).
But if such a change is made, and the initiator does not specify RDSL,
which is odd but specification compliant, the target will incorrectly
use 256k instead of 8k.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |   10 +++++++---
 usr/iscsi/iscsid.h |    1 +
 usr/iscsi/target.c |    2 +-
 3 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index ab3bf53..079c878 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -286,8 +286,10 @@ static void text_scan_login(struct iscsi_connection *conn)
 			unsigned int val;
 			char buf[32];
 
-			if (idx == ISCSI_PARAM_MAX_RECV_DLENGTH)
+			if (idx == ISCSI_PARAM_MAX_RECV_DLENGTH) {
 				idx = ISCSI_PARAM_MAX_XMIT_DLENGTH;
+				conn->mxdsl_negotiated = 1;
+			}
 
 			if (param_str_to_val(session_keys, idx, value, &val) < 0) {
 				if (conn->session_param[idx].state
@@ -349,8 +351,6 @@ static int text_check_param(struct iscsi_connection *conn)
 		if (p[i].state == KEY_STATE_START && p[i].val != session_keys[i].def) {
 			if (conn->state == STATE_LOGIN) {
 				if (i == ISCSI_PARAM_MAX_XMIT_DLENGTH) {
-					if (p[i].val > session_keys[i].def)
-						p[i].val = session_keys[i].def;
 					p[i].state = KEY_STATE_DONE;
 					continue;
 				}
@@ -471,6 +471,10 @@ static void login_finish(struct iscsi_connection *conn)
 {
 	switch (conn->session_type) {
 	case SESSION_NORMAL:
+		if (!conn->mxdsl_negotiated)
+			/* use spec default if he did not mention MRDSL */
+			conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val =
+				session_keys[ISCSI_PARAM_MAX_XMIT_DLENGTH].def;
 		if (!conn->session)
 			session_create(conn);
 		memcpy(conn->isid, conn->session->isid, sizeof(conn->isid));
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index a8c8cb1..2b08252 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -140,6 +140,7 @@ struct iscsi_connection {
 
 	int tid;
 	struct param session_param[ISCSI_PARAM_MAX];
+	int mxdsl_negotiated;
 
 	char *initiator;
 	uint8_t isid[6];
diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
index 2653839..53d8164 100644
--- a/usr/iscsi/target.c
+++ b/usr/iscsi/target.c
@@ -265,7 +265,7 @@ int iscsi_target_create(struct target *t)
 	struct iscsi_target *target;
 	struct param default_tgt_session_param[] = {
 		[ISCSI_PARAM_MAX_RECV_DLENGTH] = {0, 8192},
-		[ISCSI_PARAM_MAX_XMIT_DLENGTH] = {0, 8192},  /* do not edit */
+		[ISCSI_PARAM_MAX_XMIT_DLENGTH] = {0, 8192},
 		[ISCSI_PARAM_HDRDGST_EN] = {0, DIGEST_NONE},
 		[ISCSI_PARAM_DATADGST_EN] = {0, DIGEST_NONE},
 		[ISCSI_PARAM_INITIAL_R2T_EN] = {0, 1},
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:03:51 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:03:51 -0400
Subject: [Stgt-devel] [PATCH] bidi quiet warning
Message-ID: <20070904200351.GC6578@osc.edu>

Always zero out task->len for write commands.  They do not send data
back to the initiator.  For reads and bidirectional commands, the backing
store will set task->len to the read result size, which must be within
the size the initiator requested at the transport layer.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    8 +++++---
 1 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 079c878..41d5cad 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1034,9 +1034,11 @@ static int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *scmd)
 	task->len = scmd->len;
 	task->rw = scmd->rw;
 
-	if (task->len > task->read_len) {
-		dprintf("shrinking target len %d to initiator len %d\n",
-		        task->len, task->read_len);
+	if (task->dir == WRITE)
+		task->len = 0;  /* no read result */
+	else if (task->len > task->read_len) {
+		dprintf("shrunk too big device read len %d > %u\n",
+			task->len, task->read_len);
 		task->len = task->read_len;
 	}
 
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:05:48 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:05:48 -0400
Subject: [Stgt-devel] iSER patches, second release
Message-ID: <20070904200548.GD6578@osc.edu>

This is the second major release of support for iSCSI Extensions
for RDMA (iSER) to the existing STGT user space SCSI target.  It
uses OpenFabrics libraries and kernel drivers to act as a SCSI
target over RDMA-capable devices.  The code has been tested
against the existing Linux iSER initiator over InfiniBand cards,
but should be specification compliant and work generally.

A bit of documentation is included, and a short technical report is
available at http://www.osc.edu/~pw/papers/iser-snapi07.pdf .
For performance, a single SCSI client using iSCSI over gigabit
ethernet does 100 MB/s.  iSCSI over IPoIB gets 200 MB/s, and iSER
over native IB sees 500 MB/s (to a RAM disk).

More information on STGT is available at http://stgt.berlios.de .

The iSER patches can be downloaded from:

        git://git.osc.edu/tgt

or browsed at:

        http://git.osc.edu/?p=tgt.git;a=summary

New and modified files are distributed under a GPLv2 license.
Following this mail are the individual patches to stgt-devel
for review and eventual inclusion in STGT.

Changes since previous series are as follows.

Major rewrite and cleanup.  Many error handling issues and corner
cases were fixed.  Also the patchset was split up even finer for
easier review:  18 small patches instead of 7 big ones.

Per-connection resource negotiation.  Hooks in iscsid give the
transport a chance to prepare itself before the transition to
full-feature mode.  This allows sizing buffers correctly;
however, there are some issues with the open-iscsi initiator in
this area still.  It doesn't negotiate all the parameters.  We'll
get it patched up.

All debug and error messages go through tgt log.c functions rather
than appearing on stderr through iser-private debugging functions.

Multiple RDMA devices in the target should work now, but have
never been tested.  The code is at least structured so it could
function.

IP-based ACLs work.  There is a way to get an IP address out of
an RDMA connection, and we use that to check the ACLs.

Fixed RDMA data transfer size to be independent of [IT]RDSL as it
should be.

Tested with valgrind.  Memory does not leak.

Tested with open-iscsi regression script.  All the tests pass, both
for TCP and RDMA.

Also, various linux kernels have minor iscsi and iser bugs.
We're running on v2.6.22-rc5, which mostly works, but sometimes
will oops.  Certainly we'll get these fixed, but be careful on
production machines.

Thanks to everybody for suggestions and fixes, especially
Alexander Nezhinsky and Erez Zilber.

		-- Pete


From pw at osc.edu  Tue Sep  4 22:07:00 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:07:00 -0400
Subject: [Stgt-devel] [PATCH 01/18] iser docs
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904200700.GE6578@osc.edu>

A document describing what iSCSI on RDMA is about, how it is
implemented in tgtd, and how to use it.  Also things that
should be fixed someday.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 doc/README.iser |  244 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 244 insertions(+), 0 deletions(-)
 create mode 100644 doc/README.iser

diff --git a/doc/README.iser b/doc/README.iser
new file mode 100644
index 0000000..1aafcac
--- /dev/null
+++ b/doc/README.iser
@@ -0,0 +1,244 @@
+iSCSI Extensions for RDMA (iSER)
+================================
+
+Background
+----------
+
+There is a draft specification at ietf.org to extend the iSCSI protocol
+to work on RDMA-capable networks as well as on traditional TCP/IP.  The
+current version is:
+
+	"iSCSI Extensions for RDMA Specification", Mike Ko, 20-Oct-05,
+	<draft-ietf-ips-iser-06.txt>
+
+RDMA stands for Remote Direct Memory Access, a way of accessing memory
+of a remote node directly through the network without involving the
+processor of that remote node.  Many network devices implement some form
+of RDMA.  Two of the more popular network devices are InfiniBand (IB)
+and iWARP.  IB uses its own physical and network layer, while iWARP sits
+on top of TCP/IP (or SCTP).
+
+Using these devices requires a new application programming interface
+(API).  The Linux kernel has many components of the OpenFabrics software
+stack, including APIs for access from user space and drivers for some
+popular RDMA-capable NICs, including IB cards with the Mellanox chipset
+and iWARP cards from NetEffect, Chelsio, and Ammasso.  Most Linux
+distributions ship the user space libraries for device access and RDMA
+connection management.
+
+
+RDMA in tgtd
+------------
+
+The Linux kernel can act as a SCSI initiator on the iSER transport, but
+not as a target.  tgtd is a user space target that supports multiple
+transports, including iSCSI/TCP, and now iSER on RDMA devices.
+
+The iSER code was written by researchers at the Ohio Supercomputer
+Center in early 2007:
+
+	Dennis Dalessandro <dennis at osc.edu>
+	Ananth Devulapalli <ananth at osc.edu>
+	Pete Wyckoff <pw at osc.edu>
+
+We wanted to use a faster transport to test the capabilities of an
+object-based storage device (OSD) emulator we had previously written.
+Our cluster has InfiniBand cards, and while running TCP/IP over IB is
+possible, the performance is not nearly as good as using native IB
+directly.
+
+A report describing this implementation and some performance results
+will appear in IEEE conference proceedings as:
+
+	Dennis Dalessandro, Ananth Devulapalli and Pete Wyckoff,
+	iSER Storage Target for Object-based Storage Devices,
+	Proceedings of MSST'07, SNAPI Workshop, San Diego, CA,
+	September 2007.
+
+and is available at:
+
+	http://www.osc.edu/~pw/papers/iser-snapi07.pdf
+
+The code mostly lives in iscsi/iscsi_rdma.c, with a few places in
+iscsi/iscsid.c that check if the transport is RDMA or not and behave
+accordingly.  iSCSI already had the idea of a transport, with just the
+single TCP one defined.  We added the RDMA transport and virtualized
+some more functions where TCP and RDMA behave differently.
+
+
+Design Issues
+-------------
+
+In general, a SCSI system includes two components, an initiator and a
+target. The initiator submits commands and awaits responses.  The target
+services commands from initiators and returns responses.  Data may flow
+from the initiator, from the client, or both (bidirectional).  The iSER
+specification requires all data transfers to be started by the target,
+regardless of direction.  In a read operation, the target uses RDMA
+Write to move data to the initiator, while a write operation uses RDMA
+Read to fetch data from the initiator.
+
+
+1. Memory registration
+
+One of the most severe stumbling blocks in moving any application to
+take advantage of RDMA features is memory registration.  Before using
+RDMA, both the sending and receiving buffers must be registered with the
+operating system.  This operation ensures that the underlying hardware
+pages will not be modified during the transfer, and provides the
+physical addresses of the buffers to the network card.  However, the
+process itself is time consuming, and CPU intensive.  Previous
+investigations have shown that for InfiniBand, with a nominal transfer
+rate of 900 MB/s, the throughput drops to around 500 MB/s when memory
+registration and deregistration are included in the critical path.
+
+Our target implementation uses pre-registered buffers for RDMA
+operations.  In general such a scheme is difficult to justify due to the
+large per-connection resource requirements.  However, in this
+application it may be appropriate.  Since the target always initiates
+RDMA operations and never advertises RDMA buffers, it can securely use
+one pool of buffers for multiple clients and can manage its memory
+resources explicitly.  Also, the architecture of the code is such that
+the iSCSI layer dictates incoming and outgoing buffer locations to the
+storage device layer, so supplying a registered buffer is relatively
+easy.
+
+
+2. Event management
+
+There is a mismatch between what the tgtd event framework assumes and
+what the RDMA notification interface provides.  The existing TCP-based
+iSCSI target code has one file descriptor per connection and it is
+driven by readability or writeability of the socket.  A single poll
+system call returns which sockets can be serviced, driving the TCP code
+to read or write as appropriate.  The RDMA interface can be used in
+accordance with this design by requesting interrupts from the network
+card on work request completions.  Notifications appear on the file
+descriptor that represents a completion queue to which all RDMA events
+are delivered.
+
+However, the existing sockets-based code goes beyond this and changes
+the bitmask of requested events to control its code flow.  For instance,
+after it finishes sending a response, it will modify the bitmask to only
+look for readability.  Even if the socket is writeable, there is no data
+to write, hence polling for that status is not useful.  The code also
+disables new message arrival during command execution as a sort of
+exclusion facility, again by modifying the bitmask.  We cannot do this
+with the RDMA interface.  Hence we must maintain an active list of tasks
+that have data to write and drive a progress engine to service them.
+The need for progress is tracked by a counter, and the tgtd event loop
+checks this counter and calls into the iSER-specific while the counter
+is still non-zero.  tgtd will block in the poll call when it must wait
+on network activity.  No dedicated thread is needed for iSER.
+
+
+3. Padding
+
+The iSCSI specification clearly states that all segments in the protocol
+data unit (PDU) must be individually padded to four-byte boundaries.
+However, the iSER specification remains mute on the subject of padding.
+It is clear from an implementation perspective that padding data
+segments is both unnecessary and would add considerable overhead to
+implement.  (Possibly a memory copy or extra SG entry on the initiator
+when sending directly from user memory.)   RDMA is used to move all
+data, with byte granularity provided by the network.  The need for
+padding in the TCP case was motivated by the optional marker support to
+work around the limitations of the streaming mode of TCP.  IB and iWARP
+are message-based networks and would never need markers.  And finally,
+the Linux initiator does not add padding either.
+
+
+Using iSER
+----------
+
+Compile tgtd with "make ISCSI=1 ISCSI_RDMA=1" to build iSCSI and iSER.
+You'll need to have two libraries installed on your system:
+libibverbs.so and librdmacm.so.  If they are installed in the normal
+system paths (/usr/include and /usr/lib or /usr/lib64), they will be
+found automatically.  Otherwise, edit CFLAGS and LIBS in usr/Makefile
+near ISCSI_RDMA to specify the paths by hand, e.g., for a /usr/local
+install, it should look like:
+
+	ifneq ($(ISCSI_RDMA),)
+	CFLAGS += -DISCSI_RDMA -I/usr/local/include
+	TGTD_OBJS += iscsi/iscsi_rdma.o
+	LIBS += -L/usr/local/lib -libverbs -lrdmacm
+	endif
+
+(You may possibly also have to set, e.g., LD_LIBRARY_PATH=/usr/local/lib
+in your environment to use the libibverbs.so and librdmacm.so shared
+libraries at runtime.)
+
+The target will listen on all TCP interfaces (as usual), as well as all
+RDMA devices.  Both use the same default iSCSI port, 3260.  Clients on
+TCP or RDMA will connect to the same tgtd instance.
+
+Start the daemon (as root):
+
+	./tgtd
+
+It will send messages to syslog.  You can add "-d 9" to turn on debug
+messages.
+
+Configure the running target with one or more devices, using the tgtadm
+program you just built (also as root).  Full information is in
+doc/README.iscsi.  Here is a quick-start guide:
+
+	dd if=/dev/zero bs=1k count=1 seek=1048575 of=/tmp/tid1lun1
+	./tgtadm --lld iscsi --mode target \
+		 --op new --tid 1 --targetname $(hostname)
+	./tgtadm --lld iscsi --mode target \
+		 --op bind --tid 1 --initiator-address ALL
+	./tgtadm --lld iscsi --mode logicalunit \
+		 --op new --tid 1 --lun 1 --backing-store /tmp/tid1lun1
+
+To make your initiator use RDMA, make sure the "ib_iser" module is
+loaded in your kernel.  Then do discovery as usual, over TCP:
+
+	iscsiadm -m discovery -t sendtargets -p $targetip
+
+where $targetip is the ethernet address of your IPoIB device.  Discovery
+traffic will use IPoIB, but login and full feature phase will use RDMA
+natively.
+
+Then do something like the following to change the transport type:
+
+	iscsiadm -m node -p $targetip -T $targetname --op update \
+	    -n node.transport_name -v iser
+
+Next, login as usual:
+
+	iscsiadm -m node -p $targetip -T $targetname --login
+
+And access the new block device, e.g. /dev/sdb.
+
+
+Errata
+------
+
+The Linux kernel iSER initiator is currently lacking support for
+bidirectional transfers, and for extended command descriptors (CDBs).
+We'll send the patches for these soon.
+
+The Linux kernel iSER initiator uses a different header structure on its
+packets than is in the iSER draft specification.  This is described in
+an InfiniBand document and is required for that network, which only
+supports for Zero-Based Addressing.  If you are using a non-IB initiator
+that doesn't need this header extension, it won't work with tgtd.  There
+may be some way to negotiate the header format.  Using iWARP hardware
+devices with the Linux kernel iSER initiator also will not work due to
+its reliance on fast memory registration (FMR), an InfiniBand-only feature.
+
+The current code sizes its per-connection resource consumption based on
+negotiatied parameters.  However, the Linux iSER initiator does not
+support negotiation of MaxOutstandingUnexpectedPDUs, so that value is
+hard-coded in the target.  Also, open-iscsi is hard-coded with a very
+small value of TargetRecvDataSegmentLength, so even though the target
+would be willing to accept a larger size, it cannot.  This may limit
+performance of small transfers on high-speed networks:  transfers bigger
+than 8 kB, but not large enough to amortize a round-trip for RDMA setup.
+
+The data structures for connection management in the iSER code are
+desgined to handle multiple devices, but have never been tested with
+such hardware.
+
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:07:28 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:07:28 -0400
Subject: [Stgt-devel] [PATCH 02/18] iser counter events
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904200728.GF6578@osc.edu>

Like fd event handling, also handle integer counter events.  This will
be used in RDMA to make progress on a connection, necessary because
RDMA API does not have a file descriptor that can be used with poll
to detect connection writability.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/tgtd.c |   70 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 usr/tgtd.h |    4 +++
 2 files changed, 70 insertions(+), 4 deletions(-)

diff --git a/usr/tgtd.c b/usr/tgtd.c
index 42e21f4..6744534 100644
--- a/usr/tgtd.c
+++ b/usr/tgtd.c
@@ -41,9 +41,15 @@
 #define MAX_FDS	4096
 
 struct tgt_event {
-	event_handler_t *handler;
+	union {
+		event_handler_t *handler;
+		counter_event_handler_t *counter_handler;
+	};
+	union {
+		int fd;
+		int *counter;
+	};
 	void *data;
-	int fd;
 	struct list_head e_list;
 };
 
@@ -52,6 +58,7 @@ unsigned long pagesize, pageshift, pagemask;
 static int ep_fd;
 static char program_name[] = "tgtd";
 static LIST_HEAD(tgt_events_list);
+static LIST_HEAD(tgt_counter_events_list);
 
 static struct option const long_options[] =
 {
@@ -129,6 +136,22 @@ int tgt_event_add(int fd, int events, event_handler_t handler, void *data)
 	return err;
 }
 
+int tgt_counter_event_add(int *counter, counter_event_handler_t handler,
+			  void *data)
+{
+	struct tgt_event *tev;
+
+	tev = zalloc(sizeof(*tev));
+	if (!tev)
+		return -ENOMEM;
+
+	tev->data = data;
+	tev->counter_handler = handler;
+	tev->counter = counter;
+	list_add(&tev->e_list, &tgt_counter_events_list);
+	return 0;
+}
+
 static struct tgt_event *tgt_event_lookup(int fd)
 {
 	struct tgt_event *tev;
@@ -140,6 +163,17 @@ static struct tgt_event *tgt_event_lookup(int fd)
 	return NULL;
 }
 
+static struct tgt_event *tgt_counter_event_lookup(int *counter)
+{
+	struct tgt_event *tev;
+
+	list_for_each_entry(tev, &tgt_counter_events_list, e_list) {
+		if (tev->counter == counter)
+			return tev;
+	}
+	return NULL;
+}
+
 void tgt_event_del(int fd)
 {
 	struct tgt_event *tev;
@@ -155,6 +189,20 @@ void tgt_event_del(int fd)
 	free(tev);
 }
 
+void tgt_counter_event_del(int *counter)
+{
+	struct tgt_event *tev;
+
+	tev = tgt_counter_event_lookup(counter);
+	if (!tev) {
+		eprintf("Cannot find counter event %p\n", counter);
+		return;
+	}
+
+	list_del(&tev->e_list);
+	free(tev);
+}
+
 int tgt_event_modify(int fd, int events)
 {
 	struct epoll_event ev;
@@ -174,11 +222,25 @@ int tgt_event_modify(int fd, int events)
 
 static void event_loop(void)
 {
-	int nevent, i, timeout = TGTD_TICK_PERIOD * 1000;
+	int nevent, i, done, timeout = TGTD_TICK_PERIOD * 1000;
 	struct epoll_event events[1024];
-	struct tgt_event *tev;
+	struct tgt_event *tev, *tevn;
 
 retry:
+	/*
+	 * Check the counter events to see if they have any work to run.
+	 */
+	do {
+		done = 1;
+		list_for_each_entry_safe(tev, tevn, &tgt_counter_events_list,
+					e_list) {
+			if (*tev->counter) {
+				done = 0;
+				tev->counter_handler(tev->counter, tev->data);
+			}
+		}
+	} while (!done);
+
 	nevent = epoll_wait(ep_fd, events, ARRAY_SIZE(events), timeout);
 	if (nevent < 0) {
 		if (errno != EINTR) {
diff --git a/usr/tgtd.h b/usr/tgtd.h
index c39b9c2..a260588 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -195,8 +195,12 @@ extern int tgt_unbind_host_to_target(int tid, int host_no);
 extern int tgt_bound_target_lookup(int host_no);
 
 typedef void (event_handler_t)(int fd, int events, void *data);
+typedef void (counter_event_handler_t)(int *counter, void *data);
 extern int tgt_event_add(int fd, int events, event_handler_t handler, void *data);
+extern int tgt_counter_event_add(int *counter, counter_event_handler_t handler,
+				 void *data);
 extern void tgt_event_del(int fd);
+extern void tgt_counter_event_del(int *counter);
 extern int tgt_event_modify(int fd, int events);
 extern int target_cmd_queue(int tid, struct scsi_cmd *cmd);
 extern void target_cmd_done(struct scsi_cmd *cmd);
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:07:48 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:07:48 -0400
Subject: [Stgt-devel] [PATCH 03/18] iser transport buf
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904200748.GG6578@osc.edu>

For RDMA, it is often nice to use data from a pool of pre-registered
buffers.  To do this, the transport allocates memory for a response and
passes it down to the devices to fill.  Some operations, though,
allocate their own buffers and return that new memory instead.  These
are usually small and the allocation is just done for convenience to
avoid length bounds checking.  Copy the data into the provided transport
buffer instead.

If the transport does not provide a buffer at cmd->uaddr, the newly
alloced buffer is returned as before.

Also fixes some leaks of these extra buffers in error paths, and cleans
up unreachable code in ibmvio inquiry.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/ibmvio/ibmvio.c |   25 +++++++++----------------
 usr/mmc.c           |    6 ++----
 usr/sbc.c           |    3 +--
 usr/smc.c           |    9 +++++----
 usr/spc.c           |   36 +++++++++++++++++++++++++++---------
 usr/spc.h           |    1 +
 6 files changed, 45 insertions(+), 35 deletions(-)

diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index cdd3782..a0002cf 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -143,10 +143,16 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	uint8_t *data, *scb = cmd->scb;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+	uint32_t len;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
 
+	dprintf("%x %x\n", scb[1], scb[2]);
+
+	if (scb[1] & 0x3)
+		return spc_inquiry(host_no, cmd);
+
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
@@ -155,23 +161,12 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	}
 	memset(data, 0, pagesize);
 
-	dprintf("%x %x\n", scb[1], scb[2]);
-
-	if (!(scb[1] & 0x3)) {
-		cmd->len = __ibmvio_inquiry(host_no, cmd, data);
-		ret = SAM_STAT_GOOD;
-	} else
-		return spc_inquiry(host_no, cmd);
-
-	if (ret != SAM_STAT_GOOD)
-		goto sense;
-
-	cmd->len = min_t(int, cmd->len, scb[4]);
-	cmd->uaddr = (unsigned long) data;
+	len = __ibmvio_inquiry(host_no, cmd, data);
 
 	if (cmd->dev->lun != cmd->dev_id)
 		data[0] = TYPE_NO_LUN;
 
+	spc_return_buf(cmd, data, min_t(int, len, scb[4]));
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
@@ -194,7 +189,6 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 	struct list_head *dev_list = &cmd->c_target->device_list;
 	uint64_t lun, *data;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096;
-	int *len = &cmd->len;
 	uint8_t *lun_buf = cmd->lun;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
@@ -210,7 +204,6 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 		goto sense;
 	}
 	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long)data;
 
 	alen &= ~(8 - 1);
 	oalen = alen;
@@ -240,7 +233,7 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 
 done:
 	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
-	*len = min(oalen, nr_luns * 8 + 8);
+	spc_return_buf(cmd, data, min(oalen, nr_luns * 8 + 8));
 	return SAM_STAT_GOOD;
 sense:
 	*len = 0;
diff --git a/usr/mmc.c b/usr/mmc.c
index 7f70943..74968fb 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -75,7 +75,6 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long) data;
 
 	/* forged for single session data cd only. all iso file fall into this */
 	if (cmd->scb[1] & 0x2) {
@@ -94,7 +93,7 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 		data[6] = 0x01;
 	}
 
-	cmd->len = data[1] + 2;
+	spc_return_buf(cmd, data, data[1] + 2);
 
 	return SAM_STAT_GOOD;
 }
@@ -111,14 +110,13 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long) data;
 
 	size = cmd->dev->size >> MMC_BLK_SHIFT;
 
 	data[0] = (size >> 32) ?
 		__cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
 	data[1] = __cpu_to_be32(1U << MMC_BLK_SHIFT);
-	cmd->len = 8;
+	spc_return_buf(cmd, data, 8);
 
 	return SAM_STAT_GOOD;
 }
diff --git a/usr/sbc.c b/usr/sbc.c
index 33485e6..32100a6 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -121,15 +121,14 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
-	cmd->uaddr = (unsigned long) data;
 
 	size = cmd->dev->size >> BLK_SHIFT;
 
 	data[0] = (size >> 32) ?
 		__cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
 	data[1] = __cpu_to_be32(1U << BLK_SHIFT);
-	cmd->len = 8;
 
+	spc_return_buf(cmd, data, 8);
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
diff --git a/usr/smc.c b/usr/smc.c
index 4f0ee4b..4397523 100644
--- a/usr/smc.c
+++ b/usr/smc.c
@@ -282,8 +282,10 @@ static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
 	}
 	memset(data, 0, pagesize);
 
-	if (scb[11])	/* Reserved byte */
+	if (scb[11]) {	/* Reserved byte */
+		free(data);
 		goto sense;
+	}
 
 	switch(element_type) {
 	case ELEMENT_ANY:
@@ -333,6 +335,7 @@ static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
 						  dvcid, voltag);
 		break;
 	default:
+		free(data);
 		goto sense;
 		break;
 	}
@@ -340,10 +343,8 @@ static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
 	/* Lastly, fill in data header */
 	len = element_status_data_hdr(data, dvcid, voltag, first, count);
 
-	cmd->len = min_t(int, len, alloc_len);
-	cmd->uaddr = (unsigned long) data;
 	cmd->rw = READ;
-
+	spc_return_buf(cmd, data, min_t(int, len, alloc_len));
 	return SAM_STAT_GOOD;
 
 sense:
diff --git a/usr/spc.c b/usr/spc.c
index ad71e4a..337ba29 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -38,6 +38,22 @@
 #define PRODUCT_REV	"0"
 #define BLK_SHIFT	9
 
+/*
+ * Helper to move return data into read result buffer allocated by transport,
+ * if one exists.
+ */
+void spc_return_buf(struct scsi_cmd *cmd, void *data, uint32_t len)
+{
+	if (cmd->uaddr) {
+		memcpy((void *) (unsigned long) cmd->uaddr, data,
+		       min(cmd->len, len));
+		free(data);
+	} else {
+		cmd->uaddr = (unsigned long) data;
+	}
+	cmd->len = len;
+}
+
 int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int len = 0, ret = SAM_STAT_CHECK_CONDITION;
@@ -139,15 +155,17 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 		}
 	}
 
-	if (ret != SAM_STAT_GOOD)
+	if (ret != SAM_STAT_GOOD) {
+		free(data);
 		goto sense;
+	}
 
-	cmd->len = min_t(int, len, scb[4]);
-	cmd->uaddr = (unsigned long) data;
-
+	if (scb[4] < len)
+	    len = scb[4];
 	if (cmd->dev->lun != cmd->dev_id)
 		data[0] = TYPE_NO_LUN;
 
+	spc_return_buf(cmd, data, len);
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
@@ -202,9 +220,8 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 		}
 	}
 
-	cmd->uaddr = (unsigned long)data;
 	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
-	cmd->len = min(oalen, nr_luns * 8 + 8);
+	spc_return_buf(cmd, data, min(oalen, nr_luns * 8 + 8));
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
@@ -278,7 +295,7 @@ static int build_mode_page(uint8_t *data, struct mode_pg *pg)
 int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 {
 	int len = 0;
-	uint8_t *data, *scb, mode6, dbd, pcode, subpcode;
+	uint8_t *data = NULL, *scb, mode6, dbd, pcode, subpcode;
 	uint16_t alloc_len;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
@@ -341,11 +358,12 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 		data[7] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
 	}
 
-	cmd->len = len;
-	cmd->uaddr = (unsigned long)data;
+	spc_return_buf(cmd, data, len);
 	return SAM_STAT_GOOD;
 
 sense:
+	if (data)
+		free(data);
 	cmd->len = 0;
 	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
diff --git a/usr/spc.h b/usr/spc.h
index 1cc8623..c9824c6 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -1,6 +1,7 @@
 #ifndef __SPC_H
 #define __SPC_H
 
+extern void spc_return_buf(struct scsi_cmd *cmd, void *data, uint32_t len);
 extern int spc_inquiry(int host_no, struct scsi_cmd *cmd);
 extern int spc_report_luns(int host_no, struct scsi_cmd *cmd);
 extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:08:18 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:08:18 -0400
Subject: [Stgt-devel] [PATCH 04/18] iser bidi alloc read buf
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904200818.GH6578@osc.edu>

Allocate the read buffer for bidirectional commands in the transport to
pass down to devices.  A device can fill and return this buffer in
task->uaddr, and thus choose to do the read or write processing in any
order.  Unfortunately, this allocation can not be combined with the task
and task->data allocation as the bidi read size is not known until after
AHS processing.

Necessary for iscsi RDMA transport to be able to provide its own buffers
for the read phase too.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |   27 +++++++++++++++++++--------
 usr/tgtd.h         |    2 ++
 2 files changed, 21 insertions(+), 8 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 41d5cad..4b4e35f 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -992,6 +992,8 @@ void iscsi_free_task(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 
+	if (task->addr && task->addr != (unsigned long) task->data)
+		free((void *) (unsigned long) task->addr);
 	free(task);
 	/* from alloc */
 	conn_put(conn);
@@ -1007,10 +1009,6 @@ static void iscsi_free_cmd_task(struct iscsi_task *task)
 	target_cmd_done(&task->scmd);
 
 	list_del(&task->c_hlist);
-	if (task->data) {
-		if ((unsigned long) task->data != task->addr)
-			free((void *) (unsigned long) task->addr);
-	}
 	iscsi_free_task(task);
 }
 
@@ -1073,7 +1071,6 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 	struct scsi_cmd *scmd = &task->scmd;
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
-	unsigned long uaddr = (unsigned long) task->data;
 	uint32_t data_len;
 	uint8_t *ahs;
 	int ahslen;
@@ -1116,18 +1113,32 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 
 	/* figure out incoming (write) and outgoing (read) sizes */
 	data_len = 0;
+	scmd->bidi_uaddr = 0;
+	scmd->bidi_len = 0;
+	task->read_len = 0;
 	task->write_len = 0;
+
 	if (task->dir == WRITE || task->dir == BIDIRECTIONAL) {
 		task->write_len = ntohl(req->data_length);
 		data_len = task->write_len;
 	}
-	task->read_len = 0;
 	if (task->dir == BIDIRECTIONAL && ahslen >= 8) {
 		struct iscsi_rlength_ahdr *ahs_bidi = (void *) ahs;
 		if (ahs_bidi->ahstype == ISCSI_AHSTYPE_RLENGTH) {
 			task->read_len = ntohl(ahs_bidi->read_length);
 			dprintf("bidi read len %u\n", task->read_len);
 		}
+		if (task->read_len) {
+			uint32_t len;
+			void *buf;
+
+			len = roundup(task->read_len, 4);
+			buf = malloc(len);
+			if (!buf)
+				return -ENOMEM;
+			scmd->bidi_uaddr = (unsigned long) buf;
+			scmd->bidi_len = task->read_len;
+		}
 	}
 	if (task->dir == READ) {
 		task->read_len = ntohl(req->data_length);
@@ -1136,10 +1147,10 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 
 	memcpy(scmd->lun, task->req.lun, sizeof(scmd->lun));
 	scmd->rw = req->flags & ISCSI_FLAG_CMD_WRITE;
-	scmd->len = ntohl(req->data_length);
+	scmd->len = data_len;
 	scmd->attribute = cmd_attr(task);
 	scmd->tag = req->itt;
-	scmd->uaddr = uaddr;
+	scmd->uaddr = (unsigned long) task->data;
 
 	return target_cmd_queue(conn->session->target->tid, scmd);
 }
diff --git a/usr/tgtd.h b/usr/tgtd.h
index a260588..c92b663 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -129,6 +129,8 @@ struct scsi_cmd {
 
 	uint64_t uaddr;
 	uint32_t len;
+	uint64_t bidi_uaddr;  /* for read part when bidi */
+	uint32_t bidi_len;
 	int mmapped;
 	struct scsi_lu *dev;
 	unsigned long state;
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:08:34 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:08:34 -0400
Subject: [Stgt-devel] [PATCH 05/18] iser cpu to be 64
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904200834.GI6578@osc.edu>

Define underscore-free 64-bit versions of CPU to big-endian conversions,
for consistency with the rest of iscsi.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.h |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 2b08252..42b1b5c 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -33,8 +33,10 @@
 
 #define cpu_to_be16(x)	__cpu_to_be16(x)
 #define cpu_to_be32(x)	__cpu_to_be32(x)
+#define cpu_to_be64(x)	__cpu_to_be64(x)
 #define be16_to_cpu(x)	__be16_to_cpu(x)
 #define be32_to_cpu(x)	__be32_to_cpu(x)
+#define be64_to_cpu(x)	__be64_to_cpu(x)
 
 #define ISCSI_NAME_LEN 256
 
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:08:50 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:08:50 -0400
Subject: [Stgt-devel] [PATCH 06/18] iser list del init
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904200850.GJ6578@osc.edu>

Add this handy function for removing an item from a list and
initializing its list pointers.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/list.h |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/usr/list.h b/usr/list.h
index 3e85c9b..d2e0019 100644
--- a/usr/list.h
+++ b/usr/list.h
@@ -83,4 +83,10 @@ static inline void list_del(struct list_head *entry)
 	entry->next = entry->prev = NULL;
 }
 
+static inline void list_del_init(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	INIT_LIST_HEAD(entry);
+}
+
 #endif
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:09:03 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:09:03 -0400
Subject: [Stgt-devel] [PATCH 07/18] iser virtualize event modify
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904200903.GK6578@osc.edu>

Make event modification a transport-specific operation.  TCP
has a nice transmit flow control mechanism that relies on
checking that the socket is writeable.  RDMA cannot take
advantage of this.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |   26 ++++++++++++++++++--------
 usr/iscsi/iscsid.c    |   22 ++++++++++++----------
 usr/iscsi/transport.h |    1 +
 3 files changed, 31 insertions(+), 18 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 0c35aa5..c775594 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -232,13 +232,23 @@ static int iscsi_tcp_show(int ep, char *buf, int rest)
 	return total > 0 ? total : 0;
 }
 
+void iscsi_event_modify(int fd, int events)
+{
+	int ret;
+
+	ret = tgt_event_modify(fd, events);
+	if (ret)
+		eprintf("tgt_event_modify failed\n");
+}
+
 struct iscsi_transport iscsi_tcp = {
-	.name		= "iscsi",
-	.rdma		= 0,
-	.ep_init	= iscsi_tcp_init,
-	.ep_read	= iscsi_tcp_read,
-	.ep_write_begin	= iscsi_tcp_write_begin,
-	.ep_write_end	= iscsi_tcp_write_end,
-	.ep_close	= iscsi_tcp_close,
-	.ep_show	= iscsi_tcp_show,
+	.name			= "iscsi",
+	.rdma			= 0,
+	.ep_init		= iscsi_tcp_init,
+	.ep_read		= iscsi_tcp_read,
+	.ep_write_begin		= iscsi_tcp_write_begin,
+	.ep_write_end		= iscsi_tcp_write_end,
+	.ep_close		= iscsi_tcp_close,
+	.ep_show		= iscsi_tcp_show,
+	.ep_event_modify	= iscsi_event_modify,
 };
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 4b4e35f..85d4c95 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1041,7 +1041,7 @@ static int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *scmd)
 	}
 
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
-	tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+	task->conn->tp->ep_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 
 	return 0;
 }
@@ -1165,13 +1165,13 @@ static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 	if (rw && task->r2t_count) {
 		if (!task->unsol_count) {
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
-			tgt_event_modify(conn->fd, EPOLLIN | EPOLLOUT);
+			conn->tp->ep_event_modify(conn->fd, EPOLLIN | EPOLLOUT);
 		}
 		return err;
 	}
 
 	task->offset = 0;  /* for use as transmit pointer for data-ins */
-	tgt_event_modify(conn->fd, EPOLLIN);
+	conn->tp->ep_event_modify(conn->fd, EPOLLIN);
 	err = iscsi_target_cmd_queue(task);
 	return err;
 }
@@ -1201,7 +1201,7 @@ static int iscsi_tm_done(struct mgmt_req *mreq)
 		break;
 	}
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
-	tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+	task->conn->tp->ep_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 	return 0;
 }
 
@@ -1257,7 +1257,8 @@ static int iscsi_task_execute(struct iscsi_task *task)
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_LOGOUT:
 		list_add_tail(&task->c_list, &task->conn->tx_clist);
-		tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+		task->conn->tp->ep_event_modify(task->conn->fd,
+						EPOLLIN | EPOLLOUT);
 		break;
 	case ISCSI_OP_SCSI_CMD:
 		/* convenient directionality for our internal use */
@@ -1277,7 +1278,8 @@ static int iscsi_task_execute(struct iscsi_task *task)
 		err = iscsi_tm_execute(task);
 		if (err) {
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
-			tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+			task->conn->tp->ep_event_modify(task->conn->fd,
+							EPOLLIN | EPOLLOUT);
 		}
 		break;
 	case ISCSI_OP_TEXT:
@@ -1721,7 +1723,7 @@ static int iscsi_task_tx_start(struct iscsi_connection *conn)
 
 nodata:
 	dprintf("no more data\n");
-	tgt_event_modify(conn->fd, EPOLLIN);
+	conn->tp->ep_event_modify(conn->fd, EPOLLIN);
 	return -EAGAIN;
 }
 
@@ -1885,7 +1887,7 @@ again:
 			conn_read_pdu(conn);
 	} else {
 		conn_write_pdu(conn);
-		tgt_event_modify(fd, EPOLLOUT);
+		conn->tp->ep_event_modify(fd, EPOLLOUT);
 		ret = cmnd_execute(conn);
 		if (ret)
 			conn->state = STATE_CLOSE;
@@ -2029,7 +2031,7 @@ static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		else {
 			conn->state = STATE_SCSI;
 			conn_read_pdu(conn);
-			tgt_event_modify(fd, EPOLLIN);
+			conn->tp->ep_event_modify(fd, EPOLLIN);
 		}
 		break;
 	case STATE_EXIT:
@@ -2040,7 +2042,7 @@ static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		break;
 	default:
 		conn_read_pdu(conn);
-		tgt_event_modify(fd, EPOLLIN);
+		conn->tp->ep_event_modify(fd, EPOLLIN);
 		break;
 	}
 }
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index ec34bb0..9660396 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -11,6 +11,7 @@ struct iscsi_transport {
 	void (*ep_write_end)(int ep);
 	size_t (*ep_close) (int ep);
 	int (*ep_show) (int ep, char *buf, int rest);
+	void (*ep_event_modify) (int ep, int events);
 };
 
 extern struct iscsi_transport iscsi_tcp;
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:09:20 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:09:20 -0400
Subject: [Stgt-devel] [PATCH 08/18] iser virtualize malloc
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904200920.GL6578@osc.edu>

Virtualize malloc and free when dealing with memory that the
transport will use.  It must be per-connection for RDMA.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |   14 ++++++++++++++
 usr/iscsi/iscsid.c    |    8 ++++----
 usr/iscsi/transport.h |    4 ++++
 3 files changed, 22 insertions(+), 4 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index c775594..0d189c7 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -241,6 +241,18 @@ void iscsi_event_modify(int fd, int events)
 		eprintf("tgt_event_modify failed\n");
 }
 
+void *iscsi_tcp_malloc(struct iscsi_connection *conn __attribute__((unused)),
+		       size_t sz)
+{
+	return malloc(sz);
+}
+
+void iscsi_tcp_free(struct iscsi_connection *conn __attribute__((unused)),
+		    void *buf)
+{
+	free(buf);
+}
+
 struct iscsi_transport iscsi_tcp = {
 	.name			= "iscsi",
 	.rdma			= 0,
@@ -251,4 +263,6 @@ struct iscsi_transport iscsi_tcp = {
 	.ep_close		= iscsi_tcp_close,
 	.ep_show		= iscsi_tcp_show,
 	.ep_event_modify	= iscsi_event_modify,
+	.ep_malloc		= iscsi_tcp_malloc,
+	.ep_free		= iscsi_tcp_free,
 };
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 85d4c95..2d96930 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -971,7 +971,7 @@ iscsi_alloc_task(struct iscsi_connection *conn, int ext_len)
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
 	struct iscsi_task *task;
 
-	task = malloc(sizeof(*task) + ext_len);
+	task = conn->tp->ep_malloc(conn, sizeof(*task) + ext_len);
 	if (!task)
 		return NULL;
 	memset(task, 0, sizeof(*task));
@@ -993,8 +993,8 @@ void iscsi_free_task(struct iscsi_task *task)
 	struct iscsi_connection *conn = task->conn;
 
 	if (task->addr && task->addr != (unsigned long) task->data)
-		free((void *) (unsigned long) task->addr);
-	free(task);
+		conn->tp->ep_free(conn, (void *) (unsigned long) task->addr);
+	conn->tp->ep_free(conn, task);
 	/* from alloc */
 	conn_put(conn);
 }
@@ -1133,7 +1133,7 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 			void *buf;
 
 			len = roundup(task->read_len, 4);
-			buf = malloc(len);
+			buf = conn->tp->ep_malloc(conn, len);
 			if (!buf)
 				return -ENOMEM;
 			scmd->bidi_uaddr = (unsigned long) buf;
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index 9660396..c37d0da 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -1,6 +1,8 @@
 #ifndef __TRANSPORT_H
 #define __TRANSPORT_H
 
+struct iscsi_connection;
+
 struct iscsi_transport {
 	const char *name;
 	int rdma;
@@ -12,6 +14,8 @@ struct iscsi_transport {
 	size_t (*ep_close) (int ep);
 	int (*ep_show) (int ep, char *buf, int rest);
 	void (*ep_event_modify) (int ep, int events);
+	void *(*ep_malloc) (struct iscsi_connection *conn, size_t sz);
+	void (*ep_free) (struct iscsi_connection *conn, void *buf);
 };
 
 extern struct iscsi_transport iscsi_tcp;
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:09:32 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:09:32 -0400
Subject: [Stgt-devel] [PATCH 09/18] iser event handler to tcp
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904200932.GM6578@osc.edu>

Move iscsi_event_handler to iscsi_tcp.c as it is TCP-specific.  RDMA will
have its own event handler.  Both will call into iscsi_tx_handler and
iscsi_rx_handler, which are now exported, along with iscsi_scsi_cmd_execute
that will be needed when an RDMA read collects all the write data.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |   23 ++++++++++++++++++++++-
 usr/iscsi/iscsid.c    |   25 +++----------------------
 usr/iscsi/iscsid.h    |    4 +++-
 3 files changed, 28 insertions(+), 24 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 0d189c7..7e0ab90 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -40,6 +40,8 @@
 #define LISTEN_MAX		4
 #define INCOMING_MAX		32
 
+static void iscsi_tcp_event_handler(int fd, int events, void *data);
+
 static int set_keepalive(int fd)
 {
 	int ret, opt;
@@ -97,7 +99,7 @@ static void accept_connection(int afd, int events, void *data)
 	conn_read_pdu(conn);
 	set_non_blocking(fd);
 
-	err = tgt_event_add(fd, EPOLLIN, iscsi_event_handler, conn);
+	err = tgt_event_add(fd, EPOLLIN, iscsi_tcp_event_handler, conn);
 	if (err)
 		goto free_conn;
 
@@ -109,6 +111,25 @@ out:
 	return;
 }
 
+static void iscsi_tcp_event_handler(int fd, int events, void *data)
+{
+	struct iscsi_connection *conn = (struct iscsi_connection *) data;
+
+	if (events & EPOLLIN)
+		iscsi_rx_handler(fd, conn);
+
+	if (conn->state == STATE_CLOSE)
+		dprintf("connection closed\n");
+
+	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
+		iscsi_tx_handler(fd, conn);
+
+	if (conn->state == STATE_CLOSE) {
+		conn_close(conn, fd);
+		dprintf("connection closed\n");
+	}
+}
+
 static int iscsi_tcp_init(void)
 {
 	struct addrinfo hints, *res, *res0;
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 2d96930..0701c69 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1155,7 +1155,7 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 	return target_cmd_queue(conn->session->target->tid, scmd);
 }
 
-static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
+int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
@@ -1750,7 +1750,7 @@ static int do_recv(int fd, struct iscsi_connection *conn, int next_state)
 	return ret;
 }
 
-static void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
+void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -1917,7 +1917,7 @@ again:
 	return 0;
 }
 
-static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
+void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -2047,25 +2047,6 @@ static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 	}
 }
 
-void iscsi_event_handler(int fd, int events, void *data)
-{
-	struct iscsi_connection *conn = (struct iscsi_connection *) data;
-
-	if (events & EPOLLIN)
-		iscsi_rx_handler(fd, conn);
-
-	if (conn->state == STATE_CLOSE)
-		dprintf("connection closed\n");
-
-	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
-		iscsi_tx_handler(fd, conn);
-
-	if (conn->state == STATE_CLOSE) {
-		conn_close(conn, fd);
-		dprintf("connection closed\n");
-	}
-}
-
 struct tgt_driver iscsi = {
 	.name			= "iscsi",
 	.use_kernel		= 0,
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 42b1b5c..d6bc0a9 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -260,10 +260,12 @@ extern int conn_take_fd(struct iscsi_connection *conn, int fd);
 extern void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_session *session);
 
 /* iscsid.c */
-extern void iscsi_event_handler(int fd, int events, void *data);
 extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
 extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
 extern void conn_read_pdu(struct iscsi_connection *conn);
+extern void iscsi_tx_handler(int fd, struct iscsi_connection *conn);
+extern void iscsi_rx_handler(int fd, struct iscsi_connection *conn);
+extern int iscsi_scsi_cmd_execute(struct iscsi_task *task);
 
 /* iscsid.c iscsi_task */
 extern void iscsi_free_task(struct iscsi_task *task);
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:09:46 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:09:46 -0400
Subject: [Stgt-devel] [PATCH 10/18] iser connection transport data
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904200946.GN6578@osc.edu>

Add a private data field to iscsi_connection to hold state for the
transport, and allocate room for it at connection allocation time.

Move the TCP socket fd from generic code into this private data region.

Also virtualize getsockname and getpeername as TCP and RDMA determine
those IP addresses differently.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/conn.c      |   21 +++++++-------
 usr/iscsi/iscsi_tcp.c |   72 ++++++++++++++++++++++++++++++++++++------------
 usr/iscsi/iscsid.c    |   60 ++++++++++++++++++++--------------------
 usr/iscsi/iscsid.h    |   14 +++++-----
 usr/iscsi/session.c   |    2 +-
 usr/iscsi/target.c    |   10 +++---
 usr/iscsi/transport.h |   20 +++++++++----
 7 files changed, 121 insertions(+), 78 deletions(-)

diff --git a/usr/iscsi/conn.c b/usr/iscsi/conn.c
index fcd2385..1e9dace 100644
--- a/usr/iscsi/conn.c
+++ b/usr/iscsi/conn.c
@@ -42,11 +42,11 @@ void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_session *se
 	list_add(&conn->clist, &session->conn_list);
 }
 
-struct iscsi_connection *conn_alloc(void)
+struct iscsi_connection *conn_alloc(unsigned int trans_len)
 {
 	struct iscsi_connection *conn;
 
-	conn = zalloc(sizeof(*conn));
+	conn = zalloc(sizeof(*conn) + trans_len);
 	if (!conn)
 		return NULL;
 
@@ -69,6 +69,9 @@ struct iscsi_connection *conn_alloc(void)
 	INIT_LIST_HEAD(&conn->clist);
 	INIT_LIST_HEAD(&conn->tx_clist);
 
+	if (trans_len)
+		conn->trans_data = &conn[1];
+
 	return conn;
 }
 
@@ -87,12 +90,11 @@ static void conn_free(struct iscsi_connection *conn)
 		session_put(session);
 }
 
-void conn_close(struct iscsi_connection *conn, int fd)
+void conn_close(struct iscsi_connection *conn)
 {
 	struct iscsi_task *task, *tmp;
 
-	tgt_event_del(fd);
-	conn->tp->ep_close(fd);
+	conn->tp->ep_close(conn);
 
 	dprintf("connection closed\n");
 
@@ -166,13 +168,10 @@ struct iscsi_connection *conn_find(struct iscsi_session *session, uint32_t cid)
 	return NULL;
 }
 
-int conn_take_fd(struct iscsi_connection *conn, int fd)
+int conn_take_fd(struct iscsi_connection *conn)
 {
-	uint64_t sid = sid64(conn->isid, conn->tsih);
-
-	dprintf("conn_take_fd: %d %u %u %u %" PRIx64 "\n",
-		  fd, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
+	dprintf("%u %u %u %" PRIx64 "\n", conn->cid, conn->stat_sn,
+		conn->exp_stat_sn, sid64(conn->isid, conn->tsih));
 	conn->session->conn_cnt++;
-
 	return 0;
 }
diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 7e0ab90..33cd6f8 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -42,6 +42,10 @@
 
 static void iscsi_tcp_event_handler(int fd, int events, void *data);
 
+struct tcp_conn_info {
+	int fd;
+};
+
 static int set_keepalive(int fd)
 {
 	int ret, opt;
@@ -74,6 +78,7 @@ static void accept_connection(int afd, int events, void *data)
 	struct sockaddr_storage from;
 	socklen_t namesize;
 	struct iscsi_connection *conn;
+	struct tcp_conn_info *tci;
 	int fd, err;
 
 	dprintf("%d\n", afd);
@@ -89,11 +94,12 @@ static void accept_connection(int afd, int events, void *data)
 	if (err)
 		goto out;
 
-	conn = conn_alloc();
+	conn = conn_alloc(sizeof(*tci));
 	if (!conn)
 		goto out;
 
-	conn->fd = fd;
+	tci = conn->trans_data;
+	tci->fd = fd;
 	conn->tp = &iscsi_tcp;
 
 	conn_read_pdu(conn);
@@ -116,16 +122,16 @@ static void iscsi_tcp_event_handler(int fd, int events, void *data)
 	struct iscsi_connection *conn = (struct iscsi_connection *) data;
 
 	if (events & EPOLLIN)
-		iscsi_rx_handler(fd, conn);
+		iscsi_rx_handler(conn);
 
 	if (conn->state == STATE_CLOSE)
 		dprintf("connection closed\n");
 
 	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
-		iscsi_tx_handler(fd, conn);
+		iscsi_tx_handler(conn);
 
 	if (conn->state == STATE_CLOSE) {
-		conn_close(conn, fd);
+		conn_close(conn);
 		dprintf("connection closed\n");
 	}
 }
@@ -204,38 +210,49 @@ static int iscsi_tcp_init(void)
 	return !nr_sock;
 }
 
-static size_t iscsi_tcp_read (int ep, void *buf, size_t nbytes)
+static size_t iscsi_tcp_read(struct iscsi_connection *conn, void *buf,
+			     size_t nbytes)
 {
-	return read(ep, buf, nbytes);
+	struct tcp_conn_info *tci = conn->trans_data;
+	return read(tci->fd, buf, nbytes);
 }
 
-static size_t iscsi_tcp_write_begin(int ep, void *buf, size_t nbytes)
+static size_t iscsi_tcp_write_begin(struct iscsi_connection *conn, void *buf,
+				    size_t nbytes)
 {
+	struct tcp_conn_info *tci = conn->trans_data;
 	int opt = 1;
-	setsockopt(ep, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
-	return write(ep, buf, nbytes);
+
+	setsockopt(tci->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+	return write(tci->fd, buf, nbytes);
 }
 
-static void iscsi_tcp_write_end(int ep)
+static void iscsi_tcp_write_end(struct iscsi_connection *conn)
 {
+	struct tcp_conn_info *tci = conn->trans_data;
 	int opt = 0;
-	setsockopt(ep, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+
+	setsockopt(tci->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
 }
 
-static size_t iscsi_tcp_close(int ep)
+static size_t iscsi_tcp_close(struct iscsi_connection *conn)
 {
-	return close(ep);
+	struct tcp_conn_info *tci = conn->trans_data;
+
+	tgt_event_del(tci->fd);
+	return close(tci->fd);
 }
 
-static int iscsi_tcp_show(int ep, char *buf, int rest)
+static int iscsi_tcp_show(struct iscsi_connection *conn, char *buf, int rest)
 {
+	struct tcp_conn_info *tci = conn->trans_data;
 	int err, total = 0;
 	socklen_t slen;
 	char dst[INET6_ADDRSTRLEN];
 	struct sockaddr_storage from;
 
 	slen = sizeof(from);
-	err = getpeername(ep, (struct sockaddr *) &from, &slen);
+	err = getpeername(tci->fd, (struct sockaddr *) &from, &slen);
 	if (err < 0) {
 		eprintf("%m\n");
 		return 0;
@@ -253,11 +270,12 @@ static int iscsi_tcp_show(int ep, char *buf, int rest)
 	return total > 0 ? total : 0;
 }
 
-void iscsi_event_modify(int fd, int events)
+void iscsi_event_modify(struct iscsi_connection *conn, int events)
 {
 	int ret;
+	struct tcp_conn_info *tci = conn->trans_data;
 
-	ret = tgt_event_modify(fd, events);
+	ret = tgt_event_modify(tci->fd, events);
 	if (ret)
 		eprintf("tgt_event_modify failed\n");
 }
@@ -274,6 +292,22 @@ void iscsi_tcp_free(struct iscsi_connection *conn __attribute__((unused)),
 	free(buf);
 }
 
+int iscsi_tcp_getsockname(struct iscsi_connection *conn, struct sockaddr *sa,
+			  socklen_t *len)
+{
+	struct tcp_conn_info *tci = conn->trans_data;
+
+	return getsockname(tci->fd, sa, len);
+}
+
+int iscsi_tcp_getpeername(struct iscsi_connection *conn, struct sockaddr *sa,
+			  socklen_t *len)
+{
+	struct tcp_conn_info *tci = conn->trans_data;
+
+	return getpeername(tci->fd, sa, len);
+}
+
 struct iscsi_transport iscsi_tcp = {
 	.name			= "iscsi",
 	.rdma			= 0,
@@ -286,4 +320,6 @@ struct iscsi_transport iscsi_tcp = {
 	.ep_event_modify	= iscsi_event_modify,
 	.ep_malloc		= iscsi_tcp_malloc,
 	.ep_free		= iscsi_tcp_free,
+	.ep_getsockname		= iscsi_tcp_getsockname,
+	.ep_getpeername		= iscsi_tcp_getpeername,
 };
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 0701c69..02906e8 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -435,7 +435,7 @@ static void login_start(struct iscsi_connection *conn)
 			return;
 		}
 
-		if (ip_acl(conn->tid, conn->fd)) {
+		if (ip_acl(conn->tid, conn)) {
 			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
 			rsp->status_detail = ISCSI_LOGIN_STATUS_TGT_NOT_FOUND;
 			conn->state = STATE_EXIT;
@@ -691,7 +691,8 @@ static void text_scan_text(struct iscsi_connection *conn)
 			blen = sizeof(buf);
 
 			slen = sizeof(ss);
-			getsockname(conn->fd, (struct sockaddr *) &ss, &slen);
+			conn->tp->ep_getsockname(conn, (struct sockaddr *) &ss,
+						 &slen);
 			if (ss.ss_family == AF_INET6) {
 				*p++ = '[';
 				blen--;
@@ -1041,7 +1042,7 @@ static int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *scmd)
 	}
 
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
-	task->conn->tp->ep_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+	task->conn->tp->ep_event_modify(task->conn, EPOLLIN | EPOLLOUT);
 
 	return 0;
 }
@@ -1165,13 +1166,13 @@ int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 	if (rw && task->r2t_count) {
 		if (!task->unsol_count) {
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
-			conn->tp->ep_event_modify(conn->fd, EPOLLIN | EPOLLOUT);
+			conn->tp->ep_event_modify(conn, EPOLLIN | EPOLLOUT);
 		}
 		return err;
 	}
 
 	task->offset = 0;  /* for use as transmit pointer for data-ins */
-	conn->tp->ep_event_modify(conn->fd, EPOLLIN);
+	conn->tp->ep_event_modify(conn, EPOLLIN);
 	err = iscsi_target_cmd_queue(task);
 	return err;
 }
@@ -1201,7 +1202,7 @@ static int iscsi_tm_done(struct mgmt_req *mreq)
 		break;
 	}
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
-	task->conn->tp->ep_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+	task->conn->tp->ep_event_modify(task->conn, EPOLLIN | EPOLLOUT);
 	return 0;
 }
 
@@ -1257,8 +1258,7 @@ static int iscsi_task_execute(struct iscsi_task *task)
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_LOGOUT:
 		list_add_tail(&task->c_list, &task->conn->tx_clist);
-		task->conn->tp->ep_event_modify(task->conn->fd,
-						EPOLLIN | EPOLLOUT);
+		task->conn->tp->ep_event_modify(task->conn, EPOLLIN | EPOLLOUT);
 		break;
 	case ISCSI_OP_SCSI_CMD:
 		/* convenient directionality for our internal use */
@@ -1278,7 +1278,7 @@ static int iscsi_task_execute(struct iscsi_task *task)
 		err = iscsi_tm_execute(task);
 		if (err) {
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
-			task->conn->tp->ep_event_modify(task->conn->fd,
+			task->conn->tp->ep_event_modify(task->conn,
 							EPOLLIN | EPOLLOUT);
 		}
 		break;
@@ -1723,15 +1723,15 @@ static int iscsi_task_tx_start(struct iscsi_connection *conn)
 
 nodata:
 	dprintf("no more data\n");
-	conn->tp->ep_event_modify(conn->fd, EPOLLIN);
+	conn->tp->ep_event_modify(conn, EPOLLIN);
 	return -EAGAIN;
 }
 
-static int do_recv(int fd, struct iscsi_connection *conn, int next_state)
+static int do_recv(struct iscsi_connection *conn, int next_state)
 {
 	int ret;
 
-	ret = conn->tp->ep_read(fd, conn->rx_buffer, conn->rx_size);
+	ret = conn->tp->ep_read(conn, conn->rx_buffer, conn->rx_size);
 	if (!ret) {
 		conn->state = STATE_CLOSE;
 		return 0;
@@ -1750,7 +1750,7 @@ static int do_recv(int fd, struct iscsi_connection *conn, int next_state)
 	return ret;
 }
 
-void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
+void iscsi_rx_handler(struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -1764,7 +1764,7 @@ void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
 again:
 	switch (conn->rx_iostate) {
 	case IOSTATE_RX_BHS:
-		ret = do_recv(fd, conn, IOSTATE_RX_INIT_AHS);
+		ret = do_recv(conn, IOSTATE_RX_INIT_AHS);
 		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_AHS)
 			break;
 	case IOSTATE_RX_INIT_AHS:
@@ -1801,7 +1801,7 @@ again:
 		else if (conn->rx_iostate != IOSTATE_RX_AHS)
 			break;
 	case IOSTATE_RX_AHS:
-		ret = do_recv(fd, conn, hdigest ?
+		ret = do_recv(conn, hdigest ?
 			      IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA);
 		if (ret <= 0)
 			break;
@@ -1814,7 +1814,7 @@ again:
 		conn->rx_size = sizeof(conn->rx_digest);
 		conn->rx_iostate = IOSTATE_RX_HDIGEST;
 	case IOSTATE_RX_HDIGEST:
-		ret = do_recv(fd, conn, IOSTATE_RX_CHECK_HDIGEST);
+		ret = do_recv(conn, IOSTATE_RX_CHECK_HDIGEST);
 		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_CHECK_HDIGEST)
 			break;
 	case IOSTATE_RX_CHECK_HDIGEST:
@@ -1840,7 +1840,7 @@ again:
 			break;
 		}
 	case IOSTATE_RX_DATA:
-		ret = do_recv(fd, conn, ddigest ?
+		ret = do_recv(conn, ddigest ?
 			      IOSTATE_RX_INIT_DDIGEST : IOSTATE_RX_END);
 		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_DDIGEST)
 			break;
@@ -1849,7 +1849,7 @@ again:
 		conn->rx_size = sizeof(conn->rx_digest);
 		conn->rx_iostate = IOSTATE_RX_DDIGEST;
 	case IOSTATE_RX_DDIGEST:
-		ret = do_recv(fd, conn, IOSTATE_RX_CHECK_DDIGEST);
+		ret = do_recv(conn, IOSTATE_RX_CHECK_DDIGEST);
 		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_CHECK_DDIGEST)
 			break;
 	case IOSTATE_RX_CHECK_DDIGEST:
@@ -1887,18 +1887,18 @@ again:
 			conn_read_pdu(conn);
 	} else {
 		conn_write_pdu(conn);
-		conn->tp->ep_event_modify(fd, EPOLLOUT);
+		conn->tp->ep_event_modify(conn, EPOLLOUT);
 		ret = cmnd_execute(conn);
 		if (ret)
 			conn->state = STATE_CLOSE;
 	}
 }
 
-static int do_send(int fd, struct iscsi_connection *conn, int next_state)
+static int do_send(struct iscsi_connection *conn, int next_state)
 {
 	int ret;
 again:
-	ret = conn->tp->ep_write_begin(fd, conn->tx_buffer, conn->tx_size);
+	ret = conn->tp->ep_write_begin(conn, conn->tx_buffer, conn->tx_size);
 	if (ret < 0) {
 		if (errno != EINTR && errno != EAGAIN)
 			conn->state = STATE_CLOSE;
@@ -1917,7 +1917,7 @@ again:
 	return 0;
 }
 
-void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
+void iscsi_tx_handler(struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -1937,7 +1937,7 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 
 	switch (conn->tx_iostate) {
 	case IOSTATE_TX_BHS:
-		ret = do_send(fd, conn, IOSTATE_TX_INIT_AHS);
+		ret = do_send(conn, IOSTATE_TX_INIT_AHS);
 		if (ret < 0)
 			break;
 	case IOSTATE_TX_INIT_AHS:
@@ -1966,7 +1966,7 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		conn->tx_buffer = conn->tx_digest;
 		conn->tx_size = sizeof(conn->tx_digest);
 	case IOSTATE_TX_HDIGEST:
-		ret = do_send(fd, conn, IOSTATE_TX_INIT_DATA);
+		ret = do_send(conn, IOSTATE_TX_INIT_DATA);
 		if (ret < 0)
 			break;
 	case IOSTATE_TX_INIT_DATA:
@@ -1987,7 +1987,7 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		if (conn->tx_iostate != IOSTATE_TX_DATA)
 			break;
 	case IOSTATE_TX_DATA:
-		ret = do_send(fd, conn, ddigest ?
+		ret = do_send(conn, ddigest ?
 			      IOSTATE_TX_INIT_DDIGEST : IOSTATE_TX_END);
 		if (ret < 0)
 			return;
@@ -2002,7 +2002,7 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		conn->tx_buffer = conn->tx_digest;
 		conn->tx_size = sizeof(conn->tx_digest);
 	case IOSTATE_TX_DDIGEST:
-		ret = do_send(fd, conn, IOSTATE_TX_END);
+		ret = do_send(conn, IOSTATE_TX_END);
 		break;
 	default:
 		eprintf("error %d %d\n", conn->state, conn->tx_iostate);
@@ -2020,18 +2020,18 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		exit(1);
 	}
 
-	conn->tp->ep_write_end(fd);
+	conn->tp->ep_write_end(conn);
 	cmnd_finish(conn);
 
 	switch (conn->state) {
 	case STATE_KERNEL:
-		ret = conn_take_fd(conn, fd);
+		ret = conn_take_fd(conn);
 		if (ret)
 			conn->state = STATE_CLOSE;
 		else {
 			conn->state = STATE_SCSI;
 			conn_read_pdu(conn);
-			conn->tp->ep_event_modify(fd, EPOLLIN);
+			conn->tp->ep_event_modify(conn, EPOLLIN);
 		}
 		break;
 	case STATE_EXIT:
@@ -2042,7 +2042,7 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		break;
 	default:
 		conn_read_pdu(conn);
-		conn->tp->ep_event_modify(fd, EPOLLIN);
+		conn->tp->ep_event_modify(conn, EPOLLIN);
 		break;
 	}
 }
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index d6bc0a9..109461f 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -134,7 +134,6 @@ struct iscsi_connection {
 	int state;
 	int rx_iostate;
 	int tx_iostate;
-	int fd;
 	int refcount;
 
 	struct list_head clist;
@@ -186,6 +185,7 @@ struct iscsi_connection {
 	} auth;
 
 	struct iscsi_transport *tp;
+	void *trans_data;   /* transport specific data */
 };
 
 #define STATE_FREE		0
@@ -251,20 +251,20 @@ extern struct list_head iscsi_targets_list;
 extern int cmnd_exec_auth_chap(struct iscsi_connection *conn);
 
 /* conn.c */
-extern struct iscsi_connection *conn_alloc(void);
-extern void conn_close(struct iscsi_connection *conn, int fd);
+extern struct iscsi_connection *conn_alloc(unsigned int trans_len);
+extern void conn_close(struct iscsi_connection *conn);
 extern void conn_put(struct iscsi_connection *conn);
 extern int conn_get(struct iscsi_connection *conn);
 extern struct iscsi_connection * conn_find(struct iscsi_session *session, uint32_t cid);
-extern int conn_take_fd(struct iscsi_connection *conn, int fd);
+extern int conn_take_fd(struct iscsi_connection *conn);
 extern void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_session *session);
 
 /* iscsid.c */
 extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
 extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
 extern void conn_read_pdu(struct iscsi_connection *conn);
-extern void iscsi_tx_handler(int fd, struct iscsi_connection *conn);
-extern void iscsi_rx_handler(int fd, struct iscsi_connection *conn);
+extern void iscsi_tx_handler(struct iscsi_connection *conn);
+extern void iscsi_rx_handler(struct iscsi_connection *conn);
 extern int iscsi_scsi_cmd_execute(struct iscsi_task *task);
 
 /* iscsid.c iscsi_task */
@@ -280,7 +280,7 @@ extern void session_put(struct iscsi_session *session);
 struct iscsi_target * target_find_by_name(const char *name);
 struct iscsi_target * target_find_by_id(int tid);
 extern void target_list_build(struct iscsi_connection *, char *, char *);
-extern int ip_acl(int tid, int fd);
+extern int ip_acl(int tid, struct iscsi_connection *conn);
 extern int iscsi_target_create(struct target *);
 extern void iscsi_target_destroy(int);
 extern int iscsi_target_show(int mode, int tid, uint64_t sid, uint32_t cid,
diff --git a/usr/iscsi/session.c b/usr/iscsi/session.c
index dfb94d0..3b1650d 100644
--- a/usr/iscsi/session.c
+++ b/usr/iscsi/session.c
@@ -103,7 +103,7 @@ int session_create(struct iscsi_connection *conn)
 	}
 
 	memset(addr, 0, sizeof(addr));
-	conn->tp->ep_show(conn->fd, addr, sizeof(addr));
+	conn->tp->ep_show(conn, addr, sizeof(addr));
 
 	snprintf(session->info, 1024, _TAB3 "Initiator: %s\n"
 		 _TAB3 "Connection: %u\n"
diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
index 53d8164..3ddb2d7 100644
--- a/usr/iscsi/target.c
+++ b/usr/iscsi/target.c
@@ -115,7 +115,7 @@ static int address_match(struct sockaddr *sa1, struct sockaddr *sa2)
 	return 0;
 }
 
-static int ip_match(int fd, char *address)
+static int ip_match(struct iscsi_connection *conn, char *address)
 {
 	struct sockaddr_storage from;
 	struct addrinfo hints, *res;
@@ -124,7 +124,7 @@ static int ip_match(int fd, char *address)
 	int err;
 
 	len = sizeof(from);
-	err = getpeername(fd, (struct sockaddr *) &from, &len);
+	err = conn->tp->ep_getpeername(conn, (struct sockaddr *) &from, &len);
 	if (err < 0)
 		return -EPERM;
 
@@ -173,7 +173,7 @@ out:
 	return err;
 }
 
-int ip_acl(int tid, int fd)
+int ip_acl(int tid, struct iscsi_connection *conn)
 {
 	int idx, err;
 	char *addr;
@@ -183,7 +183,7 @@ int ip_acl(int tid, int fd)
 		if (!addr)
 			break;
 
-		err = ip_match(fd, addr);
+		err = ip_match(conn, addr);
 		if (!err)
 			return 0;
 	}
@@ -198,7 +198,7 @@ void target_list_build(struct iscsi_connection *conn, char *addr, char *name)
 		if (name && strcmp(tgt_targetname(target->tid), name))
 			continue;
 
-		if (ip_acl(target->tid, conn->fd))
+		if (ip_acl(target->tid, conn))
 			continue;
 
 		if (isns_scn_access(target->tid, conn->initiator))
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index c37d0da..c1e9dc1 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -1,6 +1,8 @@
 #ifndef __TRANSPORT_H
 #define __TRANSPORT_H
 
+#include <sys/socket.h>
+
 struct iscsi_connection;
 
 struct iscsi_transport {
@@ -8,14 +10,20 @@ struct iscsi_transport {
 	int rdma;
 
 	int (*ep_init) (void);
-	size_t (*ep_read) (int ep, void *buf, size_t nbytes);
-	size_t (*ep_write_begin) (int ep, void *buf, size_t nbytes);
-	void (*ep_write_end)(int ep);
-	size_t (*ep_close) (int ep);
-	int (*ep_show) (int ep, char *buf, int rest);
-	void (*ep_event_modify) (int ep, int events);
+	size_t (*ep_read) (struct iscsi_connection *conn, void *buf,
+			   size_t nbytes);
+	size_t (*ep_write_begin) (struct iscsi_connection *conn, void *buf,
+				  size_t nbytes);
+	void (*ep_write_end) (struct iscsi_connection *conn);
+	size_t (*ep_close) (struct iscsi_connection *conn);
+	int (*ep_show) (struct iscsi_connection *conn, char *buf, int rest);
+	void (*ep_event_modify) (struct iscsi_connection *conn, int events);
 	void *(*ep_malloc) (struct iscsi_connection *conn, size_t sz);
 	void (*ep_free) (struct iscsi_connection *conn, void *buf);
+	int (*ep_getsockname) (struct iscsi_connection *conn,
+			       struct sockaddr *sa, socklen_t *len);
+	int (*ep_getpeername) (struct iscsi_connection *conn,
+			       struct sockaddr *sa, socklen_t *len);
 };
 
 extern struct iscsi_transport iscsi_tcp;
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:09:55 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:09:55 -0400
Subject: [Stgt-devel] [PATCH 11/18] iser connection init
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904200955.GO6578@osc.edu>

After successful negotiation, call into the transport to allocate resources
or otherwise ready the switch to full feature mode.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |    6 ++++++
 usr/iscsi/iscsid.c    |   19 ++++++++++++++++++-
 usr/iscsi/transport.h |    1 +
 3 files changed, 25 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 33cd6f8..566dd9e 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -210,6 +210,11 @@ static int iscsi_tcp_init(void)
 	return !nr_sock;
 }
 
+static int iscsi_tcp_conn_init(struct iscsi_connection *conn)
+{
+	return 0;
+}
+
 static size_t iscsi_tcp_read(struct iscsi_connection *conn, void *buf,
 			     size_t nbytes)
 {
@@ -312,6 +317,7 @@ struct iscsi_transport iscsi_tcp = {
 	.name			= "iscsi",
 	.rdma			= 0,
 	.ep_init		= iscsi_tcp_init,
+	.ep_conn_init		= iscsi_tcp_conn_init,
 	.ep_read		= iscsi_tcp_read,
 	.ep_write_begin		= iscsi_tcp_write_begin,
 	.ep_write_end		= iscsi_tcp_write_end,
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 02906e8..e3cb8e1 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -469,12 +469,26 @@ static void login_start(struct iscsi_connection *conn)
 
 static void login_finish(struct iscsi_connection *conn)
 {
+	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *) &conn->rsp.bhs;
+	int ret;
+
 	switch (conn->session_type) {
 	case SESSION_NORMAL:
 		if (!conn->mxdsl_negotiated)
 			/* use spec default if he did not mention MRDSL */
 			conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val =
 				session_keys[ISCSI_PARAM_MAX_XMIT_DLENGTH].def;
+		/*
+		 * Allocate transport resources for this connection.
+		 */
+		ret = conn->tp->ep_conn_init(conn);
+		if (ret) {
+			rsp->flags = 0;
+			rsp->status_class = ISCSI_STATUS_CLS_TARGET_ERR;
+			rsp->status_detail = ISCSI_LOGIN_STATUS_NO_RESOURCES;
+			conn->state = STATE_EXIT;
+			break;
+		}
 		if (!conn->session)
 			session_create(conn);
 		memcpy(conn->isid, conn->session->isid, sizeof(conn->isid));
@@ -641,8 +655,11 @@ static void cmnd_exec_login(struct iscsi_connection *conn)
 			default:
 				goto init_err;
 			}
-			if (!stay && !nsg_disagree)
+			if (!stay && !nsg_disagree) {
 				login_finish(conn);
+				if (rsp->status_class)
+					return;
+			}
 			break;
 		default:
 			goto init_err;
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index c1e9dc1..3421371 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -10,6 +10,7 @@ struct iscsi_transport {
 	int rdma;
 
 	int (*ep_init) (void);
+	int (*ep_conn_init) (struct iscsi_connection *conn);
 	size_t (*ep_read) (struct iscsi_connection *conn, void *buf,
 			   size_t nbytes);
 	size_t (*ep_write_begin) (struct iscsi_connection *conn, void *buf,
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:10:34 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:10:34 -0400
Subject: [Stgt-devel] [PATCH 12/18] iser task transport data
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904201034.GP6578@osc.edu>

RDMA will need to store some per-task data to use initiator-provided
tags in later RDMA operations.  Provide some space for this and hook
into the transport at task initialization time.

Signed-off-by: Erez Zilber <erezz at voltaire.com>
Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |    6 ++++++
 usr/iscsi/iscsid.c    |   15 ++++++++++++---
 usr/iscsi/iscsid.h    |    8 ++++----
 usr/iscsi/transport.h |    3 +++
 4 files changed, 25 insertions(+), 7 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 566dd9e..53cf0e5 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -215,6 +215,10 @@ static int iscsi_tcp_conn_init(struct iscsi_connection *conn)
 	return 0;
 }
 
+static void iscsi_tcp_task_init(struct iscsi_task *task)
+{
+}
+
 static size_t iscsi_tcp_read(struct iscsi_connection *conn, void *buf,
 			     size_t nbytes)
 {
@@ -316,8 +320,10 @@ int iscsi_tcp_getpeername(struct iscsi_connection *conn, struct sockaddr *sa,
 struct iscsi_transport iscsi_tcp = {
 	.name			= "iscsi",
 	.rdma			= 0,
+	.task_trans_len		= 0,
 	.ep_init		= iscsi_tcp_init,
 	.ep_conn_init		= iscsi_tcp_conn_init,
+	.ep_task_init		= iscsi_tcp_task_init,
 	.ep_read		= iscsi_tcp_read,
 	.ep_write_begin		= iscsi_tcp_write_begin,
 	.ep_write_end		= iscsi_tcp_write_end,
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index e3cb8e1..bf613f4 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -989,18 +989,25 @@ iscsi_alloc_task(struct iscsi_connection *conn, int ext_len)
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
 	struct iscsi_task *task;
 
-	task = conn->tp->ep_malloc(conn, sizeof(*task) + ext_len);
+	task = conn->tp->ep_malloc(conn, sizeof(*task) +
+				   conn->tp->task_trans_len + ext_len);
 	if (!task)
 		return NULL;
-	memset(task, 0, sizeof(*task));
+	memset(task, 0, sizeof(*task) + conn->tp->task_trans_len);
 
 	memcpy(&task->req, req, sizeof(*req));
 	task->conn = conn;
 	INIT_LIST_HEAD(&task->c_hlist);
 	INIT_LIST_HEAD(&task->c_list);
 
-	if (ext_len)
+	if (conn->tp->task_trans_len)
+		task->trans_data = (void *) &task[1];
+
+	if (ext_len) {
+		task->extdata = (void *)((uintptr_t) &task[1] +
+				      conn->tp->task_trans_len);
 		task->data = task->extdata;
+	}
 
 	conn_get(conn);
 	return task;
@@ -1434,6 +1441,8 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 
 	task->tag = req->itt;
 
+	conn->tp->ep_task_init(task);
+
 	if (ahs_len) {
 		task->ahs = task->data + sizeof(req->cdb);
 		task->data = task->ahs + ahs_len;
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 109461f..8ef141a 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -122,12 +122,12 @@ struct iscsi_task {
 	int unsol_count;
 	int exp_r2tsn;
 
-	void *ahs;
-	void *data;
-
 	struct scsi_cmd scmd;
 
-	unsigned long extdata[0];
+	void *trans_data;   /* transport specific data */
+	void *extdata;      /* extra data, after transport, incl ahs and data */
+	void *ahs;
+	void *data;
 };
 
 struct iscsi_connection {
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index 3421371..a8b8680 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -4,13 +4,16 @@
 #include <sys/socket.h>
 
 struct iscsi_connection;
+struct iscsi_task;
 
 struct iscsi_transport {
 	const char *name;
 	int rdma;
+	int task_trans_len;
 
 	int (*ep_init) (void);
 	int (*ep_conn_init) (struct iscsi_connection *conn);
+	void (*ep_task_init) (struct iscsi_task *task);
 	size_t (*ep_read) (struct iscsi_connection *conn, void *buf,
 			   size_t nbytes);
 	size_t (*ep_write_begin) (struct iscsi_connection *conn, void *buf,
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:10:49 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:10:49 -0400
Subject: [Stgt-devel] [PATCH 13/18] iser close free
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904201049.GQ6578@osc.edu>

Separate transport close operation from the free operation, as RDMA will
initiate a close, but must not free resources until all references to
the connection have gone away.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/conn.c      |    3 ++-
 usr/iscsi/iscsi_tcp.c |   12 +++++++++---
 usr/iscsi/transport.h |    3 ++-
 3 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/usr/iscsi/conn.c b/usr/iscsi/conn.c
index 1e9dace..9b0c3b9 100644
--- a/usr/iscsi/conn.c
+++ b/usr/iscsi/conn.c
@@ -80,6 +80,7 @@ static void conn_free(struct iscsi_connection *conn)
 	struct iscsi_session *session = conn->session;
 
 	dprintf("freeing connection\n");
+	conn->tp->ep_conn_free(conn);
 	list_del(&conn->clist);
 	free(conn->req_buffer);
 	free(conn->rsp_buffer);
@@ -94,7 +95,7 @@ void conn_close(struct iscsi_connection *conn)
 {
 	struct iscsi_task *task, *tmp;
 
-	conn->tp->ep_close(conn);
+	conn->tp->ep_conn_close(conn);
 
 	dprintf("connection closed\n");
 
diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 53cf0e5..f03caa5 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -244,12 +244,17 @@ static void iscsi_tcp_write_end(struct iscsi_connection *conn)
 	setsockopt(tci->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
 }
 
-static size_t iscsi_tcp_close(struct iscsi_connection *conn)
+static void iscsi_tcp_conn_close(struct iscsi_connection *conn)
 {
 	struct tcp_conn_info *tci = conn->trans_data;
 
 	tgt_event_del(tci->fd);
-	return close(tci->fd);
+	close(tci->fd);
+}
+
+static void iscsi_tcp_conn_free(struct iscsi_connection *conn
+				__attribute__((unused)))
+{
 }
 
 static int iscsi_tcp_show(struct iscsi_connection *conn, char *buf, int rest)
@@ -327,7 +332,8 @@ struct iscsi_transport iscsi_tcp = {
 	.ep_read		= iscsi_tcp_read,
 	.ep_write_begin		= iscsi_tcp_write_begin,
 	.ep_write_end		= iscsi_tcp_write_end,
-	.ep_close		= iscsi_tcp_close,
+	.ep_conn_close		= iscsi_tcp_conn_close,
+	.ep_conn_free		= iscsi_tcp_conn_free,
 	.ep_show		= iscsi_tcp_show,
 	.ep_event_modify	= iscsi_event_modify,
 	.ep_malloc		= iscsi_tcp_malloc,
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index a8b8680..f35d9d7 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -19,7 +19,8 @@ struct iscsi_transport {
 	size_t (*ep_write_begin) (struct iscsi_connection *conn, void *buf,
 				  size_t nbytes);
 	void (*ep_write_end) (struct iscsi_connection *conn);
-	size_t (*ep_close) (struct iscsi_connection *conn);
+	void (*ep_conn_close) (struct iscsi_connection *conn);
+	void (*ep_conn_free) (struct iscsi_connection *conn);
 	int (*ep_show) (struct iscsi_connection *conn, char *buf, int rest);
 	void (*ep_event_modify) (struct iscsi_connection *conn, int events);
 	void *(*ep_malloc) (struct iscsi_connection *conn, size_t sz);
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:11:03 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:11:03 -0400
Subject: [Stgt-devel] [PATCH 14/18] iser transport mxdsl
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904201103.GR6578@osc.edu>

The RDMA transport chooses the size for data-in and data-out
transfers, as these operations are not visible to the initiator.
MaxXmitDataSegmentLength applies only to control-type PDUs, not
to RDMA data transfers.  Add a per-connection parameter to hold
the data transfer size chosen by the transport, with the proper
default for TCP.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/conn.c   |    2 ++
 usr/iscsi/iscsid.c |   17 +++++++++++------
 usr/iscsi/iscsid.h |    1 +
 3 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/usr/iscsi/conn.c b/usr/iscsi/conn.c
index 9b0c3b9..b1d3937 100644
--- a/usr/iscsi/conn.c
+++ b/usr/iscsi/conn.c
@@ -65,6 +65,8 @@ struct iscsi_connection *conn_alloc(unsigned int trans_len)
 	conn->refcount = 1;
 	conn->state = STATE_FREE;
 	param_set_defaults(conn->session_param, session_keys);
+	conn->data_inout_max_size =
+		conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
 
 	INIT_LIST_HEAD(&conn->clist);
 	INIT_LIST_HEAD(&conn->tx_clist);
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index bf613f4..f72073b 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -478,6 +478,11 @@ static void login_finish(struct iscsi_connection *conn)
 			/* use spec default if he did not mention MRDSL */
 			conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val =
 				session_keys[ISCSI_PARAM_MAX_XMIT_DLENGTH].def;
+
+		/* update based on negotiations (but conn_init can override) */
+		conn->data_inout_max_size =
+			conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
+
 		/*
 		 * Allocate transport resources for this connection.
 		 */
@@ -920,7 +925,6 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
 	int datalen;
-	int max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
@@ -933,9 +937,10 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 	datalen = min_t(uint32_t, task->read_len, task->len);
 	datalen -= task->offset;
 
-	dprintf("%d %d %d %d %x\n", datalen, task->read_len, task->len, max_burst, rsp->itt);
+	dprintf("%d %d %d %d %x\n", datalen, task->read_len, task->len,
+		conn->data_inout_max_size, rsp->itt);
 
-	if (datalen <= max_burst) {
+	if (datalen <= conn->data_inout_max_size) {
 		rsp->flags = ISCSI_FLAG_CMD_FINAL;
 
 		/* collapse status into final packet if successful */
@@ -946,7 +951,7 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 			calc_residual((struct iscsi_cmd_rsp *) rsp, task);
 		}
 	} else
-		datalen = max_burst;
+		datalen = conn->data_inout_max_size;
 
 	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
 	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
@@ -965,7 +970,7 @@ static int iscsi_r2t_build(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_r2t_rsp *rsp = (struct iscsi_r2t_rsp *) &conn->rsp.bhs;
-	int length, max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
+	int length;
 
 	memset(rsp, 0, sizeof(*rsp));
 
@@ -977,7 +982,7 @@ static int iscsi_r2t_build(struct iscsi_task *task)
 	rsp->r2tsn = cpu_to_be32(task->exp_r2tsn++);
 	rsp->data_offset = cpu_to_be32(task->offset);
 	rsp->ttt = (unsigned long) task;
-	length = min(task->r2t_count, max_burst);
+	length = min(task->r2t_count, conn->data_inout_max_size);
 	rsp->data_length = cpu_to_be32(length);
 
 	return 0;
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 8ef141a..99b8448 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -142,6 +142,7 @@ struct iscsi_connection {
 	int tid;
 	struct param session_param[ISCSI_PARAM_MAX];
 	int mxdsl_negotiated;
+	int data_inout_max_size;
 
 	char *initiator;
 	uint8_t isid[6];
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:11:13 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:11:13 -0400
Subject: [Stgt-devel] [PATCH 15/18] iser rounding
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904201113.GS6578@osc.edu>

RDMA data packets are not padded up to 4 byte boundaries, unlike TCP.
Reasons for this can be found in doc/README.iser.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |   24 +++++++++++++++++-------
 1 files changed, 17 insertions(+), 7 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index f72073b..05ca46b 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1162,7 +1162,9 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 			uint32_t len;
 			void *buf;
 
-			len = roundup(task->read_len, 4);
+			len = task->read_len;
+			if (!conn->tp->rdma)
+				len = roundup(len, 4);
 			buf = conn->tp->ep_malloc(conn, len);
 			if (!buf)
 				return -ENOMEM;
@@ -1428,8 +1430,12 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 	int ahs_len, imm_len, data_len, task_len;
 
 	ahs_len = roundup(req->hlength * 4, 4);
-	imm_len = roundup(ntoh24(req->dlength), 4);
-	data_len = roundup(ntohl(req->data_length), 4);
+	imm_len = ntoh24(req->dlength);
+	data_len = ntohl(req->data_length);
+	if (!conn->tp->rdma) {
+		imm_len = roundup(imm_len, 4);
+		data_len = roundup(data_len, 4);
+	}
 
 	dprintf("%u %x %d %d %d %x %x\n", conn->session->tsih,
 		req->cdb[0], ahs_len, imm_len, data_len,
@@ -1813,7 +1819,7 @@ again:
 		}
 		conn->req.ahssize = conn->req.bhs.hlength * 4;
 		conn->req.datasize = ntoh24(conn->req.bhs.dlength);
-		conn->rx_size = roundup(conn->req.ahssize, 4);
+		conn->rx_size = conn->req.ahssize;
 		if (conn->rx_size) {
 			conn->rx_buffer = conn->req.ahs;
 			conn->rx_iostate = IOSTATE_RX_AHS;
@@ -1862,7 +1868,10 @@ again:
 		}
 		conn->rx_iostate = IOSTATE_RX_INIT_DATA;
 	case IOSTATE_RX_INIT_DATA:
-		conn->rx_size = roundup(conn->req.datasize, 4);
+		if (conn->tp->rdma)
+			conn->rx_size = conn->req.datasize;
+		else
+			conn->rx_size = roundup(conn->req.datasize, 4);
 		if (conn->rx_size) {
 			conn->rx_iostate = IOSTATE_RX_DATA;
 			conn->rx_buffer = conn->req.data;
@@ -2002,12 +2011,13 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 			break;
 	case IOSTATE_TX_INIT_DATA:
 		if (conn->rsp.datasize) {
-			int pad;
+			int pad = 0;
 
 			conn->tx_iostate = IOSTATE_TX_DATA;
 			conn->tx_buffer = conn->rsp.data;
 			conn->tx_size = conn->rsp.datasize;
-			pad = conn->tx_size & (PAD_WORD_LEN - 1);
+			if (!conn->tp->rdma)
+				pad = conn->tx_size & (PAD_WORD_LEN - 1);
 			if (pad) {
 				pad = PAD_WORD_LEN - pad;
 				memset(conn->tx_buffer + conn->tx_size, 0, pad);
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:11:26 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:11:26 -0400
Subject: [Stgt-devel] [PATCH 16/18] iser params
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904201126.GT6578@osc.edu>

Add iSCSI parameters as defined in the draft iSER specification.
Handle special parameter cases for RDMA:

    - no digests
    - do not offer iSER parameters unless initiator requests them
    - do not offer MRDSL (use [IT]RDSL instead)

Except do not advertise MaxOutstandingUnexpectedPDUs just yet, as
the open-iscsi initiatior does not understand it.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_if.h |    5 +++++
 usr/iscsi/iscsid.c   |   21 ++++++++++++++++++++-
 usr/iscsi/param.c    |   38 ++++++++++++++++++++++++++++++++++++++
 usr/iscsi/target.c   |    8 ++++++++
 4 files changed, 71 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/iscsi_if.h b/usr/iscsi/iscsi_if.h
index 58a76a2..b4f1e04 100644
--- a/usr/iscsi/iscsi_if.h
+++ b/usr/iscsi/iscsi_if.h
@@ -215,6 +215,11 @@ enum iscsi_param {
 	ISCSI_PARAM_OFMARKINT,
 	ISCSI_PARAM_IFMARKINT,
 	ISCSI_PARAM_MAXCONNECTIONS,
+	/* iSER draft */
+	ISCSI_PARAM_RDMA_EXTENSIONS,
+	ISCSI_PARAM_TARGET_RDSL,
+	ISCSI_PARAM_INITIATOR_RDSL,
+	ISCSI_PARAM_MAX_OUTST_PDU,
 	/* must always be last */
 	ISCSI_PARAM_MAX,
 };
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 05ca46b..fd9f8f2 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -270,7 +270,7 @@ static void login_security_done(struct iscsi_connection *conn)
 static void text_scan_login(struct iscsi_connection *conn)
 {
 	char *key, *value, *data;
-	int datasize, idx;
+	int datasize, idx, is_rdma = 0;
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
 
 	data = conn->req.data;
@@ -291,6 +291,9 @@ static void text_scan_login(struct iscsi_connection *conn)
 				conn->mxdsl_negotiated = 1;
 			}
 
+			if (idx == ISCSI_PARAM_RDMA_EXTENSIONS)
+				is_rdma = 1;
+
 			if (param_str_to_val(session_keys, idx, value, &val) < 0) {
 				if (conn->session_param[idx].state
 				    == KEY_STATE_START) {
@@ -337,6 +340,15 @@ static void text_scan_login(struct iscsi_connection *conn)
 			text_key_add(conn, key, "NotUnderstood");
 	}
 
+	if (is_rdma) {
+		/* do not try to do digests, not supported in iser */
+		conn->session_param[ISCSI_PARAM_HDRDGST_EN].val = DIGEST_NONE;
+		conn->session_param[ISCSI_PARAM_DATADGST_EN].val = DIGEST_NONE;
+	} else {
+		/* do not offer RDMA, initiator must explicitly request */
+		conn->session_param[ISCSI_PARAM_RDMA_EXTENSIONS].val = 0;
+	}
+
 out:
 	return;
 }
@@ -354,6 +366,13 @@ static int text_check_param(struct iscsi_connection *conn)
 					p[i].state = KEY_STATE_DONE;
 					continue;
 				}
+				if (p[ISCSI_PARAM_RDMA_EXTENSIONS].val == 1) {
+					if (i == ISCSI_PARAM_MAX_RECV_DLENGTH)
+						continue;
+				} else {
+					if (i >= ISCSI_PARAM_RDMA_EXTENSIONS)
+						continue;
+				}
 				memset(buf, 0, sizeof(buf));
 				param_val_to_str(session_keys, i, p[i].val,
 						 buf);
diff --git a/usr/iscsi/param.c b/usr/iscsi/param.c
index 9eac62c..76236d1 100644
--- a/usr/iscsi/param.c
+++ b/usr/iscsi/param.c
@@ -118,6 +118,18 @@ static int minimum_check_val(struct iscsi_key *key, unsigned int *val)
 	return 0;
 }
 
+static int min_or_zero_check_val(struct iscsi_key *key, unsigned int *val)
+{
+	int err = 0;
+
+	if (*val != 0 && (*val < key->min || key->max < *val)) {
+		*val = key->min;
+		err = -EINVAL;
+	}
+
+	return 0;
+}
+
 static int maximum_check_val(struct iscsi_key *key, unsigned int *val)
 {
 	int err = 0;
@@ -140,6 +152,16 @@ static int minimum_set_val(struct param *param, int idx, unsigned int *val)
 	return 0;
 }
 
+static int min_or_zero_set_val(struct param *param, int idx, unsigned int *val)
+{
+	if (*val > param[idx].val || *val == 0)
+		*val = param[idx].val;
+	else
+		param[idx].val = *val;
+
+	return 0;
+}
+
 static int maximum_set_val(struct param *param, int idx, unsigned int *val)
 {
 	if (param[idx].val > *val)
@@ -265,6 +287,13 @@ static struct iscsi_key_ops minimum_ops = {
 	.set_val = minimum_set_val,
 };
 
+static struct iscsi_key_ops min_or_zero_ops = {
+	.val_to_str = range_val_to_str,
+	.str_to_val = range_str_to_val,
+	.check_val = min_or_zero_check_val,
+	.set_val = min_or_zero_set_val,
+};
+
 static struct iscsi_key_ops maximum_ops = {
 	.val_to_str = range_val_to_str,
 	.str_to_val = range_str_to_val,
@@ -345,6 +374,15 @@ struct iscsi_key session_keys[] = {
 	{"IFMarkInt", 2048, 1, 65535, &marker_ops},
 	[ISCSI_PARAM_MAXCONNECTIONS] =
 	{"MaxConnections", 1, 1, 65535, &minimum_ops},
+	/* iSER draft */
+	[ISCSI_PARAM_RDMA_EXTENSIONS] =
+	{"RDMAExtensions", 0, 0, 1, &and_ops},
+	[ISCSI_PARAM_TARGET_RDSL] =
+	{"TargetRecvDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_INITIATOR_RDSL] =
+	{"InitiatorRecvDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_MAX_OUTST_PDU] =
+	{"MaxOutstandingUnexpectedPDUs", 0, 2, 4294967295U, &min_or_zero_ops},
 	[ISCSI_PARAM_MAX] =
 	{NULL,},
 };
diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
index 3ddb2d7..61da4e2 100644
--- a/usr/iscsi/target.c
+++ b/usr/iscsi/target.c
@@ -283,6 +283,14 @@ int iscsi_target_create(struct target *t)
 		[ISCSI_PARAM_OFMARKINT] = {0, 2048},
 		[ISCSI_PARAM_IFMARKINT] = {0, 2048},
 		[ISCSI_PARAM_MAXCONNECTIONS] = {0, 1},
+#ifdef ISCSI_RDMA
+		[ISCSI_PARAM_RDMA_EXTENSIONS] = {0, 1},
+#else
+		[ISCSI_PARAM_RDMA_EXTENSIONS] = {0, 0},
+#endif
+		[ISCSI_PARAM_TARGET_RDSL] = {0, 262144},
+		[ISCSI_PARAM_INITIATOR_RDSL] = {0, 262144},
+		[ISCSI_PARAM_MAX_OUTST_PDU] =  {0, 0},  /* not in open-iscsi */
 	};
 
 	target = malloc(sizeof(*target));
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:11:45 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:11:45 -0400
Subject: [Stgt-devel] [PATCH 17/18] iser iscsid changes
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904201145.GU6578@osc.edu>

Handle the special cases for RDMA in core iscsid code.  These changes
all look at conn->tp->rdma and do not affect TCP code.

    - track RDMA setting at session and verify conns are compatible
    - no status collapse on final data packet
    - all data-in transmits must reenable TX for conn
    - TX state machine finishes tasks without going through epoll
    - TX handler returns status to trigger RDMA flow control

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c  |   42 ++++++++++++++++++++++++++++++++----------
 usr/iscsi/iscsid.h  |    5 ++++-
 usr/iscsi/session.c |    2 ++
 3 files changed, 38 insertions(+), 11 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index fd9f8f2..54fa9d4 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -513,8 +513,21 @@ static void login_finish(struct iscsi_connection *conn)
 			conn->state = STATE_EXIT;
 			break;
 		}
-		if (!conn->session)
+		if (!conn->session) {
 			session_create(conn);
+		} else {
+			if (conn->tp->rdma ^ conn->session->rdma) {
+				eprintf("new conn rdma %d, but session %d\n",
+					conn->tp->rdma, conn->session->rdma);
+				rsp->flags = 0;
+				rsp->status_class =
+					ISCSI_STATUS_CLS_INITIATOR_ERR;
+				rsp->status_detail =
+					ISCSI_LOGIN_STATUS_INVALID_REQUEST;
+				conn->state = STATE_EXIT;
+				break;
+			}
+		}
 		memcpy(conn->isid, conn->session->isid, sizeof(conn->isid));
 		conn->tsih = conn->session->tsih;
 		break;
@@ -963,7 +976,8 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 		rsp->flags = ISCSI_FLAG_CMD_FINAL;
 
 		/* collapse status into final packet if successful */
-		if (task->result == 0 && task->dir != BIDIRECTIONAL) {
+		if (task->result == 0 && task->dir != BIDIRECTIONAL &&
+		    !conn->tp->rdma) {
 			rsp->flags |= ISCSI_FLAG_DATA_STATUS;
 			rsp->cmd_status = task->result;
 			rsp->statsn = cpu_to_be32(conn->stat_sn++);
@@ -1700,7 +1714,7 @@ static int iscsi_scsi_cmd_tx_done(struct iscsi_connection *conn)
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
 		if (task->offset < task->len || task->result != 0
-		   || task->dir == BIDIRECTIONAL) {
+		   || task->dir == BIDIRECTIONAL || conn->tp->rdma) {
 			dprintf("more data or sense or bidir %x\n", hdr->itt);
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
 			return 0;
@@ -1976,7 +1990,7 @@ again:
 	return 0;
 }
 
-void iscsi_tx_handler(struct iscsi_connection *conn)
+int iscsi_tx_handler(struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -1991,9 +2005,10 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 	if (conn->state == STATE_SCSI && !conn->tx_task) {
 		ret = iscsi_task_tx_start(conn);
 		if (ret)
-			return;
+			goto out;
 	}
 
+again:
 	switch (conn->tx_iostate) {
 	case IOSTATE_TX_BHS:
 		ret = do_send(conn, IOSTATE_TX_INIT_AHS);
@@ -2050,7 +2065,7 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 		ret = do_send(conn, ddigest ?
 			      IOSTATE_TX_INIT_DDIGEST : IOSTATE_TX_END);
 		if (ret < 0)
-			return;
+			goto out;
 		if (conn->tx_iostate != IOSTATE_TX_INIT_DDIGEST)
 			break;
 	case IOSTATE_TX_INIT_DDIGEST:
@@ -2069,10 +2084,14 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 		exit(1);
 	}
 
-	if (ret < 0 ||
-	    conn->tx_iostate != IOSTATE_TX_END ||
-	    conn->state == STATE_CLOSE)
-		return;
+	if (ret < 0 || conn->state == STATE_CLOSE)
+		goto out;
+
+	if (conn->tx_iostate != IOSTATE_TX_END) {
+		if (conn->tp->rdma)
+			goto again;  /* avoid event loop, just push */
+		goto out;
+	}
 
 	if (conn->tx_size) {
 		eprintf("error %d %d %d\n", conn->state, conn->tx_iostate,
@@ -2105,6 +2124,9 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 		conn->tp->ep_event_modify(conn, EPOLLIN);
 		break;
 	}
+
+out:
+	return ret;
 }
 
 struct tgt_driver iscsi = {
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 99b8448..341e849 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -91,6 +91,9 @@ struct iscsi_session {
 	struct param session_param[ISCSI_PARAM_MAX];
 
 	char *info;
+
+	/* if this session uses rdma connections */
+	int rdma;
 };
 
 struct iscsi_task {
@@ -264,7 +267,7 @@ extern void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_sess
 extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
 extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
 extern void conn_read_pdu(struct iscsi_connection *conn);
-extern void iscsi_tx_handler(struct iscsi_connection *conn);
+extern int iscsi_tx_handler(struct iscsi_connection *conn);
 extern void iscsi_rx_handler(struct iscsi_connection *conn);
 extern int iscsi_scsi_cmd_execute(struct iscsi_task *task);
 
diff --git a/usr/iscsi/session.c b/usr/iscsi/session.c
index 3b1650d..028d538 100644
--- a/usr/iscsi/session.c
+++ b/usr/iscsi/session.c
@@ -128,6 +128,8 @@ int session_create(struct iscsi_connection *conn)
 	memcpy(session->isid, conn->isid, sizeof(session->isid));
 	session->tsih = last_tsih = tsih;
 
+	session->rdma = conn->tp->rdma;
+
 	conn_add_to_session(conn, session);
 
 	dprintf("session_create: %#" PRIx64 "\n", sid64(conn->isid, session->tsih));
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:12:02 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:12:02 -0400
Subject: [Stgt-devel] [PATCH 18/18] iser core
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <20070904201202.GV6578@osc.edu>

Core iSCSI RDMA support.  Adds the iscsi_rdma.c file that implements the
RDMA transport.  Enabled only if ISCSI_RDMA is defined during the build,
in which case RDMA libraries and headers must be present on the system.

The iscsi TX handler redirects R2T and DATA_IN packets to new transport
functions for RDMA mode.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/Makefile           |    5 +
 usr/iscsi/iscsi_rdma.c | 1688 ++++++++++++++++++++++++++++++++++++++++++++++++
 usr/iscsi/iscsid.c     |   25 +
 usr/iscsi/transport.c  |    3 +
 usr/iscsi/transport.h  |    3 +
 5 files changed, 1724 insertions(+), 0 deletions(-)
 create mode 100644 usr/iscsi/iscsi_rdma.c

diff --git a/usr/Makefile b/usr/Makefile
index addf5be..745eaba 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -38,6 +38,11 @@ TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o \
 		isns.o libcrc32c.o)
 TGTD_OBJS += bs_sync.o
 LIBS += -lcrypto -lpthread
+ifneq ($(ISCSI_RDMA),)
+CFLAGS += -DISCSI_RDMA
+TGTD_OBJS += iscsi/iscsi_rdma.o
+LIBS += -libverbs -lrdmacm
+endif
 endif
 
 ifneq ($(FCP),)
diff --git a/usr/iscsi/iscsi_rdma.c b/usr/iscsi/iscsi_rdma.c
new file mode 100644
index 0000000..9e6bac6
--- /dev/null
+++ b/usr/iscsi/iscsi_rdma.c
@@ -0,0 +1,1688 @@
+/*
+ * iSCSI extensions for RDMA (iSER) data path
+ *
+ * Copyright (C) 2007 Dennis Dalessandro (dennis at osc.edu)
+ * Copyright (C) 2007 Ananth Devulapalli (ananth at osc.edu)
+ * Copyright (C) 2007 Pete Wyckoff (pw at osc.edu)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <assert.h>
+#include <netdb.h>
+#include <sys/epoll.h>
+#include <infiniband/verbs.h>
+#include <rdma/rdma_cma.h>
+
+#include "util.h"
+#include "iscsid.h"
+
+#if defined(HAVE_VALGRIND) && !defined(NDEBUG)
+#include <valgrind/memcheck.h>
+#else
+#define VALGRIND_MAKE_MEM_DEFINED(addr, len)
+#endif
+
+/*
+ * The IB-extended version from the kernel.  Stags and VAs are in
+ * big-endian format.
+ */
+struct iser_hdr {
+	uint8_t   flags;
+	uint8_t   rsvd[3];
+	uint32_t  write_stag; /* write rkey */
+	uint64_t  write_va;
+	uint32_t  read_stag;  /* read rkey */
+	uint64_t  read_va;
+} __attribute__((packed));
+
+#define ISER_WSV	(0x08)
+#define ISER_RSV	(0x04)
+#define ISCSI_CTRL	(0x10)
+#define ISER_HELLO	(0x20)
+#define ISER_HELLORPLY	(0x30)
+
+struct conn_info;
+
+/*
+ * Posted receives for control messages.  All must start with the conn
+ * pointer, which will be followed up from a work request during a flush,
+ * when it is not known what type to expect.
+ */
+struct recvlist {
+	struct conn_info *conn;
+	struct ibv_sge sge;
+	void *buf;
+	struct ibv_recv_wr wr;
+	unsigned long bytes_recvd;
+};
+
+/*
+ * Posted sends for control messages.
+ */
+struct sendlist {
+	struct conn_info *conn;
+	struct ibv_sge sge;
+	void *buf;
+	struct ibv_send_wr wr;
+	struct list_head list;
+};
+
+/*
+ * RDMA read and write operations.
+ */
+struct rdmalist {
+	struct conn_info *conn;
+	struct ibv_sge sge;
+	struct ibv_send_wr wr;
+	struct list_head list;
+	struct iscsi_task *task;  /* to get iser_task for remote stag and va */
+};
+
+/*
+ * Each SCSI command may have its own RDMA parameters.  These appear on
+ * the connection then later are assigned to the particular task to be
+ * used when the target responds.
+ */
+struct iser_task {
+	/* read and write from the initiator's point of view */
+	uint32_t rem_read_stag, rem_write_stag;
+	uint64_t rem_read_va, rem_write_va;
+};
+
+struct iser_device;
+
+/*
+ * Parallels iscsi_connection.  Adds more fields for iser.
+ */
+struct conn_info {
+	struct ibv_qp *qp_hndl;
+	struct rdma_cm_id *cma_id;
+	struct iscsi_connection *iscsi_conn;
+	struct iser_device *dev;
+	struct sockaddr_storage peer_addr;  /* initiator address */
+	struct sockaddr_storage self_addr;  /* target address */
+	unsigned int ssize, rsize, max_outst_pdu;
+	unsigned int readb, writeb;
+
+	/* read and write from the initiator's point of view */
+	uint32_t rem_read_stag, rem_write_stag;
+	uint64_t rem_read_va, rem_write_va;
+
+	enum {
+	    LOGIN_PHASE_START,      /* keep 1 send spot and 1 recv posted */
+	    LOGIN_PHASE_LAST_SEND,  /* need 1 more send before ff */
+	    LOGIN_PHASE_FF,         /* full feature */
+	} login_phase;
+
+	void *srbuf;    /* registered space for non-rdma send and recv */
+	void *listbuf;  /* space for the send, recv, rdma list elements */
+	struct ibv_mr *srmr;   /* mr for registered srbuf */
+
+	/* lists of free send, rdma slots */
+	struct list_head sendl, rdmal;
+
+	/* no recvl: just always immediately repost */
+	/* but count so we can drain CQ on close */
+	int recvl_posted;
+
+	/* login phase resources, freed at full-feature */
+	void *srbuf_login;
+	void *listbuf_login;
+	struct ibv_mr *srmr_login;
+	struct list_head sendl_login, recvl_login;
+
+	/* points to the current recvlist, sendlist items for each conn */
+	struct recvlist *rcv_comm_event;
+	struct sendlist *send_comm_event;
+
+	/* to chain this connection onto the list of those ready to tx */
+	struct list_head conn_tx_ready;
+
+	/* list of all iser conns */
+	struct list_head iser_conn_list;
+
+	/* to consume posted receives after disconnect */
+	int draining;
+
+	/* when free has been called, waits until all posted msgs complete */
+	int freed;
+};
+
+/*
+ * Pre-registered memory.  Buffers are allocated by iscsi from us, handed
+ * to device to fill, then iser can send them directly without registration.
+ * Also for write path.
+ */
+struct mempool {
+	struct list_head list;
+	void *buf;
+};
+
+/*
+ * Shared variables for a particular device.  The conn[] array will
+ * have to be broken out when multiple device support is added, maybe with
+ * a pointer into this "device" struct.
+ */
+struct iser_device {
+	struct list_head list;
+	struct ibv_context *ibv_hndl;
+	struct ibv_pd *pd;
+	struct ibv_cq *cq;
+	struct ibv_comp_channel *cq_channel;
+
+	/* mempool registered buffer, list area, handle */
+	void *mempool_regbuf;
+	void *mempool_listbuf;
+	struct ibv_mr *mempool_mr;
+
+	/* free and allocated mempool entries */
+	struct list_head mempool_free, mempool_alloc;
+};
+
+/* global, across all devices */
+static struct rdma_event_channel *rdma_evt_channel;
+static struct rdma_cm_id *cma_listen_id;
+static struct list_head conn_tx_ready;  /* conns with tasks ready to tx */
+
+/* accepted at RDMA layer, but not yet established */
+static struct list_head temp_conn;
+
+/* all devices */
+static struct list_head iser_dev_list;
+
+/* all iser connections */
+static struct list_head iser_conn_list;
+
+/* if any task needs an rdma read or write slot to proceed */
+static int waiting_rdma_slot;
+
+/* progress available, used with tgt_counter_event */
+static int num_tx_ready;
+static int num_rx_ready;
+
+#define uint64_from_ptr(p) (uint64_t)(uintptr_t)(p)
+#define ptr_from_int64(p) (void *)(unsigned long)(p)
+
+#define ISCSI_LISTEN_PORT 3260
+
+/*
+ * Crazy hard-coded linux iser settings need 128 * 8 slots + slop, plus
+ * room for our rdmas and send requests.
+ */
+#define MAX_WQE 1800
+
+/*
+ * Number of outstanding RDMAs per command; should instead wait for previous
+ * RDMAs to complete before starting new ones.
+ *
+ * The RDMA size is completely up to the target.  Parameters IRDSL and TRDSL
+ * only apply to control-type PDUs.  We allocate only so many rdma slots
+ * per connection, but many tasks might be in progress on the connection.
+ * Internal flow control stops tasks when there are no slots.
+ *
+ * RDMA size tradeoffs:
+ *    big RDMA operations are more efficient
+ *    small RDMA operations better for fairness with many clients
+ *    small RDMA operations allow better pipelining
+ *    eventually target devices may not want to have to malloc and return
+ *        entire buffer to transport in one go
+ */
+#define RDMA_PER_CONN 20
+#define RDMA_TRANSFER_SIZE (512 * 1024)
+
+/*
+ * Number of allocatable buffers, each of this size.  Headers are added
+ * so that iscsi alloctations fit.  Do at least 128 for linux iser.
+ */
+#define MEMPOOL_NUM (192)
+#define MEMPOOL_SIZE roundup(512 * 1024 + \
+			     sizeof(struct iscsi_task) + \
+			     sizeof(struct iser_hdr) + \
+			     sizeof(struct iscsi_hdr) + \
+			     sizeof(struct iscsi_ecdb_ahdr) + \
+			     sizeof(struct iscsi_rlength_ahdr), 4096)
+
+static void iser_cqe_handler(int fd, int events, void *data);
+static void iser_rx_progress(int *counter, void *data);
+static void iser_rdma_read_completion(struct rdmalist *rdma);
+static void iscsi_rdma_conn_free(struct iscsi_connection *conn);
+static int iscsi_rdma_show(struct iscsi_connection *iscsi_conn, char *buf,
+			   int rest);
+static void iscsi_rdma_event_modify(struct iscsi_connection *conn, int events);
+
+/*
+ * Called when ready for full feature, builds resources.
+ */
+static int iser_init_comm(struct conn_info *conn)
+{
+	unsigned int i;
+	int ret = -1;
+	unsigned long size;
+	uint8_t *srbuf, *listbuf;
+	struct sendlist *sendl;
+	struct recvlist *recvl;
+	struct rdmalist *rdmal;
+	struct ibv_recv_wr *bad_wr;
+	int rdma_per_conn = RDMA_PER_CONN;
+
+	dprintf("sizing %u/%u outst %u\n", conn->ssize, conn->rsize,
+		conn->max_outst_pdu);
+
+	size = (conn->rsize + conn->ssize) * conn->max_outst_pdu;
+	conn->srbuf = malloc(size);
+	if (!conn->srbuf) {
+		eprintf("malloc srbuf %lu\n", size);
+		goto out;
+	}
+
+	conn->srmr = ibv_reg_mr(conn->dev->pd, conn->srbuf, size,
+				IBV_ACCESS_LOCAL_WRITE);
+	if (!conn->srmr) {
+		eprintf("register srbuf\n");
+		goto out;
+	}
+
+	INIT_LIST_HEAD(&conn->sendl);
+	INIT_LIST_HEAD(&conn->rdmal);
+
+	size = conn->max_outst_pdu * sizeof(struct sendlist) +
+	       conn->max_outst_pdu * sizeof(struct recvlist) +
+	       conn->max_outst_pdu * rdma_per_conn * sizeof(struct rdmalist);
+	conn->listbuf = malloc(size);
+	if (!conn->listbuf) {
+		eprintf("malloc listbuf %lu\n", size);
+		goto out;
+	}
+	memset(conn->listbuf, 0, size);
+
+	srbuf = conn->srbuf;
+	listbuf = conn->listbuf;
+	for (i = 0; i < conn->max_outst_pdu; i++) {
+		sendl = (void *) listbuf;
+		listbuf += sizeof(*sendl);
+		sendl->buf = srbuf;
+		srbuf += conn->ssize;
+		sendl->conn = conn;
+
+		sendl->sge.addr = uint64_from_ptr(sendl->buf);
+		sendl->sge.length = conn->ssize;
+		sendl->sge.lkey = conn->srmr->lkey;
+
+		sendl->wr.wr_id = uint64_from_ptr(sendl);
+		sendl->wr.sg_list = &sendl->sge;
+		sendl->wr.num_sge = 1;
+		sendl->wr.opcode = IBV_WR_SEND;
+		sendl->wr.send_flags = IBV_SEND_SIGNALED;
+		list_add_tail(&sendl->list, &conn->sendl);
+	}
+
+	for (i = 0; i < conn->max_outst_pdu; i++) {
+		recvl = (void *) listbuf;
+		listbuf += sizeof(*recvl);
+		recvl->buf = srbuf;
+		srbuf += conn->rsize;
+		recvl->conn = conn;
+
+		recvl->sge.addr = uint64_from_ptr(recvl->buf);
+		recvl->sge.length = conn->rsize;
+		recvl->sge.lkey = conn->srmr->lkey;
+
+		recvl->wr.wr_id = uint64_from_ptr(recvl);
+		recvl->wr.sg_list = &recvl->sge;
+		recvl->wr.num_sge = 1;
+
+		ret = ibv_post_recv(conn->qp_hndl, &recvl->wr, &bad_wr);
+		if (ret) {
+			eprintf("ibv_post_recv (%d/%d): %m\n", i,
+				conn->max_outst_pdu);
+			exit(1);
+		}
+		++conn->recvl_posted;
+	}
+
+	for (i = 0; i < conn->max_outst_pdu * rdma_per_conn; i++) {
+		rdmal = (void *) listbuf;
+		listbuf += sizeof(*rdmal);
+		rdmal->conn = conn;
+		rdmal->sge.lkey = conn->dev->mempool_mr->lkey;
+
+		rdmal->wr.wr_id = uint64_from_ptr(rdmal);
+		rdmal->wr.sg_list = &rdmal->sge;
+		rdmal->wr.num_sge = 1;
+		rdmal->wr.send_flags = IBV_SEND_SIGNALED;
+		list_add_tail(&rdmal->list, &conn->rdmal);
+	}
+
+	ret = 0;
+
+out:
+	return ret;
+}
+
+/*
+ * Called at accept time, builds resources just for login phase.
+ */
+static int iser_init_comm_login(struct conn_info *conn)
+{
+	unsigned int i;
+	int ret = -1;
+	unsigned long size;
+	uint8_t *srbuf, *listbuf;
+	struct sendlist *sendl;
+	struct recvlist *recvl;
+	struct ibv_recv_wr *bad_wr;
+
+	dprintf("sizing %u/%u outst %u\n", conn->ssize, conn->rsize,
+		conn->max_outst_pdu);
+
+	size = (conn->rsize + conn->ssize) * conn->max_outst_pdu;
+	conn->srbuf_login = malloc(size);
+	if (!conn->srbuf_login) {
+		eprintf("malloc srbuf %lu\n", size);
+		goto out;
+	}
+
+	conn->srmr_login = ibv_reg_mr(conn->dev->pd, conn->srbuf_login, size,
+				      IBV_ACCESS_LOCAL_WRITE);
+	if (!conn->srmr_login) {
+		eprintf("ibv_reg_mr srbuf failed\n");
+		goto out;
+	}
+
+	INIT_LIST_HEAD(&conn->sendl_login);
+	INIT_LIST_HEAD(&conn->recvl_login);
+
+	size = conn->max_outst_pdu * sizeof(struct sendlist) +
+	       conn->max_outst_pdu * sizeof(struct recvlist);
+	conn->listbuf_login = malloc(size);
+	if (!conn->listbuf_login) {
+		eprintf("malloc listbuf %lu\n", size);
+		goto out;
+	}
+	memset(conn->listbuf_login, 0, size);
+
+	srbuf = conn->srbuf_login;
+	listbuf = conn->listbuf_login;
+	for (i = 0; i < conn->max_outst_pdu; i++) {
+		sendl = (void *) listbuf;
+		listbuf += sizeof(*sendl);
+		sendl->buf = srbuf;
+		srbuf += conn->ssize;
+		sendl->conn = conn;
+
+		sendl->sge.addr = uint64_from_ptr(sendl->buf);
+		sendl->sge.length = conn->ssize;
+		sendl->sge.lkey = conn->srmr_login->lkey;
+
+		sendl->wr.wr_id = uint64_from_ptr(sendl);
+		sendl->wr.sg_list = &sendl->sge;
+		sendl->wr.num_sge = 1;
+		sendl->wr.opcode = IBV_WR_SEND;
+		sendl->wr.send_flags = IBV_SEND_SIGNALED;
+		list_add_tail(&sendl->list, &conn->sendl_login);
+	}
+
+	for (i = 0; i < conn->max_outst_pdu; i++) {
+		recvl = (void *) listbuf;
+		listbuf += sizeof(*recvl);
+		recvl->buf = srbuf;
+		srbuf += conn->rsize;
+		recvl->conn = conn;
+
+		recvl->sge.addr = uint64_from_ptr(recvl->buf);
+		recvl->sge.length = conn->rsize;
+		recvl->sge.lkey = conn->srmr_login->lkey;
+
+		recvl->wr.wr_id = uint64_from_ptr(recvl);
+		recvl->wr.sg_list = &recvl->sge;
+		recvl->wr.num_sge = 1;
+		recvl->wr.next = NULL;
+
+		ret = ibv_post_recv(conn->qp_hndl, &recvl->wr, &bad_wr);
+		if (ret) {
+			eprintf("ibv_post_recv: %m\n");
+			goto out;
+		}
+	}
+
+	ret = 0;
+
+out:
+	return ret;
+}
+
+/*
+ * On connection shutdown.
+ */
+static void iser_free_comm(struct conn_info *ci)
+{
+	int ret;
+
+	dprintf("freeing conn %p\n", ci);
+
+	/* release mr and free the lists */
+	dprintf("dereg mr %p\n", ci->srmr);
+	ret = ibv_dereg_mr(ci->srmr);
+	if (ret)
+		eprintf("ibv_dereg_mr\n");
+	free(ci->srbuf);
+	free(ci->listbuf);
+}
+
+/*
+ * When ready for full-feature mode, free login-phase resources.
+ */
+static void iser_free_comm_login(struct conn_info *ci)
+{
+	int ret;
+
+	if (ci->srbuf_login == NULL)
+		return;
+
+	dprintf("freeing, login phase %d\n", ci->login_phase);
+
+	/* release mr and free the lists */
+	ret = ibv_dereg_mr(ci->srmr_login);
+	if (ret)
+		eprintf("ibv_dereg_mr\n");
+	free(ci->srbuf_login);
+	free(ci->listbuf_login);
+	ci->srbuf_login = NULL;  /* remember freed */
+}
+
+/*
+ * One pool of registered memory per device (per PD that is).
+ */
+static int iser_init_mempool(struct iser_device *dev)
+{
+	struct mempool *mp;
+	uint8_t *regbuf, *listbuf;
+	int i;
+
+	regbuf = malloc(MEMPOOL_NUM * MEMPOOL_SIZE);
+	if (!regbuf) {
+		eprintf("malloc regbuf %zu\n", MEMPOOL_NUM * MEMPOOL_SIZE);
+		return -ENOMEM;
+	}
+
+	listbuf = malloc(MEMPOOL_NUM * sizeof(*mp));
+	if (!listbuf) {
+		eprintf("malloc listbuf %zu\n", MEMPOOL_NUM * sizeof(*mp));
+		free(regbuf);
+		return -ENOMEM;
+	}
+
+	dev->mempool_mr = ibv_reg_mr(dev->pd, regbuf,
+				     MEMPOOL_NUM * MEMPOOL_SIZE,
+				     IBV_ACCESS_LOCAL_WRITE);
+	if (!dev->mempool_mr) {
+		eprintf("register regbuf\n");
+		free(regbuf);
+		free(listbuf);
+		return -1;
+	}
+
+	dev->mempool_regbuf = regbuf;
+	dev->mempool_listbuf = listbuf;
+	INIT_LIST_HEAD(&dev->mempool_free);
+	INIT_LIST_HEAD(&dev->mempool_alloc);
+
+	for (i = 0; i < MEMPOOL_NUM; i++) {
+		mp = (void *) listbuf;
+		listbuf += sizeof(*mp);
+		mp->buf = regbuf;
+		regbuf += MEMPOOL_SIZE;
+		list_add_tail(&mp->list, &dev->mempool_free);
+	}
+
+	return 0;
+}
+
+/*
+ * First time a new connection is received on an RDMA device, record
+ * it and build a PD and static memory.
+ */
+static int iser_device_init(struct iser_device *dev)
+{
+	struct ibv_device_attr device_attr;
+	int cqe_num;
+	int ret = -1;
+
+	dprintf("dev %p\n", dev);
+	dev->pd = ibv_alloc_pd(dev->ibv_hndl);
+	if (dev->pd == NULL) {
+		eprintf("ibv_alloc_pd failed\n");
+		goto out;
+	}
+
+	ret = iser_init_mempool(dev);
+	if (ret) {
+		eprintf("iser_init_mempool failed\n");
+		goto out;
+	}
+
+	ret = ibv_query_device(dev->ibv_hndl, &device_attr);
+	if (ret < 0) {
+		eprintf("ibv_query_device: %m\n");
+		goto out;
+	}
+	cqe_num = device_attr.max_cqe;
+	dprintf("max %d CQEs\n", cqe_num);
+
+	ret = -1;
+	dev->cq_channel = ibv_create_comp_channel(dev->ibv_hndl);
+	if (dev->cq_channel == NULL) {
+		eprintf("ibv_create_comp_channel failed: %m\n");
+		goto out;
+	}
+
+	dev->cq = ibv_create_cq(dev->ibv_hndl, cqe_num, NULL,
+				dev->cq_channel, 0);
+	if (dev->cq == NULL) {
+		eprintf("ibv_create_cq failed: %m\n");
+		goto out;
+	}
+
+	ret = ibv_req_notify_cq(dev->cq, 0);
+	if (ret) {
+		eprintf("ibv_req_notify failed: %s\n", strerror(ret));
+		goto out;
+	}
+
+	ret = tgt_event_add(dev->cq_channel->fd, EPOLLIN, iser_cqe_handler,
+			    dev);
+	if (ret) {
+		eprintf("tgt_event_add failed: %m\n");
+		goto out;
+
+	}
+
+	list_add(&dev->list, &iser_dev_list);
+
+out:
+	return ret;
+}
+
+static void iser_accept_connection(struct rdma_cm_event *event)
+{
+	int ret, found;
+	struct ibv_qp_init_attr qp_init_attr;
+	struct iscsi_connection *conn;
+	struct conn_info *ci;
+	struct iser_device *dev;
+	unsigned int hdrsz;
+	struct rdma_conn_param conn_param = {
+		.responder_resources = 1,
+		.initiator_depth = 1,
+		.retry_count = 5,
+	};
+
+	dprintf("entry\n");
+
+	/* find device */
+	found = 0;
+	list_for_each_entry(dev, &iser_dev_list, list) {
+		if (dev->ibv_hndl == event->id->verbs) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		dev = malloc(sizeof(*dev));
+		if (dev == NULL) {
+			eprintf("unable to allocate dev\n");
+			goto reject;
+		}
+		dev->ibv_hndl = event->id->verbs;
+		ret = iser_device_init(dev);
+		if (ret) {
+			free(dev);
+			goto reject;
+		}
+	}
+
+	/* build a new connection structure */
+	conn = conn_alloc(sizeof(*ci));
+	if (!conn) {
+		eprintf("unable to allocate conn\n");
+		goto reject;
+	}
+	ci = conn->trans_data;
+	ci->iscsi_conn = conn;
+	ci->iscsi_conn->tp = &iscsi_iser;
+	conn_read_pdu(ci->iscsi_conn);
+	ci->cma_id = event->id;
+	ci->dev = dev;
+	ci->login_phase = LOGIN_PHASE_START;
+	INIT_LIST_HEAD(&ci->conn_tx_ready);
+	list_add(&ci->iser_conn_list, &temp_conn);
+	/* initiator sits at dst, we are src */
+	memcpy(&ci->peer_addr, &event->id->route.addr.dst_addr,
+	       sizeof(ci->peer_addr));
+	memcpy(&ci->self_addr, &event->id->route.addr.src_addr,
+	       sizeof(ci->self_addr));
+#ifndef NDEBUG
+	{
+		char str[256];
+
+		iscsi_rdma_show(conn, str, sizeof(str));
+		str[sizeof(str)-1] = 0;
+		dprintf("new conn %p from %s\n", ci, str);
+	}
+#endif
+
+	/* create qp next */
+	memset(&qp_init_attr, 0, sizeof(qp_init_attr));
+	/* wire both send and recv to the same CQ */
+	qp_init_attr.send_cq =  dev->cq;
+	qp_init_attr.recv_cq  = dev->cq;
+	qp_init_attr.cap.max_send_wr = MAX_WQE;
+	qp_init_attr.cap.max_recv_wr = MAX_WQE;
+	qp_init_attr.cap.max_send_sge = 1;  /* scatter/gather entries */
+	qp_init_attr.cap.max_recv_sge = 1;
+	qp_init_attr.qp_type = IBV_QPT_RC;
+	/* only generate completion queue entries if requested */
+	qp_init_attr.sq_sig_all = 0;
+
+	ret = rdma_create_qp(ci->cma_id, dev->pd, &qp_init_attr);
+	if (ret) {
+		eprintf("create qp failed\n");
+		conn_put(ci->iscsi_conn);
+		goto reject;
+	}
+	ci->qp_hndl = ci->cma_id->qp;
+	VALGRIND_MAKE_MEM_DEFINED(ci->qp_hndl, sizeof(*ci->qp_hndl));
+
+	ci->rcv_comm_event = NULL;
+	ci->send_comm_event = NULL;
+	ci->readb = 0;
+	ci->writeb = 0;
+
+	/*
+	 * Post buffers for the login phase, only.
+	 */
+	hdrsz = sizeof(struct iser_hdr) +
+		sizeof(struct iscsi_hdr) +
+		sizeof(struct iscsi_ecdb_ahdr) +
+		sizeof(struct iscsi_rlength_ahdr);
+	ci->ssize = hdrsz + 8192;
+	ci->rsize = hdrsz + 8192;
+	ci->max_outst_pdu = 1;
+	ret = iser_init_comm_login(ci);
+	if (ret) {
+		iser_free_comm_login(ci);
+		conn_put(ci->iscsi_conn);
+		goto reject;
+	}
+
+	/* now we can actually accept the connection */
+	ret = rdma_accept(ci->cma_id, &conn_param);
+	if (ret) {
+		eprintf("rdma_accept failed\n");
+		iser_free_comm_login(ci);
+		conn_put(ci->iscsi_conn);
+		goto reject;
+	}
+
+	return;
+
+reject:
+	ret = rdma_reject(event->id, NULL, 0);
+	if (ret)
+		eprintf("rdma_reject failed: %s\n", strerror(-ret));
+}
+
+/*
+ * Finish putting the connection together, now that the other side
+ * has ACKed our acceptance.  Moves it from the temp_conn to the
+ * iser_conn_list.
+ *
+ * Release the temporary conn_info and glue it into iscsi_conn.
+ */
+static void iser_conn_established(struct rdma_cm_event *event)
+{
+	int found = 0;
+	struct conn_info *ci;
+
+	/* find it in connection list */
+	list_for_each_entry(ci, &temp_conn, iser_conn_list) {
+		if (ci->cma_id == event->id) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		eprintf("cma id %p not found\n", event->id);
+		return;
+	}
+	dprintf("established conn %p\n", ci);
+	list_del(&ci->iser_conn_list);
+	list_add(&ci->iser_conn_list, &iser_conn_list);
+}
+
+static void iser_disconnect(struct rdma_cm_event *ev)
+{
+	struct conn_info *ci;
+
+	/*
+	 * If not found, initiator disconnected first, so tell iscsi about
+	 * it; else iscsi already did the conn_close.
+	 */
+	dprintf("initiator disconn, QP %d\n", ev->id->qp->qp_num);
+	list_for_each_entry(ci, &iser_conn_list, iser_conn_list) {
+		if (ci->qp_hndl->qp_num == ev->id->qp->qp_num) {
+			ci->iscsi_conn->state = STATE_CLOSE;
+			conn_close(ci->iscsi_conn);
+			break;
+		}
+	}
+}
+
+/*
+ * Handle RDMA connection events.
+ */
+static void iser_handle_rdmacm(int fd __attribute__((unused)),
+			       int events __attribute__((unused)),
+			       void *data __attribute__((unused)))
+{
+	int ret;
+	struct rdma_cm_event *event;
+	struct rdma_cm_id *destroy_cm_id = NULL;
+
+	dprintf("entry\n");
+	ret = rdma_get_cm_event(rdma_evt_channel, &event);
+	if (ret) {
+		eprintf("rdma_get_cm_event failed\n");
+		return;
+	}
+
+	VALGRIND_MAKE_MEM_DEFINED(event, sizeof(*event));
+	switch (event->event) {
+	case RDMA_CM_EVENT_CONNECT_REQUEST:
+		iser_accept_connection(event);
+		break;
+	case RDMA_CM_EVENT_ESTABLISHED:
+		iser_conn_established(event);
+		break;
+	case RDMA_CM_EVENT_DISCONNECTED:
+		iser_disconnect(event);
+		destroy_cm_id = event->id;
+		break;
+	default:
+		eprintf("unknown event %d\n", event->event);
+		break;
+	}
+
+	ret = rdma_ack_cm_event(event);
+	if (ret) {
+		eprintf("ack cm event failed\n");
+		return;
+	}
+
+	if (destroy_cm_id) {
+		ret = rdma_destroy_id(destroy_cm_id);
+		if (ret)
+			eprintf("rdma_destroy_id failed\n");
+	}
+}
+
+/*
+ * Deal with just one work completion.
+ */
+static void handle_wc(struct ibv_wc *wc)
+{
+	int ret;
+	struct recvlist *recvl;
+	struct sendlist *sendl;
+	struct rdmalist *rdmal;
+	struct conn_info *ci;
+	struct ibv_recv_wr *bad_wr;
+
+	switch (wc->opcode) {
+	case IBV_WC_SEND:
+		dprintf("outgoing rsp complete\n");
+		sendl = ptr_from_int64(wc->wr_id);
+		ci = sendl->conn;
+		if (ci->login_phase == LOGIN_PHASE_START) {
+		    list_add(&sendl->list, &ci->sendl_login);
+		} else if (ci->login_phase == LOGIN_PHASE_LAST_SEND) {
+			/* release login resources */
+			dprintf("last login send completed, release, to ff\n");
+			iser_free_comm_login(ci);
+			ci->login_phase = LOGIN_PHASE_FF;
+			break;
+		} else {
+		    list_add(&sendl->list, &ci->sendl);
+		}
+		break;
+
+	case IBV_WC_RECV:
+		dprintf("incoming cmd, len %d\n", wc->byte_len);
+		recvl = ptr_from_int64(wc->wr_id);
+		ci = recvl->conn;
+		--ci->recvl_posted;
+		if (ci->iscsi_conn->state == STATE_CLOSE)
+			goto close_err;
+
+		recvl->bytes_recvd = wc->byte_len;
+		VALGRIND_MAKE_MEM_DEFINED(recvl->buf, recvl->bytes_recvd);
+
+		/*
+		 * Global pointer to the working receive on this connection
+		 * for reads from iscsid.c.
+		 */
+		ci->rcv_comm_event = recvl;
+		iscsi_rx_handler(ci->iscsi_conn);
+		ci->rcv_comm_event = NULL;
+
+		if (ci->login_phase == LOGIN_PHASE_LAST_SEND) {
+			/* do not repost, just one more send then reinit */
+			dprintf("transitioning to full-feature, no repost\n");
+			break;
+		}
+
+		dprintf("incoming cmd proc done, repost\n");
+		ret = ibv_post_recv(ci->qp_hndl, &recvl->wr, &bad_wr);
+		if (ret) {
+			eprintf("ibv_post_recv failed\n");
+			exit(1);
+		}
+		++ci->recvl_posted;
+		break;
+
+	case IBV_WC_RDMA_WRITE:
+		dprintf("RDMA write done\n");
+		rdmal = ptr_from_int64(wc->wr_id);
+		ci = rdmal->conn;
+		if (ci->iscsi_conn->state == STATE_CLOSE)
+			goto close_err;
+
+		iscsi_rdma_event_modify(ci->iscsi_conn, EPOLLIN | EPOLLOUT);
+		list_add(&rdmal->list, &ci->rdmal);
+		if (waiting_rdma_slot) {
+			waiting_rdma_slot = 0;
+			num_tx_ready = 1;
+		}
+		break;
+
+	case IBV_WC_RDMA_READ:
+		dprintf("RDMA read done, len %d\n", wc->byte_len);
+		rdmal = ptr_from_int64(wc->wr_id);
+		ci = rdmal->conn;
+		if (ci->iscsi_conn->state == STATE_CLOSE)
+			goto close_err;
+
+		assert(rdmal->sge.length == wc->byte_len);
+		iser_rdma_read_completion(rdmal);
+		list_add(&rdmal->list, &ci->rdmal);
+		if (waiting_rdma_slot) {
+			waiting_rdma_slot = 0;
+			num_tx_ready = 1;
+		}
+		break;
+
+	default:
+		eprintf("unexpected opcode %d\n", wc->opcode);
+		exit(1);
+	}
+
+	return;
+
+close_err:
+	eprintf("conn state set to closed .. IMPLEMENT ME\n");
+	exit(1);
+}
+
+/*
+ * Called directly from main event loop when a CQ notification is
+ * available.
+ */
+static void iser_cqe_handler(int fd __attribute__((unused)),
+			     int events __attribute__((unused)),
+			     void *data)
+{
+	int ret;
+	void *cq_context;
+	struct iser_device *dev = data;
+
+	ret = ibv_get_cq_event(dev->cq_channel, &dev->cq, &cq_context);
+	if (ret != 0) {
+		eprintf("notification, but no CQ event\n");
+		exit(1);
+	}
+
+	ibv_ack_cq_events(dev->cq, 1);
+
+	ret = ibv_req_notify_cq(dev->cq, 0);
+	if (ret) {
+		eprintf("ibv_req_notify_cq: %s\n", strerror(ret));
+		exit(1);
+	}
+
+	iser_rx_progress(NULL, dev);
+}
+
+/*
+ * Called from tgtd when num_tx_ready (counter) non-zero.  Walks the
+ * list of active connections and tries to push tx on each, until nothing
+ * is ready anymore.  No progress limit here.
+ */
+static void iser_tx_progress(int *counter __attribute__((unused)),
+			     void *data __attribute__((unused)))
+{
+	int reloop, ret;
+	struct conn_info *ci, *cin;
+	struct iscsi_connection *conn;
+
+	dprintf("entry\n");
+	num_tx_ready = 0;
+
+	do {
+		reloop = 0;
+		list_for_each_entry_safe(ci, cin, &conn_tx_ready,
+					 conn_tx_ready) {
+			conn = ci->iscsi_conn;
+			if (conn->state == STATE_CLOSE) {
+				dprintf("ignoring tx for closed conn\n");
+			} else {
+				dprintf("trying tx\n");
+				ret = iscsi_tx_handler(conn);
+				if (conn->state == STATE_CLOSE) {
+					conn_close(conn);
+					dprintf("connection %p closed\n", ci);
+				} else {
+					if (ret == 0) {
+						reloop = 1;
+					} else {
+						/* but leave on tx ready list */
+						waiting_rdma_slot = 1;
+					}
+				}
+			}
+		}
+	} while (reloop);
+}
+
+/*
+ * Could read as many entries as possible without blocking, but
+ * that just fills up a list of tasks.  Instead pop out of here
+ * so that tx progress, like issuing rdma reads and writes, can
+ * happen periodically.
+ */
+#define MAX_RX_PROGRESS 8
+static void iser_rx_progress_one(struct iser_device *dev)
+{
+	int ret, numwc = 0;
+	struct ibv_wc wc;
+	struct conn_info *ci;
+	struct recvlist *recvl;
+
+	for (;;) {
+		ret = ibv_poll_cq(dev->cq, 1, &wc);
+		if (ret < 0) {
+			eprintf("ibv_poll_cq %d\n", ret);
+			break;
+		} else if (ret == 0) {
+			break;
+		}
+
+		VALGRIND_MAKE_MEM_DEFINED(&wc, sizeof(wc));
+		if (wc.status != IBV_WC_SUCCESS) {
+			if (wc.status == IBV_WC_WR_FLUSH_ERR) {
+				recvl = ptr_from_int64(wc.wr_id);
+				ci = recvl->conn;
+				if (ci->draining) {
+					--ci->recvl_posted;
+					if (ci->freed && ci->recvl_posted == 0)
+						iscsi_rdma_conn_free(
+							ci->iscsi_conn);
+					continue;
+				}
+			}
+			eprintf("bad WC status %d for wr_id 0x%llx\n",
+				wc.status, (unsigned long long) wc.wr_id);
+			exit(1);
+		}
+
+		handle_wc(&wc);
+		if (++numwc == MAX_RX_PROGRESS) {
+			num_rx_ready = 1;
+			break;
+		}
+	}
+}
+
+/*
+ * Only one progress counter, must look across all devs.
+ */
+static void iser_rx_progress(int *counter __attribute__((unused)), void *data)
+{
+	struct iser_device *dev;
+
+	dprintf("entry\n");
+	num_rx_ready = 0;
+	if (data == NULL) {
+		list_for_each_entry(dev, &iser_dev_list, list)
+			iser_rx_progress_one(dev);
+	} else {
+		dev = data;
+		iser_rx_progress_one(dev);
+	}
+}
+
+/*
+ * Init entire iscsi transport.  Begin listening for connections.
+ */
+static int iscsi_rdma_init(void)
+{
+	int ret;
+	struct sockaddr_in sock_addr;
+	short int port = ISCSI_LISTEN_PORT;
+
+	rdma_evt_channel = rdma_create_event_channel();
+
+	if (!rdma_evt_channel) {
+		eprintf("cannot initialize RDMA; load kernel modules?\n");
+		return -1;
+	}
+
+	ret = rdma_create_id(rdma_evt_channel, &cma_listen_id, NULL,
+			     RDMA_PS_TCP);
+	if (ret) {
+		eprintf("rdma_create_id: %s\n", strerror(ret));
+		return -1;
+	}
+
+	memset(&sock_addr, 0, sizeof(sock_addr));
+	sock_addr.sin_family = AF_INET;
+	sock_addr.sin_port = htons(port);
+	sock_addr.sin_addr.s_addr = INADDR_ANY;
+	ret = rdma_bind_addr(cma_listen_id, (struct sockaddr *) &sock_addr);
+	if (ret) {
+		if (ret == -1)
+			eprintf("rdma_bind_addr -1: %m\n");
+		else
+			eprintf("rdma_bind_addr: %s\n", strerror(-ret));
+		return -1;
+	}
+
+	/* 0 == maximum backlog */
+	ret = rdma_listen(cma_listen_id, 0);
+	if (ret) {
+		if (ret == -1)
+			eprintf("rdma_listen -1: %m\n");
+		else
+			eprintf("rdma_listen: %s\n", strerror(-ret));
+		return -1;
+	}
+
+	dprintf("listening for iser connections on port %d\n", port);
+	ret = tgt_event_add(cma_listen_id->channel->fd, EPOLLIN,
+			    iser_handle_rdmacm, NULL);
+	if (ret)
+		return ret;
+
+	INIT_LIST_HEAD(&conn_tx_ready);
+	INIT_LIST_HEAD(&iser_dev_list);
+	INIT_LIST_HEAD(&iser_conn_list);
+	INIT_LIST_HEAD(&temp_conn);
+	num_tx_ready = 0;
+	num_rx_ready = 0;
+	ret = tgt_counter_event_add(&num_tx_ready, iser_tx_progress, NULL);
+	ret = tgt_counter_event_add(&num_rx_ready, iser_rx_progress, NULL);
+	return ret;
+}
+
+/*
+ * Allocate resources for this new connection.  Called after login, when
+ * final negotiated transfer parameters are known.
+ */
+static int iscsi_rdma_conn_init(struct iscsi_connection *conn)
+{
+	int ret = -1;
+	struct conn_info *ci = conn->trans_data;
+	unsigned int irdsl, trdsl, outst_pdu, hdrsz;
+
+	dprintf("entry\n");
+
+	/*
+	 * Build full feature connection structures, but leave around the
+	 * login ones until the final send finishes.
+	 */
+	ci->login_phase = LOGIN_PHASE_LAST_SEND;  /* one more send, then done */
+	irdsl = conn->session_param[ISCSI_PARAM_INITIATOR_RDSL].val;
+	trdsl = conn->session_param[ISCSI_PARAM_TARGET_RDSL].val;
+	outst_pdu = conn->session_param[ISCSI_PARAM_MAX_OUTST_PDU].val;
+
+	/* hack, ib/ulp/iser does not have this param, but reading the code
+	 * shows
+	 *    ISCSI_XMIT_CMDS_MAX=128
+	 *    ISER_INFLIGHT_DATAOUTS=8
+	 *    ISER_MAX_RX_MISC_PDUS=4
+	 *    ISER_MAX_TX_MISC_PDUS=6
+	 * and their formula for max tx dtos outstanding
+	 *    = cmds_max * (1 + dataouts) + rx_misc + tx_misc
+	 */
+	if (outst_pdu == 0)
+		outst_pdu = 128 * (1 + 8) + 6 + 4;
+
+	/* RDSLs do not include headers. */
+	hdrsz = sizeof(struct iser_hdr) +
+		sizeof(struct iscsi_hdr) +
+		sizeof(struct iscsi_ecdb_ahdr) +
+		sizeof(struct iscsi_rlength_ahdr);
+
+	ci->ssize = hdrsz + irdsl;
+	ci->rsize = hdrsz + trdsl;
+	ci->max_outst_pdu = outst_pdu;
+	ret = iser_init_comm(ci);
+	if (ret) {
+		eprintf("iser_init_comm failed\n");
+		goto out;
+	}
+
+	/*
+	 * How much data to grab in an RDMA operation, read or write.
+	 */
+	conn->data_inout_max_size = RDMA_TRANSFER_SIZE;
+
+out:
+	return ret;
+}
+
+/*
+ * Copy the remote va and stag that were temporarily saved in conn_info.
+ */
+static void iscsi_iser_task_init(struct iscsi_task *task)
+{
+	struct conn_info *ci = task->conn->trans_data;
+	struct iser_task *itask = task->trans_data;
+
+	itask->rem_read_stag = ci->rem_read_stag;
+	itask->rem_read_va = ci->rem_read_va;
+	itask->rem_write_stag = ci->rem_write_stag;
+	itask->rem_write_va = ci->rem_write_va;
+}
+
+static int iser_parse_hdr(struct conn_info *ci, struct recvlist *recvl)
+{
+	int ret = -1;
+	struct iser_hdr *hdr = recvl->buf;
+
+	switch (hdr->flags & 0xF0) {
+	case ISCSI_CTRL:
+		dprintf("control type PDU\n");
+		if (hdr->flags & ISER_RSV) {
+			ci->rem_read_stag = be32_to_cpu(hdr->read_stag);
+			ci->rem_read_va = be64_to_cpu(hdr->read_va);
+			dprintf("rstag %x va %llx\n",
+				ci->rem_read_stag,
+				(unsigned long long) ci->rem_read_va);
+		}
+		if (hdr->flags & ISER_WSV) {
+			ci->rem_write_stag = be32_to_cpu(hdr->write_stag);
+			ci->rem_write_va = be64_to_cpu(hdr->write_va);
+			dprintf("wstag %x va %llx\n",
+				ci->rem_write_stag,
+				(unsigned long long) ci->rem_write_va);
+		}
+		ret = 0;
+		break;
+	case ISER_HELLO:
+		dprintf("iSER Hello message??\n");
+		break;
+	default:
+		eprintf("malformed iser hdr, flags 0x%02x\n", hdr->flags);
+		break;
+	}
+
+	ci->readb = sizeof(*hdr);
+	return ret;
+}
+
+static size_t iscsi_iser_read(struct iscsi_connection *iscsi_conn, void *buf,
+			      size_t nbytes)
+{
+	int ret;
+	struct conn_info *ci = iscsi_conn->trans_data;
+	struct recvlist *recvl;
+
+	dprintf("buf %p nbytes %zu\n", buf, nbytes);
+	recvl = ci->rcv_comm_event;
+	assert(recvl != NULL);
+
+	if (ci->readb == 0) {
+		if (recvl->bytes_recvd < sizeof(struct iser_hdr))
+			return 0;
+
+		ret = iser_parse_hdr(ci, recvl);
+		if (ret != 0)
+			return 0;
+	}
+
+	if (ci->readb + nbytes > recvl->bytes_recvd) {
+		if (ci->readb > recvl->bytes_recvd)
+			nbytes = recvl->bytes_recvd;
+		else
+			nbytes = recvl->bytes_recvd - ci->readb;
+	}
+
+	/* always copy headers into iscsi task structure */
+	memcpy(buf, (char *) recvl->buf + ci->readb, nbytes);
+	ci->readb += nbytes;
+
+	if (ci->readb == recvl->bytes_recvd)
+		ci->readb = 0;
+
+	return nbytes;
+}
+
+static size_t iscsi_iser_write_begin(struct iscsi_connection *iscsi_conn,
+				     void *buf, size_t nbytes)
+{
+	struct conn_info *ci = iscsi_conn->trans_data;
+	struct sendlist *sendl;
+
+	if (ci->send_comm_event == NULL) {
+		/* find one, first time here */
+		struct list_head *ci_sendl = &ci->sendl;
+
+		if (ci->login_phase != LOGIN_PHASE_FF)
+			ci_sendl = &ci->sendl_login;
+
+		if (list_empty(ci_sendl)) {
+			/* bug, max outst pdu should constrain this */
+			eprintf("no free send slot\n");
+			exit(1);
+		}
+		sendl = list_entry(ci_sendl->next, typeof(*sendl), list);
+		list_del(&sendl->list);
+		ci->send_comm_event = sendl;
+		dprintf("new sendl %p len %zu\n", sendl, nbytes);
+	} else {
+		sendl = ci->send_comm_event;
+		dprintf("reuse sendl %p len %u + %zu\n", sendl, ci->writeb,
+			nbytes);
+	}
+
+	if (ci->writeb + nbytes > ci->ssize) {
+		eprintf("send buf overflow %d + %zd > %u\n", ci->writeb,
+			nbytes, ci->ssize);
+		exit(1);
+	}
+
+	if (ci->writeb == 0) {
+		/* insert iser hdr */
+		struct iser_hdr *hdr = sendl->buf;
+
+		memset(hdr, 0, sizeof(*hdr));
+		hdr->flags = ISCSI_CTRL;
+		ci->writeb = sizeof(*hdr);
+	}
+
+	memcpy((char *) sendl->buf + ci->writeb, buf, nbytes);
+	ci->writeb += nbytes;
+	return nbytes;
+}
+
+static void iscsi_iser_write_end(struct iscsi_connection *iscsi_conn)
+{
+	int ret;
+	struct ibv_send_wr *bad_wr;
+	struct conn_info *ci = iscsi_conn->trans_data;
+	struct sendlist *sendl;
+
+	sendl = ci->send_comm_event;  /* set from _write_begin above */
+	dprintf("sendl %p len %d\n", sendl, ci->writeb);
+
+	sendl->sge.length = ci->writeb;
+
+	ret = ibv_post_send(ci->qp_hndl, &sendl->wr, &bad_wr);
+	if (ret) {
+		/* bug, should have sized max_outst_pdu properly */
+		eprintf("ibv_post_send ret %d\n", ret);
+		exit(1);
+	}
+
+	ci->writeb = 0;  /* reset count */
+	ci->send_comm_event = NULL;
+
+	/* wake up the progress engine to do the done */
+	dprintf("inc progress to finish cmd\n");
+	num_tx_ready = 1;
+}
+
+/*
+ * Expected opcodes are: IBV_WR_RDMA_WRITE, IBV_WR_RDMA_READ.
+ */
+static int iser_post_rdma_wr(struct conn_info *ci, struct iscsi_task *task,
+			     void *buf, ssize_t size, int op,
+			     uint64_t remote_va, uint32_t remote_rkey)
+{
+	int ret;
+	struct rdmalist *rdmal;
+	struct ibv_send_wr *bad_wr;
+
+	if (list_empty(&ci->rdmal)) {
+		eprintf("no slot\n");
+		return -1;
+	}
+	rdmal = list_entry(ci->rdmal.next, typeof(*rdmal), list);
+	list_del(&rdmal->list);
+
+	rdmal->task = task;
+	rdmal->sge.addr = uint64_from_ptr(buf);
+	rdmal->sge.length = size;
+
+	rdmal->wr.opcode = op;
+	rdmal->wr.wr.rdma.remote_addr = remote_va;
+	rdmal->wr.wr.rdma.rkey = remote_rkey;
+
+	ret = ibv_post_send(ci->qp_hndl, &rdmal->wr, &bad_wr);
+	if (ret)
+		eprintf("ibv_post_send ret %d\n", ret);
+
+	return ret;
+}
+
+/*
+ * Convert the iscsi r2t request to an RDMA read and post it.
+ */
+static int iscsi_rdma_rdma_read(struct iscsi_connection *conn)
+{
+	struct conn_info *ci = conn->trans_data;
+	struct iscsi_task *task = conn->tx_task;
+	struct iser_task *itask = task->trans_data;
+	struct iscsi_r2t_rsp *r2t = (struct iscsi_r2t_rsp *) &conn->rsp.bhs;
+	uint8_t *buf;
+	uint32_t len;
+	int ret;
+
+	buf = (uint8_t *) task->data + task->offset;
+	len = be32_to_cpu(r2t->data_length);
+
+	dprintf("len %u stag %x va %llx\n",
+		len, itask->rem_write_stag,
+		(unsigned long long) itask->rem_write_va);
+
+	ret = iser_post_rdma_wr(ci, task, buf, len, IBV_WR_RDMA_READ,
+				itask->rem_write_va, itask->rem_write_stag);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Initiator registers the entire buffer, but gives us a VA that
+	 * is advanced by immediate + unsolicited data amounts.  Advance
+	 * rem_va as we read, knowing that the target always grabs segments
+	 * in order.
+	 */
+	itask->rem_write_va += len;
+
+	return 0;
+}
+
+/*
+ * Convert the iscsi data-in response to an RDMA write and send it.
+ */
+static int iscsi_rdma_rdma_write(struct iscsi_connection *conn)
+{
+	struct conn_info *ci = conn->trans_data;
+	struct iscsi_task *task = conn->tx_task;
+	struct iser_task *itask = task->trans_data;
+	struct iscsi_pdu *rsp = &conn->rsp;
+	struct iscsi_data_rsp *datain = (struct iscsi_data_rsp *) &rsp->bhs;
+	uint32_t offset;
+	int ret;
+
+	offset = be32_to_cpu(datain->offset);
+
+	dprintf("offset %d len %d stag %x va %llx\n", offset, rsp->datasize,
+		itask->rem_read_stag, (unsigned long long) itask->rem_read_va);
+
+	ret = iser_post_rdma_wr(ci, task, rsp->data, rsp->datasize,
+				IBV_WR_RDMA_WRITE, itask->rem_read_va + offset,
+				itask->rem_read_stag);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * iscsi thinks we are txing, but really we're waiting for this
+	 * rdma to finish before sending the completion.  Then we'll stick
+	 * ourselves back on the list.
+	 */
+	if (task->offset == task->len) {
+		iscsi_rdma_event_modify(ci->iscsi_conn, EPOLLIN);
+	} else {
+		/* poke ourselves to do the next rdma */
+		num_tx_ready = 1;
+	}
+
+	return ret;
+}
+
+/*
+ * Called from CQ processing.  Hands completed write data to iscsi.
+ */
+static void iser_rdma_read_completion(struct rdmalist *rdmal)
+{
+	struct conn_info *ci = rdmal->conn;
+	struct iscsi_connection *conn = ci->iscsi_conn;
+	struct iscsi_task *task;
+
+	/* task is no longer conn->tx_task, look it up */
+	list_for_each_entry(task, &conn->session->cmd_list, c_hlist) {
+		if (task == rdmal->task)
+			goto found;
+	}
+	eprintf("no task\n");
+	return;
+
+found:
+	/* equivalent of iscsi_data_out_rx_start + _done */
+	conn->rx_buffer = ptr_from_int64(rdmal->sge.addr);
+	conn->rx_size = rdmal->sge.length;
+	task->offset += rdmal->sge.length;
+	task->r2t_count -= rdmal->sge.length;
+	VALGRIND_MAKE_MEM_DEFINED(conn->rx_buffer, conn->rx_size);
+
+	dprintf("itt %x len %u arrived, r2t_count %d\n", (uint32_t) task->tag,
+		rdmal->sge.length, task->r2t_count);
+
+	/*
+	 * We soliticed this data, so hdr->ttt is what we asked for.  Bypass
+	 * data_out_rx_done and just run the task.  If more r2t are needed,
+	 * this will generate them.
+	 */
+	iscsi_scsi_cmd_execute(task);
+
+	conn->rx_task = NULL;
+	conn_read_pdu(conn);
+}
+
+/*
+ * Close connection.  There is no device close function.  This is called
+ * from iscsi.
+ */
+static void iscsi_rdma_conn_close(struct iscsi_connection *conn)
+{
+	struct conn_info *ci = conn->trans_data;
+	int ret;
+
+	ret = rdma_disconnect(ci->cma_id);
+	if (ret)
+		eprintf("rdma_disconnect: %s\n", strerror(-ret));
+	dprintf("did rdma_disconnect\n");
+	list_del(&ci->conn_tx_ready);
+	list_del(&ci->iser_conn_list);
+	ci->draining = 1;
+}
+
+/*
+ * Called when the connection is freed, from iscsi, but won't do anything until
+ * all posted WRs have gone away.  So also called again from RX progress when
+ * it notices this happens.
+ */
+static void iscsi_rdma_conn_free(struct iscsi_connection *conn)
+{
+	struct conn_info *ci = conn->trans_data;
+	int ret;
+
+	dprintf("conn %p recvl %d\n", ci, ci->recvl_posted);
+	ci->freed = 1;
+
+	/* wait until all WRs flushed */
+	if (ci->recvl_posted != 0)
+		return;
+
+	iser_free_comm_login(ci);
+	if (ci->login_phase == LOGIN_PHASE_FF)
+		iser_free_comm(ci);
+
+	/* finally destory QP */
+	ret = ibv_destroy_qp(ci->qp_hndl);
+	if (ret)
+		eprintf("ibv_destroy_qp: %s\n", strerror(-ret));
+}
+
+static int iscsi_rdma_show(struct iscsi_connection *iscsi_conn, char *buf,
+			   int rest)
+{
+	int ret;
+	char host[NI_MAXHOST];
+	struct conn_info *ci = iscsi_conn->trans_data;
+
+	ret = getnameinfo((struct sockaddr *) &ci->peer_addr,
+			  sizeof(ci->peer_addr), host, sizeof(host), NULL, 0,
+			  NI_NUMERICHOST);
+	if (ret) {
+		eprintf("getnameinfo: %m\n");
+		return 0;
+	}
+	return snprintf(buf, rest, "RDMA IP Address: %s", host);
+}
+
+static void iscsi_rdma_event_modify(struct iscsi_connection *conn, int events)
+{
+	struct conn_info *ci = conn->trans_data;
+
+	if (events & EPOLLOUT) {
+		/* with multiple commands queued, may already be on list */
+		if (list_empty(&ci->conn_tx_ready)) {
+			dprintf("tx ready adding %p\n", ci);
+			list_add(&ci->conn_tx_ready, &conn_tx_ready);
+		}
+		num_tx_ready = 1;
+	} else {
+		dprintf("tx ready removing %p\n", ci);
+		list_del_init(&ci->conn_tx_ready);
+	}
+}
+
+static void *iscsi_rdma_malloc(struct iscsi_connection *iscsi_conn, size_t sz)
+{
+	struct mempool *mem;
+	struct conn_info *ci = iscsi_conn->trans_data;
+	struct iser_device *dev = ci->dev;
+
+	if (list_empty(&dev->mempool_free)) {
+		/* XXX: take slow path: allocate and register */
+		eprintf("free list empty\n");
+		exit(1);
+	}
+
+	if (sz > MEMPOOL_SIZE) {
+		eprintf("size %zu too big\n", sz);
+		exit(1);
+	}
+
+	mem = list_entry(dev->mempool_free.next, typeof(*mem), list);
+	list_del(&mem->list);
+	list_add(&mem->list, &dev->mempool_alloc);
+	dprintf("malloc %p sz %zu\n", mem->buf, sz);
+	return mem->buf;
+}
+
+static void iscsi_rdma_free(struct iscsi_connection *iscsi_conn, void *buf)
+{
+	int found = 0;
+	struct mempool *mem;
+	struct conn_info *ci = iscsi_conn->trans_data;
+	struct iser_device *dev = ci->dev;
+
+	list_for_each_entry(mem, &dev->mempool_alloc, list) {
+		if (mem->buf == buf) {
+			found = 1;
+			break;
+		}
+	}
+	dprintf("free %p\n", mem->buf);
+	if (!found) {
+		eprintf("couldn't locate buf %p\n", buf);
+		exit(1);
+	}
+	list_del(&mem->list);
+	list_add(&mem->list, &dev->mempool_free);
+}
+
+static int iscsi_rdma_getsockname(struct iscsi_connection *conn,
+				  struct sockaddr *sa, socklen_t *len)
+{
+	struct conn_info *ci = conn->trans_data;
+
+	if (*len > sizeof(ci->self_addr))
+		*len = sizeof(ci->self_addr);
+	memcpy(sa, &ci->self_addr, *len);
+	return 0;
+}
+
+static int iscsi_rdma_getpeername(struct iscsi_connection *conn,
+				  struct sockaddr *sa, socklen_t *len)
+{
+	struct conn_info *ci = conn->trans_data;
+
+	if (*len > sizeof(ci->peer_addr))
+		*len = sizeof(ci->peer_addr);
+	memcpy(sa, &ci->peer_addr, *len);
+	return 0;
+}
+
+struct iscsi_transport iscsi_iser = {
+	.name			= "iser",
+	.rdma			= 1,
+	.task_trans_len		= sizeof(struct iser_task),
+	.ep_init		= iscsi_rdma_init,
+	.ep_conn_init		= iscsi_rdma_conn_init,
+	.ep_task_init		= iscsi_iser_task_init,
+	.ep_read		= iscsi_iser_read,
+	.ep_write_begin		= iscsi_iser_write_begin,
+	.ep_write_end		= iscsi_iser_write_end,
+	.ep_rdma_read		= iscsi_rdma_rdma_read,
+	.ep_rdma_write		= iscsi_rdma_rdma_write,
+	.ep_conn_close		= iscsi_rdma_conn_close,
+	.ep_conn_free		= iscsi_rdma_conn_free,
+	.ep_show		= iscsi_rdma_show,
+	.ep_event_modify	= iscsi_rdma_event_modify,
+	.ep_malloc		= iscsi_rdma_malloc,
+	.ep_free		= iscsi_rdma_free,
+	.ep_getsockname		= iscsi_rdma_getsockname,
+	.ep_getpeername		= iscsi_rdma_getpeername,
+};
+
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 54fa9d4..80dfc7a 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -2008,6 +2008,29 @@ int iscsi_tx_handler(struct iscsi_connection *conn)
 			goto out;
 	}
 
+	/*
+	 * For rdma, grab the data-in or r2t packet and covert to
+	 * an RDMA operation.
+	 */
+	if (conn->tp->rdma && conn->state == STATE_SCSI) {
+		switch (conn->rsp.bhs.opcode) {
+		case ISCSI_OP_R2T:
+			ret = conn->tp->ep_rdma_read(conn);
+			if (ret < 0)  /* wait for free slot */
+				goto out;
+			goto finish;
+
+		case ISCSI_OP_SCSI_DATA_IN:
+			ret = conn->tp->ep_rdma_write(conn);
+			if (ret < 0)
+				goto out;
+			goto finish;
+
+		default:
+			break;
+		}
+	}
+
 again:
 	switch (conn->tx_iostate) {
 	case IOSTATE_TX_BHS:
@@ -2100,6 +2123,8 @@ again:
 	}
 
 	conn->tp->ep_write_end(conn);
+
+finish:
 	cmnd_finish(conn);
 
 	switch (conn->state) {
diff --git a/usr/iscsi/transport.c b/usr/iscsi/transport.c
index ba232ed..e17b554 100644
--- a/usr/iscsi/transport.c
+++ b/usr/iscsi/transport.c
@@ -29,6 +29,9 @@
 
 struct iscsi_transport *iscsi_transports[] = {
 	&iscsi_tcp,
+#ifdef ISCSI_RDMA
+	&iscsi_iser,
+#endif
 	NULL,
 };
 
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index f35d9d7..db5beb0 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -19,6 +19,8 @@ struct iscsi_transport {
 	size_t (*ep_write_begin) (struct iscsi_connection *conn, void *buf,
 				  size_t nbytes);
 	void (*ep_write_end) (struct iscsi_connection *conn);
+	int (*ep_rdma_read) (struct iscsi_connection *conn);
+	int (*ep_rdma_write) (struct iscsi_connection *conn);
 	void (*ep_conn_close) (struct iscsi_connection *conn);
 	void (*ep_conn_free) (struct iscsi_connection *conn);
 	int (*ep_show) (struct iscsi_connection *conn, char *buf, int rest);
@@ -32,5 +34,6 @@ struct iscsi_transport {
 };
 
 extern struct iscsi_transport iscsi_tcp;
+extern struct iscsi_transport iscsi_iser;
 
 #endif
-- 
1.5.2.5



From pw at osc.edu  Tue Sep  4 22:19:12 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 4 Sep 2007 16:19:12 -0400
Subject: [Stgt-devel] iSER
In-Reply-To: <20070904032420.GA20306@lemming.cita.utoronto.ca>
References: <20070903132326.GA8441@lemming.cita.utoronto.ca>
	<20070903170223.GA28887@osc.edu>
	<20070904032420.GA20306@lemming.cita.utoronto.ca>
Message-ID: <20070904201912.GA6840@osc.edu>

robin.humble+stgt at anu.edu.au wrote on Mon, 03 Sep 2007 23:24 -0400:
> On Mon, Sep 03, 2007 at 01:02:23PM -0400, Pete Wyckoff wrote:
> >Open-iscsi has no way to specify the RDMA parameters,
> >IntiatorRecvDataSegmentLength or TargetRDSL, that size the control
> >transfer sizes.  You can set them on the target similarly to how you
> >set MRDSL above, but the initiator will insist on 8k TRDSL.  I'll
> >try to generate patches for that some day.  Data sizes are
> >(recently) chosen by the target unilaterally.
> 
> 8k's pretty small. to get ~90% of max bandwidth out of single IB
> messages (at least via verbs) something north of 50-100kB seems to be
> required(*).
> presumably you have multiple messages in flight though? if so then
> maybe a total RDMA buffer of order this size would be enough. I guess
> we'll find out :)

Yeah, small.  The [it]rdsl numbers affect only _control_ type
packets (as I was informed in an earlier thread here).  But these do
include the immediate data and unsolicited data packets, if you have
configured things as such.  For RDMA read/write, it is 512k now, but
see the #define in iscsi_rdma.c if you want to play with it.

I haven't done much testing of throughput vs packet size lately, and
in fact, ripping out the unsignaled completions may have slowed
things down some.  But they were a mess as far as tracking RDMA
resources went.  Would love some help with tuning if you are so
inclined.

		-- Pete


From markh794 at gmail.com  Wed Sep  5 09:54:14 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 05 Sep 2007 17:54:14 +1000
Subject: [Stgt-devel] [Patch 1/1] Add support for VPD pages 80h - ffh
Message-ID: <46DE60A6.8050904@gmail.com>

Re-submit of patch with suggested improvements.

- Added pointer struct target to scsi_lu struct
- Added lu_exit() to free allocation of VPD pages
- Removed osd from test startup script
- Removed osd specific VPD pages B0h and B1h

- Passes checkpatch.pl sanity check.

Thanks
Mark

>From 2a83f45df48d4cc295e1de5fcf302260cffee4cf Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Wed, 5 Sep 2007 06:38:39 +1000
Subject: Add support for VPD pages 0x80 - 0xff

An array of 128 vpd structures added to lu_phy_attr struct.

Use alloc_vpd(data size) to pre-allocate data for custom VPD page.
- This data is appended to the 4 byte VPD header at runtime.
  i.e. When an INQUIRY with EVPD bit set.

- Only VPD pages 80h and 83h have been implemented at this point.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/mmc.c    |    1 +
 usr/osd.c    |    1 +
 usr/sbc.c    |    1 +
 usr/scc.c    |    1 +
 usr/smc.c    |    3 +-
 usr/spc.c    |  232 ++++++++++++++++++++++++++++++++++++++++++++++------------
 usr/spc.h    |    2 +
 usr/target.c |   11 +--
 usr/tgtd.h   |   16 +++-
 9 files changed, 210 insertions(+), 58 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index 7f70943..0a0c033 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -177,6 +177,7 @@ static struct device_type_template mmc_template = {
 	.type		= TYPE_ROM,
 	.lu_init	= mmc_lu_init,
 	.lu_config	= spc_lu_config,
+	.lu_exit	= spc_lu_exit,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/osd.c b/usr/osd.c
index 189fba4..ef45393 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -73,6 +73,7 @@ static struct device_type_template osd_template = {
 	.type		= TYPE_OSD,
 	.lu_init	= osd_lu_init,
 	.lu_config	= spc_lu_config,
+	.lu_exit	= spc_lu_exit,
 	.ops		= {
 		/* 0x00 */
 		{spc_test_unit,},
diff --git a/usr/sbc.c b/usr/sbc.c
index 33485e6..d862e6b 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -214,6 +214,7 @@ static struct device_type_template sbc_template = {
 	.type		= TYPE_DISK,
 	.lu_init	= sbc_lu_init,
 	.lu_config	= spc_lu_config,
+	.lu_exit	= spc_lu_exit,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/scc.c b/usr/scc.c
index 0a154a5..c55ae3d 100644
--- a/usr/scc.c
+++ b/usr/scc.c
@@ -54,6 +54,7 @@ static struct device_type_template scc_template = {
 	.type		= TYPE_RAID,
 	.lu_init	= scc_lu_init,
 	.lu_config	= spc_lu_config,
+	.lu_exit	= spc_lu_exit,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/smc.c b/usr/smc.c
index 4f0ee4b..df38b25 100644
--- a/usr/smc.c
+++ b/usr/smc.c
@@ -445,7 +445,8 @@ static int smc_lu_init(struct scsi_lu *lu)
 	else
 		return -ENOMEM;
 
-	spc_lu_init(lu);
+	if (spc_lu_init(lu))
+		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "VIRTUAL-CHANGER",
 						sizeof(lu->attrs.product_id));
diff --git a/usr/spc.c b/usr/spc.c
index ad71e4a..3b2c553 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -20,6 +20,7 @@
  * 02110-1301 USA
  */
 #include <errno.h>
+#include <inttypes.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -38,6 +39,96 @@
 #define PRODUCT_REV	"0"
 #define BLK_SHIFT	9
 
+/** Protocol Identifier Values
+ * 0 Fibre Channel (FCP-2)
+ * 1 Parallel SCSI (SPI-5)
+ * 2 SSA (SSA-S3P)
+ * 3 IEEE 1394 (SBP-3)
+ * 4 SCSI Remote Direct Memory Access (SRP)
+ * 5 iSCSI
+ * 6 SAS Serial SCSI Protocol (SAS)
+ * 7 Automation/Drive Interface (ADT)
+ * 8 AT Attachment Interface (ATA/ATAPI-7)
+ */
+#define PIV_FCP 0
+#define PIV_SPI 1
+#define PIV_S3P 2
+#define PIV_SBP 3
+#define PIV_SRP 4
+#define PIV_ISCSI 5
+#define PIV_SAS 6
+#define PIV_ADT 7
+#define PIV_ATA 8
+
+#define PIV_VALID 0x80
+
+/** Code Set
+ *  1 - Designator fild contains binary values
+ *  2 - Designator field contains ASCII printable chars
+ *  3 - Designaotor field contains UTF-8
+ */
+#define INQ_CODE_BIN 1
+#define INQ_CODE_ASCII 2
+#define INQ_CODE_UTF8 3
+
+/** Association field
+ * 00b - Associated with Logical Unit
+ * 01b - Associated with target port
+ * 10b - Associated with SCSI Target device
+ * 11b - Reserved
+ */
+#define ASS_LU	0
+#define ASS_TGT_PORT 0x10
+#define ASS_TGT_DEV 0x20
+
+/** Designator type - SPC-4 Reference
+ * 0 - Vendor specific - 7.6.3.3
+ * 1 - T10 vendor ID - 7.6.3.4
+ * 2 - EUI-64 - 7.6.3.5
+ * 3 - NAA - 7.6.3.6
+ * 4 - Relative Target port identifier - 7.6.3.7
+ * 5 - Target Port group - 7.6.3.8
+ * 6 - Logical Unit group - 7.6.3.9
+ * 7 - MD5 logical unit identifier - 7.6.3.10
+ * 8 - SCSI name string - 7.6.3.11
+ */
+#define DESG_VENDOR 0
+#define DESG_T10 1
+#define DESG_EUI64 2
+#define DESG_NAA 3
+#define DESG_REL_TGT_PORT 4
+#define DESG_TGT_PORT_GRP 5
+#define DESG_LU_GRP 6
+#define DESG_MD5 7
+#define DESG_SCSI 8
+
+static int valid_vpd(struct vpd **lu_vpd, uint8_t page)
+{
+	if (lu_vpd[page & 0x7f])
+		return 1;
+	return 0;
+}
+
+void update_vpd_80(struct scsi_lu *lu, void *sn)
+{
+	struct vpd *vpd_pg = lu->attrs.lu_vpd[0];
+	char *data = (char *)vpd_pg->data;
+
+	snprintf(data, SCSI_SN_LEN, "%-8s", (char *)sn);
+}
+
+void update_vpd_83(struct scsi_lu *lu, void *id)
+{
+	struct vpd *vpd_pg = lu->attrs.lu_vpd[3];
+	uint8_t	*data = vpd_pg->data;
+
+	data[0] = (PIV_ISCSI << 4) | INQ_CODE_ASCII;
+	data[1] = PIV_VALID | ASS_TGT_PORT | DESG_VENDOR;
+	data[3] = SCSI_ID_LEN;
+
+	strncpy((char *)data + 4, id, SCSI_ID_LEN);
+}
+
 int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int len = 0, ret = SAM_STAT_CHECK_CONDITION;
@@ -47,6 +138,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 	uint8_t devtype = 0;
 	struct lu_phy_attr *attrs;
+	struct vpd *vpd_pg;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
@@ -98,43 +190,35 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	} else if (scb[1] & 0x1) {
 		/* EVPD bit set */
 		if (scb[2] == 0x0) {
+			int i, j, tmp;
+
+			i = 5;
+			tmp = 1;
 			data[0] = devtype;
-			data[1] = 0x0;
-			data[3] = 3;
+			data[1] = 0;
+			data[2] = 0;
+			for (j = 0; j < 0x80; j++) {
+				if (attrs->lu_vpd[j]) {
+					data[i] = j | 0x80;
+					tmp++;
+					i++;
+				}
+			}
+			data[3] = tmp;
 			data[4] = 0x0;
-			data[5] = 0x80;
-			data[6] = 0x83;
-			len = 7;
+			len = tmp + 4;
 			ret = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x80) {
-			int tmp = SCSI_SN_LEN;
-
-			data[1] = 0x80;
-			data[3] = SCSI_SN_LEN;
-			memset(data + 4, 0x20, 4);
-			len = 4 + SCSI_SN_LEN;
-			ret = SAM_STAT_GOOD;
-
-			if (strlen(attrs->scsi_sn)) {
-				uint8_t *p;
-				char *q;
+		} else if (valid_vpd(attrs->lu_vpd, scb[2])) {
+			int tmp;
+			vpd_pg = attrs->lu_vpd[scb[2] & 0x7f];
+			tmp = vpd_pg->size;
 
-				p = data + 4 + tmp - 1;
-				q = attrs->scsi_sn + SCSI_SN_LEN - 1;
-				for (; tmp > 0; tmp--, q)
-					*(p--) = *(q--);
-			}
-		} else if (scb[2] == 0x83) {
-			int tmp = SCSI_ID_LEN;
-
-			data[1] = 0x83;
-			data[3] = tmp + 4;
-			data[4] = 0x1;
-			data[5] = 0x1;
-			data[7] = tmp;
-			strncpy((char *) data + 8, attrs->scsi_id, SCSI_ID_LEN);
-
-			len = tmp + 8;
+			data[0] = devtype;
+			data[1] = scb[2];
+			data[2] = (tmp >> 8);
+			data[3] = tmp & 0xff;
+			memcpy(&data[4], vpd_pg->data, tmp);
+			len = tmp + 4;
 			ret = SAM_STAT_GOOD;
 		}
 	}
@@ -358,6 +442,19 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 }
 
+struct vpd *alloc_vpd(uint16_t size)
+{
+	struct vpd *vpd_pg;
+
+	vpd_pg = zalloc(sizeof(struct vpd) + size);
+	if (!vpd_pg)
+		return NULL;
+
+	vpd_pg->size = size;
+
+	return vpd_pg;
+}
+
 static struct mode_pg *alloc_mode_pg(uint8_t pcode, uint8_t subpcode,
 				     uint16_t size)
 {
@@ -500,6 +597,11 @@ int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
 	int err = TGTADM_SUCCESS;
 	char *p;
 	char buf[256];
+	struct lu_phy_attr *attrs;
+	struct vpd **lu_vpd;
+
+	attrs = &lu->attrs;
+	lu_vpd = attrs->lu_vpd;
 
 	if (!strncmp("targetOps", params, 9))
 		params = params + 10;
@@ -512,36 +614,38 @@ int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_scsi_id:
-			match_strncpy(lu->attrs.scsi_id, &args[0],
-				      sizeof(lu->attrs.scsi_id));
+			match_strncpy(attrs->scsi_id, &args[0],
+						sizeof(attrs->scsi_id));
+			lu_vpd[3]->vpd_update(lu, attrs->scsi_id);
 			break;
 		case Opt_scsi_sn:
-			match_strncpy(lu->attrs.scsi_sn, &args[0],
-				      sizeof(lu->attrs.scsi_sn));
+			match_strncpy(attrs->scsi_sn, &args[0],
+						sizeof(attrs->scsi_sn));
+			lu_vpd[0]->vpd_update(lu, attrs->scsi_sn);
 			break;
 		case Opt_vendor_id:
-			match_strncpy(lu->attrs.vendor_id, &args[0],
-				      sizeof(lu->attrs.vendor_id));
+			match_strncpy(attrs->vendor_id, &args[0],
+						sizeof(attrs->vendor_id));
 			break;
 		case Opt_product_id:
-			match_strncpy(lu->attrs.product_id, &args[0],
-				      sizeof(lu->attrs.product_id));
+			match_strncpy(attrs->product_id, &args[0],
+						sizeof(attrs->product_id));
 			break;
 		case Opt_product_rev:
-			match_strncpy(lu->attrs.product_rev, &args[0],
-				      sizeof(lu->attrs.product_rev));
+			match_strncpy(attrs->product_rev, &args[0],
+						sizeof(attrs->product_rev));
 			break;
 		case Opt_sense_format:
 			match_strncpy(buf, &args[0], sizeof(buf));
-			lu->attrs.sense_format = atoi(buf);
+			attrs->sense_format = atoi(buf);
 			break;
 		case Opt_removable:
 			match_strncpy(buf, &args[0], sizeof(buf));
-			lu->attrs.removable = atoi(buf);
+			attrs->removable = atoi(buf);
 			break;
 		case Opt_online:
 			match_strncpy(buf, &args[0], sizeof(buf));
-			lu->attrs.online = atoi(buf);
+			attrs->online = atoi(buf);
 			break;
 		case Opt_mode_page:
 			match_strncpy(buf, &args[0], sizeof(buf));
@@ -561,10 +665,34 @@ int spc_lu_config(struct scsi_lu *lu, char *params)
 
 int spc_lu_init(struct scsi_lu *lu)
 {
+	struct vpd **lu_vpd = lu->attrs.lu_vpd;
+	struct target *tgt = lu->tgt;
+	int pg;
+
+	lu->attrs.device_type = lu->dev_type_template.type;
+	lu->attrs.qualifier = 0x0;
+
 	snprintf(lu->attrs.vendor_id, sizeof(lu->attrs.vendor_id),
 		 "%-16s", VENDOR_ID);
 	snprintf(lu->attrs.product_rev, sizeof(lu->attrs.product_rev),
 		 "%s", "0001");
+	snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
+		 "deadbeaf%d:%" PRIu64, tgt->tid, lu->lun);
+	snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
+		 "beaf%d%" PRIu64, tgt->tid, lu->lun);
+
+	/* VPD page 0x80 */
+	pg = 0x80 & 0x7f;
+	lu_vpd[pg] = alloc_vpd(SCSI_SN_LEN);
+	lu_vpd[pg]->vpd_update = update_vpd_80;
+	lu_vpd[pg]->vpd_update(lu, lu->attrs.scsi_sn);
+
+	/* VPD page 0x83 */
+	pg = 0x83 & 0x7f;
+	lu_vpd[pg] = alloc_vpd(SCSI_ID_LEN + 4); /* +Designator descriptor len*/
+	lu_vpd[pg]->vpd_update = update_vpd_83;
+	lu_vpd[pg]->vpd_update(lu, lu->attrs.scsi_id);
+
 	lu->attrs.removable = 0;
 	lu->attrs.sense_format = 0;
 	lu->attrs.online = 0;
@@ -572,3 +700,15 @@ int spc_lu_init(struct scsi_lu *lu)
 
 	return 0;
 }
+
+void spc_lu_exit(struct scsi_lu *lu)
+{
+	int i;
+	struct vpd **lu_vpd = lu->attrs.lu_vpd;
+
+	for (i = 0; i < 0x80; i++)
+		if (lu_vpd[i])
+			free(lu_vpd[i]);
+
+}
+
diff --git a/usr/spc.h b/usr/spc.h
index 1cc8623..dfb8987 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -12,8 +12,10 @@ extern int spc_lu_init(struct scsi_lu *lu);
 typedef int (match_fn_t)(struct scsi_lu *lu, char *params);
 extern int lu_config(struct scsi_lu *lu, char *params, match_fn_t *);
 extern int spc_lu_config(struct scsi_lu *lu, char *params);
+extern void spc_lu_exit(struct scsi_lu *lu);
 extern void dump_cdb(struct scsi_cmd *cmd);
 extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
 extern int add_mode_page(struct scsi_lu *lu, char *params);
+extern struct vpd *alloc_vpd(uint16_t size);
 
 #endif
diff --git a/usr/target.c b/usr/target.c
index 2474d05..22eec0b 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -261,12 +261,14 @@ int tgt_device_create(int tid, int dev_type, uint64_t lun, char *args, int backi
 		goto free_lu;
 	}
 
+	lu->tgt = target;
+
 	lu->lun = lun;
 	lu->lu_state = SCSI_LU_RUNNING;
 	tgt_cmd_queue_init(&lu->cmd_queue);
 
  	if (lu->dev_type_template.lu_init) {
- 		ret = lu->dev_type_template.lu_init(lu);
+		ret = lu->dev_type_template.lu_init(lu);
 		if (ret)
 			goto free_lu;
 	}
@@ -285,13 +287,6 @@ int tgt_device_create(int tid, int dev_type, uint64_t lun, char *args, int backi
 			goto free_lu;
 	}
 
-	lu->attrs.device_type = lu->dev_type_template.type;
-	lu->attrs.qualifier = 0x0;
-	snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
-		 "deadbeaf%d:%" PRIu64, tid, lun);
-	snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
-		 "beaf%d%" PRIu64, tid, lun);
-
 	if (tgt_drivers[target->lid]->lu_create)
 		tgt_drivers[target->lid]->lu_create(lu);
 
diff --git a/usr/tgtd.h b/usr/tgtd.h
index c39b9c2..45bd8f6 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -36,6 +36,15 @@ struct tgt_cmd_queue {
 	struct list_head queue;
 };
 
+struct scsi_lu;
+struct scsi_cmd;
+
+struct vpd {
+	uint16_t size;
+	void (*vpd_update)(struct scsi_lu *lu, void *data);
+	uint8_t data[0];
+};
+
 struct lu_phy_attr {
 	char scsi_id[SCSI_ID_LEN + 1];
 	char scsi_sn[SCSI_SN_LEN + 1];
@@ -52,10 +61,9 @@ struct lu_phy_attr {
 	char online;		/* Logical Unit online */
 	char reset;		/* Power-on or reset has occured */
 	char sense_format;	/* Descrptor format sense data supported */
-};
 
-struct scsi_lu;
-struct scsi_cmd;
+	struct vpd *lu_vpd[0x80]; /* VPD pages 0x80 -> 0xff masked with 0x80*/
+};
 
 struct device_type_operations {
 	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
@@ -109,6 +117,8 @@ struct scsi_lu {
 
 	struct backingstore_template *bst;
 
+	struct target *tgt;
+
 	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
 	struct mode_pg *mode_pgs[0x3f];
 
-- 
1.5.2.3






From robin.humble+stgt at anu.edu.au  Wed Sep  5 16:46:18 2007
From: robin.humble+stgt at anu.edu.au (Robin Humble)
Date: Wed, 5 Sep 2007 10:46:18 -0400
Subject: [Stgt-devel] iSER
In-Reply-To: <20070904201912.GA6840@osc.edu>
References: <20070903132326.GA8441@lemming.cita.utoronto.ca>
	<20070903170223.GA28887@osc.edu>
	<20070904032420.GA20306@lemming.cita.utoronto.ca>
	<20070904201912.GA6840@osc.edu>
Message-ID: <20070905144618.GA26761@lemming.cita.utoronto.ca>

On Tue, Sep 04, 2007 at 04:19:12PM -0400, Pete Wyckoff wrote:
>I haven't done much testing of throughput vs packet size lately, and
>in fact, ripping out the unsignaled completions may have slowed
>things down some.  But they were a mess as far as tracking RDMA
>resources went.  Would love some help with tuning if you are so
>inclined.

the good news:

I'm not seeing any of the iSER resource starvation/flow control
problems I was seeing before. with latest git://git.osc.edu/tgt that
looks to be fixed.

so, trying out a few speed tests ->

bypassing the page cache (and readahead?) with O_DIRECT:
 eg. dd if=/dev/zero of=/dev/sdc bs=1k count=8000 oflag=direct
   bs   write MB/s read MB/s
  10M     1200      520
   1M      790      460
 200k      480      350
   4k       40       34
   1k       11        9
large writes look fabulous, but reads seem to be limited by something
other than IB bandwidth.

in the more usual usage case via the page cache:
 eg. dd if=/dev/zero of=/dev/sdc bs=1k count=8000000 
   bs   write MB/s read MB/s
  10M     1100      260
   1M     1100      270
   4k      960      270
   1k       30      240
so maybe extra copies to/from page cache are getting in the way of the
read bandwidth and are lowering it by a factor of 2.
I'm guessing the good small block read performance here is due to
readahead, and the mostly better writes are from aggregation.

setup is DDR IB, 2.6.22.6 kernel, centos5 x86_64 with ofed 1.2
userland, server with 7G ramfs backing store, single client with
mem=512M.

the bad news:

if I make an ext3 filesystem on the iSER device and then dd a few G to
a file in the filesystem then I very quickly get an ext3 shutdown.
  Sep  5 23:06:03 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 393216, length 1
  Sep  5 23:06:03 x11 kernel: Aborting journal on device sdc.
  Sep  5 23:06:03 x11 kernel: ext3_abort called.
  Sep  5 23:06:03 x11 kernel: EXT3-fs error (device sdc): ext3_journal_start_sb: Detected aborted journal
  Sep  5 23:06:03 x11 kernel: Remounting filesystem read-only
  Sep  5 23:06:03 x11 kernel: EXT3-fs error (device sdc): ext3_free_blocks: Freeing blocks in system zones - Block = 393216, count = 1
  Sep  5 23:06:03 x11 kernel: EXT3-fs error (device sdc) in ext3_free_blocks_sb: Journal has aborted
  Sep  5 23:06:03 x11 kernel: __journal_remove_journal_head: freeing b_committed_data

if I leave out the iSER setup steps and use IPoIB instead then it works ok.
I tried with a centos kernel and ofed1.1, and also 2.6.22.6 and ofed1.2.

the above error message is from the centos kernel. 2.6.22.6 generates these:
  Sep  5 23:48:33 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 164279, length 1
  Sep  5 23:48:33 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 164280, length 1
  Sep  5 23:48:33 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 164281, length 1
  Sep  5 23:48:33 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 164282, length 1
  Sep  5 23:48:33 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 164283, length 1
  Sep  5 23:48:33 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 164284, length 1
  Sep  5 23:48:33 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 164285, length 1
  ... and many more

which looks a bit like a miscommunication of the size/geometry of the
device? or maybe corruption? :-/ the dd's were all smaller (few G) than
the size of the filesystem (6+G) so it wasn't running out of space.

cheers,
robin


From erezz at Voltaire.COM  Thu Sep  6 12:00:02 2007
From: erezz at Voltaire.COM (Erez Zilber)
Date: Thu, 06 Sep 2007 13:00:02 +0300
Subject: [Stgt-devel] iSER
In-Reply-To: <20070905144618.GA26761@lemming.cita.utoronto.ca>
References: <20070903132326.GA8441@lemming.cita.utoronto.ca>	<20070903170223.GA28887@osc.edu>	<20070904032420.GA20306@lemming.cita.utoronto.ca>	<20070904201912.GA6840@osc.edu>
	<20070905144618.GA26761@lemming.cita.utoronto.ca>
Message-ID: <46DFCFA2.3030101@Voltaire.COM>


> if I leave out the iSER setup steps and use IPoIB instead then it works ok.
> I tried with a centos kernel and ofed1.1, and also 2.6.22.6 and ofed1.2.
>
>   
I suggest that you use OFED 1.2 on the initiator side. It has many bug 
fixes (compared to OFED 1.1). Also, note that open-iscsi over iSER in 
OFED 1.2 is supported only on the following distros: SLES 10, RHEL4 
up3-up5 & RHEL 5. Other distros were not tested (although they might work).

Erez


From nezhinsky at gmail.com  Thu Sep  6 14:22:08 2007
From: nezhinsky at gmail.com (Alexander Nezhinsky)
Date: Thu, 6 Sep 2007 15:22:08 +0300
Subject: [Stgt-devel] iSER patches, second release
In-Reply-To: <20070904200548.GD6578@osc.edu>
References: <20070904200548.GD6578@osc.edu>
Message-ID: <5eb093080709060522t7694baa9w18d7872d3ab28821@mail.gmail.com>

Pete,

I have a few questions regarding the code. I'll post them in different mails.

In handle_wc() in case of IBV_WC_RECV, iscsi_rx_handler() gets called and
the received pdu is passed as an implicit parameter, through
ci->rcv_comm_event.
Only then it gets reposted.

First, the parameter passing method somewhat bothers me because it seems
that on a SMP system two RECV completions may arrive through different
CPUs and then we end up with garbage in ci->rcv_comm_event.
Do I miss anything on this? Are all completions handled by the same CPU?
Is there an implicit guard somewhere?

Second, it looks like iscsi_rx_handler() will eventually copy the pdu data.
Even if set to a small value, if the traffic consists only of such small writes
it will be copied entirely.

Third, reposting is postponed until iscsi handles the rx event.

I'd suggest:
a. to add the rx descriptor to a list and have  iscsi_rx_handler() to feed upon
this list which may be guarded if necessary
b. to repost a different rx buffer - so it gets reposted as soon as possible -
and meanwhile...
c. not to copy the current one - but instead use it by reference all
the way down
the target, just as you do with the rdma buffers.

This may increase the number of resources to allocate but this may improve
the performance, at least in some cases.

Alexander Nezhisnky


From pw at osc.edu  Thu Sep  6 22:10:28 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 6 Sep 2007 16:10:28 -0400
Subject: [Stgt-devel] iSER patches, second release
In-Reply-To: <5eb093080709060522t7694baa9w18d7872d3ab28821@mail.gmail.com>
References: <20070904200548.GD6578@osc.edu>
	<5eb093080709060522t7694baa9w18d7872d3ab28821@mail.gmail.com>
Message-ID: <20070906201028.GC14234@osc.edu>

nezhinsky at gmail.com wrote on Thu, 06 Sep 2007 15:22 +0300:
> I have a few questions regarding the code. I'll post them in different mails.

Thanks for looking this over.

> In handle_wc() in case of IBV_WC_RECV, iscsi_rx_handler() gets called and
> the received pdu is passed as an implicit parameter, through
> ci->rcv_comm_event.
> Only then it gets reposted.
> 
> First, the parameter passing method somewhat bothers me because it seems
> that on a SMP system two RECV completions may arrive through different
> CPUs and then we end up with garbage in ci->rcv_comm_event.
> Do I miss anything on this? Are all completions handled by the same CPU?
> Is there an implicit guard somewhere?

Yes, it bothers me a bit too.  There is some mismatch in how iscsi
wants to read bytes when it needs them:  48 first, then look for AHS
and possible read those, then maybe some immediate data.  Three
separate read(fd, ...) for one control PDU.  On the other hand, RDMA
gets all the data in one go.  So we compromise by feeding the bytes
into iscsi via memcpy for each of its small do_recv operations.

It would be possible to have a separate RX state machine just for
RDMA, but we didn't want to diverge the code so much.  I think this
way works, although Robin points out that there are bugs somewhere.

The iscsi code is not multi-threaded.  So only one handle_wc() will
ever be in progress.  And iscsi_rx_handler() always consumes the
bhs, ahs, and data completely.  See the "goto again" in there.  We don't
have to worry about partially consumed control PDU for different
tasks.  This would all break if we went multithreaded in the iscsi
core itself.  I'm not sure anyone needs multithreading at that
level---we already do support it at the backing store level, which
is where it probably makes most sense.

> Second, it looks like iscsi_rx_handler() will eventually copy the pdu data.
> Even if set to a small value, if the traffic consists only of such small writes
> it will be copied entirely.

Yes, up to TRDSL will be fully copied.  That's 8 kB now in linux
iser, but you could imagine wanting it bigger for better small
transfer performance.  If you enable unsolicited data, up to that
amount will be copied.  Ick.

> Third, reposting is postponed until iscsi handles the rx event.

Not so bothered about that.  We post receives to accommodate max
outstanding requests on the client.  It's hardcoded now, but should
be fixed (in the initiator) to be negotiated.  The receive slot
will not be reused until the initiator sees the response.

> I'd suggest:
> a. to add the rx descriptor to a list and have  iscsi_rx_handler() to feed upon
> this list which may be guarded if necessary
> b. to repost a different rx buffer - so it gets reposted as soon as possible -
> and meanwhile...
> c. not to copy the current one - but instead use it by reference all
> the way down
> the target, just as you do with the rdma buffers.
> 
> This may increase the number of resources to allocate but this may improve
> the performance, at least in some cases.

You may end up paying more overhead for the management, though.
Agreed saving the 8 kB memcpy (or maybe larger) may be a good idea,
but there is some complexity with keeping the data in the original
recvl buffer.  See how iscsi_scsi_cmd_rx_start() allocates the task
and ahs and data all in one go.  This can be modified, but I want to
avoid lots of "if (rdma)" cases.  And remember that TCP doesn't have
message boundaries, so things need to work when you get the 48-byte
BHS first then go back and read the rest, perhaps in multiple
1500-byte read statements across separate poll() iterations.

If you get interested in writing a slim queueing layer between TCP
or RDMA receive processing, and iscsi rx processing, I'll certainly
help and try to get it integrated.

		-- Pete


From robin.humble+stgt at anu.edu.au  Fri Sep  7 12:10:10 2007
From: robin.humble+stgt at anu.edu.au (Robin Humble)
Date: Fri, 7 Sep 2007 06:10:10 -0400
Subject: [Stgt-devel] iSER
In-Reply-To: <46DFCFA2.3030101@Voltaire.COM>
References: <20070903132326.GA8441@lemming.cita.utoronto.ca>
	<20070903170223.GA28887@osc.edu>
	<20070904032420.GA20306@lemming.cita.utoronto.ca>
	<20070904201912.GA6840@osc.edu>
	<20070905144618.GA26761@lemming.cita.utoronto.ca>
	<46DFCFA2.3030101@Voltaire.COM>
Message-ID: <20070907101010.GA24150@lemming.cita.utoronto.ca>

On Thu, Sep 06, 2007 at 01:00:02PM +0300, Erez Zilber wrote:
>rjh wrote:
>>if I leave out the iSER setup steps and use IPoIB instead then it works ok.
>>I tried with a centos kernel and ofed1.1, and also 2.6.22.6 and ofed1.2.
>I suggest that you use OFED 1.2 on the initiator side. It has many bug 
>fixes (compared to OFED 1.1).

I only used ofed1.1 with some of the tests (those with orig centos5
kernels) and saw the problem with both ofed1.1 and ofed1.2.

but thanks - I'll definitely stick to just ofed1.2 from now on.

>Also, note that open-iscsi over iSER in 
>OFED 1.2 is supported only on the following distros: SLES 10, RHEL4 
>up3-up5 & RHEL 5. Other distros were not tested (although they might work).

I'm using centos5 == rhel5.

the ofed1.2 userland I'm using is from here:
  http://people.redhat.com/dledford/Infiniband/openib/1.2/1.el5/x86_64/
and I've tried kernel.org 2.6.22.6 and also RedHat's ofed1.2 kernels:
  http://people.redhat.com/dledford/Infiniband/kernel/2.6.18/32.el5/x86_64/

the changelog in the userland .src.rpm says:
  * Wed Jun 27 2007 Doug Ledford <dledford at redhat.com> 1.2-1
  - Update to final OFED 1.2 release

so hopefully that is a recent enough OFED?

cheers,
robin


From nezhinsky at gmail.com  Sat Sep  8 13:49:54 2007
From: nezhinsky at gmail.com (Alexander Nezhinsky)
Date: Sat, 8 Sep 2007 13:49:54 +0200
Subject: [Stgt-devel] iSER patches, second release
In-Reply-To: <20070906201028.GC14234@osc.edu>
References: <20070904200548.GD6578@osc.edu>
	<5eb093080709060522t7694baa9w18d7872d3ab28821@mail.gmail.com>
	<20070906201028.GC14234@osc.edu>
Message-ID: <5eb093080709080449u6fdbe443h2d11cbcec227db31@mail.gmail.com>

> There is some mismatch in how iscsi
> wants to read bytes when it needs them:  48 first, then look for AHS
> and possible read those, then maybe some immediate data.  Three
> separate read(fd, ...) for one control PDU.  On the other hand, RDMA
> gets all the data in one go.  So we compromise by feeding the bytes
> into iscsi via memcpy for each of its small do_recv operations.
>
> It would be possible to have a separate RX state machine just for
> RDMA, but we didn't want to diverge the code so much.  I think this
> way works, although Robin points out that there are bugs somewhere.

I believe that it is more efficient and flexible to separate the flows between
the transports on a slightly higher level than the basic operations like
polling, reading bytes from stream, malloc etc.

I suggest doing the separation by encapsulating some coarser grained ops,
that have application-level meaning. In case of iser/tcp iscsi, these
should be,
in principle: allocate/free iscsi and/or transport task; receive PDU; send
PDU etc.

For example, right now there are .ep_read per-transport function pointers.
They "know" nothing about PDUs, only about streams and bytes,
and as such are problematic for iser which is not stream based.

If there were per-transport .rx_pdu method, there would be no need to use
checks like "if(rdma)". TCP might use the code it uses today within its own
implementation, reading PDU by chunks, while iser might push the entire
pdu and tweak the RX state machine forcing it into a correct final state.

But here we run into another problem.
iscsi/tcp "pulls" PDUs from stream byte-by-byte, while iscsi/iser "pushes"
PDUs when they are received. So tcp would prefer a method that reads,
while iser would ask for a callback that notifies.

A common denominator can be found for these, but you are right,
encapsulating "the big thing" now will lead to virtually separate
state machines.
Thus, to minimize changes in the existing code, i'd suggest doing
something in the middle:
defining a per-transport method, which corresponds more or less to
what the function do_recv() does today.

That is, the RX state machine code still asks to read the PDUs by chunks,
but these chunks are requested by type, not merely by size.
This way, tcp will read bytes from the stream, while iser will only
manipulate pointers, setting them to the correct locations within the
receive buffer. We retain the RX state-machine code almost as is.
The only changes necessary there are related to the pointers like
conn->rx_buffer, which  probably  should be moved into the tcp
realization of .do_read. Perhaps, bhs may be also referenced by pointer.
But this is it, more or less.

Another example of making a coarse-grain separation is allocation & release
of iscsi tasks. I wanted to write a separate mail about it but this fits the
current discussion.

Function conn->tp->ep_free() gets called only in iscsi_free_task(), separately
for the data and the descriptor. Because the data buffer has no identification
attached, it must be looked for through the list of the buffers, for iser.

If we make task_free() a transport-specific pointer, instead, no
overhead is incurred.
iscsi will use free(), while iser will return the buffer to the list
without searching.
Of course task_alloc() should also be turned into a per-transport method,
after it is called some basic initializations are done on the common level,
in iscsid.c. It looks that if done this way, there is no need for
ep_free/ep_maloc
anymore.

> This would all break if we went multithreaded in the iscsi
> core itself.  I'm not sure anyone needs multithreading at that
> level---we already do support it at the backing store level, which
> is where it probably makes most sense.

First, one could spread different connections' handling between CPUs,
which may make some sense if multiple initiators are working with the
target. And, second, an unsafe code can sometimes break in ways
quite unexpected at the time it was written, during the system's evolution.

> Yes, up to TRDSL will be fully copied.  That's 8 kB now in linux
> iser, but you could imagine wanting it bigger for better small
> transfer performance.  If you enable unsolicited data, up to that
> amount will be copied.

So it does pay to eliminate the unsolicited data copy.

> > Third, reposting is postponed until iscsi handles the rx event.
>
> Not so bothered about that.  We post receives to accommodate max
> outstanding requests on the client.  It's hardcoded now, but should
> be fixed (in the initiator) to be negotiated.  The receive slot
> will not be reused until the initiator sees the response.

Agree.
This is actually more related to the interplay between the
mechanism of resource allocation and the mechanism of generation
of MaxCmdSN sent to the initiator, as this is the real control of max
outstanding cmds.

> See how iscsi_scsi_cmd_rx_start() allocates the task
> and ahs and data all in one go.  This can be modified, but I want to
> avoid lots of "if (rdma)" cases.  And remember that TCP doesn't have
> message boundaries, so things need to work when you get the 48-byte
> BHS first then go back and read the rest, perhaps in multiple
> 1500-byte read statements across separate poll() iterations.

It seems that what i have suggested about turning do_read() into a
per-transport method solves this problem, doesn't it?

> If you get interested in writing a slim queueing layer between TCP
> or RDMA receive processing, and iscsi rx processing, I'll certainly
> help and try to get it integrated.

I do want to contribute, both with the PDU queuing and with implementing
my suggestion above, if we agree on it or on another alternative.

Alexander


From pw at osc.edu  Sat Sep  8 21:02:35 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 8 Sep 2007 15:02:35 -0400
Subject: [Stgt-devel] iSER patches, second release
In-Reply-To: <5eb093080709080449u6fdbe443h2d11cbcec227db31@mail.gmail.com>
References: <20070904200548.GD6578@osc.edu>
	<5eb093080709060522t7694baa9w18d7872d3ab28821@mail.gmail.com>
	<20070906201028.GC14234@osc.edu>
	<5eb093080709080449u6fdbe443h2d11cbcec227db31@mail.gmail.com>
Message-ID: <20070908190235.GC20397@osc.edu>

nezhinsky at gmail.com wrote on Sat, 08 Sep 2007 13:49 +0200:
> Thus, to minimize changes in the existing code, i'd suggest doing
> something in the middle:
> defining a per-transport method, which corresponds more or less to
> what the function do_recv() does today.
> 
> That is, the RX state machine code still asks to read the PDUs by chunks,
> but these chunks are requested by type, not merely by size.
> This way, tcp will read bytes from the stream, while iser will only
> manipulate pointers, setting them to the correct locations within the
> receive buffer. We retain the RX state-machine code almost as is.
> The only changes necessary there are related to the pointers like
> conn->rx_buffer, which  probably  should be moved into the tcp
> realization of .do_read. Perhaps, bhs may be also referenced by pointer.
> But this is it, more or less.

I agree with your analysis.  This does seem like the right
compromise between totally rewriting the state machine and doing the
byte-wise copy in iser we do now.  Conceptually to iscsid, the
difference is that do_read (please rename) can return more than you
asked for.  In iser, we'll hang the recv pdu on the task, in-place, and
adjust ahs, data pointers into it.  For tcp, we'll alloc new space
for ahs and data then call do_read more to copy the bytes in.
Hopefully this can all be abstracted out nicely.

As a side note, I could almost be convinced that having an iser-only
rx state machine would be appropriate.  6 of the 11 states have to
do with digests, which we will never see in iser.  And iser doesn't
need to track rx_iostate at all:  it gets all bhs, ahs, immed data
in one go.  Similar arguments for the tx state machine.  In case you
change your mind about keeping the current state machines, once you
get into the actual implementation.

> Another example of making a coarse-grain separation is allocation & release
> of iscsi tasks. I wanted to write a separate mail about it but this fits the
> current discussion.
> 
> Function conn->tp->ep_free() gets called only in iscsi_free_task(), separately
> for the data and the descriptor. Because the data buffer has no identification
> attached, it must be looked for through the list of the buffers, for iser.
> 
> If we make task_free() a transport-specific pointer, instead, no
> overhead is incurred.
> iscsi will use free(), while iser will return the buffer to the list
> without searching.
> Of course task_alloc() should also be turned into a per-transport method,
> after it is called some basic initializations are done on the common level,
> in iscsid.c. It looks that if done this way, there is no need for
> ep_free/ep_maloc
> anymore.

I like your idea about getting rid of ep_malloc and ep_free.  That
is the wrong level to do the abstraction.  But watch out for
bidi_uaddr.  You don't know the size of the read buffer in a
bidirectional command until the AHS has been processed.  This comes
after task alloc in the current code, hence the second call to
malloc.  In iser this should be a pre-registered buffer, while for
tcp we can get away with normal malloc.  Maybe this issue goes away
if you do task_alloc differently.

> I do want to contribute, both with the PDU queuing and with implementing
> my suggestion above, if we agree on it or on another alternative.

I'm all for it.  It's clear to me that your read_pdu and task_alloc
abstraction points are better than the existing ep_read and
ep_malloc ones.

Let me know if you have questions on any aspects of the current
code.  It's not very heavily commented.  I'll test your patches when
they're ready.

		-- Pete



From robin.humble+stgt at anu.edu.au  Sun Sep  9 17:30:32 2007
From: robin.humble+stgt at anu.edu.au (Robin Humble)
Date: Sun, 9 Sep 2007 11:30:32 -0400
Subject: [Stgt-devel] iSER
In-Reply-To: <20070905144618.GA26761@lemming.cita.utoronto.ca>
References: <20070903132326.GA8441@lemming.cita.utoronto.ca>
	<20070903170223.GA28887@osc.edu>
	<20070904032420.GA20306@lemming.cita.utoronto.ca>
	<20070904201912.GA6840@osc.edu>
	<20070905144618.GA26761@lemming.cita.utoronto.ca>
Message-ID: <20070909153032.GA27634@lemming.cita.utoronto.ca>

I experimented a little further with iSER in latest git://git.osc.edu/tgt

Summary:
 - 2.6.21 seems to be a good kernel. 2.6.22 or newer, or RedHat's OFED 1.2
   patched kernels all seem to have iSER bugs that make them unusable.
 - as everything works in 2.6.21 presumably this means there's nothing
   wrong with the iSER implementation in tgtd. well done! :)

with 2.6.18-32.el5 (RHEL5 kernel w/OFED 1.2) I get the below read
corruption problems on just the raw iSER device (/dev/sdc):
   # ls -l file.1m 
  -rw-r--r-- 1 root root 1048576 Sep  7 02:02 file.1m
   # dd if=file.1m of=/dev/sdc bs=1M count=1
   # for i in `seq 0 9`; do dd if=/dev/sdc of=file.1m.copy.$i bs=1M count=1; done
   # md5sum file.1m* | sort
  274b3110146c844578050b6445061c58  file.1m
  274b3110146c844578050b6445061c58  file.1m.copy.0
  274b3110146c844578050b6445061c58  file.1m.copy.1
  274b3110146c844578050b6445061c58  file.1m.copy.2
  274b3110146c844578050b6445061c58  file.1m.copy.4
  274b3110146c844578050b6445061c58  file.1m.copy.5
  274b3110146c844578050b6445061c58  file.1m.copy.6
  274b3110146c844578050b6445061c58  file.1m.copy.8
  3925690d020b07b3af4f631903040820  file.1m.copy.9
  5bb8f0621f73a9de271604ef044adaf8  file.1m.copy.7
  b153b34fc88b410eb99d145bc3f81106  file.1m.copy.3
about 10 to 20% of reads are incorrect at bs=1M. reads are ok below
bs=500k or so.

with the 2.6.22.6 kernel and iSER I couldn't find any corruption
issues using dd to /dev/sdc. however (as reported previously) if I put
an ext3 filesystem on the iSER device and then dd to a file in the ext3
filsystem then pretty much immediately I get:
  Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196611, length 1
  Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196612, length 1
  Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196613, length 1
  ...

I get the same type of errors with 2.6.23-rc5 too.

with 2.6.21 (mem=512M) on the initiator side and 2.6.21 or 2.6.22.6
(7.1g ramdisk as backing store) then everything seems to work fine.
eg. bonnie++

Version  1.03       ------Sequential Output------ --Sequential Input- --Random-
                    -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
Machine        Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
x11            512M 80329  99 521771 99 224506 44 85983  95 525440 49 +++++ +++
x11              1G 80649  99 484939 92 207655 43 59377  98 488031 41 13703  14
x11              2G 79976  99 461833 94 208618 42 74189  97 467245 39 10060  13
x11              4G 79873  99 487361 97 210199 43 87312  98 484341 42  8459  13
                    ------Sequential Create------ --------Random Create--------
                    -Create-- --Read--- -Delete-- -Create-- --Read--- -Delete--
              files  /sec %CP  /sec %CP  /sec %CP  /sec %CP  /sec %CP  /sec %CP
                 16 +++++ +++ +++++ +++ +++++ +++ +++++ +++ +++++ +++ +++++ +++
                 64 80318  99 +++++ +++ 86949  99 80277  99 +++++ +++ 83630 100
                256 68904  97 436942 98 61886  83 67777  95 +++++ +++ 48291  69
                512 40226  62 34164  25 37500  65 44426  67 22325  18 28473  53

cheers,
robin


From pw at osc.edu  Sun Sep  9 20:12:42 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sun, 9 Sep 2007 14:12:42 -0400
Subject: [Stgt-devel] iSER
In-Reply-To: <20070909153032.GA27634@lemming.cita.utoronto.ca>
References: <20070903132326.GA8441@lemming.cita.utoronto.ca>
	<20070903170223.GA28887@osc.edu>
	<20070904032420.GA20306@lemming.cita.utoronto.ca>
	<20070904201912.GA6840@osc.edu>
	<20070905144618.GA26761@lemming.cita.utoronto.ca>
	<20070909153032.GA27634@lemming.cita.utoronto.ca>
Message-ID: <20070909181242.GA9302@osc.edu>

robin.humble+stgt at anu.edu.au wrote on Sun, 09 Sep 2007 11:30 -0400:
> Summary:
>  - 2.6.21 seems to be a good kernel. 2.6.22 or newer, or RedHat's OFED 1.2
>    patched kernels all seem to have iSER bugs that make them unusable.
>  - as everything works in 2.6.21 presumably this means there's nothing
>    wrong with the iSER implementation in tgtd. well done! :)

Well, that's good and bad news.  Nice to know that things do work at times,
but we have to figure out what happened in the initiator now.  Or maybe tgt
is making some bad assumptions.

> with the 2.6.22.6 kernel and iSER I couldn't find any corruption
> issues using dd to /dev/sdc. however (as reported previously) if I put
> an ext3 filesystem on the iSER device and then dd to a file in the ext3
> filsystem then pretty much immediately I get:
>   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196611, length 1
>   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196612, length 1
>   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196613, length 1
>   ...
> 
> I get the same type of errors with 2.6.23-rc5 too.

I'm still not been able to reproduce this, at least on my
2.6.22-rc5.  One of these days we'll move to some newer kernels
here, but have been sort of waiting for the bidi approaches to
stabilize somewhat.

The only issue I've found is a slight race condition when the
initiator unexpectly hangs up.  The target would exit if it saw
a work request flush before seeing the CM disconnect event.  Added
a new patch to the git to fix this.  But it doesn't explain your
corruption issues.

> with 2.6.21 (mem=512M) on the initiator side and 2.6.21 or 2.6.22.6
> (7.1g ramdisk as backing store) then everything seems to work fine.
> eg. bonnie++
> 
> Version  1.03       ------Sequential Output------ --Sequential Input- --Random-
>                     -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
> Machine        Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
> x11            512M 80329  99 521771 99 224506 44 85983  95 525440 49 +++++ +++
> x11              1G 80649  99 484939 92 207655 43 59377  98 488031 41 13703  14
> x11              2G 79976  99 461833 94 208618 42 74189  97 467245 39 10060  13
> x11              4G 79873  99 487361 97 210199 43 87312  98 484341 42  8459  13
>                     ------Sequential Create------ --------Random Create--------
>                     -Create-- --Read--- -Delete-- -Create-- --Read--- -Delete--
>               files  /sec %CP  /sec %CP  /sec %CP  /sec %CP  /sec %CP  /sec %CP
>                  16 +++++ +++ +++++ +++ +++++ +++ +++++ +++ +++++ +++ +++++ +++
>                  64 80318  99 +++++ +++ 86949  99 80277  99 +++++ +++ 83630 100
>                 256 68904  97 436942 98 61886  83 67777  95 +++++ +++ 48291  69
>                 512 40226  62 34164  25 37500  65 44426  67 22325  18 28473  53

You're getting neighborhood of 500 MB/s for block reads _and_ writes
through ext3.  This is different from your earlier results with dd:

robin.humble+stgt at anu.edu.au wrote on Wed, 05 Sep 2007 10:46 -0400:
> bypassing the page cache (and readahead?) with O_DIRECT:
>  eg. dd if=/dev/zero of=/dev/sdc bs=1k count=8000 oflag=direct
>    bs   write MB/s read MB/s
>   10M     1200      520
>    1M      790      460
>  200k      480      350
>    4k       40       34
>    1k       11        9
> large writes look fabulous, but reads seem to be limited by something
> other than IB bandwidth.
> 
> in the more usual usage case via the page cache:
>  eg. dd if=/dev/zero of=/dev/sdc bs=1k count=8000000 
>    bs   write MB/s read MB/s
>   10M     1100      260
>    1M     1100      270
>    4k      960      270
>    1k       30      240
> so maybe extra copies to/from page cache are getting in the way of the
> read bandwidth and are lowering it by a factor of 2.
> I'm guessing the good small block read performance here is due to
> readahead, and the mostly better writes are from aggregation.

We see similar behavior as your earlier tests on dd, where reads are
too slow, and have started trying to figure out what's taking so
long in the code.  One would expect reads to be the fast case, as
they map to RDMA write operations.

Thanks for doing all this testing.

		-- Pete


From nezhinsky at gmail.com  Sun Sep  9 21:39:49 2007
From: nezhinsky at gmail.com (Alexander Nezhinsky)
Date: Sun, 9 Sep 2007 22:39:49 +0300
Subject: [Stgt-devel] iSER patches, second release
In-Reply-To: <20070908190235.GC20397@osc.edu>
References: <20070904200548.GD6578@osc.edu>
	<5eb093080709060522t7694baa9w18d7872d3ab28821@mail.gmail.com>
	<20070906201028.GC14234@osc.edu>
	<5eb093080709080449u6fdbe443h2d11cbcec227db31@mail.gmail.com>
	<20070908190235.GC20397@osc.edu>
Message-ID: <5eb093080709091239g6254f1c4g83646c5b8a352e2a@mail.gmail.com>

> I agree with your analysis.  This does seem like the right
> compromise between totally rewriting the state machine and doing the
> byte-wise copy in iser we do now.
>
> As a side note, I could almost be convinced that having an iser-only
> rx state machine would be appropriate.  6 of the 11 states have to

Ok, let's see if it is possible without making an earthquake ))

> I like your idea about getting rid of ep_malloc and ep_free.  That
> is the wrong level to do the abstraction.  But watch out for
> bidi_uaddr.  You don't know the size of the read buffer in a
> bidirectional command until the AHS has been processed.  This comes
> after task alloc in the current code, hence the second call to
> malloc.  In iser this should be a pre-registered buffer

maybe, there should be: task_alloc(), task_add_buf(), task_release()
or smth. like this, so that adding a buffer amounts either to malloc
or getting a pre-registered buffer, while release handles *all* previously
allocated buffers.

> Let me know if you have questions on any aspects of the current
> code.  It's not very heavily commented.  I'll test your patches when
> they're ready.

great, i'll start working on that, but it can take some time as i don't have
too much bandwidth.

Another question, though. As far as i understand, when rdma read due
to an r2t request is done, iser_rdma_read_completion() is called and
it calls iscsi_scsi_cmd_execute() which may issue more R2Ts if
necessary.
So we send R2T --> RDMA-Read, then wait for completion, then send
another one.
This imposes delays between consecutive rdma-reads.
If we issue all r2t requests at once (in the correct order, though), we
guarantee that there are no gaps (or they are as small as possible)
between the data chunks sent from the initiator.

Generally, the number of R2T simultaneously outstanding is governed by
MaxOutstandingR2Ts, but it is irrelevant in iSER, just as MaxBurstSize is
irrelevant. The only limitation on issuing R2Ts is the limitation of
the hardware
upon the max outstanding RDMA-Read requests.

Alexander.


From tomof at acm.org  Mon Sep 10 19:31:46 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Tue, 11 Sep 2007 02:31:46 +0900
Subject: [Stgt-devel] [PATCH] print newline
In-Reply-To: <20070904200245.GA6578@osc.edu>
References: <20070904200245.GA6578@osc.edu>
Message-ID: <20070910010614O.tomof@acm.org>

On Tue, 4 Sep 2007 16:02:45 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Add newlines missing on some dprintf and eprintf.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/chap.c   |    2 +-
>  usr/iscsi/iscsid.c |    3 ++-
>  usr/xen/xenbus.c   |    2 +-
>  3 files changed, 4 insertions(+), 3 deletions(-)

Applied, thanks.



From tomof at acm.org  Mon Sep 10 19:31:48 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Tue, 11 Sep 2007 02:31:48 +0900
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <20070904200306.GB6578@osc.edu>
References: <20070904200306.GB6578@osc.edu>
Message-ID: <20070910024326H.tomof@acm.org>

On Tue, 4 Sep 2007 16:03:06 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Repair one corner case in MaxRecvDataSegmentLength processing.  Default
> target has always kept data segments at 8k, even if the initiator asks
> for more.  Some target administrators may increase this by, e.g.:
> 
>     tgtadm --lld iscsi --mode target --op update --tid 1 \
> 	   --name MaxXmitDataSegmentLength --value 262144
> 
> so that target will generate up to min(initiator-specified RDSL, 256k).
> But if such a change is made, and the initiator does not specify RDSL,
> which is odd but specification compliant, the target will incorrectly
> use 256k instead of 8k.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsid.c |   10 +++++++---
>  usr/iscsi/iscsid.h |    1 +
>  usr/iscsi/target.c |    2 +-
>  3 files changed, 9 insertions(+), 4 deletions(-)

What?

As I explained before, I can't understand your description.


From tomof at acm.org  Mon Sep 10 19:31:47 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Tue, 11 Sep 2007 02:31:47 +0900
Subject: [Stgt-devel] [PATCH] bidi quiet warning
In-Reply-To: <20070904200351.GC6578@osc.edu>
References: <20070904200351.GC6578@osc.edu>
Message-ID: <20070910010629M.tomof@acm.org>

On Tue, 4 Sep 2007 16:03:51 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Always zero out task->len for write commands.  They do not send data
> back to the initiator.  For reads and bidirectional commands, the backing
> store will set task->len to the read result size, which must be within
> the size the initiator requested at the transport layer.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsid.c |    8 +++++---
>  1 files changed, 5 insertions(+), 3 deletions(-)

Applied, thanks.


From tomof at acm.org  Mon Sep 10 19:38:02 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Tue, 11 Sep 2007 02:38:02 +0900
Subject: [Stgt-devel] iSER patches, second release
In-Reply-To: <20070906201028.GC14234@osc.edu>
References: <20070904200548.GD6578@osc.edu>
	<5eb093080709060522t7694baa9w18d7872d3ab28821@mail.gmail.com>
	<20070906201028.GC14234@osc.edu>
Message-ID: <20070910025008L.tomof@acm.org>

On Thu, 6 Sep 2007 16:10:28 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> nezhinsky at gmail.com wrote on Thu, 06 Sep 2007 15:22 +0300:
> > I have a few questions regarding the code. I'll post them in different mails.
> 
> Thanks for looking this over.
> 
> > In handle_wc() in case of IBV_WC_RECV, iscsi_rx_handler() gets called and
> > the received pdu is passed as an implicit parameter, through
> > ci->rcv_comm_event.
> > Only then it gets reposted.
> > 
> > First, the parameter passing method somewhat bothers me because it seems
> > that on a SMP system two RECV completions may arrive through different
> > CPUs and then we end up with garbage in ci->rcv_comm_event.
> > Do I miss anything on this? Are all completions handled by the same CPU?
> > Is there an implicit guard somewhere?
> 
> Yes, it bothers me a bit too.  There is some mismatch in how iscsi
> wants to read bytes when it needs them:  48 first, then look for AHS
> and possible read those, then maybe some immediate data.  Three
> separate read(fd, ...) for one control PDU.  On the other hand, RDMA
> gets all the data in one go.  So we compromise by feeding the bytes
> into iscsi via memcpy for each of its small do_recv operations.
> 
> It would be possible to have a separate RX state machine just for
> RDMA, but we didn't want to diverge the code so much.  I think this
> way works, although Robin points out that there are bugs somewhere.

iSER guys, please try not to be away from the iSCSI tcp code (that is,
don't invent something like RDMA RX state machine). We need stable
iSER code first. After that is merged, then you can talk about the
performance.


From pw at osc.edu  Fri Sep 14 23:40:34 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Fri, 14 Sep 2007 17:40:34 -0400
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <20070910024326H.tomof@acm.org>
References: <20070904200306.GB6578@osc.edu> <20070910024326H.tomof@acm.org>
Message-ID: <20070914214034.GA15545@osc.edu>

tomof at acm.org wrote on Tue, 11 Sep 2007 02:31 +0900:
> On Tue, 4 Sep 2007 16:03:06 -0400
> Pete Wyckoff <pw at osc.edu> wrote:
> 
> > Repair one corner case in MaxRecvDataSegmentLength processing.  Default
> > target has always kept data segments at 8k, even if the initiator asks
> > for more.  Some target administrators may increase this by, e.g.:
> > 
> >     tgtadm --lld iscsi --mode target --op update --tid 1 \
> > 	   --name MaxXmitDataSegmentLength --value 262144
> > 
> > so that target will generate up to min(initiator-specified RDSL, 256k).
> > But if such a change is made, and the initiator does not specify RDSL,
> > which is odd but specification compliant, the target will incorrectly
> > use 256k instead of 8k.
> > 
> > Signed-off-by: Pete Wyckoff <pw at osc.edu>
> > ---
> >  usr/iscsi/iscsid.c |   10 +++++++---
> >  usr/iscsi/iscsid.h |    1 +
> >  usr/iscsi/target.c |    2 +-
> >  3 files changed, 9 insertions(+), 4 deletions(-)
> 
> What?
> 
> As I explained before, I can't understand your description.

Oh, sorry.  I thought our last go-round ended with my explaining why
this was necessary.  I'll drop the patch.  It never happens in
practice.  Open-iscsi always provides MaxRecvDataSegmentLength
during login, even if it is using the spec. default of 8k.
Presumably other initiators do so too.

		-- Pete


From pw at osc.edu  Fri Sep 14 23:50:07 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Fri, 14 Sep 2007 17:50:07 -0400
Subject: [Stgt-devel] iSER patches, second release
In-Reply-To: <5eb093080709091239g6254f1c4g83646c5b8a352e2a@mail.gmail.com>
References: <20070904200548.GD6578@osc.edu>
	<5eb093080709060522t7694baa9w18d7872d3ab28821@mail.gmail.com>
	<20070906201028.GC14234@osc.edu>
	<5eb093080709080449u6fdbe443h2d11cbcec227db31@mail.gmail.com>
	<20070908190235.GC20397@osc.edu>
	<5eb093080709091239g6254f1c4g83646c5b8a352e2a@mail.gmail.com>
Message-ID: <20070914215007.GB15545@osc.edu>

nezhinsky at gmail.com wrote on Sun, 09 Sep 2007 22:39 +0300:
> Another question, though. As far as i understand, when rdma read due
> to an r2t request is done, iser_rdma_read_completion() is called and
> it calls iscsi_scsi_cmd_execute() which may issue more R2Ts if
> necessary.
> So we send R2T --> RDMA-Read, then wait for completion, then send
> another one.
> This imposes delays between consecutive rdma-reads.
> If we issue all r2t requests at once (in the correct order, though), we
> guarantee that there are no gaps (or they are as small as possible)
> between the data chunks sent from the initiator.
> 
> Generally, the number of R2T simultaneously outstanding is governed by
> MaxOutstandingR2Ts, but it is irrelevant in iSER, just as MaxBurstSize is
> irrelevant. The only limitation on issuing R2Ts is the limitation of
> the hardware
> upon the max outstanding RDMA-Read requests.

You are right.  Neither TCP nor RDMA will issue more than one
outstanding R2T, although TCP could do so if MaxOutstandingR2Ts
allows.  We have the flexibility to do more RDMA reads, and perhaps
can get better performance with the pipelining that would bring.  I
think it would be a minor modification to iscsid.c, but suggest you
hold off until we get your no-copy-PDU work in.  And even this work
we should sit on for a bit until Tomo has a chance to think about
the current set of patches.

I fixed one bug today ("iscsi: do not lose tx state") and pushed up
a new git.  Hopefully Robin and others will help us shake out more
bugs.  We'll be running tests next week and taking a close look at
performance.

		-- Pete


From tomof at acm.org  Sat Sep 15 02:29:47 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 15 Sep 2007 09:29:47 +0900
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <20070914214034.GA15545@osc.edu>
References: <20070904200306.GB6578@osc.edu> <20070910024326H.tomof@acm.org>
	<20070914214034.GA15545@osc.edu>
Message-ID: <20070914054037P.tomof@acm.org>

On Fri, 14 Sep 2007 17:40:34 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> tomof at acm.org wrote on Tue, 11 Sep 2007 02:31 +0900:
> > On Tue, 4 Sep 2007 16:03:06 -0400
> > Pete Wyckoff <pw at osc.edu> wrote:
> > 
> > > Repair one corner case in MaxRecvDataSegmentLength processing.  Default
> > > target has always kept data segments at 8k, even if the initiator asks
> > > for more.  Some target administrators may increase this by, e.g.:
> > > 
> > >     tgtadm --lld iscsi --mode target --op update --tid 1 \
> > > 	   --name MaxXmitDataSegmentLength --value 262144
> > > 
> > > so that target will generate up to min(initiator-specified RDSL, 256k).
> > > But if such a change is made, and the initiator does not specify RDSL,
> > > which is odd but specification compliant, the target will incorrectly
> > > use 256k instead of 8k.
> > > 
> > > Signed-off-by: Pete Wyckoff <pw at osc.edu>
> > > ---
> > >  usr/iscsi/iscsid.c |   10 +++++++---
> > >  usr/iscsi/iscsid.h |    1 +
> > >  usr/iscsi/target.c |    2 +-
> > >  3 files changed, 9 insertions(+), 4 deletions(-)
> > 
> > What?
> > 
> > As I explained before, I can't understand your description.
> 
> Oh, sorry.  I thought our last go-round ended with my explaining why
> this was necessary.  I'll drop the patch.  It never happens in
> practice.  Open-iscsi always provides MaxRecvDataSegmentLength
> during login, even if it is using the spec. default of 8k.
> Presumably other initiators do so too.

I still don't see what you mean. tgt works with initiators doesn't
provide MaxRecvDataSegmentLength during login. Can you try the
attached patches.
-------------- next part --------------
Index: usr/login.c
===================================================================
--- usr/login.c	(revision 779)
+++ usr/login.c	(working copy)
@@ -1001,10 +1001,10 @@
 						  max_data_length))
 				return 0;
 
-			if (!add_params_provider_specific(session, cid,
-							  pdu, data,
- max_data_length))
-				return 0;
+/* 			if (!add_params_provider_specific(session, cid, */
+/* 							  pdu, data, */
+/*  max_data_length)) */
+/* 				return 0; */
 		} else {
 			sprintf(value, "%d", conn->max_recv_dlength);
 			if (!iscsi_add_text(pdu, data, max_data_length,
-------------- next part --------------
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 78846ba..a4844da 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -798,9 +798,11 @@ static void cmnd_finish(struct iscsi_connection *conn)
 	case STATE_SECURITY_FULL:
 		/* fall through */
 	case STATE_LOGIN_FULL:
-		if (conn->session_type == SESSION_NORMAL)
+		if (conn->session_type == SESSION_NORMAL) {
 			conn->state = STATE_KERNEL;
-		else
+			eprintf("target setting %d, result %d\n",
+				conn->session->target->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val, conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val);
+		} else
 			conn->state = STATE_FULL;
 		break;
 	}

From albert.pauw at gmail.com  Sat Sep 15 22:28:01 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Sat, 15 Sep 2007 22:28:01 +0200
Subject: [Stgt-devel] [PATCH] isns fix initiator -> target
Message-ID: <46EC4051.7040704@gmail.com>

Here's a little patch for the isns part.

Seems that when incorporating the open-iscsi isns stuf in tgt the change 
from initiator type to target type was forgotton.

In particular

file usr/iscsi/isns.c

ISNS_NODE_INITIATOR -> ISNS_NODE_TARGET
ISNS_SCN_FLAG_INITIATOR -> ISNS_SCN_FLAG_TARGET

There are quite a few local parameters left in with initiator in the 
name, but I left those in, this patch only let tgt tell to isns that it 
is a target.

Albert
-------------- next part --------------
A non-text attachment was scrubbed...
Name: isns.patch
Type: text/x-patch
Size: 1104 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070915/b47f0c54/attachment.bin>

From tomof at acm.org  Sun Sep 16 07:38:15 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 16 Sep 2007 14:38:15 +0900
Subject: [Stgt-devel] [PATCH] isns fix initiator -> target
In-Reply-To: <46EC4051.7040704@gmail.com>
References: <46EC4051.7040704@gmail.com>
Message-ID: <200709160538.l8G5cFS8020762@mbox.iij4u.or.jp>

From: Albert Pauw <albert.pauw at gmail.com>
Subject: [Stgt-devel] [PATCH] isns fix initiator -> target
Date: Sat, 15 Sep 2007 22:28:01 +0200

> Here's a little patch for the isns part.
> 
> Seems that when incorporating the open-iscsi isns stuf in tgt the change 
> from initiator type to target type was forgotton.

No.


> In particular
> 
> file usr/iscsi/isns.c
> 
> ISNS_NODE_INITIATOR -> ISNS_NODE_TARGET
> ISNS_SCN_FLAG_INITIATOR -> ISNS_SCN_FLAG_TARGET
> 
> There are quite a few local parameters left in with initiator in the 
> name, but I left those in, this patch only let tgt tell to isns that it 
> is a target.

Please send a patch as inline text in the body of the email.


--- usr/iscsi/isns.c	2007-09-05 20:38:55.000000000 +0200
+++ usr/iscsi/isns.c.new	2007-09-15 22:19:49.000000000 +0200
@@ -265,7 +265,7 @@
 	length += isns_tlv_set(&tlv, ISNS_ATTR_ISCSI_NAME, strlen(name), name);
 	length += isns_tlv_set(&tlv, 0, 0, 0);
 
-	scn_flags = ISNS_SCN_FLAG_INITIATOR | ISNS_SCN_FLAG_OBJECT_REMOVE |
+	scn_flags = ISNS_SCN_FLAG_TARGET | ISNS_SCN_FLAG_OBJECT_REMOVE |
 		ISNS_SCN_FLAG_OBJECT_ADDED | ISNS_SCN_FLAG_OBJECT_UPDATED;

No. We register SCN to monitor initiators.


 	set_scn_flag(scn_flags);
 	scn_flags = htonl(scn_flags);
@@ -291,7 +291,7 @@
 	struct isns_hdr *hdr = (struct isns_hdr *) buf;
 	struct isns_tlv *tlv;
 	struct iscsi_target *target;
-	uint32_t node = htonl(ISNS_NODE_INITIATOR);
+	uint32_t node = htonl(ISNS_NODE_TARGET);
 	struct isns_qry_mgmt *mgmt;
 
No, we send a query about initiators.


 	if (list_empty(&iscsi_targets_list))
@@ -681,7 +681,7 @@
 			name = (char *) tlv->value;
 			break;
 		case ISNS_ATTR_ISCSI_NODE_TYPE:
-			if (ntohl(*(tlv->value)) == ISNS_NODE_INITIATOR && name) {
+			if (ntohl(*(tlv->value)) == ISNS_NODE_TARGET && name) {
 				eprintf("%s\n", (char *) name);
 				ini = malloc(sizeof(*ini));
 				if (!ini)

No, we handle the response to the query about initiators.


From tomof at acm.org  Sun Sep 16 07:42:19 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 16 Sep 2007 14:42:19 +0900
Subject: [Stgt-devel] [PATCH] isns fix initiator -> target
In-Reply-To: <46EC4051.7040704@gmail.com>
References: <46EC4051.7040704@gmail.com>
Message-ID: <200709160542.l8G5gJgw022599@mbox.iij4u.or.jp>

From: Albert Pauw <albert.pauw at gmail.com>
Subject: [Stgt-devel] [PATCH] isns fix initiator -> target
Date: Sat, 15 Sep 2007 22:28:01 +0200

> There are quite a few local parameters left in with initiator in the 
> name, but I left those in, this patch only let tgt tell to isns that it 
> is a target.

If tgt tells an iSNS server to register it as an initiator, it's quite
strange. tgt properly works for me.


From albert.pauw at gmail.com  Sun Sep 16 08:21:08 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Sun, 16 Sep 2007 08:21:08 +0200
Subject: [Stgt-devel] [PATCH] isns fix initiator -> target
In-Reply-To: <200709160542.l8G5gJgw022599@mbox.iij4u.or.jp>
References: <46EC4051.7040704@gmail.com>
	<200709160542.l8G5gJgw022599@mbox.iij4u.or.jp>
Message-ID: <46ECCB54.6010701@gmail.com>

> If tgt tells an iSNS server to register it as an initiator, it's quite
> strange. tgt properly works for me.
> 
It's weird, I tried it again this morning with the original tgt source 
and indeed it registers as a target. I get the feeling that open-isns
has a little mixup here.

I am running open-iscsi and tgt on the same host, but as we discovered 
earlier the registration with open-isns gets confused about this. But 
even when the initiator has been stopped and shortly after expunged from 
the isns database something of it is left. When I start tgt isns still 
thinks that it is an initiator (as it comes from the same host).

When I remove the isns DB and start from scratch it works fine, tgt is 
registered as a target.

I don't know if this all makes sense to Olaf (open-isns).

Albert


From erezz at voltaire.com  Sun Sep 16 10:08:05 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Sun, 16 Sep 2007 11:08:05 +0300
Subject: [Stgt-devel] iSER
In-Reply-To: <20070907101010.GA24150@lemming.cita.utoronto.ca>
References: <20070903132326.GA8441@lemming.cita.utoronto.ca>	<20070903170223.GA28887@osc.edu>	<20070904032420.GA20306@lemming.cita.utoronto.ca>	<20070904201912.GA6840@osc.edu>	<20070905144618.GA26761@lemming.cita.utoronto.ca>	<46DFCFA2.3030101@Voltaire.COM>
	<20070907101010.GA24150@lemming.cita.utoronto.ca>
Message-ID: <46ECE465.3030602@voltaire.com>


> the ofed1.2 userland I'm using is from here:
>   http://people.redhat.com/dledford/Infiniband/openib/1.2/1.el5/x86_64/
> and I've tried kernel.org 2.6.22.6 and also RedHat's ofed1.2 kernels:
>   http://people.redhat.com/dledford/Infiniband/kernel/2.6.18/32.el5/x86_64/
>
> the changelog in the userland .src.rpm says:
>   * Wed Jun 27 2007 Doug Ledford <dledford at redhat.com> 1.2-1
>   - Update to final OFED 1.2 release
>
> so hopefully that is a recent enough OFED?
>
>   

I'm using OFED 1.2 from openfabrics (not from RedHat), but they should
be identical. It looks ok.

Erez



From tomof at acm.org  Sun Sep 16 17:33:46 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Mon, 17 Sep 2007 00:33:46 +0900
Subject: [Stgt-devel] [Patch 1/1] Add support for VPD pages 80h - ffh
In-Reply-To: <46DE60A6.8050904@gmail.com>
References: <46DE60A6.8050904@gmail.com>
Message-ID: <20070915190146K.tomof@acm.org>

On Wed, 05 Sep 2007 17:54:14 +1000
Mark Harvey <markh794 at gmail.com> wrote:

> Re-submit of patch with suggested improvements.
> 
> - Added pointer struct target to scsi_lu struct
> - Added lu_exit() to free allocation of VPD pages
> - Removed osd from test startup script
> - Removed osd specific VPD pages B0h and B1h
> 
> - Passes checkpatch.pl sanity check.

Merged, Thanks! Sorry about the delay again.


Here are some comments.


> +/** Protocol Identifier Values
> + * 0 Fibre Channel (FCP-2)
> + * 1 Parallel SCSI (SPI-5)

We use the following style:

> +/*
> + * Protocol Identifier Values
> + *
> + * 0 Fibre Channel (FCP-2)
> + * 1 Parallel SCSI (SPI-5)


> +static int valid_vpd(struct vpd **lu_vpd, uint8_t page)
> +{
> +	if (lu_vpd[page & 0x7f])
> +		return 1;

I think that we use 0x7f and 0x80 at too many places. I put new macros
for them.


> +	return 0;
> +}
> +
> +void update_vpd_80(struct scsi_lu *lu, void *sn)
> +{
> +	struct vpd *vpd_pg = lu->attrs.lu_vpd[0];
> +	char *data = (char *)vpd_pg->data;
> +
> +	snprintf(data, SCSI_SN_LEN, "%-8s", (char *)sn);

This doesn't work. We need right-aligned ASCII data.


> +}
> +
> +void update_vpd_83(struct scsi_lu *lu, void *id)
> +{
> +	struct vpd *vpd_pg = lu->attrs.lu_vpd[3];
> +	uint8_t	*data = vpd_pg->data;
> +
> +	data[0] = (PIV_ISCSI << 4) | INQ_CODE_ASCII;
> +	data[1] = PIV_VALID | ASS_TGT_PORT | DESG_VENDOR;
> +	data[3] = SCSI_ID_LEN;
> +
> +	strncpy((char *)data + 4, id, SCSI_ID_LEN);
> +}
> +
>  int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  {
>  	int len = 0, ret = SAM_STAT_CHECK_CONDITION;
> @@ -47,6 +138,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
>  	uint8_t devtype = 0;
>  	struct lu_phy_attr *attrs;
> +	struct vpd *vpd_pg;
>  
>  	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
>  		goto sense;
> @@ -98,43 +190,35 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  	} else if (scb[1] & 0x1) {
>  		/* EVPD bit set */
>  		if (scb[2] == 0x0) {
> +			int i, j, tmp;
> +
> +			i = 5;
> +			tmp = 1;
>  			data[0] = devtype;
> -			data[1] = 0x0;
> -			data[3] = 3;
> +			data[1] = 0;
> +			data[2] = 0;
> +			for (j = 0; j < 0x80; j++) {
> +				if (attrs->lu_vpd[j]) {
> +					data[i] = j | 0x80;
> +					tmp++;
> +					i++;
> +				}
> +			}

I use a more common way here.


> +			data[3] = tmp;
>  			data[4] = 0x0;
> -			data[5] = 0x80;
> -			data[6] = 0x83;
> -			len = 7;
> +			len = tmp + 4;
>  			ret = SAM_STAT_GOOD;
> -		} else if (scb[2] == 0x80) {
> -			int tmp = SCSI_SN_LEN;
> -
> -			data[1] = 0x80;
> -			data[3] = SCSI_SN_LEN;
> -			memset(data + 4, 0x20, 4);
> -			len = 4 + SCSI_SN_LEN;
> -			ret = SAM_STAT_GOOD;
> -
> -			if (strlen(attrs->scsi_sn)) {
> -				uint8_t *p;
> -				char *q;
> +		} else if (valid_vpd(attrs->lu_vpd, scb[2])) {
> +			int tmp;
> +			vpd_pg = attrs->lu_vpd[scb[2] & 0x7f];
> +			tmp = vpd_pg->size;
>  
> -				p = data + 4 + tmp - 1;
> -				q = attrs->scsi_sn + SCSI_SN_LEN - 1;
> -				for (; tmp > 0; tmp--, q)
> -					*(p--) = *(q--);
> -			}
> -		} else if (scb[2] == 0x83) {
> -			int tmp = SCSI_ID_LEN;
> -
> -			data[1] = 0x83;
> -			data[3] = tmp + 4;
> -			data[4] = 0x1;
> -			data[5] = 0x1;
> -			data[7] = tmp;
> -			strncpy((char *) data + 8, attrs->scsi_id, SCSI_ID_LEN);
> -
> -			len = tmp + 8;
> +			data[0] = devtype;
> +			data[1] = scb[2];
> +			data[2] = (tmp >> 8);
> +			data[3] = tmp & 0xff;
> +			memcpy(&data[4], vpd_pg->data, tmp);
> +			len = tmp + 4;
>  			ret = SAM_STAT_GOOD;
>  		}
>  	}
> @@ -358,6 +442,19 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
>  	return SAM_STAT_GOOD;
>  }
>  
> +struct vpd *alloc_vpd(uint16_t size)
> +{
> +	struct vpd *vpd_pg;
> +
> +	vpd_pg = zalloc(sizeof(struct vpd) + size);
> +	if (!vpd_pg)
> +		return NULL;
> +
> +	vpd_pg->size = size;
> +
> +	return vpd_pg;
> +}
> +
>  static struct mode_pg *alloc_mode_pg(uint8_t pcode, uint8_t subpcode,
>  				     uint16_t size)
>  {
> @@ -500,6 +597,11 @@ int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
>  	int err = TGTADM_SUCCESS;
>  	char *p;
>  	char buf[256];
> +	struct lu_phy_attr *attrs;
> +	struct vpd **lu_vpd;
> +
> +	attrs = &lu->attrs;
> +	lu_vpd = attrs->lu_vpd;
>  
>  	if (!strncmp("targetOps", params, 9))
>  		params = params + 10;
> @@ -512,36 +614,38 @@ int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
>  		token = match_token(p, tokens, args);
>  		switch (token) {
>  		case Opt_scsi_id:
> -			match_strncpy(lu->attrs.scsi_id, &args[0],
> -				      sizeof(lu->attrs.scsi_id));
> +			match_strncpy(attrs->scsi_id, &args[0],
> +						sizeof(attrs->scsi_id));

Wrong tabs. Should be:

+			match_strncpy(attrs->scsi_id, &args[0],
+				      sizeof(attrs->scsi_id));


> +			lu_vpd[3]->vpd_update(lu, attrs->scsi_id);
>  			break;
>  		case Opt_scsi_sn:
> -			match_strncpy(lu->attrs.scsi_sn, &args[0],
> -				      sizeof(lu->attrs.scsi_sn));
> +			match_strncpy(attrs->scsi_sn, &args[0],
> +						sizeof(attrs->scsi_sn));
> +			lu_vpd[0]->vpd_update(lu, attrs->scsi_sn);
>  			break;
>  		case Opt_vendor_id:
> -			match_strncpy(lu->attrs.vendor_id, &args[0],
> -				      sizeof(lu->attrs.vendor_id));
> +			match_strncpy(attrs->vendor_id, &args[0],
> +						sizeof(attrs->vendor_id));
>  			break;
>  		case Opt_product_id:
> -			match_strncpy(lu->attrs.product_id, &args[0],
> -				      sizeof(lu->attrs.product_id));
> +			match_strncpy(attrs->product_id, &args[0],
> +						sizeof(attrs->product_id));
>  			break;
>  		case Opt_product_rev:
> -			match_strncpy(lu->attrs.product_rev, &args[0],
> -				      sizeof(lu->attrs.product_rev));
> +			match_strncpy(attrs->product_rev, &args[0],
> +						sizeof(attrs->product_rev));
>  			break;
>  		case Opt_sense_format:
>  			match_strncpy(buf, &args[0], sizeof(buf));
> -			lu->attrs.sense_format = atoi(buf);
> +			attrs->sense_format = atoi(buf);
>  			break;
>  		case Opt_removable:
>  			match_strncpy(buf, &args[0], sizeof(buf));
> -			lu->attrs.removable = atoi(buf);
> +			attrs->removable = atoi(buf);
>  			break;
>  		case Opt_online:
>  			match_strncpy(buf, &args[0], sizeof(buf));
> -			lu->attrs.online = atoi(buf);
> +			attrs->online = atoi(buf);
>  			break;
>  		case Opt_mode_page:
>  			match_strncpy(buf, &args[0], sizeof(buf));
> @@ -561,10 +665,34 @@ int spc_lu_config(struct scsi_lu *lu, char *params)
>  
>  int spc_lu_init(struct scsi_lu *lu)
>  {
> +	struct vpd **lu_vpd = lu->attrs.lu_vpd;
> +	struct target *tgt = lu->tgt;
> +	int pg;
> +
> +	lu->attrs.device_type = lu->dev_type_template.type;
> +	lu->attrs.qualifier = 0x0;
> +
>  	snprintf(lu->attrs.vendor_id, sizeof(lu->attrs.vendor_id),
>  		 "%-16s", VENDOR_ID);
>  	snprintf(lu->attrs.product_rev, sizeof(lu->attrs.product_rev),
>  		 "%s", "0001");
> +	snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
> +		 "deadbeaf%d:%" PRIu64, tgt->tid, lu->lun);
> +	snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
> +		 "beaf%d%" PRIu64, tgt->tid, lu->lun);
> +
> +	/* VPD page 0x80 */
> +	pg = 0x80 & 0x7f;
> +	lu_vpd[pg] = alloc_vpd(SCSI_SN_LEN);
> +	lu_vpd[pg]->vpd_update = update_vpd_80;
> +	lu_vpd[pg]->vpd_update(lu, lu->attrs.scsi_sn);
> +
> +	/* VPD page 0x83 */
> +	pg = 0x83 & 0x7f;
> +	lu_vpd[pg] = alloc_vpd(SCSI_ID_LEN + 4); /* +Designator descriptor len*/
> +	lu_vpd[pg]->vpd_update = update_vpd_83;
> +	lu_vpd[pg]->vpd_update(lu, lu->attrs.scsi_id);
> +
>  	lu->attrs.removable = 0;
>  	lu->attrs.sense_format = 0;
>  	lu->attrs.online = 0;
> @@ -572,3 +700,15 @@ int spc_lu_init(struct scsi_lu *lu)
>  
>  	return 0;
>  }
> +
> +void spc_lu_exit(struct scsi_lu *lu)
> +{
> +	int i;
> +	struct vpd **lu_vpd = lu->attrs.lu_vpd;
> +
> +	for (i = 0; i < 0x80; i++)
> +		if (lu_vpd[i])
> +			free(lu_vpd[i]);
> +
> +}
> +
> diff --git a/usr/spc.h b/usr/spc.h
> index 1cc8623..dfb8987 100644
> --- a/usr/spc.h
> +++ b/usr/spc.h
> @@ -12,8 +12,10 @@ extern int spc_lu_init(struct scsi_lu *lu);
>  typedef int (match_fn_t)(struct scsi_lu *lu, char *params);
>  extern int lu_config(struct scsi_lu *lu, char *params, match_fn_t *);
>  extern int spc_lu_config(struct scsi_lu *lu, char *params);
> +extern void spc_lu_exit(struct scsi_lu *lu);
>  extern void dump_cdb(struct scsi_cmd *cmd);
>  extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
>  extern int add_mode_page(struct scsi_lu *lu, char *params);
> +extern struct vpd *alloc_vpd(uint16_t size);
>  
>  #endif
> diff --git a/usr/target.c b/usr/target.c
> index 2474d05..22eec0b 100644
> --- a/usr/target.c
> +++ b/usr/target.c
> @@ -261,12 +261,14 @@ int tgt_device_create(int tid, int dev_type, uint64_t lun, char *args, int backi
>  		goto free_lu;
>  	}
>  
> +	lu->tgt = target;
> +
>  	lu->lun = lun;
>  	lu->lu_state = SCSI_LU_RUNNING;
>  	tgt_cmd_queue_init(&lu->cmd_queue);
>  
>   	if (lu->dev_type_template.lu_init) {
> - 		ret = lu->dev_type_template.lu_init(lu);
> +		ret = lu->dev_type_template.lu_init(lu);
>  		if (ret)
>  			goto free_lu;
>  	}
> @@ -285,13 +287,6 @@ int tgt_device_create(int tid, int dev_type, uint64_t lun, char *args, int backi
>  			goto free_lu;
>  	}
>  
> -	lu->attrs.device_type = lu->dev_type_template.type;
> -	lu->attrs.qualifier = 0x0;
> -	snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
> -		 "deadbeaf%d:%" PRIu64, tid, lun);
> -	snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
> -		 "beaf%d%" PRIu64, tid, lun);
> -
>  	if (tgt_drivers[target->lid]->lu_create)
>  		tgt_drivers[target->lid]->lu_create(lu);
>  
> diff --git a/usr/tgtd.h b/usr/tgtd.h
> index c39b9c2..45bd8f6 100644
> --- a/usr/tgtd.h
> +++ b/usr/tgtd.h
> @@ -36,6 +36,15 @@ struct tgt_cmd_queue {
>  	struct list_head queue;
>  };
>  
> +struct scsi_lu;
> +struct scsi_cmd;
> +
> +struct vpd {
> +	uint16_t size;
> +	void (*vpd_update)(struct scsi_lu *lu, void *data);
> +	uint8_t data[0];
> +};
> +
>  struct lu_phy_attr {
>  	char scsi_id[SCSI_ID_LEN + 1];
>  	char scsi_sn[SCSI_SN_LEN + 1];
> @@ -52,10 +61,9 @@ struct lu_phy_attr {
>  	char online;		/* Logical Unit online */
>  	char reset;		/* Power-on or reset has occured */
>  	char sense_format;	/* Descrptor format sense data supported */
> -};
>  
> -struct scsi_lu;
> -struct scsi_cmd;
> +	struct vpd *lu_vpd[0x80]; /* VPD pages 0x80 -> 0xff masked with 0x80*/
> +};
>  
>  struct device_type_operations {
>  	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
> @@ -109,6 +117,8 @@ struct scsi_lu {
>  
>  	struct backingstore_template *bst;
>  
> +	struct target *tgt;
> +
>  	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
>  	struct mode_pg *mode_pgs[0x3f];
>  
> -- 
> 1.5.2.3
> 
> 
> 
> 
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel


From okir at lst.de  Mon Sep 17 09:08:19 2007
From: okir at lst.de (Olaf Kirch)
Date: Mon, 17 Sep 2007 09:08:19 +0200
Subject: [Stgt-devel] [PATCH] isns fix initiator -> target
In-Reply-To: <46ECCB54.6010701@gmail.com>
References: <46EC4051.7040704@gmail.com>
	<200709160542.l8G5gJgw022599@mbox.iij4u.or.jp>
	<46ECCB54.6010701@gmail.com>
Message-ID: <200709170908.20408.okir@lst.de>

On Sunday 16 September 2007 08:21, Albert Pauw wrote:
> I am running open-iscsi and tgt on the same host, but as we discovered 
> earlier the registration with open-isns gets confused about this. But 
> even when the initiator has been stopped and shortly after expunged from 
> the isns database something of it is left. When I start tgt isns still 
> thinks that it is an initiator (as it comes from the same host).

That sounds weird indeed. Can you reproduce this reliably? If so,
please send me the complete debug log of the session, as well as
a database dump taken before and after tgt re-registers.

Olaf
-- 
Olaf Kirch  |  --- o --- Nous sommes du soleil we love when we play
okir at lst.de |    / | \   sol.dhoop.naytheet.ah kin.ir.samse.qurax


From albert.pauw at gmail.com  Mon Sep 17 09:57:39 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Mon, 17 Sep 2007 09:57:39 +0200
Subject: [Stgt-devel] [PATCH] isns fix initiator -> target
In-Reply-To: <200709170908.20408.okir@lst.de>
References: <46EC4051.7040704@gmail.com>
	<200709160542.l8G5gJgw022599@mbox.iij4u.or.jp>
	<46ECCB54.6010701@gmail.com> <200709170908.20408.okir@lst.de>
Message-ID: <b2919bc20709170057k3898778ub5bd49c10a9c1505@mail.gmail.com>

Hi Olaf,

I haven't been able to reproduce this. I must have mixed up things (as it
was quite late),
and the next day (after clearing the isns DB by hand first) everything
worked as it should.


On 9/17/07, Olaf Kirch <okir at lst.de> wrote:
>
> On Sunday 16 September 2007 08:21, Albert Pauw wrote:
> > I am running open-iscsi and tgt on the same host, but as we discovered
> > earlier the registration with open-isns gets confused about this. But
> > even when the initiator has been stopped and shortly after expunged from
> > the isns database something of it is left. When I start tgt isns still
> > thinks that it is an initiator (as it comes from the same host).
>
> That sounds weird indeed. Can you reproduce this reliably? If so,
> please send me the complete debug log of the session, as well as
> a database dump taken before and after tgt re-registers.
>
> Olaf
> --
> Olaf Kirch  |  --- o --- Nous sommes du soleil we love when we play
> okir at lst.de |    / | \   sol.dhoop.naytheet.ah kin.ir.samse.qurax
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070917/31186302/attachment.html>

From pw at osc.edu  Mon Sep 17 16:41:02 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 17 Sep 2007 10:41:02 -0400
Subject: [Stgt-devel] first burst > max burst
Message-ID: <20070917144102.GA28236@osc.edu>

I've been tripping over this lately:

        if ((session->imm_data_en || !session->initial_r2t_en) &&
             session->first_burst > session->max_burst) {
                printk("iscsi: invalid burst lengths: "
                       "first_burst %d max_burst %d\n",
                       session->first_burst, session->max_burst);
                return -EINVAL;
        }       

when testing stock v2.6.23-rc6.  My previous kernel had that
code hacked out, somewhat accidentally.

The open-iscsi regression.dat has two blocks of 10 tests total that
will trigger this complaint.  It asks for FBL from 4k..128k, but MBL
of only 4k.

The spec tells us:

   FirstBurstLength MUST NOT exceed MaxBurstLength.

But stgt does not enforce this constraint.

What's your philosophy here?  The initiator is asking for something
that is not valid.  Negotiation happens with the target, which
merrily does the "minimum" dance for the two parameters separately, but
doesn't enforce the constraint.  Then finally in iscsi_conn_start(),
the initiator complains.  Do you think stgt should have code that
quietly decreases FirstBurstLength if it exceeds MaxBurstLength so
that the login will succeed?

I would have thought this was operator error, not a target
deficiency, but your commit ffd0436ed2e5a741c8d30062b489b989acf0a526
says in part:

    iSCSI RFC states that the first burst length must be smaller than the
    max burst length. We currently assume targets will be good, but that may
    not be the case, so this patch adds a check.

Whose job is it to be good here?

		-- Pete


From apauw at inter.nl.net  Mon Sep 17 22:27:57 2007
From: apauw at inter.nl.net (Albert Pauw)
Date: Mon, 17 Sep 2007 22:27:57 +0200
Subject: [Stgt-devel] Difference in isns implementation between open-iscsi
	and tgt
Message-ID: <46EEE34D.9030104@inter.nl.net>

Tomo,

I noticed the following difference between the open-iscsi and tgt 
implementation of isns.

As isns server I am using open-isns. What I see is that when I start
open-iscsi, it registers itself and then closes the connection.

When I start tgt, it registers itself, but leaves the connection open.
Only when I stop tgt it closes the connection with the isns server.
Shouldn't it also close the connection after registration, only open
it again when a targetnode is added or deleted and close it after?

Albert


From tomof at acm.org  Tue Sep 18 04:19:53 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Tue, 18 Sep 2007 11:19:53 +0900
Subject: [Stgt-devel] Difference in isns implementation between
 open-iscsi	and tgt
In-Reply-To: <46EEE34D.9030104@inter.nl.net>
References: <46EEE34D.9030104@inter.nl.net>
Message-ID: <200709180219.l8I2JsbN032617@mbox.iij4u.or.jp>

From: Albert Pauw <apauw at inter.nl.net>
Subject: [Stgt-devel] Difference in isns implementation between open-iscsi	and tgt
Date: Mon, 17 Sep 2007 22:27:57 +0200

> Tomo,
> 
> I noticed the following difference between the open-iscsi and tgt 
> implementation of isns.
> 
> As isns server I am using open-isns. What I see is that when I start
> open-iscsi, it registers itself and then closes the connection.
> 
> When I start tgt, it registers itself, but leaves the connection open.
> Only when I stop tgt it closes the connection with the isns server.
> Shouldn't it also close the connection after registration, only open
> it again when a targetnode is added or deleted and close it after?

IIRC, RFC says nothing about it.

I can't recall why I implemented both differently.


From markh794 at gmail.com  Tue Sep 18 13:02:45 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Tue, 18 Sep 2007 21:02:45 +1000
Subject: [Stgt-devel] [Patch 1/1] Add support for VPD pages 80h - ffh
In-Reply-To: <20070915190146K.tomof@acm.org>
References: <46DE60A6.8050904@gmail.com> <20070915190146K.tomof@acm.org>
Message-ID: <46EFB055.5010907@gmail.com>

FUJITA Tomonori wrote:
> On Wed, 05 Sep 2007 17:54:14 +1000
> Mark Harvey <markh794 at gmail.com> wrote:
>
>   
>> Re-submit of patch with suggested improvements.
>>
>> - Added pointer struct target to scsi_lu struct
>> - Added lu_exit() to free allocation of VPD pages
>> - Removed osd from test startup script
>> - Removed osd specific VPD pages B0h and B1h
>>
>> - Passes checkpatch.pl sanity check.
>>     
>
> Merged, Thanks! Sorry about the delay again.
>
>   

Many thanks.

> Here are some comments.
>
>   

Thanks..

>   
>> +/** Protocol Identifier Values
>> + * 0 Fibre Channel (FCP-2)
>> + * 1 Parallel SCSI (SPI-5)
>>     
>
> We use the following style:
>
>   
OK - Noted for next time.
I tried to fit this into the kernel-doc style..

>> +/*
>> + * Protocol Identifier Values
>> + *
>> + * 0 Fibre Channel (FCP-2)
>> + * 1 Parallel SCSI (SPI-5)
>>     
>
>
>   
>> +static int valid_vpd(struct vpd **lu_vpd, uint8_t page)
>> +{
>> +	if (lu_vpd[page & 0x7f])
>> +		return 1;
>>     
>
> I think that we use 0x7f and 0x80 at too many places. I put new macros
> for them.
>   

Much nicer - thanks.

And for the macros.

For some reason I always seem to steer clear of macros - and I don't 
really know why. Especially when examples are presented to make life easier.


>
>   
>> +	return 0;
>> +}
>> +
>> +void update_vpd_80(struct scsi_lu *lu, void *sn)
>> +{
>> +	struct vpd *vpd_pg = lu->attrs.lu_vpd[0];
>> +	char *data = (char *)vpd_pg->data;
>> +
>> +	snprintf(data, SCSI_SN_LEN, "%-8s", (char *)sn);
>>     
>
> This doesn't work. We need right-aligned ASCII data.
>   

Thats what I was trying to achieve with %-8s...

Thanks for the correction.

>
>   
>> +}
>> +
>> +void update_vpd_83(struct scsi_lu *lu, void *id)
>> +{
>> +	struct vpd *vpd_pg = lu->attrs.lu_vpd[3];
>> +	uint8_t	*data = vpd_pg->data;
>> +
>> +	data[0] = (PIV_ISCSI << 4) | INQ_CODE_ASCII;
>> +	data[1] = PIV_VALID | ASS_TGT_PORT | DESG_VENDOR;
>> +	data[3] = SCSI_ID_LEN;
>> +
>> +	strncpy((char *)data + 4, id, SCSI_ID_LEN);
>> +}
>> +
>>  int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>>  {
>>  	int len = 0, ret = SAM_STAT_CHECK_CONDITION;
>> @@ -47,6 +138,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>>  	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
>>  	uint8_t devtype = 0;
>>  	struct lu_phy_attr *attrs;
>> +	struct vpd *vpd_pg;
>>  
>>  	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
>>  		goto sense;
>> @@ -98,43 +190,35 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>>  	} else if (scb[1] & 0x1) {
>>  		/* EVPD bit set */
>>  		if (scb[2] == 0x0) {
>> +			int i, j, tmp;
>> +
>> +			i = 5;
>> +			tmp = 1;
>>  			data[0] = devtype;
>> -			data[1] = 0x0;
>> -			data[3] = 3;
>> +			data[1] = 0;
>> +			data[2] = 0;
>> +			for (j = 0; j < 0x80; j++) {
>> +				if (attrs->lu_vpd[j]) {
>> +					data[i] = j | 0x80;
>> +					tmp++;
>> +					i++;
>> +				}
>> +			}
>>     
>
> I use a more common way here.
>   

Again, thanks.

>
>   
>> +			data[3] = tmp;
>>  			data[4] = 0x0;
>> -			data[5] = 0x80;
>> -			data[6] = 0x83;
>> -			len = 7;
>> +			len = tmp + 4;
>>  			ret = SAM_STAT_GOOD;
>> -		} else if (scb[2] == 0x80) {
>> -			int tmp = SCSI_SN_LEN;
>> -
>> -			data[1] = 0x80;
>> -			data[3] = SCSI_SN_LEN;
>> -			memset(data + 4, 0x20, 4);
>> -			len = 4 + SCSI_SN_LEN;
>> -			ret = SAM_STAT_GOOD;
>> -
>> -			if (strlen(attrs->scsi_sn)) {
>> -				uint8_t *p;
>> -				char *q;
>> +		} else if (valid_vpd(attrs->lu_vpd, scb[2])) {
>> +			int tmp;
>> +			vpd_pg = attrs->lu_vpd[scb[2] & 0x7f];
>> +			tmp = vpd_pg->size;
>>  
>> -				p = data + 4 + tmp - 1;
>> -				q = attrs->scsi_sn + SCSI_SN_LEN - 1;
>> -				for (; tmp > 0; tmp--, q)
>> -					*(p--) = *(q--);
>> -			}
>> -		} else if (scb[2] == 0x83) {
>> -			int tmp = SCSI_ID_LEN;
>> -
>> -			data[1] = 0x83;
>> -			data[3] = tmp + 4;
>> -			data[4] = 0x1;
>> -			data[5] = 0x1;
>> -			data[7] = tmp;
>> -			strncpy((char *) data + 8, attrs->scsi_id, SCSI_ID_LEN);
>> -
>> -			len = tmp + 8;
>> +			data[0] = devtype;
>> +			data[1] = scb[2];
>> +			data[2] = (tmp >> 8);
>> +			data[3] = tmp & 0xff;
>> +			memcpy(&data[4], vpd_pg->data, tmp);
>> +			len = tmp + 4;
>>  			ret = SAM_STAT_GOOD;
>>  		}
>>  	}
>> @@ -358,6 +442,19 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
>>  	return SAM_STAT_GOOD;
>>  }
>>  
>> +struct vpd *alloc_vpd(uint16_t size)
>> +{
>> +	struct vpd *vpd_pg;
>> +
>> +	vpd_pg = zalloc(sizeof(struct vpd) + size);
>> +	if (!vpd_pg)
>> +		return NULL;
>> +
>> +	vpd_pg->size = size;
>> +
>> +	return vpd_pg;
>> +}
>> +
>>  static struct mode_pg *alloc_mode_pg(uint8_t pcode, uint8_t subpcode,
>>  				     uint16_t size)
>>  {
>> @@ -500,6 +597,11 @@ int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
>>  	int err = TGTADM_SUCCESS;
>>  	char *p;
>>  	char buf[256];
>> +	struct lu_phy_attr *attrs;
>> +	struct vpd **lu_vpd;
>> +
>> +	attrs = &lu->attrs;
>> +	lu_vpd = attrs->lu_vpd;
>>  
>>  	if (!strncmp("targetOps", params, 9))
>>  		params = params + 10;
>> @@ -512,36 +614,38 @@ int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
>>  		token = match_token(p, tokens, args);
>>  		switch (token) {
>>  		case Opt_scsi_id:
>> -			match_strncpy(lu->attrs.scsi_id, &args[0],
>> -				      sizeof(lu->attrs.scsi_id));
>> +			match_strncpy(attrs->scsi_id, &args[0],
>> +						sizeof(attrs->scsi_id));
>>     
>
> Wrong tabs. Should be:
>
> +			match_strncpy(attrs->scsi_id, &args[0],
> +				      sizeof(attrs->scsi_id));
>
>
>   
>> +			lu_vpd[3]->vpd_update(lu, attrs->scsi_id);
>>  			break;
>>  		case Opt_scsi_sn:
>> -			match_strncpy(lu->attrs.scsi_sn, &args[0],
>> -				      sizeof(lu->attrs.scsi_sn));
>> +			match_strncpy(attrs->scsi_sn, &args[0],
>> +						sizeof(attrs->scsi_sn));
>> +			lu_vpd[0]->vpd_update(lu, attrs->scsi_sn);
>>  			break;
>>  		case Opt_vendor_id:
>> -			match_strncpy(lu->attrs.vendor_id, &args[0],
>> -				      sizeof(lu->attrs.vendor_id));
>> +			match_strncpy(attrs->vendor_id, &args[0],
>> +						sizeof(attrs->vendor_id));
>>  			break;
>>  		case Opt_product_id:
>> -			match_strncpy(lu->attrs.product_id, &args[0],
>> -				      sizeof(lu->attrs.product_id));
>> +			match_strncpy(attrs->product_id, &args[0],
>> +						sizeof(attrs->product_id));
>>  			break;
>>  		case Opt_product_rev:
>> -			match_strncpy(lu->attrs.product_rev, &args[0],
>> -				      sizeof(lu->attrs.product_rev));
>> +			match_strncpy(attrs->product_rev, &args[0],
>> +						sizeof(attrs->product_rev));
>>  			break;
>>  		case Opt_sense_format:
>>  			match_strncpy(buf, &args[0], sizeof(buf));
>> -			lu->attrs.sense_format = atoi(buf);
>> +			attrs->sense_format = atoi(buf);
>>  			break;
>>  		case Opt_removable:
>>  			match_strncpy(buf, &args[0], sizeof(buf));
>> -			lu->attrs.removable = atoi(buf);
>> +			attrs->removable = atoi(buf);
>>  			break;
>>  		case Opt_online:
>>  			match_strncpy(buf, &args[0], sizeof(buf));
>> -			lu->attrs.online = atoi(buf);
>> +			attrs->online = atoi(buf);
>>  			break;
>>  		case Opt_mode_page:
>>  			match_strncpy(buf, &args[0], sizeof(buf));
>> @@ -561,10 +665,34 @@ int spc_lu_config(struct scsi_lu *lu, char *params)
>>  
>>  int spc_lu_init(struct scsi_lu *lu)
>>  {
>> +	struct vpd **lu_vpd = lu->attrs.lu_vpd;
>> +	struct target *tgt = lu->tgt;
>> +	int pg;
>> +
>> +	lu->attrs.device_type = lu->dev_type_template.type;
>> +	lu->attrs.qualifier = 0x0;
>> +
>>  	snprintf(lu->attrs.vendor_id, sizeof(lu->attrs.vendor_id),
>>  		 "%-16s", VENDOR_ID);
>>  	snprintf(lu->attrs.product_rev, sizeof(lu->attrs.product_rev),
>>  		 "%s", "0001");
>> +	snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
>> +		 "deadbeaf%d:%" PRIu64, tgt->tid, lu->lun);
>> +	snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
>> +		 "beaf%d%" PRIu64, tgt->tid, lu->lun);
>> +
>> +	/* VPD page 0x80 */
>> +	pg = 0x80 & 0x7f;
>> +	lu_vpd[pg] = alloc_vpd(SCSI_SN_LEN);
>> +	lu_vpd[pg]->vpd_update = update_vpd_80;
>> +	lu_vpd[pg]->vpd_update(lu, lu->attrs.scsi_sn);
>> +
>> +	/* VPD page 0x83 */
>> +	pg = 0x83 & 0x7f;
>> +	lu_vpd[pg] = alloc_vpd(SCSI_ID_LEN + 4); /* +Designator descriptor len*/
>> +	lu_vpd[pg]->vpd_update = update_vpd_83;
>> +	lu_vpd[pg]->vpd_update(lu, lu->attrs.scsi_id);
>> +
>>  	lu->attrs.removable = 0;
>>  	lu->attrs.sense_format = 0;
>>  	lu->attrs.online = 0;
>> @@ -572,3 +700,15 @@ int spc_lu_init(struct scsi_lu *lu)
>>  
>>  	return 0;
>>  }
>> +
>> +void spc_lu_exit(struct scsi_lu *lu)
>> +{
>> +	int i;
>> +	struct vpd **lu_vpd = lu->attrs.lu_vpd;
>> +
>> +	for (i = 0; i < 0x80; i++)
>> +		if (lu_vpd[i])
>> +			free(lu_vpd[i]);
>> +
>> +}
>> +
>> diff --git a/usr/spc.h b/usr/spc.h
>> index 1cc8623..dfb8987 100644
>> --- a/usr/spc.h
>> +++ b/usr/spc.h
>> @@ -12,8 +12,10 @@ extern int spc_lu_init(struct scsi_lu *lu);
>>  typedef int (match_fn_t)(struct scsi_lu *lu, char *params);
>>  extern int lu_config(struct scsi_lu *lu, char *params, match_fn_t *);
>>  extern int spc_lu_config(struct scsi_lu *lu, char *params);
>> +extern void spc_lu_exit(struct scsi_lu *lu);
>>  extern void dump_cdb(struct scsi_cmd *cmd);
>>  extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
>>  extern int add_mode_page(struct scsi_lu *lu, char *params);
>> +extern struct vpd *alloc_vpd(uint16_t size);
>>  
>>  #endif
>> diff --git a/usr/target.c b/usr/target.c
>> index 2474d05..22eec0b 100644
>> --- a/usr/target.c
>> +++ b/usr/target.c
>> @@ -261,12 +261,14 @@ int tgt_device_create(int tid, int dev_type, uint64_t lun, char *args, int backi
>>  		goto free_lu;
>>  	}
>>  
>> +	lu->tgt = target;
>> +
>>  	lu->lun = lun;
>>  	lu->lu_state = SCSI_LU_RUNNING;
>>  	tgt_cmd_queue_init(&lu->cmd_queue);
>>  
>>   	if (lu->dev_type_template.lu_init) {
>> - 		ret = lu->dev_type_template.lu_init(lu);
>> +		ret = lu->dev_type_template.lu_init(lu);
>>  		if (ret)
>>  			goto free_lu;
>>  	}
>> @@ -285,13 +287,6 @@ int tgt_device_create(int tid, int dev_type, uint64_t lun, char *args, int backi
>>  			goto free_lu;
>>  	}
>>  
>> -	lu->attrs.device_type = lu->dev_type_template.type;
>> -	lu->attrs.qualifier = 0x0;
>> -	snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
>> -		 "deadbeaf%d:%" PRIu64, tid, lun);
>> -	snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
>> -		 "beaf%d%" PRIu64, tid, lun);
>> -
>>  	if (tgt_drivers[target->lid]->lu_create)
>>  		tgt_drivers[target->lid]->lu_create(lu);
>>  
>> diff --git a/usr/tgtd.h b/usr/tgtd.h
>> index c39b9c2..45bd8f6 100644
>> --- a/usr/tgtd.h
>> +++ b/usr/tgtd.h
>> @@ -36,6 +36,15 @@ struct tgt_cmd_queue {
>>  	struct list_head queue;
>>  };
>>  
>> +struct scsi_lu;
>> +struct scsi_cmd;
>> +
>> +struct vpd {
>> +	uint16_t size;
>> +	void (*vpd_update)(struct scsi_lu *lu, void *data);
>> +	uint8_t data[0];
>> +};
>> +
>>  struct lu_phy_attr {
>>  	char scsi_id[SCSI_ID_LEN + 1];
>>  	char scsi_sn[SCSI_SN_LEN + 1];
>> @@ -52,10 +61,9 @@ struct lu_phy_attr {
>>  	char online;		/* Logical Unit online */
>>  	char reset;		/* Power-on or reset has occured */
>>  	char sense_format;	/* Descrptor format sense data supported */
>> -};
>>  
>> -struct scsi_lu;
>> -struct scsi_cmd;
>> +	struct vpd *lu_vpd[0x80]; /* VPD pages 0x80 -> 0xff masked with 0x80*/
>> +};
>>  
>>  struct device_type_operations {
>>  	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
>> @@ -109,6 +117,8 @@ struct scsi_lu {
>>  
>>  	struct backingstore_template *bst;
>>  
>> +	struct target *tgt;
>> +
>>  	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
>>  	struct mode_pg *mode_pgs[0x3f];
>>  
>> -- 
>> 1.5.2.3
>>
>>
>>
>>
>> _______________________________________________
>> Stgt-devel mailing list
>> Stgt-devel at lists.berlios.de
>> https://lists.berlios.de/mailman/listinfo/stgt-devel
>>     
>
>   

Regards
Mark


From pw at osc.edu  Tue Sep 18 17:21:50 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 18 Sep 2007 11:21:50 -0400
Subject: [Stgt-devel] [PATCH] iscsi fix xmit param
In-Reply-To: <20070914054037P.tomof@acm.org>
References: <20070904200306.GB6578@osc.edu> <20070910024326H.tomof@acm.org>
	<20070914214034.GA15545@osc.edu> <20070914054037P.tomof@acm.org>
Message-ID: <20070918152150.GA30410@osc.edu>

tomof at acm.org wrote on Sat, 15 Sep 2007 09:29 +0900:
> I still don't see what you mean. tgt works with initiators doesn't
> provide MaxRecvDataSegmentLength during login. Can you try the
> attached patches.

You are right.  It was these lines in text_check_param that I was
not understanding:

	if (i == ISCSI_PARAM_MAX_XMIT_DLENGTH) {
		if (p[i].val > session_keys[i].def)
			p[i].val = session_keys[i].def;
		p[i].state = KEY_STATE_DONE;
		continue;
	}

Patch already dropped.

		-- Pete


