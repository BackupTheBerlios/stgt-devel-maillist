From markh794 at gmail.com  Fri Jun  1 02:28:28 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 1 Jun 2007 10:28:28 +1000
Subject: [Stgt-devel] [Patch 0/2] Re-format / resubmit patch - try 3.
Message-ID: <f29db9a80705311728rd64b53q3e5379b091f6bcde@mail.gmail.com>

Apologies if this is a duplicate... gmail hick-up and I'm not actually
sure the first one was sent.

This is a re-submit of a previously rejected patch set.
I've corrected formatting style to suit.

This email includes both patches as attachments - I'll inline the two
patches in following email.

Unfortunately, I have yet to figure out how to inline patches thru
gmail and keep <tab> chars.


Patch 1 : Add new module entry points for configuration

Add new module entry points.
  <module>_lu_init(struct scsi_lu *lu) - called at setup time.
  <module>_lu_exit(struct scsi_lu *lu) - called at shutdown time.
  <module>_lu_config(struct scsi_lu *lu) - Any module unique configuration.

Moved logical unit configuration from target -> <module>
  Along with above entry point <module>_lu_config(), will allow module
  specific configuration.
  No new functionality added yet.

Add a dump_cdb(struct scsi_cmd *cmd) - Called from spc_illegal_op()

Update - All modules use common INQUIRY routine.



Patch 2 : Add ability to dynamically set SCSI Inquiry params

Added support to configure:
  Vendor Identification
  Product Identification
  Product Revision
  Format of returned 'sense data'
  Define if the lu is capable of supporting removable media
  Define/set if the lu is online / offline.
  Params are passed using the 'tgtadm' utility:

  VendorIdent="string"
  ProductIdent="string"
  ProductRev="string"
  Removable=<0|1> - 0 == non-removable, 1 == removable media
  SenseFormat=<0|1> - 0 == Clasic sense format, 1 == New sense format
  Online=<0|1> - 0 == Unit offline, 1 == Unit Online

e.g.
tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
        --params VendorIdent=QUANTUM,ProductIdent=HD100,ProductRev=0010
tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
        --params Removable=1,SenseFormat=1,Online=1

Example script (scripts/tgt-core-test) to set up HDD & CD device.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0001-Add-new-module-entry-points-for-configuration.patch
Type: text/x-patch
Size: 22153 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070601/515d9afd/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: 0002-Add-ability-to-dynamically-set-SCSI-Inquiry-params.patch
Type: text/x-patch
Size: 5724 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070601/515d9afd/attachment-0001.bin>

From markh794 at gmail.com  Fri Jun  1 02:32:39 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 1 Jun 2007 10:32:39 +1000
Subject: [Stgt-devel] [Patch 1/2]
	Add-new-module-entry-points-for-configuration
Message-ID: <f29db9a80705311732w2f0bb27es1959faadbf88b141@mail.gmail.com>

In-lined version of the patch attachment included with [patch 0/2]... - try3

Maybe easier reading, but unsuitable for actual patching :(

Pls advise if this is considered spam & I should just not send an
inline version until I figure out gmail..



From markh794 at gmail.com  Fri Jun  1 02:34:16 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 1 Jun 2007 10:34:16 +1000
Subject: [Stgt-devel] [Patch 2/2]
	Add-ability-to-dynamically-set-SCSI-Inquiry-params - Try 3
Message-ID: <f29db9a80705311734n7ac03c5lc7db2845e5b8c938@mail.gmail.com>

Same disclaimer as [Patch 1/2]...



From vst at vlnb.net  Fri Jun  1 17:12:01 2007
From: vst at vlnb.net (Vladislav Bolkhovitin)
Date: Fri, 01 Jun 2007 19:12:01 +0400
Subject: [Stgt-devel] Question for pass-through target design
In-Reply-To: <463F36AC.3010207@vlnb.net>
References: <20070504160712.GB16528@austin.ibm.com>	<200705041704.l44H4WXa003789@mbox.iij4u.or.jp>	<463B72F6.3000207@torque.net>
	<20070506053629P.fujita.tomonori@lab.ntt.co.jp>
	<463F36AC.3010207@vlnb.net>
Message-ID: <46603741.308@vlnb.net>

Vladislav Bolkhovitin wrote:
> So, if you need in-kernel pass-through I would suggest you to look at
> SCST project (http://scst.sf.net), which is currently stable and mature,
> although also not fully finished yet. It was historically from the very
> beginning designed for full feature in-kernel pass-through for not only
> stateless SCSI devices, like disks, but also for stateful SCSI devices
> (like SSC ones a.k.a. tapes), where the correct handling of all above is
> essential. In additional to considerably better performance, the
> complete in-kernel approach makes the code simpler, smaller and cleaner
> as well as allows such things as zero-copy buffered file IO, i.e. when 
> data are sent to remote initiators or received from them directly 
> from/to the page cache (currently under development). For those who need 
> implementing SCSI devices in the user space scst_user module is about to 
> be added. Since the SCSI state machine is in kernel the interface 
> provided by scst_user is very simple, it essentially consists from only 
> a single IOCTL and allows to have overhead as low as a single syscall 
> per SCSI command without any additional context switches. It is already 
> implemented and works. For some legal reasons I can't at the moment 
> publish it, but you can see its full description in the project's SVN 
> docs (you can get them using command "svn co 
> https://svn.sourceforge.net/svnroot/scst/trunk/doc").

Now I released scst_user module and it is available from the SCST SVN, 
so you can check how simply it allows to write SCSI devices, like a VTL, 
in the user space.

Vlad


From fujita.tomonori at lab.ntt.co.jp  Sat Jun  2 03:53:05 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 02 Jun 2007 10:53:05 +0900
Subject: [Stgt-devel] [Patch
	1/2]	Add-new-module-entry-points-for-configuration
In-Reply-To: <f29db9a80705311732w2f0bb27es1959faadbf88b141@mail.gmail.com>
References: <f29db9a80705311732w2f0bb27es1959faadbf88b141@mail.gmail.com>
Message-ID: <200706020153.l521rP0g013718@mbox.iij4u.or.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 1/2]	Add-new-module-entry-points-for-configuration
Date: Fri, 1 Jun 2007 10:32:39 +1000

> In-lined version of the patch attachment included with [patch 0/2]... - try3
> 
> Maybe easier reading, but unsuitable for actual patching :(
> 
> Pls advise if this is considered spam & I should just not send an
> inline version until I figure out gmail..

Yeah, you don't need to send until you fix the gmail
configuration. Seems that some developers can use the proper format
with gmail though they might use gmail via smtp and pop service.


From fujita.tomonori at lab.ntt.co.jp  Sat Jun  2 03:53:03 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 02 Jun 2007 10:53:03 +0900
Subject: [Stgt-devel] [Patch 0/2] Re-format / resubmit patch - try 3.
In-Reply-To: <f29db9a80705311728rd64b53q3e5379b091f6bcde@mail.gmail.com>
References: <f29db9a80705311728rd64b53q3e5379b091f6bcde@mail.gmail.com>
Message-ID: <200706020153.l521rOp9031625@mbox.iij4u.or.jp>

Thanks a lot, mostly looks ok. some minor things...

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 0/2] Re-format / resubmit patch - try 3.
Date: Fri, 1 Jun 2007 10:28:28 +1000

> From 04040395672afd987d3d439bd5657c57db1cf2f9 Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Fri, 1 Jun 2007 06:00:43 +1000
> Subject: [PATCH] Add new module entry points for configuration
> 
> Add new module entry points.
>   <module>_lu_init(struct scsi_lu *lu) - called at setup time.
>   <module>_lu_exit(struct scsi_lu *lu) - called at shutdown time.
>   <module>_lu_config(struct scsi_lu *lu) - Any module unique configuration.
> 
> Moved logical unit configuration from target -> <module>
>   Along with above entry point <module>_lu_config(), will allow module
>   specific configuration.
>   No new functionality added yet.
> 
> Add a dump_cdb(struct scsi_cmd *cmd) - Called from spc_illegal_op()
> 
> Update - All modules use common INQUIRY routine.
> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>
> 
> diff --git a/usr/mmc.c b/usr/mmc.c
> index e9cc479..ae0a0ca 100644
> --- a/usr/mmc.c
> +++ b/usr/mmc.c
> @@ -121,11 +121,32 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
>  	return SAM_STAT_GOOD;
>  }
>  
> +static int mmc_lu_init(struct scsi_lu *lu)
> +{
> +	if (spc_lu_init(lu))
> +		return -ENOMEM;
> +
> +	memcpy(lu->attributes->ProductIdent, "VIRTUAL-CDROM", 16);
> +	lu->attributes->sense_format = 1;
> +	lu->attributes->version_desc[0] = 0x02A0; /* MMC3, no version claimed */
> +	lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
> +	lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
> +
> +	return 0;
> +}
> +
> +static int mmc_lu_exit(struct scsi_lu *lu)
> +{
> +	return 0;
> +}
> +
>  struct device_type_template mmc_template = {
> -	.type	= TYPE_ROM,
> -	.name	= "cdrom/dvd",
> -	.pid	= "VIRTUAL-CDROM",
> -	.ops	= {
> +	.type		= TYPE_ROM,
> +	.name		= "cdrom/dvd",
> +	.lu_init	= mmc_lu_init,
> +	.lu_exit	= mmc_lu_exit,
> +	.lu_config	= spc_lu_config,
> +	.ops		= {
>  		{spc_test_unit,},
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
> diff --git a/usr/osd.c b/usr/osd.c
> index 46bf0a0..0ce8fde 100644
> --- a/usr/osd.c
> +++ b/usr/osd.c
> @@ -20,6 +20,7 @@
>   * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
>   * 02110-1301 USA
>   */
> +#include <errno.h>
>  #include <inttypes.h>
>  #include <stdio.h>
>  #include <stdlib.h>
> @@ -33,101 +34,6 @@
>  #include "scsi.h"
>  #include "spc.h"
>  
> -#define PRODUCT_ID	"OSD"
> -#define PRODUCT_REV	"0"
> -
> -static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
> -{
> -	uint8_t *data, *scb = cmd->scb;
> -	int len, ret = SAM_STAT_CHECK_CONDITION;
> -	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
> -
> -	/* EVPD means need a page code */
> -	if ((scb[1] & 0x3) == 0 && scb[2] != 0)
> -		goto sense;
> -
> -	data = valloc(pagesize);
> -	if (!data) {
> -		key = HARDWARE_ERROR;
> -		asc = 0;
> -		goto sense;
> -	}
> -	memset(data, 0, pagesize);
> -
> -	dprintf("%x %x\n", scb[1], scb[2]);
> -
> -	data[0] = TYPE_OSD;
> -	if (!cmd->dev)
> -		data[0] = TYPE_NO_LUN;
> -
> -	if ((scb[1] & 0x1) == 0) {
> -		data[2] = 5;  /* modern version */
> -		data[3] = 0x02;  /* modern response format */
> -		data[7] = 0x02;  /* support command queueing */
> -		memset(data + 8, 0x20, 28);
> -		memcpy(data + 8,
> -		       VENDOR_ID, min_t(size_t, strlen(VENDOR_ID), 8));
> -		memcpy(data + 16,
> -		       PRODUCT_ID, min_t(size_t, strlen(PRODUCT_ID), 16));
> -		memcpy(data + 32,
> -		       PRODUCT_REV, min_t(size_t, strlen(PRODUCT_REV), 4));
> -		len = 36;
> -		if (cmd->dev) {
> -			data[58] = 0x03;
> -			data[59] = 0x40;  /* osd */
> -			data[60] = 0x09;
> -			data[61] = 0x60;  /* iscsi */
> -			data[62] = 0x03;
> -			data[63] = 0x00;  /* spc3 */
> -			len = 64;
> -		}
> -		data[4] = len - 5;  /* additional length */
> -		ret = SAM_STAT_GOOD;
> -	} else {
> -		if (!cmd->dev)
> -			goto sense;
> -
> -		data[1] = scb[2];
> -		if (scb[2] == 0x0) {
> -			/* supported VPD pages */
> -			data[3] = 3;
> -			data[4] = 0x0;
> -			data[5] = 0x80;
> -			data[6] = 0x83;
> -			len = 7;
> -			ret = SAM_STAT_GOOD;
> -		} else if (scb[2] == 0x80) {
> -			/* unit serial number "    " */
> -			data[3] = 4;
> -			memset(data + 4, 0x20, 4);
> -			len = 8;
> -			ret = SAM_STAT_GOOD;
> -		} else if (scb[2] == 0x83) {
> -			/* device identification */
> -			data[3] = SCSI_ID_LEN + 4;
> -			data[4] = 0x1;
> -			data[5] = 0x1;
> -			data[7] = SCSI_ID_LEN;
> -			if (cmd->dev)
> -				memcpy(data + 8, cmd->dev->scsi_id, SCSI_ID_LEN);
> -			len = SCSI_ID_LEN + 8;
> -			ret = SAM_STAT_GOOD;
> -		}
> -	}
> -
> -	if (ret != SAM_STAT_GOOD)
> -		goto sense;
> -
> -	cmd->len = min_t(int, len, scb[4]);
> -	cmd->uaddr = (unsigned long) data;
> -
> -	return SAM_STAT_GOOD;
> -sense:
> -	sense_data_build(cmd, key, asc, 0);
> -	cmd->len = 0;
> -	return SAM_STAT_CHECK_CONDITION;
> -}
> -
>  static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
>  {
>  	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
> @@ -145,22 +51,37 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
>  	return cmd->c_target->bst->bs_cmd_submit(cmd);
>  }
>  
> -static void device_osd_init(struct scsi_lu *lu)
> +static int osd_lu_init(struct scsi_lu *lu)
> +{
> +	if (spc_lu_init(lu))
> +		return -ENOMEM;
> +
> +	memcpy(lu->attributes->ProductIdent, "OSD", 16);
> +	lu->attributes->sense_format = 1;
> +	lu->attributes->version_desc[0] = 0x0340; /* OSD */
> +	lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
> +	lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
> +
> +	return 0;
> +}
> +
> +static int osd_lu_exit(struct scsi_lu *lu)
>  {
> -	lu->d_sense = 1;
> +	return 0;
>  }
>  
>  struct device_type_template osd_template = {
>  	.type		= TYPE_OSD,
>  	.name		= "osd",
> -	.device_init	= device_osd_init,
> +	.lu_init	= osd_lu_init,
> +	.lu_exit	= osd_lu_exit,
>  	.ops		= {
>  		[0x00 ... 0x0f] = {spc_illegal_op},
>  
>  		/* 0x10 */
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
> -		{osd_inquiry,},
> +		{spc_inquiry,},
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
> diff --git a/usr/parser.h b/usr/parser.h
> index 1ff6016..bf210bf 100644
> --- a/usr/parser.h
> +++ b/usr/parser.h
> @@ -17,7 +17,7 @@ struct match_token {
>  typedef struct match_token match_table_t[];
>  
>  /* Maximum number of arguments that match_token will find in a pattern */
> -enum {MAX_OPT_ARGS = 3};
> +enum {MAX_OPT_ARGS = 17};

For what?


>  /* Describe the location within a string of a substring */
>  typedef struct {
> diff --git a/usr/sbc.c b/usr/sbc.c
> index a22d3b0..5357087 100644
> --- a/usr/sbc.c
> +++ b/usr/sbc.c
> @@ -337,11 +337,31 @@ sense:
>  	return SAM_STAT_CHECK_CONDITION;
>  }
>  
> +static int sbc_lu_init(struct scsi_lu *lu)
> +{
> +	if (spc_lu_init(lu))
> +		return -ENOMEM;
> +
> +	memcpy(lu->attributes->ProductIdent, "VIRTUAL-DISK", 16);
> +	lu->attributes->version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
> +	lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
> +	lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
> +
> +	return 0;
> +}
> +
> +static int sbc_lu_exit(struct scsi_lu *lu)
> +{
> +	return 0;
> +}
> +
>  struct device_type_template sbc_template = {
> -	.type	= TYPE_DISK,
> -	.name	= "disk",
> -	.pid	= "VIRTUAL-DISK",
> -	.ops	= {
> +	.type		= TYPE_DISK,
> +	.name		= "disk",
> +	.lu_init	= sbc_lu_init,
> +	.lu_exit	= sbc_lu_exit,
> +	.lu_config	= spc_lu_config,
> +	.ops		= {
>  		{spc_test_unit,},
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
> diff --git a/usr/scsi.c b/usr/scsi.c
> index 1a6929f..728dfe9 100644
> --- a/usr/scsi.c
> +++ b/usr/scsi.c
> @@ -40,7 +40,7 @@
>  
>  void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
>  {
> -	if (cmd->dev && cmd->dev->d_sense) {
> +	if (cmd->dev && cmd->dev->attributes->sense_format) {
>  		/* descriptor format */
>  
>  		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
> @@ -121,3 +121,4 @@ int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd)
>  	unsigned char op = cmd->scb[0];
>  	return cmd->c_target->dev_type_template.ops[op].cmd_perform(host_no, cmd);
>  }
> +
> diff --git a/usr/spc.c b/usr/spc.c
> index b922a45..e9a74d9 100644
> --- a/usr/spc.c
> +++ b/usr/spc.c
> @@ -19,6 +19,7 @@
>   * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
>   * 02110-1301 USA
>   */
> +#include <errno.h>
>  #include <stdio.h>
>  #include <stdlib.h>
>  #include <string.h>
> @@ -27,12 +28,15 @@
>  #include "list.h"
>  #include "util.h"
>  #include "tgtd.h"
> +#include "parser.h"
>  #include "target.h"
>  #include "driver.h"
> +#include "tgtadm_error.h"
>  #include "scsi.h"
>  #include "spc.h"
>  
>  #define PRODUCT_REV	"0"
> +#define BLK_SHIFT	9
>  
>  int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  {
> @@ -40,7 +44,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  	uint8_t *data;
>  	uint8_t *scb = cmd->scb;
>  	unsigned char device_type = cmd->c_target->dev_type_template.type;
> -	char *product_id = cmd->c_target->dev_type_template.pid;
> +	struct physicalAttributes * attributes = cmd->dev->attributes;
>  	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
>  
>  	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
> @@ -57,22 +61,21 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  	dprintf("%x %x\n", scb[1], scb[2]);
>  
>  	if (!(scb[1] & 0x3)) {
> +		int i;
>  		data[0] = device_type;
> -		data[2] = 4;
> +		data[1] = (attributes->isRemovable) ? 0x80 : 0;
> +		data[2] = 5;	/* SPC-3 */
>  		data[3] = 0x42;
> -		data[4] = 59;
>  		data[7] = 0x02;
>  		memset(data + 8, 0x20, 28);
> -		strncpy((char *)data + 8, VENDOR_ID, 8);
> -		strncpy((char *)data + 16, product_id, 16);
> -		strncpy((char *)data + 32, PRODUCT_REV, 4);
> -		data[58] = 0x03;
> -		data[59] = 0x20;
> -		data[60] = 0x09;
> -		data[61] = 0x60;
> -		data[62] = 0x03;
> -		data[63] = 0x00;
> -		len = 64;
> +		strncpy((char *)data + 8, attributes->VendorIdent, 8);
> +		strncpy((char *)data + 16, attributes->ProductIdent, 16);
> +		strncpy((char *)data + 32, attributes->ProductRev, 4);
> +		for (i=0, len=58; i < VERSION_DESCRIPTOR_LEN; i++, len += 2) {
> +			data[len] = (attributes->version_desc[i] >> 8) & 0xff;
> +			data[len+1] = attributes->version_desc[i] & 0xff;
> +		}
> +		data[4] = len - 5;	/* Additional Length */
>  		ret = SAM_STAT_GOOD;
>  	} else if (scb[1] & 0x2) {
>  		/* CmdDt bit is set */
> @@ -101,13 +104,13 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  			len = 4 + SCSI_SN_LEN;
>  			ret = SAM_STAT_GOOD;
>  
> -			if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
> +			if (cmd->dev && strlen(cmd->dev->attributes->scsi_sn)) {
>  				uint8_t *p;
>  				char *q;
>  
>  				p = data + 4 + tmp - 1;
> -				q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
> -
> +				q = cmd->dev->attributes->scsi_sn +
> +								SCSI_SN_LEN - 1;
>  				for (; tmp > 0; tmp--, q)
>  					*(p--) = *(q--);
>  			}
> @@ -120,7 +123,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  			data[5] = 0x1;
>  			data[7] = tmp;
>  			if (cmd->dev)
> -				strncpy((char *) data + 8, cmd->dev->scsi_id,
> +				strncpy((char *) data + 8,
> +					cmd->dev->attributes->scsi_id,
>  				        SCSI_ID_LEN);
>  			len = tmp + 8;
>  			ret = SAM_STAT_GOOD;
> @@ -238,9 +242,98 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
>  	return SAM_STAT_GOOD;
>  }
>  
> +void dump_cdb(struct scsi_cmd *cmd)
> +{
> +	uint8_t * cdb = cmd->scb;
> +
> +	switch(cmd->scb_len) {
> +	case 6:
> +		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x",
> +			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5]);
> +		break;
> +	case 10:
> +		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
> +				" %02x %02x %02x %02x",
> +			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
> +			cdb[6], cdb[7], cdb[8], cdb[9]);
> +		break;
> +	case 12:
> +		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
> +				" %02x %02x %02x %02x %02x %02x",
> +			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
> +			cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11]);
> +		break;
> +	case 16:
> +		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
> +				" %02x %02x %02x %02x %02x %02x"
> +				" %02x %02x %02x %02x",
> +			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
> +			cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11],
> +			cdb[12], cdb[13], cdb[14], cdb[15]);
> +		break;
> +	}
> +}
> +
>  int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
>  {
> +	dump_cdb(cmd);
>  	cmd->len = 0;
>  	sense_data_build(cmd, ILLEGAL_REQUEST, 0x20, 0);
>  	return SAM_STAT_CHECK_CONDITION;
>  }
> +
> +enum {
> +	Opt_scsiid, Opt_scsisn, Opt_err,
> +};
> +
> +static match_table_t tokens = {
> +	{Opt_scsiid, "scsi_id=%s"},
> +	{Opt_scsisn, "scsi_sn=%s"},
> +	{Opt_err, NULL},
> +};
> +
> +int spc_lu_config(struct scsi_lu *lu, char * params) {
> +	int err = 0;
> +	char *p;
> +
> +	if (!strncmp("targetOps", params, 9))
> +		params = params + 10;

Hacky, but the interface between tgtadm and tgtd is hacky. So it's ok
now and I'll fix it later on.


> +	while ((p = strsep(&params, ",")) != NULL) {
> +		substring_t args[MAX_OPT_ARGS];
> +		int token;
> +		if (!*p)
> +			continue;
> +		dprintf("*p : %s\n", p);
> +		token = match_token(p, tokens, args);
> +		switch (token) {
> +		case Opt_scsiid:
> +			match_strncpy(lu->attributes->scsi_id, &args[0],
> +				      sizeof(lu->attributes->scsi_id) - 1);
> +			break;
> +		case Opt_scsisn:
> +			match_strncpy(lu->attributes->scsi_sn, &args[0],
> +				      sizeof(lu->attributes->scsi_sn) - 1);
> +			break;
> +		default:
> +			err = TGTADM_INVALID_REQUEST;
> +		}
> +	}
> +	return err;
> +}
> +
> +int spc_lu_init(struct scsi_lu * lu)
> +{
> +	lu->attributes = zalloc(sizeof(struct physicalAttributes));
> +	if(!lu->attributes)
> +		return -ENOMEM;
> +
> +	memcpy(lu->attributes->VendorIdent, VENDOR_ID, 8);
> +	memcpy(lu->attributes->ProductRev, "0001", 4);
> +	lu->attributes->isRemovable = 0;
> +	lu->attributes->sense_format = 0;
> +	lu->attributes->onLine = 0;
> +	lu->attributes->reset = 1;
> +
> +	return 0;
> +}
> diff --git a/usr/spc.h b/usr/spc.h
> index f81e74c..1036b70 100644
> --- a/usr/spc.h
> +++ b/usr/spc.h
> @@ -7,5 +7,8 @@ extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
>  extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
>  extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
>  extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
> +extern int spc_lu_init(struct scsi_lu *lu);
> +extern int spc_lu_config(struct scsi_lu *lu, char * params);
> +extern void dump_cdb(struct scsi_cmd *cmd);
>  
>  #endif
> diff --git a/usr/target.c b/usr/target.c
> index 23f450f..e3fa1e0 100644
> --- a/usr/target.c
> +++ b/usr/target.c
> @@ -29,7 +29,6 @@
>  #include <sys/socket.h>
>  
>  #include "list.h"
> -#include "parser.h"
>  #include "util.h"
>  #include "tgtd.h"
>  #include "driver.h"
> @@ -247,13 +246,19 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
>  	lu->lun = lun;
>  	lu->lu_state = SCSI_LU_RUNNING;
>  
> -	snprintf(lu->scsi_id, sizeof(lu->scsi_id),
> -		 "deadbeaf%d:%" PRIu64, tid, lun);
> -
>  	tgt_cmd_queue_init(&lu->cmd_queue);
>  
> -	if (target->dev_type_template.device_init)
> -		target->dev_type_template.device_init(lu);
> +	if (target->dev_type_template.lu_init)
> +		err = target->dev_type_template.lu_init(lu);
> +
> +	if(!err) {
> +		snprintf(lu->attributes->scsi_id,
> +			sizeof(lu->attributes->scsi_id),
> +			"deadbeaf%d:%" PRIu64, tid, lun);
> +		snprintf(lu->attributes->scsi_sn,
> +			sizeof(lu->attributes->scsi_sn),
> +			"beaf%d%" PRIu64, tid, lun);
> +	}
>  
>  	list_for_each_entry(pos, &target->device_list, device_siblings) {
>  		if (lu->lun < pos->lun)
> @@ -262,13 +267,14 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
>  	list_add_tail(&lu->device_siblings, &pos->device_siblings);
>  
>  	dprintf("Add a logical unit %" PRIu64 " to the target %d\n", lun, tid);
> -	return 0;
> +	return err;
>  }
>  
>  int tgt_device_destroy(int tid, uint64_t lun)
>  {
>  	struct target *target;
>  	struct scsi_lu *lu;
> +	int err;
>  
>  	dprintf("%u %" PRIu64 "\n", tid, lun);
>  
> @@ -281,12 +287,14 @@ int tgt_device_destroy(int tid, uint64_t lun)
>  	if (!list_empty(&lu->cmd_queue.queue) || lu->cmd_queue.active_cmd)
>  		return TGTADM_LUN_ACTIVE;
>  
> +	err = target->dev_type_template.lu_exit(lu);
> +
>  	free(lu->path);
>  	list_del(&lu->device_siblings);
>  
>  	target->bst->bs_close(lu);
>  	free(lu);
> -	return 0;
> +	return err;
>  }
>  
>  int device_reserve(struct scsi_cmd *cmd)
> @@ -339,20 +347,9 @@ int device_reserved(struct scsi_cmd *cmd)
>  	return -EBUSY;
>  }
>  
> -enum {
> -	Opt_scsiid, Opt_scsisn, Opt_err,
> -};
> -
> -static match_table_t tokens = {
> -	{Opt_scsiid, "scsi_id=%s"},
> -	{Opt_scsisn, "scsi_sn=%s"},
> -	{Opt_err, NULL},
> -};
> -
>  int tgt_device_update(int tid, uint64_t dev_id, char *params)
>  {
> -	int err = 0;
> -	char *p;
> +	int err = TGTADM_INVALID_REQUEST;
>  	struct target *target;
>  	struct scsi_lu *lu;
>  
> @@ -366,26 +363,8 @@ int tgt_device_update(int tid, uint64_t dev_id, char *params)
>  		return TGTADM_NO_LUN;
>  	}
>  
> -	while ((p = strsep(&params, ",")) != NULL) {
> -		substring_t args[MAX_OPT_ARGS];
> -		int token;
> -		if (!*p)
> -			continue;
> -		token = match_token(p, tokens, args);
> -
> -		switch (token) {
> -		case Opt_scsiid:
> -			match_strncpy(lu->scsi_id, &args[0],
> -				      sizeof(lu->scsi_id) - 1);
> -			break;
> -		case Opt_scsisn:
> -			match_strncpy(lu->scsi_sn, &args[0],
> -				      sizeof(lu->scsi_sn) - 1);
> -			break;
> -		default:
> -			err = TGTADM_INVALID_REQUEST;
> -		}
> -	}
> +	if (target->dev_type_template.lu_config)
> +		err = target->dev_type_template.lu_config(lu, params);
>  
>  	return err;
>  }
> @@ -474,8 +453,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
>  		cmd_post_perform(q, cmd);
>  
>  		dprintf("%" PRIx64 " %x %" PRIx64 " %" PRIu64 " %u %d %d\n",
> -			cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset, cmd->len,
> -			result, cmd->async);
> +			cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset,
> +			cmd->len, result, cmd->async);
>  
>  		set_cmd_processed(cmd);
>  		if (!cmd->async)
> @@ -483,7 +462,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
>  	} else {
>  		set_cmd_queued(cmd);
>  		dprintf("blocked %" PRIx64 " %x %" PRIu64 " %d\n",
> -			cmd->tag, cmd->scb[0], cmd->dev ? cmd->dev->lun : UINT64_MAX,
> +			cmd->tag, cmd->scb[0],
> +			cmd->dev ? cmd->dev->lun : UINT64_MAX,
>  			q->active_cmd);
>  
>  		list_add_tail(&cmd->qlist, &q->queue);
> @@ -1148,8 +1128,8 @@ int tgt_target_show_all(char *buf, int rest)
>  				 _TAB3 "Size: %s\n"
>  				 _TAB3 "Backing store: %s\n",
>  				 lu->lun,
> -				 lu->scsi_id,
> -				 lu->scsi_sn,
> +				 lu->attributes->scsi_id,
> +				 lu->attributes->scsi_sn,
>  				 print_disksize(lu->size),
>  				 lu->path);
>  
> diff --git a/usr/tgtadm.c b/usr/tgtadm.c
> index e55a785..3d551cc 100644
> --- a/usr/tgtadm.c
> +++ b/usr/tgtadm.c
> @@ -103,6 +103,7 @@ struct option const long_options[] = {
>  	{"initiator-address", required_argument, NULL, 'I'},
>  	{"user", required_argument, NULL, 'u'},
>  	{"password", required_argument, NULL, 'p'},
> +	{"params", required_argument, NULL, 'P'},
>  
>  	{"bus", required_argument, NULL, 'B'},
>  	{"target-type", required_argument, NULL, 'Y'},
> @@ -110,7 +111,7 @@ struct option const long_options[] = {
>  	{NULL, 0, NULL, 0},
>  };
>  
> -static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:B:Y:O";
> +static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:P:B:Y:O";
>  
>  static void usage(int status)
>  {
> @@ -355,7 +356,7 @@ int main(int argc, char **argv)
>  	int op, total, tid, rest, mode, t_type, ac_dir;
>  	uint32_t cid, hostno;
>  	uint64_t sid, lun;
> -	char *name, *value, *path, *targetname, *params, *address;
> +	char *name, *value, *path, *targetname, *params, *address, *targetOps;
>  	char *user, *password;
>  	char buf[BUFSIZE + sizeof(struct tgtadm_req)];
>  	struct tgtadm_req *req;
> @@ -365,7 +366,7 @@ int main(int argc, char **argv)
>  	t_type = TYPE_DISK;
>  	ac_dir = ACCOUNT_TYPE_INCOMING;
>  	rest = BUFSIZE;
> -	name = value = path = targetname = address = NULL;
> +	name = value = path = targetname = address = targetOps = NULL;
>  	user = password = NULL;
>  
>  	memset(buf, 0, sizeof(buf));
> @@ -396,6 +397,9 @@ int main(int argc, char **argv)
>  		case 'l':
>  			lun = strtoull(optarg, NULL, 10);
>  			break;
> +		case 'P':
> +			targetOps = optarg;
> +			break;
>  		case 'n':
>  			name = optarg;
>  			break;
> @@ -570,6 +574,10 @@ int main(int argc, char **argv)
>  	if (password)
>  		shprintf(total, params, rest, "%spassword=%s",
>  			 rest == BUFSIZE ? "" : ",", password);
> +	// Trailing ',' makes parsing params in modules easier..
> +	if (targetOps)
> +		shprintf(total, params, rest, "%stargetOps %s,",
> +			 rest == BUFSIZE ? "" : ",", targetOps);
>  
>  	req->len = sizeof(*req) + total;
>  
> diff --git a/usr/tgtadm.h b/usr/tgtadm.h
> index fb83753..d53cb40 100644
> --- a/usr/tgtadm.h
> +++ b/usr/tgtadm.h
> @@ -4,31 +4,7 @@
>  #define TGT_IPC_NAMESPACE	"TGT_IPC_ABSTRACT_NAMESPACE"
>  #define TGT_LLD_NAME_LEN	64
>  
> -enum tgtadm_errno {
> -	TGTADM_SUCCESS,
> -	TGTADM_UNKNOWN_ERR,
> -	TGTADM_NOMEM,
> -	TGTADM_NO_DRIVER,
> -	TGTADM_NO_TARGET,
> -
> -	TGTADM_NO_LUN,
> -	TGTADM_NO_SESSION,
> -	TGTADM_NO_CONNECTION,
> -	TGTADM_TARGET_EXIST,
> -	TGTADM_LUN_EXIST,
> -
> -	TGTADM_ACL_EXIST,
> -	TGTADM_USER_EXIST,
> -	TGTADM_NO_USER,
> -	TGTADM_TOO_MANY_USER,
> -	TGTADM_INVALID_REQUEST,
> -
> -	TGTADM_OUTACCOUNT_EXIST,
> -	TGTADM_TARGET_ACTIVE,
> -	TGTADM_LUN_ACTIVE,
> -	TGTADM_UNSUPPORTED_OPERATION,
> -	TGTADM_UNKNOWN_PARAM,
> -};
> +#include "tgtadm_error.h"
>  
>  enum tgtadm_op {
>  	OP_NEW,
> diff --git a/usr/tgtadm_error.h b/usr/tgtadm_error.h
> new file mode 100644
> index 0000000..319a4ad
> --- /dev/null
> +++ b/usr/tgtadm_error.h
> @@ -0,0 +1,30 @@
> +#ifndef TGTADM_ERROR_H
> +#define TGTADM_ERROR_H
> +
> +enum tgtadm_errno {
> +	TGTADM_SUCCESS,
> +	TGTADM_UNKNOWN_ERR,
> +	TGTADM_NOMEM,
> +	TGTADM_NO_DRIVER,
> +	TGTADM_NO_TARGET,
> +
> +	TGTADM_NO_LUN,
> +	TGTADM_NO_SESSION,
> +	TGTADM_NO_CONNECTION,
> +	TGTADM_TARGET_EXIST,
> +	TGTADM_LUN_EXIST,
> +
> +	TGTADM_ACL_EXIST,
> +	TGTADM_USER_EXIST,
> +	TGTADM_NO_USER,
> +	TGTADM_TOO_MANY_USER,
> +	TGTADM_INVALID_REQUEST,
> +
> +	TGTADM_OUTACCOUNT_EXIST,
> +	TGTADM_TARGET_ACTIVE,
> +	TGTADM_LUN_ACTIVE,
> +	TGTADM_UNSUPPORTED_OPERATION,
> +	TGTADM_UNKNOWN_PARAM,
> +};
> +
> +#endif
> diff --git a/usr/tgtd.h b/usr/tgtd.h
> index 06e0dd9..8cda864 100644
> --- a/usr/tgtd.h
> +++ b/usr/tgtd.h
> @@ -5,6 +5,7 @@
>  
>  #define SCSI_ID_LEN	24
>  #define SCSI_SN_LEN	8
> +#define VERSION_DESCRIPTOR_LEN 8
>  
>  #define VENDOR_ID	"IET"
>  
> @@ -29,13 +30,27 @@ struct tgt_cmd_queue {
>  	struct list_head queue;
>  };
>  
> +struct physicalAttributes {

We don't use mixed-case names (chapter 4 in the CodingStyle).

I like something like struct lu_phy_attr though I'm not good at
naming. Suggestions?


> +	char	scsi_id[SCSI_ID_LEN];

char scsi_id[SCSI_ID_LEN];


> +	char	scsi_sn[SCSI_SN_LEN];
> +
> +	/* SCSI Inquiry Params */
> +	char	VendorIdent[9];

ditto.

char vendor_id[9];


> +	char	ProductIdent[17];
> +	char	ProductRev[5];
> +	uint16_t	version_desc[VERSION_DESCRIPTOR_LEN];
> +
> +	char	isRemovable;	/* Removable media */
> +	char	onLine;
> +	char	reset;		/* Power-on or reset */
> +	char	sense_format;	/* sense data format */
> +};

Ditto.


>  struct scsi_lu {
>  	int fd;
>  	uint64_t addr; /* persistent mapped address */
>  	uint64_t size;
>  	uint64_t lun;
> -	char scsi_id[SCSI_ID_LEN];
> -	char scsi_sn[SCSI_SN_LEN];
>  	char *path;
>  
>  	/* the list of devices belonging to a target */
> @@ -48,7 +63,7 @@ struct scsi_lu {
>  	uint64_t reserve_id;
>  
>  	/* TODO: needs a structure for lots of device parameters */
> -	uint8_t d_sense;
> +	struct physicalAttributes * attributes;

No space please after *.


>  };
>  
>  struct scsi_cmd {
> @@ -121,7 +136,9 @@ struct device_type_template {
>  	char *name;
>  	char *pid;
>  
> -	void (*device_init)(struct scsi_lu *dev);
> +	int (*lu_init)(struct scsi_lu *lu);
> +	int (*lu_exit)(struct scsi_lu *lu);
> +	int (*lu_config)(struct scsi_lu *lu, char *arg);
>  
>  	struct device_type_operations ops[256];
>  };
> -- 
> 1.5.1.3
> 


From mark_harvey at symantec.com  Sat Jun  2 04:02:49 2007
From: mark_harvey at symantec.com (Mark Harvey)
Date: Fri, 1 Jun 2007 19:02:49 -0700
Subject: [Stgt-devel]
	[Patch1/2]	Add-new-module-entry-points-for-configuration
In-Reply-To: <200706020153.l521rP0g013718@mbox.iij4u.or.jp>
References: <f29db9a80705311732w2f0bb27es1959faadbf88b141@mail.gmail.com>
	<200706020153.l521rP0g013718@mbox.iij4u.or.jp>
Message-ID: <B3E98EAC5926D5498DDD341AE4B7D21C014D520A@TUS1XCHCLUPIN05.enterprise.veritas.com>

 
I've installed Firebird however pop/smtp access to gmail is blocked from
our internal network.

I'll only be able to email directly once I'm home..

BTW: 
>>  /* Maximum number of arguments that match_token will find in a
pattern */
>> -enum {MAX_OPT_ARGS = 3};
>> +enum {MAX_OPT_ARGS = 17};

>For what?

This should actually belong with [Patch 2/2].


I'll make the changes and re-post.


Thanks
Mark

-----Original Message-----
From: stgt-devel-bounces at lists.berlios.de
[mailto:stgt-devel-bounces at lists.berlios.de] On Behalf Of FUJITA
Tomonori
Sent: Saturday, 2 June 2007 11:53 AM
To: markh794 at gmail.com
Cc: stgt-devel at lists.berlios.de
Subject: Re: [Stgt-devel] [Patch1/2]
Add-new-module-entry-points-for-configuration

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 1/2]
Add-new-module-entry-points-for-configuration
Date: Fri, 1 Jun 2007 10:32:39 +1000

> In-lined version of the patch attachment included with [patch 0/2]...
- try3
> 
> Maybe easier reading, but unsuitable for actual patching :(
> 
> Pls advise if this is considered spam & I should just not send an
> inline version until I figure out gmail..

Yeah, you don't need to send until you fix the gmail
configuration. Seems that some developers can use the proper format
with gmail though they might use gmail via smtp and pop service.
_______________________________________________
Stgt-devel mailing list
Stgt-devel at lists.berlios.de
https://lists.berlios.de/mailman/listinfo/stgt-devel


From fujita.tomonori at lab.ntt.co.jp  Sat Jun  2 05:03:22 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 02 Jun 2007 12:03:22 +0900
Subject: [Stgt-devel]
	[Patch1/2]	Add-new-module-entry-points-for-configuration
In-Reply-To: <B3E98EAC5926D5498DDD341AE4B7D21C014D520A@TUS1XCHCLUPIN05.enterprise.veritas.com>
References: <f29db9a80705311732w2f0bb27es1959faadbf88b141@mail.gmail.com>
	<200706020153.l521rP0g013718@mbox.iij4u.or.jp>
	<B3E98EAC5926D5498DDD341AE4B7D21C014D520A@TUS1XCHCLUPIN05.enterprise.veritas.com>
Message-ID: <20070602120322A.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <mark_harvey at symantec.com>
Subject: Re: [Stgt-devel]	[Patch1/2]	Add-new-module-entry-points-for-configuration
Date: Fri, 1 Jun 2007 19:02:49 -0700

>  
> I've installed Firebird however pop/smtp access to gmail is blocked from
> our internal network.
> 
> I'll only be able to email directly once I'm home..

I see. Send attached patches.


> BTW: 
> >>  /* Maximum number of arguments that match_token will find in a
> pattern */
> >> -enum {MAX_OPT_ARGS = 3};
> >> +enum {MAX_OPT_ARGS = 17};
> 
> >For what?
> 
> This should actually belong with [Patch 2/2].

Well, why does the second patch need this change?


From markh794 at gmail.com  Sat Jun  2 05:31:14 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 2 Jun 2007 13:31:14 +1000
Subject: [Stgt-devel] [Patch1/2]
	Add-new-module-entry-points-for-configuration
In-Reply-To: <20070602120322A.fujita.tomonori@lab.ntt.co.jp>
References: <f29db9a80705311732w2f0bb27es1959faadbf88b141@mail.gmail.com>
	<200706020153.l521rP0g013718@mbox.iij4u.or.jp>
	<B3E98EAC5926D5498DDD341AE4B7D21C014D520A@TUS1XCHCLUPIN05.enterprise.veritas.com>
	<20070602120322A.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80706012031l4d3e5bbbs7bf7581288ebcbe7@mail.gmail.com>

On 6/2/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: "Mark Harvey" <mark_harvey at symantec.com>
> Subject: Re: [Stgt-devel]       [Patch1/2]      Add-new-module-entry-points-for-configuration
> Date: Fri, 1 Jun 2007 19:02:49 -0700
>
> >
> > I've installed Firebird however pop/smtp access to gmail is blocked from
> > our internal network.
> >
> > I'll only be able to email directly once I'm home..
>
> I see. Send attached patches.
>
>
> > BTW:
> > >>  /* Maximum number of arguments that match_token will find in a
> > pattern */
> > >> -enum {MAX_OPT_ARGS = 3};
> > >> +enum {MAX_OPT_ARGS = 17};
> >
> > >For what?
> >
> > This should actually belong with [Patch 2/2].
>
> Well, why does the second patch need this change?
>

spc.c contains :

enum {
        Opt_scsiid, Opt_scsisn,
        Opt_VendorIdent, Opt_ProductIdent,
        Opt_ProductRev, Opt_SenseFormat,
        Opt_Removable, Opt_Online,
        Opt_err,
};

So at the moment,
enum {MAX_OPT_ARGS = 17};
should read:
enum {MAX_OPT_ARGS = 9};


Once I get these current patches up to scratch and move on the the SMC
module, the extra 8 options (or maybe more) will be needed.

parser.c checks for MAX_OPT_ARGS in several places.

It would be nice to have this size set either at run time or uniq to
each scsi module.
i.e. spc only requires the above 9, the smc module will require about 17.

Cheers
Mark


From fujita.tomonori at lab.ntt.co.jp  Sat Jun  2 05:38:05 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 02 Jun 2007 12:38:05 +0900
Subject: [Stgt-devel]
	[Patch1/2]	Add-new-module-entry-points-for-configuration
In-Reply-To: <f29db9a80706012031l4d3e5bbbs7bf7581288ebcbe7@mail.gmail.com>
References: <B3E98EAC5926D5498DDD341AE4B7D21C014D520A@TUS1XCHCLUPIN05.enterprise.veritas.com>
	<20070602120322A.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80706012031l4d3e5bbbs7bf7581288ebcbe7@mail.gmail.com>
Message-ID: <20070602123805M.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] [Patch1/2]	Add-new-module-entry-points-for-configuration
Date: Sat, 2 Jun 2007 13:31:14 +1000

> > Well, why does the second patch need this change?
> >
> 
> spc.c contains :
> 
> enum {
>         Opt_scsiid, Opt_scsisn,
>         Opt_VendorIdent, Opt_ProductIdent,
>         Opt_ProductRev, Opt_SenseFormat,
>         Opt_Removable, Opt_Online,
>         Opt_err,
> };
> 
> So at the moment,
> enum {MAX_OPT_ARGS = 17};
> should read:
> enum {MAX_OPT_ARGS = 9};
> 
> 
> Once I get these current patches up to scratch and move on the the SMC
> module, the extra 8 options (or maybe more) will be needed.
> 
> parser.c checks for MAX_OPT_ARGS in several places.
> 
> It would be nice to have this size set either at run time or uniq to
> each scsi module.
> i.e. spc only requires the above 9, the smc module will require about 17.

Have you tried your code without touching MAX_OPT_ARGS?


From markh794 at gmail.com  Sat Jun  2 05:48:11 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 2 Jun 2007 13:48:11 +1000
Subject: [Stgt-devel] [Patch1/2]
	Add-new-module-entry-points-for-configuration
In-Reply-To: <20070602123805M.fujita.tomonori@lab.ntt.co.jp>
References: <B3E98EAC5926D5498DDD341AE4B7D21C014D520A@TUS1XCHCLUPIN05.enterprise.veritas.com>
	<20070602120322A.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80706012031l4d3e5bbbs7bf7581288ebcbe7@mail.gmail.com>
	<20070602123805M.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80706012048g1cf25c07xf29092a85aa525c9@mail.gmail.com>

On 6/2/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: Re: [Stgt-devel] [Patch1/2]    Add-new-module-entry-points-for-configuration
> Date: Sat, 2 Jun 2007 13:31:14 +1000
>
> > > Well, why does the second patch need this change?
> > >
> >
> > spc.c contains :
> >
> > enum {
> >         Opt_scsiid, Opt_scsisn,
> >         Opt_VendorIdent, Opt_ProductIdent,
> >         Opt_ProductRev, Opt_SenseFormat,
> >         Opt_Removable, Opt_Online,
> >         Opt_err,
> > };
> >
> > So at the moment,
> > enum {MAX_OPT_ARGS = 17};
> > should read:
> > enum {MAX_OPT_ARGS = 9};
> >
> >
> > Once I get these current patches up to scratch and move on the the SMC
> > module, the extra 8 options (or maybe more) will be needed.
> >
> > parser.c checks for MAX_OPT_ARGS in several places.
> >
> > It would be nice to have this size set either at run time or uniq to
> > each scsi module.
> > i.e. spc only requires the above 9, the smc module will require about 17.
>
> Have you tried your code without touching MAX_OPT_ARGS?
>

The short answer is no.

I'll try it a little later this afternoon and see what happens.

Cheers
Mark


From markh794 at gmail.com  Sat Jun  2 06:12:35 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 2 Jun 2007 14:12:35 +1000
Subject: [Stgt-devel] [Patch 0/2] Re-format / resubmit patch - try 3.
In-Reply-To: <200706020153.l521rOp9031625@mbox.iij4u.or.jp>
References: <f29db9a80705311728rd64b53q3e5379b091f6bcde@mail.gmail.com>
	<200706020153.l521rOp9031625@mbox.iij4u.or.jp>
Message-ID: <f29db9a80706012112g2fc91d2bt5f5f7d522d38e1a3@mail.gmail.com>

> > +struct physicalAttributes {
>
> We don't use mixed-case names (chapter 4 in the CodingStyle).
>

It will eventually sink in.. Obviously my initial read of the document
did not stick.

I've printed the CodingStyle and will read, read and re-read it.

One of these days, you will not have to repeat this to me :)


> I like something like struct lu_phy_attr though I'm not good at
> naming. Suggestions?
>

Mark.


From markh794 at gmail.com  Mon Jun  4 11:51:55 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Mon, 04 Jun 2007 19:51:55 +1000
Subject: [Stgt-devel] [Patch 0/2] Re-format / resubmit patch - try 4
In-Reply-To: <f29db9a80706012112g2fc91d2bt5f5f7d522d38e1a3@mail.gmail.com>
References: <f29db9a80705311728rd64b53q3e5379b091f6bcde@mail.gmail.com>	
	<200706020153.l521rOp9031625@mbox.iij4u.or.jp>
	<f29db9a80706012112g2fc91d2bt5f5f7d522d38e1a3@mail.gmail.com>
Message-ID: <4663E0BB.7000004@gmail.com>

> [PATCH 1/2] Add new module entry points for configuration
> 
> Add new module entry points.
>   <module>_lu_init(struct scsi_lu *lu) - called at setup time.
>   <module>_lu_exit(struct scsi_lu *lu) - called at shutdown time.
>   <module>_lu_config(struct scsi_lu *lu) - Any module unique configuration.
> 
> Moved logical unit configuration from target -> <module>
>   Along with above entry point <module>_lu_config(), will allow module
>   specific configuration.
>   No new functionality added yet.
> 
> Add a dump_cdb(struct scsi_cmd *cmd) - Called from spc_illegal_op()
> 
> Update - All modules use common INQUIRY routine.



> [PATCH] Add ability to dynamically set SCSI Inquiry params
> 
> Added support to configure:
>   Vendor Identification
>   Product Identification
>   Product Revision
>   Format of returned 'sense data'
>   Define if the lu is capable of supporting removable media
>   Define/set if the lu is online / offline.
> 
> All params are passed using the 'tgtadm' utility:
> 
>   VendorIdent="string"
>   ProductIdent="string"
>   ProductRev="string"
>   Removable=<0|1> - 0 == non-removable, 1 == removable media
>   SenseFormat=<0|1> - 0 == Clasic sense format, 1 == Support descriptor format
>   Online=<0|1> - 0 == Unit offline, 1 == Unit Online
> 
> e.g.
> tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
>         --params VendorIdent=QUANTUM,ProductIdent=HD100,ProductRev=0010
> tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
>         --params Removable=1,SenseFormat=1,Online=1
> 
> Example script (scripts/tgt-core-test) to set up HDD & CD device.
> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>


From markh794 at gmail.com  Mon Jun  4 12:08:03 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Mon, 04 Jun 2007 20:08:03 +1000
Subject: [Stgt-devel] [Patch1/2]
	Add-new-module-entry-points-for-configuration
In-Reply-To: <f29db9a80706012048g1cf25c07xf29092a85aa525c9@mail.gmail.com>
References: <B3E98EAC5926D5498DDD341AE4B7D21C014D520A@TUS1XCHCLUPIN05.enterprise.veritas.com>	
	<20070602120322A.fujita.tomonori@lab.ntt.co.jp>	
	<f29db9a80706012031l4d3e5bbbs7bf7581288ebcbe7@mail.gmail.com>	
	<20070602123805M.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80706012048g1cf25c07xf29092a85aa525c9@mail.gmail.com>
Message-ID: <4663E483.1060204@gmail.com>

Add new module entry points.
   <module>_lu_init(struct scsi_lu *lu) - called at setup time.
   <module>_lu_exit(struct scsi_lu *lu) - called at shutdown time.
   <module>_lu_config(struct scsi_lu *lu) - Any module unique configuration.

Moved logical unit configuration from target -> <module>
   Along with above entry point <module>_lu_config(), will allow module
   specific configuration.
   No new functionality added yet.

Add a dump_cdb(struct scsi_cmd *cmd) - Called from spc_illegal_op()

Update - All modules use common INQUIRY routine.

Signed-off-by: Mark Harvey <markh794 at gmail.com>


From markh794 at gmail.com  Sat Jun  2 09:25:52 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 2 Jun 2007 17:25:52 +1000
Subject: [PATCH] Add new module entry points for configuration
Message-ID: <mailman.9.1331738472.12506.stgt-devel@lists.berlios.de>

Add new module entry points.
  <module>_lu_init(struct scsi_lu *lu) - called at setup time.
  <module>_lu_exit(struct scsi_lu *lu) - called at shutdown time.
  <module>_lu_config(struct scsi_lu *lu) - Any module unique configuration.

Moved logical unit configuration from target -> <module>
  Along with above entry point <module>_lu_config(), will allow module
  specific configuration.
  No new functionality added yet.

Add a dump_cdb(struct scsi_cmd *cmd) - Called from spc_illegal_op()

Update - All modules use common INQUIRY routine.

Signed-off-by: Mark Harvey <markh794 at gmail.com>

diff --git a/usr/mmc.c b/usr/mmc.c
index e9cc479..8154ede 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -121,11 +121,32 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 }
 
+static int mmc_lu_init(struct scsi_lu *lu)
+{
+	if (spc_lu_init(lu))
+		return -ENOMEM;
+
+	memcpy(lu->attributes->product_ident, "VIRTUAL-CDROM", 16);
+	lu->attributes->sense_format = 0;
+	lu->attributes->version_desc[0] = 0x02A0; /* MMC3, no version claimed */
+	lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
+	lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
+
+	return 0;
+}
+
+static int mmc_lu_exit(struct scsi_lu *lu)
+{
+	return 0;
+}
+
 struct device_type_template mmc_template = {
-	.type	= TYPE_ROM,
-	.name	= "cdrom/dvd",
-	.pid	= "VIRTUAL-CDROM",
-	.ops	= {
+	.type		= TYPE_ROM,
+	.name		= "cdrom/dvd",
+	.lu_init	= mmc_lu_init,
+	.lu_exit	= mmc_lu_exit,
+	.lu_config	= spc_lu_config,
+	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/osd.c b/usr/osd.c
index 46bf0a0..62c0082 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -20,6 +20,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
  */
+#include <errno.h>
 #include <inttypes.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -33,101 +34,6 @@
 #include "scsi.h"
 #include "spc.h"
 
-#define PRODUCT_ID	"OSD"
-#define PRODUCT_REV	"0"
-
-static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
-{
-	uint8_t *data, *scb = cmd->scb;
-	int len, ret = SAM_STAT_CHECK_CONDITION;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
-
-	/* EVPD means need a page code */
-	if ((scb[1] & 0x3) == 0 && scb[2] != 0)
-		goto sense;
-
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = 0;
-		goto sense;
-	}
-	memset(data, 0, pagesize);
-
-	dprintf("%x %x\n", scb[1], scb[2]);
-
-	data[0] = TYPE_OSD;
-	if (!cmd->dev)
-		data[0] = TYPE_NO_LUN;
-
-	if ((scb[1] & 0x1) == 0) {
-		data[2] = 5;  /* modern version */
-		data[3] = 0x02;  /* modern response format */
-		data[7] = 0x02;  /* support command queueing */
-		memset(data + 8, 0x20, 28);
-		memcpy(data + 8,
-		       VENDOR_ID, min_t(size_t, strlen(VENDOR_ID), 8));
-		memcpy(data + 16,
-		       PRODUCT_ID, min_t(size_t, strlen(PRODUCT_ID), 16));
-		memcpy(data + 32,
-		       PRODUCT_REV, min_t(size_t, strlen(PRODUCT_REV), 4));
-		len = 36;
-		if (cmd->dev) {
-			data[58] = 0x03;
-			data[59] = 0x40;  /* osd */
-			data[60] = 0x09;
-			data[61] = 0x60;  /* iscsi */
-			data[62] = 0x03;
-			data[63] = 0x00;  /* spc3 */
-			len = 64;
-		}
-		data[4] = len - 5;  /* additional length */
-		ret = SAM_STAT_GOOD;
-	} else {
-		if (!cmd->dev)
-			goto sense;
-
-		data[1] = scb[2];
-		if (scb[2] == 0x0) {
-			/* supported VPD pages */
-			data[3] = 3;
-			data[4] = 0x0;
-			data[5] = 0x80;
-			data[6] = 0x83;
-			len = 7;
-			ret = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x80) {
-			/* unit serial number "    " */
-			data[3] = 4;
-			memset(data + 4, 0x20, 4);
-			len = 8;
-			ret = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x83) {
-			/* device identification */
-			data[3] = SCSI_ID_LEN + 4;
-			data[4] = 0x1;
-			data[5] = 0x1;
-			data[7] = SCSI_ID_LEN;
-			if (cmd->dev)
-				memcpy(data + 8, cmd->dev->scsi_id, SCSI_ID_LEN);
-			len = SCSI_ID_LEN + 8;
-			ret = SAM_STAT_GOOD;
-		}
-	}
-
-	if (ret != SAM_STAT_GOOD)
-		goto sense;
-
-	cmd->len = min_t(int, len, scb[4]);
-	cmd->uaddr = (unsigned long) data;
-
-	return SAM_STAT_GOOD;
-sense:
-	sense_data_build(cmd, key, asc, 0);
-	cmd->len = 0;
-	return SAM_STAT_CHECK_CONDITION;
-}
-
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 {
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
@@ -145,22 +51,37 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 	return cmd->c_target->bst->bs_cmd_submit(cmd);
 }
 
-static void device_osd_init(struct scsi_lu *lu)
+static int osd_lu_init(struct scsi_lu *lu)
+{
+	if (spc_lu_init(lu))
+		return -ENOMEM;
+
+	memcpy(lu->attributes->product_ident, "OSD", 16);
+	lu->attributes->sense_format = 1;
+	lu->attributes->version_desc[0] = 0x0340; /* OSD */
+	lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
+	lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
+
+	return 0;
+}
+
+static int osd_lu_exit(struct scsi_lu *lu)
 {
-	lu->d_sense = 1;
+	return 0;
 }
 
 struct device_type_template osd_template = {
 	.type		= TYPE_OSD,
 	.name		= "osd",
-	.device_init	= device_osd_init,
+	.lu_init	= osd_lu_init,
+	.lu_exit	= osd_lu_exit,
 	.ops		= {
 		[0x00 ... 0x0f] = {spc_illegal_op},
 
 		/* 0x10 */
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{osd_inquiry,},
+		{spc_inquiry,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/sbc.c b/usr/sbc.c
index a22d3b0..8f981d3 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -337,11 +337,31 @@ sense:
 	return SAM_STAT_CHECK_CONDITION;
 }
 
+static int sbc_lu_init(struct scsi_lu *lu)
+{
+	if (spc_lu_init(lu))
+		return -ENOMEM;
+
+	memcpy(lu->attributes->product_ident, "VIRTUAL-DISK", 16);
+	lu->attributes->version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
+	lu->attributes->version_desc[1] = 0x0960; /* iSCSI */
+	lu->attributes->version_desc[2] = 0x0300; /* SPC-3 */
+
+	return 0;
+}
+
+static int sbc_lu_exit(struct scsi_lu *lu)
+{
+	return 0;
+}
+
 struct device_type_template sbc_template = {
-	.type	= TYPE_DISK,
-	.name	= "disk",
-	.pid	= "VIRTUAL-DISK",
-	.ops	= {
+	.type		= TYPE_DISK,
+	.name		= "disk",
+	.lu_init	= sbc_lu_init,
+	.lu_exit	= sbc_lu_exit,
+	.lu_config	= spc_lu_config,
+	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
diff --git a/usr/scsi.c b/usr/scsi.c
index 1a6929f..728dfe9 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -40,7 +40,7 @@
 
 void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
 {
-	if (cmd->dev && cmd->dev->d_sense) {
+	if (cmd->dev && cmd->dev->attributes->sense_format) {
 		/* descriptor format */
 
 		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
@@ -121,3 +121,4 @@ int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd)
 	unsigned char op = cmd->scb[0];
 	return cmd->c_target->dev_type_template.ops[op].cmd_perform(host_no, cmd);
 }
+
diff --git a/usr/spc.c b/usr/spc.c
index b922a45..32a9ff7 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -19,6 +19,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA
  */
+#include <errno.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -27,12 +28,15 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "parser.h"
 #include "target.h"
 #include "driver.h"
+#include "tgtadm_error.h"
 #include "scsi.h"
 #include "spc.h"
 
 #define PRODUCT_REV	"0"
+#define BLK_SHIFT	9
 
 int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
@@ -40,7 +44,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	uint8_t *data;
 	uint8_t *scb = cmd->scb;
 	unsigned char device_type = cmd->c_target->dev_type_template.type;
-	char *product_id = cmd->c_target->dev_type_template.pid;
+	struct lu_phy_attr *attributes = cmd->dev->attributes;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
@@ -57,22 +61,21 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	dprintf("%x %x\n", scb[1], scb[2]);
 
 	if (!(scb[1] & 0x3)) {
+		int i;
 		data[0] = device_type;
-		data[2] = 4;
+		data[1] = (attributes->is_removable) ? 0x80 : 0;
+		data[2] = 5;	/* SPC-3 */
 		data[3] = 0x42;
-		data[4] = 59;
 		data[7] = 0x02;
 		memset(data + 8, 0x20, 28);
-		strncpy((char *)data + 8, VENDOR_ID, 8);
-		strncpy((char *)data + 16, product_id, 16);
-		strncpy((char *)data + 32, PRODUCT_REV, 4);
-		data[58] = 0x03;
-		data[59] = 0x20;
-		data[60] = 0x09;
-		data[61] = 0x60;
-		data[62] = 0x03;
-		data[63] = 0x00;
-		len = 64;
+		strncpy((char *)data + 8, attributes->vendor_ident, 8);
+		strncpy((char *)data + 16, attributes->product_ident, 16);
+		strncpy((char *)data + 32, attributes->product_rev, 4);
+		for (i=0, len=58; i < VERSION_DESCRIPTOR_LEN; i++, len += 2) {
+			data[len] = (attributes->version_desc[i] >> 8) & 0xff;
+			data[len+1] = attributes->version_desc[i] & 0xff;
+		}
+		data[4] = len - 5;	/* Additional Length */
 		ret = SAM_STAT_GOOD;
 	} else if (scb[1] & 0x2) {
 		/* CmdDt bit is set */
@@ -101,13 +104,13 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 			len = 4 + SCSI_SN_LEN;
 			ret = SAM_STAT_GOOD;
 
-			if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
+			if (cmd->dev && strlen(cmd->dev->attributes->scsi_sn)) {
 				uint8_t *p;
 				char *q;
 
 				p = data + 4 + tmp - 1;
-				q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
-
+				q = cmd->dev->attributes->scsi_sn +
+								SCSI_SN_LEN - 1;
 				for (; tmp > 0; tmp--, q)
 					*(p--) = *(q--);
 			}
@@ -120,7 +123,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 			data[5] = 0x1;
 			data[7] = tmp;
 			if (cmd->dev)
-				strncpy((char *) data + 8, cmd->dev->scsi_id,
+				strncpy((char *) data + 8,
+					cmd->dev->attributes->scsi_id,
 				        SCSI_ID_LEN);
 			len = tmp + 8;
 			ret = SAM_STAT_GOOD;
@@ -238,9 +242,98 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 }
 
+void dump_cdb(struct scsi_cmd *cmd)
+{
+	uint8_t *cdb = cmd->scb;
+
+	switch(cmd->scb_len) {
+	case 6:
+		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x",
+			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5]);
+		break;
+	case 10:
+		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
+				" %02x %02x %02x %02x",
+			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
+			cdb[6], cdb[7], cdb[8], cdb[9]);
+		break;
+	case 12:
+		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
+				" %02x %02x %02x %02x %02x %02x",
+			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
+			cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11]);
+		break;
+	case 16:
+		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x"
+				" %02x %02x %02x %02x %02x %02x"
+				" %02x %02x %02x %02x",
+			cdb[0], cdb[1], cdb[2], cdb[3], cdb[4], cdb[5],
+			cdb[6], cdb[7], cdb[8], cdb[9], cdb[10], cdb[11],
+			cdb[12], cdb[13], cdb[14], cdb[15]);
+		break;
+	}
+}
+
 int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 {
+	dump_cdb(cmd);
 	cmd->len = 0;
 	sense_data_build(cmd, ILLEGAL_REQUEST, 0x20, 0);
 	return SAM_STAT_CHECK_CONDITION;
 }
+
+enum {
+	Opt_scsiid, Opt_scsisn, Opt_err,
+};
+
+static match_table_t tokens = {
+	{Opt_scsiid, "scsi_id=%s"},
+	{Opt_scsisn, "scsi_sn=%s"},
+	{Opt_err, NULL},
+};
+
+int spc_lu_config(struct scsi_lu *lu, char *params) {
+	int err = 0;
+	char *p;
+
+	if (!strncmp("targetOps", params, 9))
+		params = params + 10;
+
+	while ((p = strsep(&params, ",")) != NULL) {
+		substring_t args[MAX_OPT_ARGS];
+		int token;
+		if (!*p)
+			continue;
+		dprintf("*p : %s\n", p);
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case Opt_scsiid:
+			match_strncpy(lu->attributes->scsi_id, &args[0],
+				      sizeof(lu->attributes->scsi_id) - 1);
+			break;
+		case Opt_scsisn:
+			match_strncpy(lu->attributes->scsi_sn, &args[0],
+				      sizeof(lu->attributes->scsi_sn) - 1);
+			break;
+		default:
+			err = TGTADM_INVALID_REQUEST;
+		}
+	}
+	return err;
+}
+
+int spc_lu_init(struct scsi_lu *lu)
+{
+	lu->attributes = zalloc(sizeof(struct lu_phy_attr));
+	if(!lu->attributes)
+		return -ENOMEM;
+
+	memcpy(lu->attributes->vendor_ident, VENDOR_ID, 8);
+	memcpy(lu->attributes->product_rev, "0001", 4);
+	lu->attributes->is_removable = 0;
+	lu->attributes->sense_format = 0;
+	lu->attributes->online = 0;
+	lu->attributes->reset = 1;
+
+	return 0;
+}
diff --git a/usr/spc.h b/usr/spc.h
index f81e74c..1036b70 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -7,5 +7,8 @@ extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
 extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
 extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
+extern int spc_lu_init(struct scsi_lu *lu);
+extern int spc_lu_config(struct scsi_lu *lu, char * params);
+extern void dump_cdb(struct scsi_cmd *cmd);
 
 #endif
diff --git a/usr/target.c b/usr/target.c
index 23f450f..8160359 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -29,7 +29,6 @@
 #include <sys/socket.h>
 
 #include "list.h"
-#include "parser.h"
 #include "util.h"
 #include "tgtd.h"
 #include "driver.h"
@@ -247,13 +246,19 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
 	lu->lun = lun;
 	lu->lu_state = SCSI_LU_RUNNING;
 
-	snprintf(lu->scsi_id, sizeof(lu->scsi_id),
-		 "deadbeaf%d:%" PRIu64, tid, lun);
-
 	tgt_cmd_queue_init(&lu->cmd_queue);
 
-	if (target->dev_type_template.device_init)
-		target->dev_type_template.device_init(lu);
+	if (target->dev_type_template.lu_init)
+		err = target->dev_type_template.lu_init(lu);
+
+	if(!err) {
+		snprintf(lu->attributes->scsi_id,
+				sizeof(lu->attributes->scsi_id),
+				"deadbeaf%d:%" PRIu64, tid, lun);
+		snprintf(lu->attributes->scsi_sn,
+				sizeof(lu->attributes->scsi_sn),
+				"beaf%d%" PRIu64, tid, lun);
+	}
 
 	list_for_each_entry(pos, &target->device_list, device_siblings) {
 		if (lu->lun < pos->lun)
@@ -262,13 +267,14 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
 	list_add_tail(&lu->device_siblings, &pos->device_siblings);
 
 	dprintf("Add a logical unit %" PRIu64 " to the target %d\n", lun, tid);
-	return 0;
+	return err;
 }
 
 int tgt_device_destroy(int tid, uint64_t lun)
 {
 	struct target *target;
 	struct scsi_lu *lu;
+	int err;
 
 	dprintf("%u %" PRIu64 "\n", tid, lun);
 
@@ -281,12 +287,14 @@ int tgt_device_destroy(int tid, uint64_t lun)
 	if (!list_empty(&lu->cmd_queue.queue) || lu->cmd_queue.active_cmd)
 		return TGTADM_LUN_ACTIVE;
 
+	err = target->dev_type_template.lu_exit(lu);
+
 	free(lu->path);
 	list_del(&lu->device_siblings);
 
 	target->bst->bs_close(lu);
 	free(lu);
-	return 0;
+	return err;
 }
 
 int device_reserve(struct scsi_cmd *cmd)
@@ -339,20 +347,9 @@ int device_reserved(struct scsi_cmd *cmd)
 	return -EBUSY;
 }
 
-enum {
-	Opt_scsiid, Opt_scsisn, Opt_err,
-};
-
-static match_table_t tokens = {
-	{Opt_scsiid, "scsi_id=%s"},
-	{Opt_scsisn, "scsi_sn=%s"},
-	{Opt_err, NULL},
-};
-
 int tgt_device_update(int tid, uint64_t dev_id, char *params)
 {
-	int err = 0;
-	char *p;
+	int err = TGTADM_INVALID_REQUEST;
 	struct target *target;
 	struct scsi_lu *lu;
 
@@ -366,26 +363,8 @@ int tgt_device_update(int tid, uint64_t dev_id, char *params)
 		return TGTADM_NO_LUN;
 	}
 
-	while ((p = strsep(&params, ",")) != NULL) {
-		substring_t args[MAX_OPT_ARGS];
-		int token;
-		if (!*p)
-			continue;
-		token = match_token(p, tokens, args);
-
-		switch (token) {
-		case Opt_scsiid:
-			match_strncpy(lu->scsi_id, &args[0],
-				      sizeof(lu->scsi_id) - 1);
-			break;
-		case Opt_scsisn:
-			match_strncpy(lu->scsi_sn, &args[0],
-				      sizeof(lu->scsi_sn) - 1);
-			break;
-		default:
-			err = TGTADM_INVALID_REQUEST;
-		}
-	}
+	if (target->dev_type_template.lu_config)
+		err = target->dev_type_template.lu_config(lu, params);
 
 	return err;
 }
@@ -474,8 +453,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
 		cmd_post_perform(q, cmd);
 
 		dprintf("%" PRIx64 " %x %" PRIx64 " %" PRIu64 " %u %d %d\n",
-			cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset, cmd->len,
-			result, cmd->async);
+			cmd->tag, cmd->scb[0], cmd->uaddr, cmd->offset,
+			cmd->len, result, cmd->async);
 
 		set_cmd_processed(cmd);
 		if (!cmd->async)
@@ -483,7 +462,8 @@ int target_cmd_queue(int tid, struct scsi_cmd *cmd)
 	} else {
 		set_cmd_queued(cmd);
 		dprintf("blocked %" PRIx64 " %x %" PRIu64 " %d\n",
-			cmd->tag, cmd->scb[0], cmd->dev ? cmd->dev->lun : UINT64_MAX,
+			cmd->tag, cmd->scb[0],
+			cmd->dev ? cmd->dev->lun : UINT64_MAX,
 			q->active_cmd);
 
 		list_add_tail(&cmd->qlist, &q->queue);
@@ -1148,8 +1128,8 @@ int tgt_target_show_all(char *buf, int rest)
 				 _TAB3 "Size: %s\n"
 				 _TAB3 "Backing store: %s\n",
 				 lu->lun,
-				 lu->scsi_id,
-				 lu->scsi_sn,
+				 lu->attributes->scsi_id,
+				 lu->attributes->scsi_sn,
 				 print_disksize(lu->size),
 				 lu->path);
 
diff --git a/usr/tgtadm.c b/usr/tgtadm.c
index e55a785..3d551cc 100644
--- a/usr/tgtadm.c
+++ b/usr/tgtadm.c
@@ -103,6 +103,7 @@ struct option const long_options[] = {
 	{"initiator-address", required_argument, NULL, 'I'},
 	{"user", required_argument, NULL, 'u'},
 	{"password", required_argument, NULL, 'p'},
+	{"params", required_argument, NULL, 'P'},
 
 	{"bus", required_argument, NULL, 'B'},
 	{"target-type", required_argument, NULL, 'Y'},
@@ -110,7 +111,7 @@ struct option const long_options[] = {
 	{NULL, 0, NULL, 0},
 };
 
-static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:B:Y:O";
+static char *short_options = "dhL:o:m:t:s:c:l:n:v:b:T:I:u:p:P:B:Y:O";
 
 static void usage(int status)
 {
@@ -355,7 +356,7 @@ int main(int argc, char **argv)
 	int op, total, tid, rest, mode, t_type, ac_dir;
 	uint32_t cid, hostno;
 	uint64_t sid, lun;
-	char *name, *value, *path, *targetname, *params, *address;
+	char *name, *value, *path, *targetname, *params, *address, *targetOps;
 	char *user, *password;
 	char buf[BUFSIZE + sizeof(struct tgtadm_req)];
 	struct tgtadm_req *req;
@@ -365,7 +366,7 @@ int main(int argc, char **argv)
 	t_type = TYPE_DISK;
 	ac_dir = ACCOUNT_TYPE_INCOMING;
 	rest = BUFSIZE;
-	name = value = path = targetname = address = NULL;
+	name = value = path = targetname = address = targetOps = NULL;
 	user = password = NULL;
 
 	memset(buf, 0, sizeof(buf));
@@ -396,6 +397,9 @@ int main(int argc, char **argv)
 		case 'l':
 			lun = strtoull(optarg, NULL, 10);
 			break;
+		case 'P':
+			targetOps = optarg;
+			break;
 		case 'n':
 			name = optarg;
 			break;
@@ -570,6 +574,10 @@ int main(int argc, char **argv)
 	if (password)
 		shprintf(total, params, rest, "%spassword=%s",
 			 rest == BUFSIZE ? "" : ",", password);
+	// Trailing ',' makes parsing params in modules easier..
+	if (targetOps)
+		shprintf(total, params, rest, "%stargetOps %s,",
+			 rest == BUFSIZE ? "" : ",", targetOps);
 
 	req->len = sizeof(*req) + total;
 
diff --git a/usr/tgtadm.h b/usr/tgtadm.h
index fb83753..d53cb40 100644
--- a/usr/tgtadm.h
+++ b/usr/tgtadm.h
@@ -4,31 +4,7 @@
 #define TGT_IPC_NAMESPACE	"TGT_IPC_ABSTRACT_NAMESPACE"
 #define TGT_LLD_NAME_LEN	64
 
-enum tgtadm_errno {
-	TGTADM_SUCCESS,
-	TGTADM_UNKNOWN_ERR,
-	TGTADM_NOMEM,
-	TGTADM_NO_DRIVER,
-	TGTADM_NO_TARGET,
-
-	TGTADM_NO_LUN,
-	TGTADM_NO_SESSION,
-	TGTADM_NO_CONNECTION,
-	TGTADM_TARGET_EXIST,
-	TGTADM_LUN_EXIST,
-
-	TGTADM_ACL_EXIST,
-	TGTADM_USER_EXIST,
-	TGTADM_NO_USER,
-	TGTADM_TOO_MANY_USER,
-	TGTADM_INVALID_REQUEST,
-
-	TGTADM_OUTACCOUNT_EXIST,
-	TGTADM_TARGET_ACTIVE,
-	TGTADM_LUN_ACTIVE,
-	TGTADM_UNSUPPORTED_OPERATION,
-	TGTADM_UNKNOWN_PARAM,
-};
+#include "tgtadm_error.h"
 
 enum tgtadm_op {
 	OP_NEW,
diff --git a/usr/tgtadm_error.h b/usr/tgtadm_error.h
new file mode 100644
index 0000000..319a4ad
--- /dev/null
+++ b/usr/tgtadm_error.h
@@ -0,0 +1,30 @@
+#ifndef TGTADM_ERROR_H
+#define TGTADM_ERROR_H
+
+enum tgtadm_errno {
+	TGTADM_SUCCESS,
+	TGTADM_UNKNOWN_ERR,
+	TGTADM_NOMEM,
+	TGTADM_NO_DRIVER,
+	TGTADM_NO_TARGET,
+
+	TGTADM_NO_LUN,
+	TGTADM_NO_SESSION,
+	TGTADM_NO_CONNECTION,
+	TGTADM_TARGET_EXIST,
+	TGTADM_LUN_EXIST,
+
+	TGTADM_ACL_EXIST,
+	TGTADM_USER_EXIST,
+	TGTADM_NO_USER,
+	TGTADM_TOO_MANY_USER,
+	TGTADM_INVALID_REQUEST,
+
+	TGTADM_OUTACCOUNT_EXIST,
+	TGTADM_TARGET_ACTIVE,
+	TGTADM_LUN_ACTIVE,
+	TGTADM_UNSUPPORTED_OPERATION,
+	TGTADM_UNKNOWN_PARAM,
+};
+
+#endif
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 06e0dd9..f5d5e2f 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -5,6 +5,7 @@
 
 #define SCSI_ID_LEN	24
 #define SCSI_SN_LEN	8
+#define VERSION_DESCRIPTOR_LEN 8
 
 #define VENDOR_ID	"IET"
 
@@ -29,13 +30,27 @@ struct tgt_cmd_queue {
 	struct list_head queue;
 };
 
+struct lu_phy_attr {
+	char scsi_id[SCSI_ID_LEN];
+	char scsi_sn[SCSI_SN_LEN];
+
+	/* SCSI Inquiry Params */
+	char vendor_ident[9];
+	char product_ident[17];
+	char product_rev[5];
+	uint16_t version_desc[VERSION_DESCRIPTOR_LEN];
+
+	char is_removable;	/* Removable media */
+	char online;		/* Logical Unit online ? */
+	char reset;		/* Power-on or reset has occured */
+	char sense_format;	/* Descrptor format sense data supported */
+};
+
 struct scsi_lu {
 	int fd;
 	uint64_t addr; /* persistent mapped address */
 	uint64_t size;
 	uint64_t lun;
-	char scsi_id[SCSI_ID_LEN];
-	char scsi_sn[SCSI_SN_LEN];
 	char *path;
 
 	/* the list of devices belonging to a target */
@@ -48,7 +63,7 @@ struct scsi_lu {
 	uint64_t reserve_id;
 
 	/* TODO: needs a structure for lots of device parameters */
-	uint8_t d_sense;
+	struct lu_phy_attr *attributes;
 };
 
 struct scsi_cmd {
@@ -121,7 +136,9 @@ struct device_type_template {
 	char *name;
 	char *pid;
 
-	void (*device_init)(struct scsi_lu *dev);
+	int (*lu_init)(struct scsi_lu *lu);
+	int (*lu_exit)(struct scsi_lu *lu);
+	int (*lu_config)(struct scsi_lu *lu, char *arg);
 
 	struct device_type_operations ops[256];
 };
-- 
1.5.1.3


--------------030802070500090204010901--


From markh794 at gmail.com  Mon Jun  4 12:09:53 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Mon, 04 Jun 2007 20:09:53 +1000
Subject: [Stgt-devel] [Patch 2/2]
 Add-ability-to-dynamically-set-SCSI-Inquiry-params - Try 4
In-Reply-To: <f29db9a80705311734n7ac03c5lc7db2845e5b8c938@mail.gmail.com>
References: <f29db9a80705311734n7ac03c5lc7db2845e5b8c938@mail.gmail.com>
Message-ID: <4663E4F1.3030506@gmail.com>

Added support to configure:
   Vendor Identification
   Product Identification
   Product Revision
   Format of returned 'sense data'
   Define if the lu is capable of supporting removable media
   Define/set if the lu is online / offline.

All params are passed using the 'tgtadm' utility:

   VendorIdent="string"
   ProductIdent="string"
   ProductRev="string"
   Removable=<0|1> - 0 == non-removable, 1 == removable media
   SenseFormat=<0|1> - 0 == Clasic sense format, 1 == Support descriptor format
   Online=<0|1> - 0 == Unit offline, 1 == Unit Online

e.g.
tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
         --params VendorIdent=QUANTUM,ProductIdent=HD100,ProductRev=0010
tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
         --params Removable=1,SenseFormat=1,Online=1

Example script (scripts/tgt-core-test) to set up HDD & CD device.

Signed-off-by: Mark Harvey <markh794 at gmail.com>



From markh794 at gmail.com  Sat Jun  2 09:57:34 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 2 Jun 2007 17:57:34 +1000
Subject: [PATCH] Add ability to dynamically set SCSI Inquiry params
Message-ID: <mailman.10.1331738472.12506.stgt-devel@lists.berlios.de>

Added support to configure:
  Vendor Identification
  Product Identification
  Product Revision
  Format of returned 'sense data'
  Define if the lu is capable of supporting removable media
  Define/set if the lu is online / offline.

All params are passed using the 'tgtadm' utility:

  VendorIdent="string"
  ProductIdent="string"
  ProductRev="string"
  Removable=<0|1> - 0 == non-removable, 1 == removable media
  SenseFormat=<0|1> - 0 == Clasic sense format, 1 == Support descriptor format
  Online=<0|1> - 0 == Unit offline, 1 == Unit Online

e.g.
tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
        --params VendorIdent=QUANTUM,ProductIdent=HD100,ProductRev=0010
tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
        --params Removable=1,SenseFormat=1,Online=1

Example script (scripts/tgt-core-test) to set up HDD & CD device.

Signed-off-by: Mark Harvey <markh794 at gmail.com>

diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
new file mode 100755
index 0000000..d529849
--- /dev/null
+++ b/scripts/tgt-core-test
@@ -0,0 +1,73 @@
+#!/bin/bash
+
+P=`ps -ef|grep -v grep|grep tgtd|wc -l`
+if [ "X"$P == "X0" ]; then
+	tgtd -d 1
+	sleep 1
+fi
+
+if [ ! -d /d/01 ]; then
+	mkdir -p /d/01
+fi
+
+if [ ! -f /d/01/hd_block ]; then
+	dd if=/dev/zero of=/d/01/hd_block bs=1M count=8
+fi
+if [ ! -f /d/01/cd_block0 ]; then
+	dd if=/dev/zero of=/d/01/cd_block0 bs=1M count=8
+fi
+if [ ! -f /d/01/cd_block1 ]; then
+	dd if=/dev/zero of=/d/01/cd_block1 bs=1M count=8
+fi
+if [ ! -f /d/01/cd_block2 ]; then
+	dd if=/dev/zero of=/d/01/cd_block2 bs=1M count=8
+fi
+
+set -x
+
+###################################################################################
+# Set up SBC HDD device
+###################################################################################
+TID=1
+
+tgtadm --lld iscsi --mode target --op new --tid $TID \
+		-T iqn.2007-03:marks-vtl_sbc:`hostname` --target-type disk
+
+sleep 1
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b /d/01/hd_block
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 --params scsi_sn=FRED00,scsi_id=Fred
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
+	--params VendorIdent=QUANTUM,ProductIdent=HD100,ProductRev=0010,Removable=1,SenseFormat=0
+
+
+tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
+
+
+###################################################################################
+# Set up MMC CD/DVD device
+###################################################################################
+TID=2
+
+tgtadm --lld iscsi --mode target --op new --tid $TID \
+		-T iqn.2007-03:marks-vtl_mmc:`hostname` --target-type cd
+
+sleep 1
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b /d/01/cd_block0
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
+	--params VendorIdent=VirtualCD,ProductIdent=CD101,ProductRev=0010,scsi_sn=XYZZY10,Removable=1
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 1 -b /d/01/cd_block1
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 1 \
+	--params VendorIdent=VirtualCD,ProductIdent=CD101,ProductRev=0010,scsi_sn=XYZZY11,Removable=1
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 2 -b /d/01/cd_block2
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 2 \
+	--params VendorIdent=VirtualCD,ProductIdent=CD101,ProductRev=0010,scsi_sn=XYZZY12,Removable=1
+
+tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
+
+tgtadm --lld iscsi --mode target --op show
+
+
diff --git a/usr/spc.c b/usr/spc.c
index 32a9ff7..a29811e 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -283,18 +283,29 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 }
 
 enum {
-	Opt_scsiid, Opt_scsisn, Opt_err,
+	Opt_scsiid, Opt_scsisn,
+	Opt_VendorIdent, Opt_ProductIdent,
+	Opt_ProductRev, Opt_SenseFormat,
+	Opt_Removable, Opt_Online,
+	Opt_err,
 };
 
 static match_table_t tokens = {
 	{Opt_scsiid, "scsi_id=%s"},
 	{Opt_scsisn, "scsi_sn=%s"},
+	{Opt_VendorIdent, "VendorIdent=%s"},
+	{Opt_ProductIdent, "ProductIdent=%s"},
+	{Opt_ProductRev, "ProductRev=%s"},
+	{Opt_SenseFormat, "SenseFormat=%s"},
+	{Opt_Removable, "Removable=%s"},
+	{Opt_Online, "Online=%s"},
 	{Opt_err, NULL},
 };
 
 int spc_lu_config(struct scsi_lu *lu, char *params) {
 	int err = 0;
 	char *p;
+	char buf[20];
 
 	if (!strncmp("targetOps", params, 9))
 		params = params + 10;
@@ -315,6 +326,30 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			match_strncpy(lu->attributes->scsi_sn, &args[0],
 				      sizeof(lu->attributes->scsi_sn) - 1);
 			break;
+		case Opt_VendorIdent:
+			match_strncpy(lu->attributes->vendor_ident, &args[0],
+					sizeof(lu->attributes->vendor_ident));
+			break;
+		case Opt_ProductIdent:
+			match_strncpy(lu->attributes->product_ident, &args[0],
+					sizeof(lu->attributes->product_ident));
+			break;
+		case Opt_ProductRev:
+			match_strncpy(lu->attributes->product_rev, &args[0],
+					sizeof(lu->attributes->product_rev));
+			break;
+		case Opt_SenseFormat:
+			match_strncpy(buf, &args[0],  sizeof(buf));
+			lu->attributes->sense_format = atoi(buf);
+			break;
+		case Opt_Removable:
+			match_strncpy(buf, &args[0],  sizeof(buf));
+			lu->attributes->is_removable = atoi(buf);
+			break;
+		case Opt_Online:
+			match_strncpy(buf, &args[0],  sizeof(buf));
+			lu->attributes->online = atoi(buf);
+			break;
 		default:
 			err = TGTADM_INVALID_REQUEST;
 		}
-- 
1.5.1.3


--------------050907090501010500080605--


From markh794 at gmail.com  Tue Jun  5 05:18:04 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Tue, 5 Jun 2007 13:18:04 +1000
Subject: [Stgt-devel] [Patch 1/2]
	Add-new-module-entry-points-for-configuration - Try 5
Message-ID: <f29db9a80706042018s263d8dcfh556ed50abbc978e@mail.gmail.com>

OK, just when I thought I'd found all my coding blunders...

A quick 'grep "if\(" identified some of my mistakes and a couple of
other that slipped thru.

Based against:

commit 05f2cb57ef7dbe8c8d700f86b742c98ec6d75534
Author: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
Date:   Sun Apr 22 03:22:56 2007 +0900

    add Linux kernle crc32c code

    Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
   =====================================

    Add new module entry points for configuration

    Add new module entry points.
      <module>_lu_init(struct scsi_lu *lu) - called at setup time.
      <module>_lu_exit(struct scsi_lu *lu) - called at shutdown time.
      <module>_lu_config(struct scsi_lu *lu) - Any module unique configuration.

    Moved logical unit configuration from target -> <module>
      Along with above entry point <module>_lu_config(), will allow module
      specific configuration.
      No new functionality added yet.

    Add a dump_cdb(struct scsi_cmd *cmd) - Called from spc_illegal_op()

    Update - All modules use common INQUIRY routine.

    Signed-off-by: Mark Harvey <markh794 at gmail.com>
   =====================================
-------------- next part --------------
A non-text attachment was scrubbed...
Name: patch1-again
Type: application/octet-stream
Size: 21763 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070605/6a80ff5d/attachment.obj>

From hare at suse.de  Tue Jun  5 10:11:30 2007
From: hare at suse.de (Hannes Reinecke)
Date: Tue, 05 Jun 2007 10:11:30 +0200
Subject: [Stgt-devel] [Patch
 1/2]	Add-new-module-entry-points-for-configuration - Try 5
In-Reply-To: <f29db9a80706042018s263d8dcfh556ed50abbc978e@mail.gmail.com>
References: <f29db9a80706042018s263d8dcfh556ed50abbc978e@mail.gmail.com>
Message-ID: <46651AB2.4090307@suse.de>

Hi Mark,

nice patches so far.
But as we now have the ability to configure the LUN dynamically, why
can't we move the 'type' definition down from the target to the LUN, too?

It still strikes me as odd that the _target_ has a type; strictly
speaking it's the _LUN_ which has a specific type, not the target.
So I'd prefer to move the type definition into the LUN.

I actually have a patch here; I see that I can reformat it on top of
your two patches.

Cheers,

Hannes
-- 
Dr. Hannes Reinecke		      zSeries & Storage
hare at suse.de			      +49 911 74053 688
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
GF: Markus Rex, HRB 16746 (AG N?rnberg)


From hare at suse.de  Tue Jun  5 15:38:26 2007
From: hare at suse.de (Hannes Reinecke)
Date: Tue, 5 Jun 2007 15:38:26 +0200
Subject: [Stgt-devel] [PATCH] Move device type to LUN
Message-ID: <20070605133826.GA32456@pentland.suse.de>

Hi all,

I really think it's more reasonable to have the device type
bound to the LUN, not the target. It feels so SPI-ish to
have it bound to the target. And IMHO it really restricts the
flexibility if a target can only support a single device type.

This patch moves the device type down to the LUN structure.
And in doing so we now also have the proper peripheral device
type and peripheral device qualifier attributes for the INQUIRY
data.

Patches are on top of Mark Harvey's latest patchset.

One thing puzzles me, though: do we support commands with no
LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
If so: where is the point here? If that's our handling of a
non-existing LUN 0 we should rather add a proper LUN 0 and
treat cmd->dev == NULL as an error case ...

Comments, etc are welcome.

Cheers,

Hannes
-- 
Dr. Hannes Reinecke		      zSeries & Storage
hare at suse.de			      +49 911 74053 688
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
GF: Markus Rex, HRB 16746 (AG N?rnberg)

From hare at suse.de  Tue Jun  5 15:28:44 2007
From: hare at suse.de (Hannes Reinecke)
Date: Tue, 5 Jun 2007 15:28:44 +0200
Subject: [PATCH] Bind device type to LUN
Message-ID: <mailman.11.1331738472.12506.stgt-devel@lists.berlios.de>

The device type should be bound to the LUN, not the target.
This way we can easily support different LUN types on the
same target.

Signed-off-by: Hannes Reinecke <hare at suse.de>
---
 usr/mgmt.c   |    2 +-
 usr/mmc.c    |    2 +-
 usr/osd.c    |    2 +-
 usr/sbc.c    |    4 +-
 usr/scsi.c   |    7 +++-
 usr/spc.c    |    9 +++--
 usr/spt.c    |    5 ++-
 usr/target.c |  110 ++++++++++++++++++++++++++++++++++++++++------------------
 usr/target.h |    3 --
 usr/tgtd.h   |   60 ++++++++++++++++++-------------
 usr/tgtif.c  |    2 +-
 11 files changed, 132 insertions(+), 74 deletions(-)

diff --git a/usr/mgmt.c b/usr/mgmt.c
index 9cda2fa..19ab738 100644
--- a/usr/mgmt.c
+++ b/usr/mgmt.c
@@ -167,7 +167,7 @@ static int device_mgmt(int lld_no, struc
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_device_create(req->tid, req->lun, params);
+		err = tgt_device_create(req->tid, req->lun, params, req->target_type);
 		break;
 	case OP_DELETE:
 		err = tgt_device_destroy(req->tid, req->lun);
diff --git a/usr/mmc.c b/usr/mmc.c
index 8154ede..929fc3c 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -49,7 +49,7 @@ static int mmc_rw(int host_no, struct sc
 	int ret;
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << MMC_BLK_SHIFT);
-	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
+	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		cmd->offset = 0;
 		cmd->len = 0;
diff --git a/usr/osd.c b/usr/osd.c
index 62c0082..35e50dd 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -48,7 +48,7 @@ static int osd_varlen_cdb(int host_no, s
 	}
 
 /* 	return SAM_STAT_GOOD; */
-	return cmd->c_target->bst->bs_cmd_submit(cmd);
+	return cmd->dev->bst->bs_cmd_submit(cmd);
 }
 
 static int osd_lu_init(struct scsi_lu *lu)
diff --git a/usr/sbc.c b/usr/sbc.c
index 8f981d3..8f6f0d1 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -67,7 +67,7 @@ static int sbc_rw(int host_no, struct sc
 	}
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << BLK_SHIFT);
-	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
+	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		key = HARDWARE_ERROR;
 		asc = 0;
@@ -173,7 +173,7 @@ static int sbc_sync_cache(int host_no, s
 		goto sense;
 	}
 
-	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
+	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	switch (ret) {
 	case EROFS:
 	case EINVAL:
diff --git a/usr/scsi.c b/usr/scsi.c
index 728dfe9..536b50a 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -119,6 +119,11 @@ uint64_t scsi_rw_offset(uint8_t *scb)
 int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd)
 {
 	unsigned char op = cmd->scb[0];
-	return cmd->c_target->dev_type_template.ops[op].cmd_perform(host_no, cmd);
+	if (!cmd->dev) {
+		cmd->len = 0;
+		sense_data_build(cmd, NOT_READY, 0x44, 0); /* Internal target failure */
+		return SAM_STAT_CHECK_CONDITION;
+	}
+	return cmd->dev->dev_type_template.ops[op].cmd_perform(host_no, cmd);
 }
 
diff --git a/usr/spc.c b/usr/spc.c
index 6aecdeb..006d3bc 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -43,7 +43,7 @@ int spc_inquiry(int host_no, struct scsi
 	int len, ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data;
 	uint8_t *scb = cmd->scb;
-	unsigned char device_type = cmd->c_target->dev_type_template.type;
+	uint8_t devtype;
 	struct lu_phy_attr *attributes = cmd->dev->attributes;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
@@ -60,9 +60,12 @@ int spc_inquiry(int host_no, struct scsi
 
 	dprintf("%x %x\n", scb[1], scb[2]);
 
+	devtype = (attributes->qualifier & 0x7 ) << 5;
+	devtype &= (attributes->device_type & 0x1f);
+
 	if (!(scb[1] & 0x3)) {
 		int i;
-		data[0] = device_type;
+		data[0] = devtype;
 		data[1] = (attributes->is_removable) ? 0x80 : 0;
 		data[2] = 5;	/* SPC-3 */
 		data[3] = 0x42;
@@ -87,7 +90,7 @@ int spc_inquiry(int host_no, struct scsi
 	} else if (scb[1] & 0x1) {
 		/* EVPD bit set */
 		if (scb[2] == 0x0) {
-			data[0] = device_type;
+			data[0] = devtype;
 			data[1] = 0x0;
 			data[3] = 3;
 			data[4] = 0x0;
diff --git a/usr/spt.c b/usr/spt.c
index fe2a848..561d7d4 100644
--- a/usr/spt.c
+++ b/usr/spt.c
@@ -67,8 +67,9 @@ static int spt_cmd_perform(int host_no,
 	struct device_type_operations *ops;
 
 	if (!cmd->dev) {
-		ops = cmd->c_target->dev_type_template.ops;
-		return ops[cmd->scb[0]].cmd_perform(host_no, cmd);
+		cmd->len = 0;
+		sense_data_build(cmd, NOT_READY, 0x44, 0); /* Internal target failure */
+		return SAM_STAT_CHECK_CONDITION;
 	}
 
 	ret = spt_sg_perform(cmd);
diff --git a/usr/target.c b/usr/target.c
index d2b8487..bc23e15 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -174,7 +174,7 @@ static int tgt_device_path_update(struct
 	if (!path)
 		return TGTADM_NOMEM;
 
-	err = target->bst->bs_open(lu, path, &dev_fd, &size);
+	err = lu->bst->bs_open(lu, path, &dev_fd, &size);
 	if (err) {
 		free(path);
 		return TGTADM_INVALID_REQUEST;
@@ -206,7 +206,7 @@ __device_lookup(int tid, uint64_t lun, s
 	return lu;
 }
 
-int tgt_device_create(int tid, uint64_t lun, char *args)
+int tgt_device_create(int tid, uint64_t lun, char *args, int l_type)
 {
 	char *p;
 	int err;
@@ -233,10 +233,37 @@ int tgt_device_create(int tid, uint64_t
 		return TGTADM_INVALID_REQUEST;
 	p++;
 
-	lu = zalloc(sizeof(*lu) + target->bst->bs_datasize);
+	if (l_type == TYPE_SPT)
+		lu = zalloc(sizeof(*lu) + sg_bst.bs_datasize);
+	else
+		lu = zalloc(sizeof(*lu) + target->bst->bs_datasize);
+
 	if (!lu)
 		return TGTADM_NOMEM;
 
+	switch (l_type) {
+	case TYPE_DISK:
+		lu->dev_type_template = sbc_template;
+		lu->bst = target->bst;
+		break;
+	case TYPE_ROM:
+		lu->dev_type_template = mmc_template;
+		lu->bst = target->bst;
+		break;
+	case TYPE_OSD:
+		lu->dev_type_template = osd_template;
+		lu->bst = target->bst;
+		break;
+	case TYPE_SPT:
+		lu->dev_type_template = spt_template;
+		lu->bst = &sg_bst;
+		break;
+	default:
+		dprintf("Unknown device type %d\n", l_type);
+		free(lu);
+		return TGTADM_INVALID_REQUEST;
+	}
+
 	err = tgt_device_path_update(target, lu, p);
 	if (err) {
 		free(lu);
@@ -248,8 +275,8 @@ int tgt_device_create(int tid, uint64_t
 
 	tgt_cmd_queue_init(&lu->cmd_queue);
 
-	if (target->dev_type_template.lu_init)
-		err = target->dev_type_template.lu_init(lu);
+	if (lu->dev_type_template.lu_init)
+		err = lu->dev_type_template.lu_init(lu);
 
 	if (!err) {
 		snprintf(lu->attributes->scsi_id,
@@ -258,6 +285,8 @@ int tgt_device_create(int tid, uint64_t
 		snprintf(lu->attributes->scsi_sn,
 				sizeof(lu->attributes->scsi_sn),
 				"beaf%d%" PRIu64, tid, lun);
+		lu->attributes->device_type = l_type;
+		lu->attributes->qualifier = 0x0;
 	}
 
 	list_for_each_entry(pos, &target->device_list, device_siblings) {
@@ -287,12 +316,12 @@ int tgt_device_destroy(int tid, uint64_t
 	if (!list_empty(&lu->cmd_queue.queue) || lu->cmd_queue.active_cmd)
 		return TGTADM_LUN_ACTIVE;
 
-	err = target->dev_type_template.lu_exit(lu);
+	err = lu->dev_type_template.lu_exit(lu);
 
 	free(lu->path);
 	list_del(&lu->device_siblings);
 
-	target->bst->bs_close(lu);
+	lu->bst->bs_close(lu);
 	free(lu);
 	return err;
 }
@@ -363,8 +392,8 @@ int tgt_device_update(int tid, uint64_t
 		return TGTADM_NO_LUN;
 	}
 
-	if (target->dev_type_template.lu_config)
-		err = target->dev_type_template.lu_config(lu, params);
+	if (lu->dev_type_template.lu_config)
+		err = lu->dev_type_template.lu_config(lu, params);
 
 	return err;
 }
@@ -1089,6 +1118,41 @@ static char *print_disksize(uint64_t siz
 	return buf;
 }
 
+static struct {
+	int value;
+	char *name;
+} disk_type_names[] = {
+	{ TYPE_DISK, "disk" },
+	{ TYPE_TAPE, "tape" },
+	{ TYPE_PRINTER, "printer" },
+	{ TYPE_PROCESSOR, "processor" },
+	{ TYPE_WORM, "worm" },
+	{ TYPE_SCANNER, "scanner" },
+	{ TYPE_MOD, "optical" },
+	{ TYPE_MEDIUM_CHANGER, "changer" },
+	{ TYPE_COMM, "comm" },
+	{ TYPE_RAID, "raid" },
+	{ TYPE_ENCLOSURE, "enc" },
+	{ TYPE_RBC, "rbc" },
+	{ TYPE_OSD, "osd" },
+	{ TYPE_NO_LUN, "No LUN" }
+};
+
+static char *print_type(int type)
+{
+	int i;
+	char *name = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(disk_type_names); i++) {
+		if (disk_type_names[i].value == type) {
+			name = disk_type_names[i].name;
+			break;
+		}
+	}
+	return name;
+}
+
+
 int tgt_target_show_all(char *buf, int rest)
 {
 	int total = 0, max = rest;
@@ -1101,12 +1165,10 @@ int tgt_target_show_all(char *buf, int r
 		shprintf(total, buf, rest,
 			 "Target %d: %s\n"
 			 _TAB1 "System information:\n"
-			 _TAB2 "Type: %s\n"
 			 _TAB2 "Driver: %s\n"
 			 _TAB2 "Status: %s\n",
 			 target->tid,
 			 target->name,
-			 target->dev_type_template.name,
 			 tgt_drivers[target->lid]->name,
 			 target_state_name(target->target_state));
 
@@ -1123,11 +1185,13 @@ int tgt_target_show_all(char *buf, int r
 		list_for_each_entry(lu, &target->device_list, device_siblings)
 			shprintf(total, buf, rest,
 				 _TAB2 "LUN: %" PRIu64 "\n"
+				 _TAB3 "Type: %s\n"
 				 _TAB3 "SCSI ID: %s\n"
 				 _TAB3 "SCSI SN: %s\n"
 				 _TAB3 "Size: %s\n"
 				 _TAB3 "Backing store: %s\n",
 				 lu->lun,
+				 print_type(lu->attributes->device_type),
 				 lu->attributes->scsi_id,
 				 lu->attributes->scsi_sn,
 				 print_disksize(lu->size),
@@ -1206,24 +1270,6 @@ int tgt_target_create(int lld, int tid,
 	if (!target)
 		return TGTADM_NOMEM;
 
-	switch (t_type) {
-	case TYPE_DISK:
-		target->dev_type_template = sbc_template;
-		break;
-	case TYPE_ROM:
-		target->dev_type_template = mmc_template;
-		break;
-	case TYPE_OSD:
-		target->dev_type_template = osd_template;
-		break;
-	case TYPE_SPT:
-		target->dev_type_template = spt_template;
-		break;
-	default:
-		free(target);
-		return TGTADM_INVALID_REQUEST;
-	}
-
 	target->name = strdup(targetname);
 	if (!target->name) {
 		free(target);
@@ -1242,11 +1288,7 @@ int tgt_target_create(int lld, int tid,
 
 	INIT_LIST_HEAD(&target->device_list);
 
-	/* FIXME */
-	if (t_type == TYPE_SPT)
-		target->bst = &sg_bst;
-	else
-		target->bst = tgt_drivers[lld]->default_bst;
+	target->bst = tgt_drivers[lld]->default_bst;
 
 	target->target_state = SCSI_TARGET_RUNNING;
 	target->lid = lld;
diff --git a/usr/target.h b/usr/target.h
index a5f1faa..688f0e6 100644
--- a/usr/target.h
+++ b/usr/target.h
@@ -41,9 +41,6 @@ struct target {
 	struct list_head acl_list;
 
 	struct tgt_account account;
-
-	/* we don't use a pointer because a lld could change this. */
-	struct device_type_template dev_type_template;
 };
 
 struct it_nexus {
diff --git a/usr/tgtd.h b/usr/tgtd.h
index f5d5e2f..9f81858 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -40,12 +40,41 @@ struct lu_phy_attr {
 	char product_rev[5];
 	uint16_t version_desc[VERSION_DESCRIPTOR_LEN];
 
+	char device_type;	/* Peripheral device type */
+	char qualifier;		/* Peripheral Qualifier */
 	char is_removable;	/* Removable media */
 	char online;		/* Logical Unit online ? */
 	char reset;		/* Power-on or reset has occured */
 	char sense_format;	/* Descrptor format sense data supported */
 };
 
+struct scsi_lu;
+struct scsi_cmd;
+
+struct device_type_operations {
+	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
+};
+
+struct device_type_template {
+	unsigned char type;
+	char *name;
+	char *pid;
+
+	int (*lu_init)(struct scsi_lu *lu);
+	int (*lu_exit)(struct scsi_lu *lu);
+	int (*lu_config)(struct scsi_lu *lu, char *arg);
+
+	struct device_type_operations ops[256];
+};
+
+struct backingstore_template {
+	int bs_datasize;
+	int (*bs_open)(struct scsi_lu *dev, char *path, int *fd, uint64_t *size);
+	void (*bs_close)(struct scsi_lu *dev);
+	int (*bs_cmd_submit)(struct scsi_cmd *cmd);
+	int (*bs_cmd_done) (struct scsi_cmd *cmd);
+};
+
 struct scsi_lu {
 	int fd;
 	uint64_t addr; /* persistent mapped address */
@@ -62,6 +91,11 @@ struct scsi_lu {
 
 	uint64_t reserve_id;
 
+	/* we don't use a pointer because a lld could change this. */
+	struct device_type_template dev_type_template;
+
+	struct backingstore_template *bst;
+
 	/* TODO: needs a structure for lots of device parameters */
 	struct lu_phy_attr *attributes;
 };
@@ -110,14 +144,6 @@ struct mgmt_req {
 	uint64_t itn_id;
 };
 
-struct backingstore_template {
-	int bs_datasize;
-	int (*bs_open)(struct scsi_lu *dev, char *path, int *fd, uint64_t *size);
-	void (*bs_close)(struct scsi_lu *dev);
-	int (*bs_cmd_submit)(struct scsi_cmd *cmd);
-	int (*bs_cmd_done) (struct scsi_cmd *cmd);
-};
-
 #ifdef USE_KERNEL
 extern int kreq_init(void);
 #else
@@ -127,27 +153,11 @@ static inline int kreq_init(void)	\
 }
 #endif
 
-struct device_type_operations {
-	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
-};
-
-struct device_type_template {
-	unsigned char type;
-	char *name;
-	char *pid;
-
-	int (*lu_init)(struct scsi_lu *lu);
-	int (*lu_exit)(struct scsi_lu *lu);
-	int (*lu_config)(struct scsi_lu *lu, char *arg);
-
-	struct device_type_operations ops[256];
-};
-
 extern int kspace_send_tsk_mgmt_res(struct mgmt_req *mreq);
 extern int kspace_send_cmd_res(uint64_t nid, int result, struct scsi_cmd *);
 
 extern int ipc_init(void);
-extern int tgt_device_create(int tid, uint64_t lun, char *args);
+extern int tgt_device_create(int tid, uint64_t lun, char *args, int l_type);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_device_update(int tid, uint64_t dev_id, char *name);
 extern int device_reserve(struct scsi_cmd *cmd);
diff --git a/usr/tgtif.c b/usr/tgtif.c
index caa0eeb..c8c9817 100644
--- a/usr/tgtif.c
+++ b/usr/tgtif.c
@@ -162,7 +162,7 @@ static void kern_queue_cmd(struct tgt_ev
 	kcmd->host_no = ev->p.cmd_req.host_no;
 	cmd = &kcmd->scmd;
 	cmd->cmd_itn_id = ev->p.cmd_req.itn_id;
-	cmd->scb = (char *)cmd + sizeof(*cmd);
+	cmd->scb = (unsigned char *)cmd + sizeof(*cmd);
 	memcpy(cmd->scb, ev->p.cmd_req.scb, scb_len);
 	cmd->scb_len = scb_len;
 	memcpy(cmd->lun, ev->p.cmd_req.lun, sizeof(cmd->lun));
-- 
1.4.3.4


--mYCpIKhGyMATD0i+--


From blackmagic02881 at gmail.com  Tue Jun  5 14:49:58 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Tue, 05 Jun 2007 08:49:58 -0400
Subject: [Stgt-devel]
	[Patch	1/2]	Add-new-module-entry-points-for-configuration - Try 5
In-Reply-To: <46651AB2.4090307@suse.de>
References: <f29db9a80706042018s263d8dcfh556ed50abbc978e@mail.gmail.com>
	<46651AB2.4090307@suse.de>
Message-ID: <1181047798.3613.1.camel@localhost.localdomain>

On Tue, 2007-06-05 at 10:11 +0200, Hannes Reinecke wrote:
> Hi Mark,
> 
> nice patches so far.
> But as we now have the ability to configure the LUN dynamically, why
> can't we move the 'type' definition down from the target to the LUN, too?
> 
> It still strikes me as odd that the _target_ has a type; strictly
> speaking it's the _LUN_ which has a specific type, not the target.
> So I'd prefer to move the type definition into the LUN.

make sense. actually in iet we suggested to have this lun type for quite
a long time.

> 
> I actually have a patch here; I see that I can reformat it on top of
> your two patches.
> 
> Cheers,
> 
> Hannes



From fujita.tomonori at lab.ntt.co.jp  Sat Jun  9 09:12:02 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 09 Jun 2007 16:12:02 +0900
Subject: [Stgt-devel] [Patch
	1/2]	Add-new-module-entry-points-for-configuration - Try 5
In-Reply-To: <f29db9a80706042018s263d8dcfh556ed50abbc978e@mail.gmail.com>
References: <f29db9a80706042018s263d8dcfh556ed50abbc978e@mail.gmail.com>
Message-ID: <200706090712.l597CSZV022841@mbox.iij4u.or.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 1/2]	Add-new-module-entry-points-for-configuration - Try 5
Date: Tue, 5 Jun 2007 13:18:04 +1000

> OK, just when I thought I'd found all my coding blunders...
> 
> A quick 'grep "if\(" identified some of my mistakes and a couple of
> other that slipped thru.

Applied, thanks a lot. No base64 attachment next time, please.

Some comments for next time.

>  int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  {
> @@ -40,7 +44,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  	uint8_t *data;
>  	uint8_t *scb = cmd->scb;
>  	unsigned char device_type = cmd->c_target->dev_type_template.type;
> -	char *product_id = cmd->c_target->dev_type_template.pid;
> +	struct lu_phy_attr *attributes = cmd->dev->attributes;
>  	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
>  
>  	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
> @@ -57,22 +61,21 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  	dprintf("%x %x\n", scb[1], scb[2]);
>  
>  	if (!(scb[1] & 0x3)) {
> +		int i;
>  		data[0] = device_type;
> -		data[2] = 4;
> +		data[1] = (attributes->is_removable) ? 0x80 : 0;
> +		data[2] = 5;	/* SPC-3 */
>  		data[3] = 0x42;
> -		data[4] = 59;
>  		data[7] = 0x02;
>  		memset(data + 8, 0x20, 28);
> -		strncpy((char *)data + 8, VENDOR_ID, 8);
> -		strncpy((char *)data + 16, product_id, 16);
> -		strncpy((char *)data + 32, PRODUCT_REV, 4);
> -		data[58] = 0x03;
> -		data[59] = 0x20;
> -		data[60] = 0x09;
> -		data[61] = 0x60;
> -		data[62] = 0x03;
> -		data[63] = 0x00;
> -		len = 64;
> +		strncpy((char *)data + 8, attributes->vendor_ident, 8);
> +		strncpy((char *)data + 16, attributes->product_ident, 16);
> +		strncpy((char *)data + 32, attributes->product_rev, 4);
> +		for (i=0, len=58; i < VERSION_DESCRIPTOR_LEN; i++, len += 2) {
> +			data[len] = (attributes->version_desc[i] >> 8) & 0xff;
> +			data[len+1] = attributes->version_desc[i] & 0xff;
> +		}

Should be:

> +		for (i = 0, len = 58; i < VERSION_DESCRIPTOR_LEN; i++, len += 2) {

Anyway, this part looks odd to me. I rewrote this part.


> +struct lu_phy_attr {
> +	char scsi_id[SCSI_ID_LEN];
> +	char scsi_sn[SCSI_SN_LEN];
> +
> +	/* SCSI Inquiry Params */
> +	char vendor_ident[9];
> +	char product_ident[17];

Renamed vendor_id and product_id.

> +	char product_rev[5];
> +	uint16_t version_desc[VERSION_DESCRIPTOR_LEN];
> +
> +	char is_removable;	/* Removable media */
> +	char online;		/* Logical Unit online ? */
> +	char reset;		/* Power-on or reset has occured */
> +	char sense_format;	/* Descrptor format sense data supported */
> +};
> +
>  struct scsi_lu {
>  	int fd;
>  	uint64_t addr; /* persistent mapped address */
>  	uint64_t size;
>  	uint64_t lun;
> -	char scsi_id[SCSI_ID_LEN];
> -	char scsi_sn[SCSI_SN_LEN];
>  	char *path;
>  
>  	/* the list of devices belonging to a target */
> @@ -48,7 +63,7 @@ struct scsi_lu {
>  	uint64_t reserve_id;
>  
>  	/* TODO: needs a structure for lots of device parameters */
> -	uint8_t d_sense;
> +	struct lu_phy_attr *attributes;

Why do we use a struct lu_phy_attr pointer? Why just can't we do:

struct scsi_lu {
...
	struct lu_phy_attr attrs;
};

'attributes' is too long for me. renamed 'attrs'.


From fujita.tomonori at lab.ntt.co.jp  Sat Jun  9 09:12:03 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 09 Jun 2007 16:12:03 +0900
Subject: [Stgt-devel] [Patch 2/2]
 Add-ability-to-dynamically-set-SCSI-Inquiry-params - Try 4
In-Reply-To: <4663E4F1.3030506@gmail.com>
References: <f29db9a80705311734n7ac03c5lc7db2845e5b8c938@mail.gmail.com>
	<4663E4F1.3030506@gmail.com>
Message-ID: <200706090712.l597CUMp026046@mbox.iij4u.or.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: Re: [Stgt-devel] [Patch 2/2] Add-ability-to-dynamically-set-SCSI-Inquiry-params - Try 4
Date: Mon, 04 Jun 2007 20:09:53 +1000

> >From 1db73f345c86e59bb3f616b44fbe761e104690e9 Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Sat, 2 Jun 2007 17:57:34 +1000
> Subject: [PATCH] Add ability to dynamically set SCSI Inquiry params
> 
> Added support to configure:
>   Vendor Identification
>   Product Identification
>   Product Revision
>   Format of returned 'sense data'
>   Define if the lu is capable of supporting removable media
>   Define/set if the lu is online / offline.
> 
> All params are passed using the 'tgtadm' utility:
> 
>   VendorIdent="string"
>   ProductIdent="string"
>   ProductRev="string"
>   Removable=<0|1> - 0 == non-removable, 1 == removable media
>   SenseFormat=<0|1> - 0 == Clasic sense format, 1 == Support descriptor format
>   Online=<0|1> - 0 == Unit offline, 1 == Unit Online
> 
> e.g.
> tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
>         --params VendorIdent=QUANTUM,ProductIdent=HD100,ProductRev=0010
> tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
>         --params Removable=1,SenseFormat=1,Online=1
> 
> Example script (scripts/tgt-core-test) to set up HDD & CD device.
> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>
> 
> diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
> new file mode 100755
> index 0000000..d529849
> --- /dev/null
> +++ b/scripts/tgt-core-test
> @@ -0,0 +1,73 @@
> +#!/bin/bash
> +
> +P=`ps -ef|grep -v grep|grep tgtd|wc -l`
> +if [ "X"$P == "X0" ]; then
> +	tgtd -d 1
> +	sleep 1
> +fi
> +
> +if [ ! -d /d/01 ]; then
> +	mkdir -p /d/01
> +fi
> +
> +if [ ! -f /d/01/hd_block ]; then
> +	dd if=/dev/zero of=/d/01/hd_block bs=1M count=8
> +fi
> +if [ ! -f /d/01/cd_block0 ]; then
> +	dd if=/dev/zero of=/d/01/cd_block0 bs=1M count=8
> +fi
> +if [ ! -f /d/01/cd_block1 ]; then
> +	dd if=/dev/zero of=/d/01/cd_block1 bs=1M count=8
> +fi
> +if [ ! -f /d/01/cd_block2 ]; then
> +	dd if=/dev/zero of=/d/01/cd_block2 bs=1M count=8
> +fi
> +
> +set -x
> +
> +###################################################################################
> +# Set up SBC HDD device
> +###################################################################################
> +TID=1
> +
> +tgtadm --lld iscsi --mode target --op new --tid $TID \
> +		-T iqn.2007-03:marks-vtl_sbc:`hostname` --target-type disk
> +
> +sleep 1
> +tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b /d/01/hd_block
> +
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 --params scsi_sn=FRED00,scsi_id=Fred
> +
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
> +	--params VendorIdent=QUANTUM,ProductIdent=HD100,ProductRev=0010,Removable=1,SenseFormat=0
> +
> +
> +tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
> +
> +
> +###################################################################################
> +# Set up MMC CD/DVD device
> +###################################################################################
> +TID=2
> +
> +tgtadm --lld iscsi --mode target --op new --tid $TID \
> +		-T iqn.2007-03:marks-vtl_mmc:`hostname` --target-type cd
> +
> +sleep 1
> +tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b /d/01/cd_block0
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
> +	--params VendorIdent=VirtualCD,ProductIdent=CD101,ProductRev=0010,scsi_sn=XYZZY10,Removable=1
> +
> +tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 1 -b /d/01/cd_block1
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 1 \
> +	--params VendorIdent=VirtualCD,ProductIdent=CD101,ProductRev=0010,scsi_sn=XYZZY11,Removable=1
> +
> +tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 2 -b /d/01/cd_block2
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 2 \
> +	--params VendorIdent=VirtualCD,ProductIdent=CD101,ProductRev=0010,scsi_sn=XYZZY12,Removable=1
> +
> +tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
> +
> +tgtadm --lld iscsi --mode target --op show
> +
> +
> diff --git a/usr/spc.c b/usr/spc.c
> index 32a9ff7..a29811e 100644
> --- a/usr/spc.c
> +++ b/usr/spc.c
> @@ -283,18 +283,29 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
>  }
>  
>  enum {
> -	Opt_scsiid, Opt_scsisn, Opt_err,
> +	Opt_scsiid, Opt_scsisn,
> +	Opt_VendorIdent, Opt_ProductIdent,
> +	Opt_ProductRev, Opt_SenseFormat,
> +	Opt_Removable, Opt_Online,
> +	Opt_err,
>  };
>  
>  static match_table_t tokens = {
>  	{Opt_scsiid, "scsi_id=%s"},
>  	{Opt_scsisn, "scsi_sn=%s"},
> +	{Opt_VendorIdent, "VendorIdent=%s"},
> +	{Opt_ProductIdent, "ProductIdent=%s"},
> +	{Opt_ProductRev, "ProductRev=%s"},
> +	{Opt_SenseFormat, "SenseFormat=%s"},
> +	{Opt_Removable, "Removable=%s"},
> +	{Opt_Online, "Online=%s"},
>  	{Opt_err, NULL},
>  };

I think that we need naming consistency here.


>  int spc_lu_config(struct scsi_lu *lu, char *params) {
>  	int err = 0;
>  	char *p;
> +	char buf[20];
>  
>  	if (!strncmp("targetOps", params, 9))
>  		params = params + 10;
> @@ -315,6 +326,30 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
>  			match_strncpy(lu->attributes->scsi_sn, &args[0],
>  				      sizeof(lu->attributes->scsi_sn) - 1);
>  			break;
> +		case Opt_VendorIdent:
> +			match_strncpy(lu->attributes->vendor_ident, &args[0],
> +					sizeof(lu->attributes->vendor_ident));
> +			break;
> +		case Opt_ProductIdent:
> +			match_strncpy(lu->attributes->product_ident, &args[0],
> +					sizeof(lu->attributes->product_ident));
> +			break;
> +		case Opt_ProductRev:
> +			match_strncpy(lu->attributes->product_rev, &args[0],
> +					sizeof(lu->attributes->product_rev));
> +			break;
> +		case Opt_SenseFormat:
> +			match_strncpy(buf, &args[0],  sizeof(buf));
> +			lu->attributes->sense_format = atoi(buf);
> +			break;
> +		case Opt_Removable:
> +			match_strncpy(buf, &args[0],  sizeof(buf));
> +			lu->attributes->is_removable = atoi(buf);
> +			break;
> +		case Opt_Online:
> +			match_strncpy(buf, &args[0],  sizeof(buf));
> +			lu->attributes->online = atoi(buf);
> +			break;
>  		default:
>  			err = TGTADM_INVALID_REQUEST;
>  		}
> -- 
> 1.5.1.3
> 


From albert.pauw at gmail.com  Sat Jun  9 09:56:48 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Sat, 09 Jun 2007 09:56:48 +0200
Subject: [Stgt-devel] tgtadm_error.h missing
Message-ID: <466A5D40.1080704@gmail.com>

Can't get stgt compiled under FC6, kernel 2.6.20-1.2952.fc6:

[root at orange usr]# make 
KERNELSRC=/usr/src/kernels/2.6.20-1.2952.fc6-i686/ ISCSI=1
cc -DISCSI -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE 
-I../include -I/usr/src/kernels/2.6.20-1.2952.fc6-i686//include -I.   -c 
-o iscsi/target.o iscsi/target.c
In file included from iscsi/target.c:37:
./tgtadm.h:7:26: error: tgtadm_error.h: No such file or directory
make: *** [iscsi/target.o] Error 1

there is no tgtadm_error.h file

Albert



From fujita.tomonori at lab.ntt.co.jp  Sat Jun  9 10:13:50 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 09 Jun 2007 17:13:50 +0900
Subject: [Stgt-devel] tgtadm_error.h missing
In-Reply-To: <466A5D40.1080704@gmail.com>
References: <466A5D40.1080704@gmail.com>
Message-ID: <200706090814.l598EGGW024174@mbox.iij4u.or.jp>

From: Albert Pauw <albert.pauw at gmail.com>
Subject: [Stgt-devel] tgtadm_error.h missing
Date: Sat, 09 Jun 2007 09:56:48 +0200

> Can't get stgt compiled under FC6, kernel 2.6.20-1.2952.fc6:
> 
> [root at orange usr]# make 
> KERNELSRC=/usr/src/kernels/2.6.20-1.2952.fc6-i686/ ISCSI=1
> cc -DISCSI -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE 
> -I../include -I/usr/src/kernels/2.6.20-1.2952.fc6-i686//include -I.   -c 
> -o iscsi/target.o iscsi/target.c
> In file included from iscsi/target.c:37:
> ./tgtadm.h:7:26: error: tgtadm_error.h: No such file or directory
> make: *** [iscsi/target.o] Error 1
> 
> there is no tgtadm_error.h file

Oops, fixed though it takes some time until kernel.org will be updated.


From pw at osc.edu  Sat Jun  9 19:18:26 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 9 Jun 2007 13:18:26 -0400
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <20070605133826.GA32456@pentland.suse.de>
References: <20070605133826.GA32456@pentland.suse.de>
Message-ID: <20070609171826.GA2582@osc.edu>

hare at suse.de wrote on Tue, 05 Jun 2007 15:38 +0200:
> This patch moves the device type down to the LUN structure.
> And in doing so we now also have the proper peripheral device
> type and peripheral device qualifier attributes for the INQUIRY
> data.

Makes sense to me too.

> One thing puzzles me, though: do we support commands with no
> LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
> If so: where is the point here? If that's our handling of a
> non-existing LUN 0 we should rather add a proper LUN 0 and
> treat cmd->dev == NULL as an error case ...

In the SCSI model, every device must have at least one LUN for
handling REPORT LUNS and a couple other commands.  It is addressed
as LUN 0 or using the "well-known" LUN for the command.  In the stgt
abstraction, though, there is no magic LUN like this.  Instead
things like spc_inqury use cmd->dev == NULL to handle this case.

Perhaps it is reasonable to create a special device for these
commands.  Up in target.c, you could assign cmd->dev to target->dev,
where that is the special device, paralleling the way that
target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
... else ILLEGAL_REQUEST" clauses can be removed from device code
too.

		-- Pete


From hare at suse.de  Mon Jun 11 17:15:19 2007
From: hare at suse.de (Hannes Reinecke)
Date: Mon, 11 Jun 2007 17:15:19 +0200
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <20070609171826.GA2582@osc.edu>
References: <20070605133826.GA32456@pentland.suse.de>
	<20070609171826.GA2582@osc.edu>
Message-ID: <466D6707.9010406@suse.de>

Pete Wyckoff wrote:
> hare at suse.de wrote on Tue, 05 Jun 2007 15:38 +0200:
>> This patch moves the device type down to the LUN structure.
>> And in doing so we now also have the proper peripheral device
>> type and peripheral device qualifier attributes for the INQUIRY
>> data.
> 
> Makes sense to me too.
> 
>> One thing puzzles me, though: do we support commands with no
>> LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
>> If so: where is the point here? If that's our handling of a
>> non-existing LUN 0 we should rather add a proper LUN 0 and
>> treat cmd->dev == NULL as an error case ...
> 
> In the SCSI model, every device must have at least one LUN for
> handling REPORT LUNS and a couple other commands.  It is addressed
> as LUN 0 or using the "well-known" LUN for the command.  In the stgt
> abstraction, though, there is no magic LUN like this.  Instead
> things like spc_inqury use cmd->dev == NULL to handle this case.
> 
Ah. Hence.

> Perhaps it is reasonable to create a special device for these
> commands.  Up in target.c, you could assign cmd->dev to target->dev,
> where that is the special device, paralleling the way that
> target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
> ... else ILLEGAL_REQUEST" clauses can be removed from device code
> too.
> 
Well, I actually thought of creating a proper LUN 0 with type 0xc.
This would be automagically created whenever a target is created.
And we could hook some management facilities to that one.
Maybe even turn it into a proper remote management :-)

But then, for this we definitely need to move the type to the LUN.

Tomo, what are you're thoughts on that one?

Cheers,

Hannes
-- 
Dr. Hannes Reinecke		      zSeries & Storage
hare at suse.de			      +49 911 74053 688
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
GF: Markus Rex, HRB 16746 (AG N?rnberg)


From James.Smart at Emulex.Com  Mon Jun 11 17:42:44 2007
From: James.Smart at Emulex.Com (James Smart)
Date: Mon, 11 Jun 2007 11:42:44 -0400
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <466D6707.9010406@suse.de>
References: <20070605133826.GA32456@pentland.suse.de>	<20070609171826.GA2582@osc.edu>
	<466D6707.9010406@suse.de>
Message-ID: <466D6D74.60207@emulex.com>

Please move to this route.... a special LUN 0 w/ REPORT_LUNS support.
Most SCSI discovery algorithms finally use it, and it solves many
problems. With out it, you re-introducing the old SCSI-2-isms, which
drove things like devinfo(/blacklist) entries, etc. Bad hacks you'd
like to avoid.

I also agree with the desire for multiple lun support. Yes, SCSI has
lots of warts (command queuing sharing a prime one), but multiple luns
makes a lot of sense in a lot of circumstances.

-- james s

Hannes Reinecke wrote:
>> Perhaps it is reasonable to create a special device for these
>> commands.  Up in target.c, you could assign cmd->dev to target->dev,
>> where that is the special device, paralleling the way that
>> target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
>> ... else ILLEGAL_REQUEST" clauses can be removed from device code
>> too.
>>
> Well, I actually thought of creating a proper LUN 0 with type 0xc.
> This would be automagically created whenever a target is created.
> And we could hook some management facilities to that one.
> Maybe even turn it into a proper remote management :-)
> 
> But then, for this we definitely need to move the type to the LUN.
> 
> Tomo, what are you're thoughts on that one?
> 
> Cheers,
> 
> Hannes


From markh794 at gmail.com  Tue Jun 12 06:32:59 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Tue, 12 Jun 2007 14:32:59 +1000
Subject: [Stgt-devel] [Patch 1/2]
	Add-new-module-entry-points-for-configuration - Try 5
In-Reply-To: <200706090712.l597CSZV022841@mbox.iij4u.or.jp>
References: <f29db9a80706042018s263d8dcfh556ed50abbc978e@mail.gmail.com>
	<200706090712.l597CSZV022841@mbox.iij4u.or.jp>
Message-ID: <f29db9a80706112132u3109d96fmb36c9ecaad44e18f@mail.gmail.com>

On 6/9/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: [Stgt-devel] [Patch 1/2]       Add-new-module-entry-points-for-configuration - Try 5
> Date: Tue, 5 Jun 2007 13:18:04 +1000
>
> > OK, just when I thought I'd found all my coding blunders...
> >
> > A quick 'grep "if\(" identified some of my mistakes and a couple of
> > other that slipped thru.
>
> Applied, thanks a lot. No base64 attachment next time, please.
>
> Some comments for next time.
>
> >  int spc_inquiry(int host_no, struct scsi_cmd *cmd)
> >  {
> > @@ -40,7 +44,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
> >       uint8_t *data;
> >       uint8_t *scb = cmd->scb;
> >       unsigned char device_type = cmd->c_target->dev_type_template.type;
> > -     char *product_id = cmd->c_target->dev_type_template.pid;
> > +     struct lu_phy_attr *attributes = cmd->dev->attributes;
> >       unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
> >
> >       if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
> > @@ -57,22 +61,21 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
> >       dprintf("%x %x\n", scb[1], scb[2]);
> >
> >       if (!(scb[1] & 0x3)) {
> > +             int i;
> >               data[0] = device_type;
> > -             data[2] = 4;
> > +             data[1] = (attributes->is_removable) ? 0x80 : 0;
> > +             data[2] = 5;    /* SPC-3 */
> >               data[3] = 0x42;
> > -             data[4] = 59;
> >               data[7] = 0x02;
> >               memset(data + 8, 0x20, 28);
> > -             strncpy((char *)data + 8, VENDOR_ID, 8);
> > -             strncpy((char *)data + 16, product_id, 16);
> > -             strncpy((char *)data + 32, PRODUCT_REV, 4);
> > -             data[58] = 0x03;
> > -             data[59] = 0x20;
> > -             data[60] = 0x09;
> > -             data[61] = 0x60;
> > -             data[62] = 0x03;
> > -             data[63] = 0x00;
> > -             len = 64;
> > +             strncpy((char *)data + 8, attributes->vendor_ident, 8);
> > +             strncpy((char *)data + 16, attributes->product_ident, 16);
> > +             strncpy((char *)data + 32, attributes->product_rev, 4);
> > +             for (i=0, len=58; i < VERSION_DESCRIPTOR_LEN; i++, len += 2) {
> > +                     data[len] = (attributes->version_desc[i] >> 8) & 0xff;
> > +                     data[len+1] = attributes->version_desc[i] & 0xff;
> > +             }
>
> Should be:
>
> > +             for (i = 0, len = 58; i < VERSION_DESCRIPTOR_LEN; i++, len += 2) {
>
> Anyway, this part looks odd to me. I rewrote this part.
>
>
> > +struct lu_phy_attr {
> > +     char scsi_id[SCSI_ID_LEN];
> > +     char scsi_sn[SCSI_SN_LEN];
> > +
> > +     /* SCSI Inquiry Params */
> > +     char vendor_ident[9];
> > +     char product_ident[17];
>
> Renamed vendor_id and product_id.
>
> > +     char product_rev[5];
> > +     uint16_t version_desc[VERSION_DESCRIPTOR_LEN];
> > +
> > +     char is_removable;      /* Removable media */
> > +     char online;            /* Logical Unit online ? */
> > +     char reset;             /* Power-on or reset has occured */
> > +     char sense_format;      /* Descrptor format sense data supported */
> > +};
> > +
> >  struct scsi_lu {
> >       int fd;
> >       uint64_t addr; /* persistent mapped address */
> >       uint64_t size;
> >       uint64_t lun;
> > -     char scsi_id[SCSI_ID_LEN];
> > -     char scsi_sn[SCSI_SN_LEN];
> >       char *path;
> >
> >       /* the list of devices belonging to a target */
> > @@ -48,7 +63,7 @@ struct scsi_lu {
> >       uint64_t reserve_id;
> >
> >       /* TODO: needs a structure for lots of device parameters */
> > -     uint8_t d_sense;
> > +     struct lu_phy_attr *attributes;
>
> Why do we use a struct lu_phy_attr pointer? Why just can't we do:
>
> struct scsi_lu {
> ...
>         struct lu_phy_attr attrs;
> };
>
> 'attributes' is too long for me. renamed 'attrs'.
>

I used a pointer and malloc(sizeof(struct lu_phy_attrs)) thinking this
will limit the size of the scsi_lu structure.

I can in-line it with scsi_lu if you like..


BTW: I am having problem accessing the git repositry via http..
(git:// blocked from work's firewall)

$ git-pull http://www.kernel.org/pub/scm/linux/kernel/git/tomo/tgt.git master
Fetching refs/heads/master from
http://www.kernel.org/pub/scm/linux/kernel/git/tomo/tgt.git using http
Getting alternates list for
http://www.kernel.org/pub/scm/linux/kernel/git/tomo/tgt.git
Getting pack list for
http://www.kernel.org/pub/scm/linux/kernel/git/tomo/tgt.git
Getting index for pack 347d7aca3fccc4218e6acf919119f6bdabc921a6
Getting index for pack acebc448c87d220eb76e7fa8a8caa8fd04fd1506
Getting pack acebc448c87d220eb76e7fa8a8caa8fd04fd1506
 which contains 468fbf386c3f7df6217353eaba33630cf293f180
walk 468fbf386c3f7df6217353eaba33630cf293f180
[snip]


$ git log
commit 468fbf386c3f7df6217353eaba33630cf293f180
Author: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
Date:   Sat Apr 14 10:03:55 2007 +0900

    fix pread/pwrite large offset bugs

    Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>

[snip]


Cheers
Mark


From fujita.tomonori at lab.ntt.co.jp  Tue Jun 12 14:33:58 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 12 Jun 2007 21:33:58 +0900
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <466D6707.9010406@suse.de>
References: <20070605133826.GA32456@pentland.suse.de>
	<20070609171826.GA2582@osc.edu> <466D6707.9010406@suse.de>
Message-ID: <20070612213358F.fujita.tomonori@lab.ntt.co.jp>

From: Hannes Reinecke <hare at suse.de>
Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
Date: Mon, 11 Jun 2007 17:15:19 +0200

> Pete Wyckoff wrote:
> > hare at suse.de wrote on Tue, 05 Jun 2007 15:38 +0200:
> >> This patch moves the device type down to the LUN structure.
> >> And in doing so we now also have the proper peripheral device
> >> type and peripheral device qualifier attributes for the INQUIRY
> >> data.
> > 
> > Makes sense to me too.
> > 
> >> One thing puzzles me, though: do we support commands with no
> >> LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
> >> If so: where is the point here? If that's our handling of a
> >> non-existing LUN 0 we should rather add a proper LUN 0 and
> >> treat cmd->dev == NULL as an error case ...
> > 
> > In the SCSI model, every device must have at least one LUN for
> > handling REPORT LUNS and a couple other commands.  It is addressed
> > as LUN 0 or using the "well-known" LUN for the command.  In the stgt
> > abstraction, though, there is no magic LUN like this.  Instead
> > things like spc_inqury use cmd->dev == NULL to handle this case.
> > 
> Ah. Hence.
> 
> > Perhaps it is reasonable to create a special device for these
> > commands.  Up in target.c, you could assign cmd->dev to target->dev,
> > where that is the special device, paralleling the way that
> > target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
> > ... else ILLEGAL_REQUEST" clauses can be removed from device code
> > too.
> > 
> Well, I actually thought of creating a proper LUN 0 with type 0xc.

We still need to handle cmd->dev == NULL case though probably we can
remove cmd->dev == NULL case in device type code.

I don't have storage systems that work in your way. Is it common?


> This would be automagically created whenever a target is created.
> And we could hook some management facilities to that one.
> Maybe even turn it into a proper remote management :-)
> 
> But then, for this we definitely need to move the type to the LUN.
> 
> Tomo, what are you're thoughts on that one?
> 
> Cheers,
> 
> Hannes
> -- 
> Dr. Hannes Reinecke		      zSeries & Storage
> hare at suse.de			      +49 911 74053 688
> SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
> GF: Markus Rex, HRB 16746 (AG N?rnberg)
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
> 


From fujita.tomonori at lab.ntt.co.jp  Tue Jun 12 14:37:06 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 12 Jun 2007 21:37:06 +0900
Subject: [Stgt-devel] [Patch
	1/2]	Add-new-module-entry-points-for-configuration - Try 5
In-Reply-To: <f29db9a80706112132u3109d96fmb36c9ecaad44e18f@mail.gmail.com>
References: <f29db9a80706042018s263d8dcfh556ed50abbc978e@mail.gmail.com>
	<200706090712.l597CSZV022841@mbox.iij4u.or.jp>
	<f29db9a80706112132u3109d96fmb36c9ecaad44e18f@mail.gmail.com>
Message-ID: <20070612213706H.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] [Patch 1/2]	Add-new-module-entry-points-for-configuration - Try 5
Date: Tue, 12 Jun 2007 14:32:59 +1000

> > >  struct scsi_lu {
> > >       int fd;
> > >       uint64_t addr; /* persistent mapped address */
> > >       uint64_t size;
> > >       uint64_t lun;
> > > -     char scsi_id[SCSI_ID_LEN];
> > > -     char scsi_sn[SCSI_SN_LEN];
> > >       char *path;
> > >
> > >       /* the list of devices belonging to a target */
> > > @@ -48,7 +63,7 @@ struct scsi_lu {
> > >       uint64_t reserve_id;
> > >
> > >       /* TODO: needs a structure for lots of device parameters */
> > > -     uint8_t d_sense;
> > > +     struct lu_phy_attr *attributes;
> >
> > Why do we use a struct lu_phy_attr pointer? Why just can't we do:
> >
> > struct scsi_lu {
> > ...
> >         struct lu_phy_attr attrs;
> > };
> >
> > 'attributes' is too long for me. renamed 'attrs'.
> >
> 
> I used a pointer and malloc(sizeof(struct lu_phy_attrs)) thinking this
> will limit the size of the scsi_lu structure.

What's the point to use a pointer (and reduce the the scsi_lu
structure size) if we always allocate a lu_phy_attr structure for each
scsi_lu?


> I can in-line it with scsi_lu if you like..
> 
> 
> BTW: I am having problem accessing the git repositry via http..
> (git:// blocked from work's firewall)

Sorry, I have no idea. dumping the current your tree and
git-clone might work.


From hare at suse.de  Tue Jun 12 14:44:03 2007
From: hare at suse.de (Hannes Reinecke)
Date: Tue, 12 Jun 2007 14:44:03 +0200
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <20070612213358F.fujita.tomonori@lab.ntt.co.jp>
References: <20070605133826.GA32456@pentland.suse.de>	<20070609171826.GA2582@osc.edu>	<466D6707.9010406@suse.de>
	<20070612213358F.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <466E9513.9030303@suse.de>

FUJITA Tomonori wrote:
> From: Hannes Reinecke <hare at suse.de>
> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> Date: Mon, 11 Jun 2007 17:15:19 +0200
> 
>> Pete Wyckoff wrote:
>>> hare at suse.de wrote on Tue, 05 Jun 2007 15:38 +0200:
>>>> This patch moves the device type down to the LUN structure.
>>>> And in doing so we now also have the proper peripheral device
>>>> type and peripheral device qualifier attributes for the INQUIRY
>>>> data.
>>> Makes sense to me too.
>>>
>>>> One thing puzzles me, though: do we support commands with no
>>>> LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
>>>> If so: where is the point here? If that's our handling of a
>>>> non-existing LUN 0 we should rather add a proper LUN 0 and
>>>> treat cmd->dev == NULL as an error case ...
>>> In the SCSI model, every device must have at least one LUN for
>>> handling REPORT LUNS and a couple other commands.  It is addressed
>>> as LUN 0 or using the "well-known" LUN for the command.  In the stgt
>>> abstraction, though, there is no magic LUN like this.  Instead
>>> things like spc_inqury use cmd->dev == NULL to handle this case.
>>>
>> Ah. Hence.
>>
>>> Perhaps it is reasonable to create a special device for these
>>> commands.  Up in target.c, you could assign cmd->dev to target->dev,
>>> where that is the special device, paralleling the way that
>>> target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
>>> ... else ILLEGAL_REQUEST" clauses can be removed from device code
>>> too.
>>>
>> Well, I actually thought of creating a proper LUN 0 with type 0xc.
> 
> We still need to handle cmd->dev == NULL case though probably we can
> remove cmd->dev == NULL case in device type code.
> 
> I don't have storage systems that work in your way. Is it common?
> 
> 
Yes, quite common. HP and EMC (to name but a few) do it this way.
Most storage arrays actually refuse to attach any devices to LUN0, as
this is a pure management LUN.

I will draft up a patch which creates a proper controller LUN0.

Cheers,

Hannes
-- 
Dr. Hannes Reinecke		      zSeries & Storage
hare at suse.de			      +49 911 74053 688
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
GF: Markus Rex, HRB 16746 (AG N?rnberg)


From fujita.tomonori at lab.ntt.co.jp  Tue Jun 12 14:53:18 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 12 Jun 2007 21:53:18 +0900
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <466E9513.9030303@suse.de>
References: <466D6707.9010406@suse.de>
	<20070612213358F.fujita.tomonori@lab.ntt.co.jp>
	<466E9513.9030303@suse.de>
Message-ID: <20070612215318F.fujita.tomonori@lab.ntt.co.jp>

From: Hannes Reinecke <hare at suse.de>
Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
Date: Tue, 12 Jun 2007 14:44:03 +0200

> FUJITA Tomonori wrote:
> > From: Hannes Reinecke <hare at suse.de>
> > Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> > Date: Mon, 11 Jun 2007 17:15:19 +0200
> > 
> >> Pete Wyckoff wrote:
> >>> hare at suse.de wrote on Tue, 05 Jun 2007 15:38 +0200:
> >>>> This patch moves the device type down to the LUN structure.
> >>>> And in doing so we now also have the proper peripheral device
> >>>> type and peripheral device qualifier attributes for the INQUIRY
> >>>> data.
> >>> Makes sense to me too.
> >>>
> >>>> One thing puzzles me, though: do we support commands with no
> >>>> LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
> >>>> If so: where is the point here? If that's our handling of a
> >>>> non-existing LUN 0 we should rather add a proper LUN 0 and
> >>>> treat cmd->dev == NULL as an error case ...
> >>> In the SCSI model, every device must have at least one LUN for
> >>> handling REPORT LUNS and a couple other commands.  It is addressed
> >>> as LUN 0 or using the "well-known" LUN for the command.  In the stgt
> >>> abstraction, though, there is no magic LUN like this.  Instead
> >>> things like spc_inqury use cmd->dev == NULL to handle this case.
> >>>
> >> Ah. Hence.
> >>
> >>> Perhaps it is reasonable to create a special device for these
> >>> commands.  Up in target.c, you could assign cmd->dev to target->dev,
> >>> where that is the special device, paralleling the way that
> >>> target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
> >>> ... else ILLEGAL_REQUEST" clauses can be removed from device code
> >>> too.
> >>>
> >> Well, I actually thought of creating a proper LUN 0 with type 0xc.
> > 
> > We still need to handle cmd->dev == NULL case though probably we can
> > remove cmd->dev == NULL case in device type code.
> > 
> > I don't have storage systems that work in your way. Is it common?
> > 
> > 
> Yes, quite common. HP and EMC (to name but a few) do it this way.
> Most storage arrays actually refuse to attach any devices to LUN0, as
> this is a pure management LUN.

I see. My IBM systems don't work in that way. But it should work for
everyone if it's common.


> I will draft up a patch which creates a proper controller LUN0.

Thanks. Then we can see how it works.


From markh794 at gmail.com  Wed Jun 13 09:56:14 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 13 Jun 2007 17:56:14 +1000
Subject: [Stgt-devel] [Patch 0/2]
Message-ID: <466FA31E.8000106@gmail.com>

Patch 1 : Add dynamic lu configuration.
Patch 2 : Move lu_phy_attr into scsi_lu structure.

Patch 2 depends on patch 1 being applied first.
It would probably have made more sense to do it the other way around...

Signed-off-by: Mark Harvey <markh794 at gmail.com>



From markh794 at gmail.com  Wed Jun 13 10:01:20 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 13 Jun 2007 18:01:20 +1000
Subject: [Stgt-devel] [Patch 1/2] Add dynamic lu configuration.
Message-ID: <466FA450.2030608@gmail.com>

Ability to configure lu at setup time.
Document extra options passed via tgtadm in doc/README.lu_configuration
Include sample script in scripts/tgt-core-test.

Signed-off-by: Mark Harvey <markh794 at gmail.com>


diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
new file mode 100644
index 0000000..1244bc0
--- /dev/null
+++ b/doc/README.lu_configuration
@@ -0,0 +1,69 @@
+Preface
+--------------
+This show a simple example to set up some logical units (lu).
+Please refer to README.iscsi on instructions to create logical unit(s).
+
+tgtadm options
+--------------
+You are able to modify some logical unit parameters as well as
+modify behaviour of SCSI Sense op code.
+
+NOTE: It is not recommended to change these parameters after the
+target/logical unit has been enabled to accept initiators.
+
+It is currently possible to change/modify the following:
+
+ Vendor Identification
+ Product Identification
+ Product Revision
+ Format of returned 'sense data'
+ Define if the lu is capable of supporting removable media
+ Define/set if the lu is online / offline.
+ Params are passed using the 'tgtadm' utility:
+
+Format of options are:
+ vendor_id="string"
+ product_id="string"
+ product_rev="string"
+ removable=<0|1> - 0 = non-removable, 1 = removable media
+ sense_format=<0|1> - 0 = Clasic sense format, 1 = Support descriptor format
+ online=<0|1> - 0 == Unit offline, 1 == Unit Online
+
+The options are passed to the logical unit via the "--params" switch to tgtadm
+
+e.g.
+tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
+            --params vendor_id=QUANTUM,product_id=HD100,product_rev=0010
+tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
+            --params removable=1,sense_format=1,online=1
+
+Or it can be performed in one go:
+tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
+    --params vendor_id=QUANTUM,product_id=HD100,product_rev=0010,scsi_sn=FRED00,removable=1,sense_format=0,online=1
+
+
+# sg_inq -v /dev/sg5
+    inquiry cdb: 12 00 00 00 24 00
+standard INQUIRY:
+    inquiry cdb: 12 00 00 00 42 00
+  PQual=0  Device_type=0  RMB=1  version=0x05  [SPC-3]
+  [AERC=0]  [TrmTsk=1]  NormACA=0  HiSUP=0  Resp_data_format=2
+  SCCS=0  ACC=0  TGPS=0  3PC=0  Protect=0  BQue=0
+  EncServ=0  MultiP=0  [MChngr=0]  [ACKREQQ=0]  Addr16=0
+  [RelAdr=0]  WBus16=0  Sync=0  Linked=0  [TranDis=0]  CmdQue=1
+  Clocking=0x0  QAS=0  IUS=0
+    length=66 (0x42)   Peripheral device type: disk
+ Vendor identification: QUANTUM
+ Product identification: HD100
+ Product revision level: 0010
+    inquiry cdb: 12 01 00 00 fc 00
+    inquiry: requested 252 bytes but got 7 bytes
+    inquiry cdb: 12 01 80 00 fc 00
+    inquiry: requested 252 bytes but got 12 bytes
+ Unit serial number: FRED00
+
+As can be seen from above 'sg_inq' output, the RMB (removable) bit is set to 1.
+The Unit serial number page updated with 'FRED00'
+
+Please refer to scripts/tgt-core-test for a working example.
+
diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
new file mode 100755
index 0000000..1bbb404
--- /dev/null
+++ b/scripts/tgt-core-test
@@ -0,0 +1,76 @@
+#!/bin/bash
+
+# Parent directory for data files..
+HOME=/d/01
+
+P=`ps -ef|grep -v grep|grep tgtd|wc -l`
+if [ "X"$P == "X0" ]; then
+	tgtd -d 1
+	sleep 1
+fi
+
+if [ ! -d $HOME ]; then
+	mkdir -p $HOME
+fi
+
+if [ ! -f $HOME/hd_block ]; then
+	dd if=/dev/zero of=$HOME/hd_block bs=1M count=8
+fi
+if [ ! -f $HOME/cd_block0 ]; then
+	dd if=/dev/zero of=$HOME/cd_block0 bs=1M count=8
+fi
+if [ ! -f $HOME/cd_block1 ]; then
+	dd if=/dev/zero of=$HOME/cd_block1 bs=1M count=8
+fi
+if [ ! -f $HOME/cd_block2 ]; then
+	dd if=/dev/zero of=$HOME/cd_block2 bs=1M count=8
+fi
+
+set -x
+
+###################################################################################
+# Set up SBC HDD device
+###################################################################################
+TID=1
+
+tgtadm --lld iscsi --mode target --op new --tid $TID \
+		-T iqn.2007-03:marks-vtl_sbc:`hostname` --target-type disk
+
+sleep 1
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b $HOME/hd_block
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 --params scsi_sn=FRED00,scsi_id=Fred
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
+	--params vendor_id=QUANTUM,product_id=HD100,product_rev=0010,removable=1,sense_format=0
+
+
+tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
+
+
+###################################################################################
+# Set up MMC CD/DVD device
+###################################################################################
+TID=2
+
+tgtadm --lld iscsi --mode target --op new --tid $TID \
+		-T iqn.2007-03:marks-vtl_mmc:`hostname` --target-type cd
+
+sleep 1
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b $HOME/cd_block0
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
+	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY10,removable=1
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 1 -b $HOME/cd_block1
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 1 \
+	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY11,removable=1
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 2 -b $HOME/cd_block2
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 2 \
+	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY12,removable=1
+
+tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
+
+tgtadm --lld iscsi --mode target --op show
+
+
diff --git a/usr/spc.c b/usr/spc.c
index 99a7df3..b9f4e16 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -64,7 +64,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 		uint16_t *desc;
 
 		data[0] = device_type;
-		data[1] = (cmd->dev->attrs->is_removable) ? 0x80 : 0;
+		data[1] = (cmd->dev->attrs->removable) ? 0x80 : 0;
 		data[2] = 5;	/* SPC-3 */
 		data[3] = 0x42;
 		data[7] = 0x02;
@@ -286,18 +286,29 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 }
 
 enum {
-	Opt_scsiid, Opt_scsisn, Opt_err,
+	Opt_scsiid, Opt_scsisn,
+	Opt_vendorid, Opt_productid,
+	Opt_productrev, Opt_sense_format,
+	Opt_removable, Opt_online,
+	Opt_err,
 };
 
 static match_table_t tokens = {
 	{Opt_scsiid, "scsi_id=%s"},
 	{Opt_scsisn, "scsi_sn=%s"},
+	{Opt_vendorid, "vendor_id=%s"},
+	{Opt_productid, "product_id=%s"},
+	{Opt_productrev, "product_rev=%s"},
+	{Opt_sense_format, "sense_format=%s"},
+	{Opt_removable, "removable=%s"},
+	{Opt_online, "online=%s"},
 	{Opt_err, NULL},
 };
 
 int spc_lu_config(struct scsi_lu *lu, char *params) {
 	int err = 0;
 	char *p;
+	char buf[20];
 
 	if (!strncmp("targetOps", params, 9))
 		params = params + 10;
@@ -318,6 +329,30 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			match_strncpy(lu->attrs->scsi_sn, &args[0],
 				      sizeof(lu->attrs->scsi_sn) - 1);
 			break;
+		case Opt_vendorid:
+			match_strncpy(lu->attrs->vendor_id, &args[0],
+					sizeof(lu->attrs->vendor_id));
+			break;
+		case Opt_productid:
+			match_strncpy(lu->attrs->product_id, &args[0],
+					sizeof(lu->attrs->product_id));
+			break;
+		case Opt_productrev:
+			match_strncpy(lu->attrs->product_rev, &args[0],
+					sizeof(lu->attrs->product_rev));
+			break;
+		case Opt_sense_format:
+			match_strncpy(buf, &args[0],  sizeof(buf));
+			lu->attrs->sense_format = atoi(buf);
+			break;
+		case Opt_removable:
+			match_strncpy(buf, &args[0],  sizeof(buf));
+			lu->attrs->removable = atoi(buf);
+			break;
+		case Opt_online:
+			match_strncpy(buf, &args[0],  sizeof(buf));
+			lu->attrs->online = atoi(buf);
+			break;
 		default:
 			err = TGTADM_INVALID_REQUEST;
 		}
@@ -333,7 +368,7 @@ int spc_lu_init(struct scsi_lu *lu)
 
 	memcpy(lu->attrs->vendor_id, VENDOR_ID, 8);
 	memcpy(lu->attrs->product_rev, "0001", 4);
-	lu->attrs->is_removable = 0;
+	lu->attrs->removable = 0;
 	lu->attrs->sense_format = 0;
 	lu->attrs->online = 0;
 	lu->attrs->reset = 1;
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 7b64655..35645b1 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -40,7 +40,7 @@ struct lu_phy_attr {
 	char product_rev[5];
 	uint16_t version_desc[VERSION_DESCRIPTOR_LEN];
 
-	char is_removable;	/* Removable media */
+	char removable;		/* Removable media */
 	char online;		/* Logical Unit online ? */
 	char reset;		/* Power-on or reset has occured */
 	char sense_format;	/* Descrptor format sense data supported */





From markh794 at gmail.com  Wed Jun 13 10:04:31 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 13 Jun 2007 18:04:31 +1000
Subject: [Stgt-devel] [Patch 2/2] Move lu_phy_attr struct into scsi_lu
	struct.
Message-ID: <466FA50F.6020604@gmail.com>

Re-arrange lu_phy_attr structure into scsi_lu struct.

Signed-off-by: Mark Harvey <markh794 at gmail.com>

diff --git a/usr/mmc.c b/usr/mmc.c
index a8aced5..0ac5f72 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -126,11 +126,11 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
-	memcpy(lu->attrs->product_id, "VIRTUAL-CDROM", 16);
-	lu->attrs->sense_format = 0;
-	lu->attrs->version_desc[0] = 0x02A0; /* MMC3, no version claimed */
-	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
-	lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
+	memcpy(lu->attrs.product_id, "VIRTUAL-CDROM", 16);
+	lu->attrs.sense_format = 0;
+	lu->attrs.version_desc[0] = 0x02A0; /* MMC3, no version claimed */
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
 	return 0;
 }
diff --git a/usr/osd.c b/usr/osd.c
index ac33168..33d6455 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -56,11 +56,11 @@ static int osd_lu_init(struct scsi_lu *lu)
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
-	memcpy(lu->attrs->product_id, "OSD", 16);
-	lu->attrs->sense_format = 1;
-	lu->attrs->version_desc[0] = 0x0340; /* OSD */
-	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
-	lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
+	memcpy(lu->attrs.product_id, "OSD", 16);
+	lu->attrs.sense_format = 1;
+	lu->attrs.version_desc[0] = 0x0340; /* OSD */
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
 	return 0;
 }
diff --git a/usr/sbc.c b/usr/sbc.c
index 2924cc6..8fe39e7 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -342,10 +342,10 @@ static int sbc_lu_init(struct scsi_lu *lu)
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
-	memcpy(lu->attrs->product_id, "VIRTUAL-DISK", 16);
-	lu->attrs->version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
-	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
-	lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
+	memcpy(lu->attrs.product_id, "VIRTUAL-DISK", 16);
+	lu->attrs.version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
 	return 0;
 }
diff --git a/usr/scsi.c b/usr/scsi.c
index 50e2080..c9fb7b6 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -40,7 +40,7 @@
 
 void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
 {
-	if (cmd->dev && cmd->dev->attrs->sense_format) {
+	if (cmd->dev && cmd->dev->attrs.sense_format) {
 		/* descriptor format */
 
 		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
diff --git a/usr/spc.c b/usr/spc.c
index b9f4e16..bf30a16 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -64,19 +64,19 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 		uint16_t *desc;
 
 		data[0] = device_type;
-		data[1] = (cmd->dev->attrs->removable) ? 0x80 : 0;
+		data[1] = (cmd->dev->attrs.removable) ? 0x80 : 0;
 		data[2] = 5;	/* SPC-3 */
 		data[3] = 0x42;
 		data[7] = 0x02;
 
 		memset(data + 8, 0x20, 28);
-		strncpy((char *)data + 8, cmd->dev->attrs->vendor_id, 8);
-		strncpy((char *)data + 16, cmd->dev->attrs->product_id, 16);
-		strncpy((char *)data + 32, cmd->dev->attrs->product_rev, 4);
+		strncpy((char *)data + 8, cmd->dev->attrs.vendor_id, 8);
+		strncpy((char *)data + 16, cmd->dev->attrs.product_id, 16);
+		strncpy((char *)data + 32, cmd->dev->attrs.product_rev, 4);
 
 		desc = (uint16_t *)(data + 58);
-		for (i = 0; i < ARRAY_SIZE(cmd->dev->attrs->version_desc); i++)
-			*desc++ = __cpu_to_be16(cmd->dev->attrs->version_desc[i]);
+		for (i = 0; i < ARRAY_SIZE(cmd->dev->attrs.version_desc); i++)
+			*desc++ = __cpu_to_be16(cmd->dev->attrs.version_desc[i]);
 
 		len = 66;
 		data[4] = len - 5;	/* Additional Length */
@@ -108,12 +108,12 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 			len = 4 + SCSI_SN_LEN;
 			ret = SAM_STAT_GOOD;
 
-			if (cmd->dev && strlen(cmd->dev->attrs->scsi_sn)) {
+			if (cmd->dev && strlen(cmd->dev->attrs.scsi_sn)) {
 				uint8_t *p;
 				char *q;
 
 				p = data + 4 + tmp - 1;
-				q = cmd->dev->attrs->scsi_sn + SCSI_SN_LEN - 1;
+				q = cmd->dev->attrs.scsi_sn + SCSI_SN_LEN - 1;
 				for (; tmp > 0; tmp--, q)
 					*(p--) = *(q--);
 			}
@@ -127,7 +127,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 			data[7] = tmp;
 			if (cmd->dev)
 				strncpy((char *) data + 8,
-					cmd->dev->attrs->scsi_id, SCSI_ID_LEN);
+					cmd->dev->attrs.scsi_id, SCSI_ID_LEN);
 
 			len = tmp + 8;
 			ret = SAM_STAT_GOOD;
@@ -322,36 +322,36 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_scsiid:
-			match_strncpy(lu->attrs->scsi_id, &args[0],
-				      sizeof(lu->attrs->scsi_id) - 1);
+			match_strncpy(lu->attrs.scsi_id, &args[0],
+				      sizeof(lu->attrs.scsi_id) - 1);
 			break;
 		case Opt_scsisn:
-			match_strncpy(lu->attrs->scsi_sn, &args[0],
-				      sizeof(lu->attrs->scsi_sn) - 1);
+			match_strncpy(lu->attrs.scsi_sn, &args[0],
+				      sizeof(lu->attrs.scsi_sn) - 1);
 			break;
 		case Opt_vendorid:
-			match_strncpy(lu->attrs->vendor_id, &args[0],
-					sizeof(lu->attrs->vendor_id));
+			match_strncpy(lu->attrs.vendor_id, &args[0],
+					sizeof(lu->attrs.vendor_id));
 			break;
 		case Opt_productid:
-			match_strncpy(lu->attrs->product_id, &args[0],
-					sizeof(lu->attrs->product_id));
+			match_strncpy(lu->attrs.product_id, &args[0],
+					sizeof(lu->attrs.product_id));
 			break;
 		case Opt_productrev:
-			match_strncpy(lu->attrs->product_rev, &args[0],
-					sizeof(lu->attrs->product_rev));
+			match_strncpy(lu->attrs.product_rev, &args[0],
+					sizeof(lu->attrs.product_rev));
 			break;
 		case Opt_sense_format:
 			match_strncpy(buf, &args[0],  sizeof(buf));
-			lu->attrs->sense_format = atoi(buf);
+			lu->attrs.sense_format = atoi(buf);
 			break;
 		case Opt_removable:
 			match_strncpy(buf, &args[0],  sizeof(buf));
-			lu->attrs->removable = atoi(buf);
+			lu->attrs.removable = atoi(buf);
 			break;
 		case Opt_online:
 			match_strncpy(buf, &args[0],  sizeof(buf));
-			lu->attrs->online = atoi(buf);
+			lu->attrs.online = atoi(buf);
 			break;
 		default:
 			err = TGTADM_INVALID_REQUEST;
@@ -362,16 +362,12 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 
 int spc_lu_init(struct scsi_lu *lu)
 {
-	lu->attrs = zalloc(sizeof(struct lu_phy_attr));
-	if (!lu->attrs)
-		return -ENOMEM;
-
-	memcpy(lu->attrs->vendor_id, VENDOR_ID, 8);
-	memcpy(lu->attrs->product_rev, "0001", 4);
-	lu->attrs->removable = 0;
-	lu->attrs->sense_format = 0;
-	lu->attrs->online = 0;
-	lu->attrs->reset = 1;
+	memcpy(lu->attrs.vendor_id, VENDOR_ID, 8);
+	memcpy(lu->attrs.product_rev, "0001", 4);
+	lu->attrs.removable = 0;
+	lu->attrs.sense_format = 0;
+	lu->attrs.online = 0;
+	lu->attrs.reset = 1;
 
 	return 0;
 }
diff --git a/usr/target.c b/usr/target.c
index 5b74be1..9170310 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -252,9 +252,9 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
 		err = target->dev_type_template.lu_init(lu);
 
 	if (!err) {
-		snprintf(lu->attrs->scsi_id, sizeof(lu->attrs->scsi_id),
+		snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
 			 "deadbeaf%d:%" PRIu64, tid, lun);
-		snprintf(lu->attrs->scsi_sn, sizeof(lu->attrs->scsi_sn),
+		snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
 			 "beaf%d%" PRIu64, tid, lun);
 	}
 
@@ -1126,8 +1126,8 @@ int tgt_target_show_all(char *buf, int rest)
 				 _TAB3 "Size: %s\n"
 				 _TAB3 "Backing store: %s\n",
 				 lu->lun,
-				 lu->attrs->scsi_id,
-				 lu->attrs->scsi_sn,
+				 lu->attrs.scsi_id,
+				 lu->attrs.scsi_sn,
 				 print_disksize(lu->size),
 				 lu->path);
 
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 35645b1..addd5a0 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -63,7 +63,7 @@ struct scsi_lu {
 	uint64_t reserve_id;
 
 	/* TODO: needs a structure for lots of device parameters */
-	struct lu_phy_attr *attrs;
+	struct lu_phy_attr attrs;
 };
 
 struct scsi_cmd {





From blackmagic02881 at gmail.com  Wed Jun 13 15:48:21 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 13 Jun 2007 09:48:21 -0400
Subject: [Stgt-devel] [Patch 2/2] Move lu_phy_attr struct into
	scsi_lu	struct.
In-Reply-To: <466FA50F.6020604@gmail.com>
References: <466FA50F.6020604@gmail.com>
Message-ID: <1181742501.3852.7.camel@ibrix05.ibrix.com>

On Wed, 2007-06-13 at 18:04 +1000, Mark Harvey wrote:
> Re-arrange lu_phy_attr structure into scsi_lu struct.
> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>
> 
> diff --git a/usr/mmc.c b/usr/mmc.c
> index a8aced5..0ac5f72 100644
> --- a/usr/mmc.c
> +++ b/usr/mmc.c
> @@ -126,11 +126,11 @@ static int mmc_lu_init(struct scsi_lu *lu)
>  	if (spc_lu_init(lu))
>  		return -ENOMEM;
>  
> -	memcpy(lu->attrs->product_id, "VIRTUAL-CDROM", 16);
> -	lu->attrs->sense_format = 0;
> -	lu->attrs->version_desc[0] = 0x02A0; /* MMC3, no version claimed */
> -	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
> -	lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
> +	memcpy(lu->attrs.product_id, "VIRTUAL-CDROM", 16);

access the memory over boundary. strncpy is better.


> +	lu->attrs.sense_format = 0;
> +	lu->attrs.version_desc[0] = 0x02A0; /* MMC3, no version claimed */
> +	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
> +	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
>  
>  	return 0;
>  }
> diff --git a/usr/osd.c b/usr/osd.c
> index ac33168..33d6455 100644
> --- a/usr/osd.c
> +++ b/usr/osd.c
> @@ -56,11 +56,11 @@ static int osd_lu_init(struct scsi_lu *lu)
>  	if (spc_lu_init(lu))
>  		return -ENOMEM;
>  
> -	memcpy(lu->attrs->product_id, "OSD", 16);
> -	lu->attrs->sense_format = 1;
> -	lu->attrs->version_desc[0] = 0x0340; /* OSD */
> -	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
> -	lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
> +	memcpy(lu->attrs.product_id, "OSD", 16);
> +	lu->attrs.sense_format = 1;
> +	lu->attrs.version_desc[0] = 0x0340; /* OSD */
> +	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
> +	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
>  
>  	return 0;
>  }
> diff --git a/usr/sbc.c b/usr/sbc.c
> index 2924cc6..8fe39e7 100644
> --- a/usr/sbc.c
> +++ b/usr/sbc.c
> @@ -342,10 +342,10 @@ static int sbc_lu_init(struct scsi_lu *lu)
>  	if (spc_lu_init(lu))
>  		return -ENOMEM;
>  
> -	memcpy(lu->attrs->product_id, "VIRTUAL-DISK", 16);
> -	lu->attrs->version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
> -	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
> -	lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
> +	memcpy(lu->attrs.product_id, "VIRTUAL-DISK", 16);
> +	lu->attrs.version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
> +	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
> +	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
>  
>  	return 0;
>  }
> diff --git a/usr/scsi.c b/usr/scsi.c
> index 50e2080..c9fb7b6 100644
> --- a/usr/scsi.c
> +++ b/usr/scsi.c
> @@ -40,7 +40,7 @@
>  
>  void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
>  {
> -	if (cmd->dev && cmd->dev->attrs->sense_format) {
> +	if (cmd->dev && cmd->dev->attrs.sense_format) {
>  		/* descriptor format */
>  
>  		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
> diff --git a/usr/spc.c b/usr/spc.c
> index b9f4e16..bf30a16 100644
> --- a/usr/spc.c
> +++ b/usr/spc.c
> @@ -64,19 +64,19 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  		uint16_t *desc;
>  
>  		data[0] = device_type;
> -		data[1] = (cmd->dev->attrs->removable) ? 0x80 : 0;
> +		data[1] = (cmd->dev->attrs.removable) ? 0x80 : 0;
>  		data[2] = 5;	/* SPC-3 */
>  		data[3] = 0x42;
>  		data[7] = 0x02;
>  
>  		memset(data + 8, 0x20, 28);
> -		strncpy((char *)data + 8, cmd->dev->attrs->vendor_id, 8);
> -		strncpy((char *)data + 16, cmd->dev->attrs->product_id, 16);
> -		strncpy((char *)data + 32, cmd->dev->attrs->product_rev, 4);
> +		strncpy((char *)data + 8, cmd->dev->attrs.vendor_id, 8);
> +		strncpy((char *)data + 16, cmd->dev->attrs.product_id, 16);
> +		strncpy((char *)data + 32, cmd->dev->attrs.product_rev, 4);
>  
>  		desc = (uint16_t *)(data + 58);
> -		for (i = 0; i < ARRAY_SIZE(cmd->dev->attrs->version_desc); i++)
> -			*desc++ = __cpu_to_be16(cmd->dev->attrs->version_desc[i]);
> +		for (i = 0; i < ARRAY_SIZE(cmd->dev->attrs.version_desc); i++)
> +			*desc++ = __cpu_to_be16(cmd->dev->attrs.version_desc[i]);
>  
>  		len = 66;
>  		data[4] = len - 5;	/* Additional Length */
> @@ -108,12 +108,12 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  			len = 4 + SCSI_SN_LEN;
>  			ret = SAM_STAT_GOOD;
>  
> -			if (cmd->dev && strlen(cmd->dev->attrs->scsi_sn)) {
> +			if (cmd->dev && strlen(cmd->dev->attrs.scsi_sn)) {
>  				uint8_t *p;
>  				char *q;
>  
>  				p = data + 4 + tmp - 1;
> -				q = cmd->dev->attrs->scsi_sn + SCSI_SN_LEN - 1;
> +				q = cmd->dev->attrs.scsi_sn + SCSI_SN_LEN - 1;
>  				for (; tmp > 0; tmp--, q)
>  					*(p--) = *(q--);
>  			}
> @@ -127,7 +127,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>  			data[7] = tmp;
>  			if (cmd->dev)
>  				strncpy((char *) data + 8,
> -					cmd->dev->attrs->scsi_id, SCSI_ID_LEN);
> +					cmd->dev->attrs.scsi_id, SCSI_ID_LEN);
>  
>  			len = tmp + 8;
>  			ret = SAM_STAT_GOOD;
> @@ -322,36 +322,36 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
>  		token = match_token(p, tokens, args);
>  		switch (token) {
>  		case Opt_scsiid:
> -			match_strncpy(lu->attrs->scsi_id, &args[0],
> -				      sizeof(lu->attrs->scsi_id) - 1);
> +			match_strncpy(lu->attrs.scsi_id, &args[0],
> +				      sizeof(lu->attrs.scsi_id) - 1);
>  			break;
>  		case Opt_scsisn:
> -			match_strncpy(lu->attrs->scsi_sn, &args[0],
> -				      sizeof(lu->attrs->scsi_sn) - 1);
> +			match_strncpy(lu->attrs.scsi_sn, &args[0],
> +				      sizeof(lu->attrs.scsi_sn) - 1);
>  			break;
>  		case Opt_vendorid:
> -			match_strncpy(lu->attrs->vendor_id, &args[0],
> -					sizeof(lu->attrs->vendor_id));
> +			match_strncpy(lu->attrs.vendor_id, &args[0],
> +					sizeof(lu->attrs.vendor_id));
>  			break;
>  		case Opt_productid:
> -			match_strncpy(lu->attrs->product_id, &args[0],
> -					sizeof(lu->attrs->product_id));
> +			match_strncpy(lu->attrs.product_id, &args[0],
> +					sizeof(lu->attrs.product_id));
>  			break;
>  		case Opt_productrev:
> -			match_strncpy(lu->attrs->product_rev, &args[0],
> -					sizeof(lu->attrs->product_rev));
> +			match_strncpy(lu->attrs.product_rev, &args[0],
> +					sizeof(lu->attrs.product_rev));
>  			break;
>  		case Opt_sense_format:
>  			match_strncpy(buf, &args[0],  sizeof(buf));
> -			lu->attrs->sense_format = atoi(buf);
> +			lu->attrs.sense_format = atoi(buf);
>  			break;
>  		case Opt_removable:
>  			match_strncpy(buf, &args[0],  sizeof(buf));
> -			lu->attrs->removable = atoi(buf);
> +			lu->attrs.removable = atoi(buf);
>  			break;
>  		case Opt_online:
>  			match_strncpy(buf, &args[0],  sizeof(buf));
> -			lu->attrs->online = atoi(buf);
> +			lu->attrs.online = atoi(buf);
>  			break;
>  		default:
>  			err = TGTADM_INVALID_REQUEST;
> @@ -362,16 +362,12 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
>  
>  int spc_lu_init(struct scsi_lu *lu)
>  {
> -	lu->attrs = zalloc(sizeof(struct lu_phy_attr));
> -	if (!lu->attrs)
> -		return -ENOMEM;
> -
> -	memcpy(lu->attrs->vendor_id, VENDOR_ID, 8);
> -	memcpy(lu->attrs->product_rev, "0001", 4);
> -	lu->attrs->removable = 0;
> -	lu->attrs->sense_format = 0;
> -	lu->attrs->online = 0;
> -	lu->attrs->reset = 1;
> +	memcpy(lu->attrs.vendor_id, VENDOR_ID, 8);
> +	memcpy(lu->attrs.product_rev, "0001", 4);
> +	lu->attrs.removable = 0;
> +	lu->attrs.sense_format = 0;
> +	lu->attrs.online = 0;
> +	lu->attrs.reset = 1;
>  
>  	return 0;
>  }
> diff --git a/usr/target.c b/usr/target.c
> index 5b74be1..9170310 100644
> --- a/usr/target.c
> +++ b/usr/target.c
> @@ -252,9 +252,9 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
>  		err = target->dev_type_template.lu_init(lu);
>  
>  	if (!err) {
> -		snprintf(lu->attrs->scsi_id, sizeof(lu->attrs->scsi_id),
> +		snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
>  			 "deadbeaf%d:%" PRIu64, tid, lun);
> -		snprintf(lu->attrs->scsi_sn, sizeof(lu->attrs->scsi_sn),
> +		snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
>  			 "beaf%d%" PRIu64, tid, lun);
>  	}
>  
> @@ -1126,8 +1126,8 @@ int tgt_target_show_all(char *buf, int rest)
>  				 _TAB3 "Size: %s\n"
>  				 _TAB3 "Backing store: %s\n",
>  				 lu->lun,
> -				 lu->attrs->scsi_id,
> -				 lu->attrs->scsi_sn,
> +				 lu->attrs.scsi_id,
> +				 lu->attrs.scsi_sn,
>  				 print_disksize(lu->size),
>  				 lu->path);
>  
> diff --git a/usr/tgtd.h b/usr/tgtd.h
> index 35645b1..addd5a0 100644
> --- a/usr/tgtd.h
> +++ b/usr/tgtd.h
> @@ -63,7 +63,7 @@ struct scsi_lu {
>  	uint64_t reserve_id;
>  
>  	/* TODO: needs a structure for lots of device parameters */
> -	struct lu_phy_attr *attrs;
> +	struct lu_phy_attr attrs;
>  };
>  
>  struct scsi_cmd {
> 
> 
> 
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From markh794 at gmail.com  Thu Jun 14 06:06:12 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 14 Jun 2007 14:06:12 +1000
Subject: [Stgt-devel] [Patch 2/2] Move lu_phy_attr struct into scsi_lu
	struct.
In-Reply-To: <1181742501.3852.7.camel@ibrix05.ibrix.com>
References: <466FA50F.6020604@gmail.com>
	<1181742501.3852.7.camel@ibrix05.ibrix.com>
Message-ID: <f29db9a80706132106k2298e6e8n568cb8ed18eb8dd8@mail.gmail.com>

On 6/13/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> On Wed, 2007-06-13 at 18:04 +1000, Mark Harvey wrote:
> > Re-arrange lu_phy_attr structure into scsi_lu struct.
> >
> > Signed-off-by: Mark Harvey <markh794 at gmail.com>
> >
> > diff --git a/usr/mmc.c b/usr/mmc.c
> > index a8aced5..0ac5f72 100644
> > --- a/usr/mmc.c
> > +++ b/usr/mmc.c
> > @@ -126,11 +126,11 @@ static int mmc_lu_init(struct scsi_lu *lu)
> >       if (spc_lu_init(lu))
> >               return -ENOMEM;
> >
> > -     memcpy(lu->attrs->product_id, "VIRTUAL-CDROM", 16);
> > -     lu->attrs->sense_format = 0;
> > -     lu->attrs->version_desc[0] = 0x02A0; /* MMC3, no version claimed */
> > -     lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
> > -     lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
> > +     memcpy(lu->attrs.product_id, "VIRTUAL-CDROM", 16);
>
> access the memory over boundary. strncpy is better.

Cheers.

I'll get a patch together to fix very soon.

Mark Harvey


From markh794 at gmail.com  Thu Jun 14 10:25:15 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 14 Jun 2007 18:25:15 +1000
Subject: [Stgt-devel] [Patch] Merge lu_phy_attr struct into scsi_lu struct
Message-ID: <4670FB6B.6020906@gmail.com>

Re-work previous [Patch 2/2]


>From ddd8aa4cdb2696f07c793b96d7e86ce002c7a4db Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Thu, 14 Jun 2007 17:00:44 +1000
Subject: Merge lu_phy_attr struct into scsi_lu struct

No advantage of having the lu_phy_attr structure. Moved all
fields into the scsi_lu structure.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/mmc.c    |   10 ++++----
 usr/osd.c    |   10 ++++----
 usr/sbc.c    |    8 +++---
 usr/scsi.c   |    2 +-
 usr/spc.c    |   60 +++++++++++++++++++++++++++------------------------------
 usr/target.c |    8 +++---
 usr/tgtd.h   |   17 ++++++---------
 7 files changed, 54 insertions(+), 61 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index a8aced5..79db47c 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -126,11 +126,11 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
-	memcpy(lu->attrs->product_id, "VIRTUAL-CDROM", 16);
-	lu->attrs->sense_format = 0;
-	lu->attrs->version_desc[0] = 0x02A0; /* MMC3, no version claimed */
-	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
-	lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
+	strncpy(lu->product_id, "VIRTUAL-CDROM", sizeof(lu->product_id) - 1);
+	lu->sense_format = 0;
+	lu->version_desc[0] = 0x02A0; /* MMC3, no version claimed */
+	lu->version_desc[1] = 0x0960; /* iSCSI */
+	lu->version_desc[2] = 0x0300; /* SPC-3 */
 
 	return 0;
 }
diff --git a/usr/osd.c b/usr/osd.c
index ac33168..8af72f3 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -56,11 +56,11 @@ static int osd_lu_init(struct scsi_lu *lu)
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
-	memcpy(lu->attrs->product_id, "OSD", 16);
-	lu->attrs->sense_format = 1;
-	lu->attrs->version_desc[0] = 0x0340; /* OSD */
-	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
-	lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
+	strncpy(lu->product_id, "OSD", sizeof(lu->product_id) - 1);
+	lu->sense_format = 1;
+	lu->version_desc[0] = 0x0340; /* OSD */
+	lu->version_desc[1] = 0x0960; /* iSCSI */
+	lu->version_desc[2] = 0x0300; /* SPC-3 */
 
 	return 0;
 }
diff --git a/usr/sbc.c b/usr/sbc.c
index 2924cc6..c172e8f 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -342,10 +342,10 @@ static int sbc_lu_init(struct scsi_lu *lu)
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
-	memcpy(lu->attrs->product_id, "VIRTUAL-DISK", 16);
-	lu->attrs->version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
-	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
-	lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
+	strncpy(lu->product_id, "VIRTUAL-DISK", sizeof(lu->product_id) - 1);
+	lu->version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
+	lu->version_desc[1] = 0x0960; /* iSCSI */
+	lu->version_desc[2] = 0x0300; /* SPC-3 */
 
 	return 0;
 }
diff --git a/usr/scsi.c b/usr/scsi.c
index 50e2080..ebd7067 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -40,7 +40,7 @@
 
 void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
 {
-	if (cmd->dev && cmd->dev->attrs->sense_format) {
+	if (cmd->dev && cmd->dev->sense_format) {
 		/* descriptor format */
 
 		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
diff --git a/usr/spc.c b/usr/spc.c
index b9f4e16..2aefd4d 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -64,19 +64,19 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 		uint16_t *desc;
 
 		data[0] = device_type;
-		data[1] = (cmd->dev->attrs->removable) ? 0x80 : 0;
+		data[1] = (cmd->dev->removable) ? 0x80 : 0;
 		data[2] = 5;	/* SPC-3 */
 		data[3] = 0x42;
 		data[7] = 0x02;
 
 		memset(data + 8, 0x20, 28);
-		strncpy((char *)data + 8, cmd->dev->attrs->vendor_id, 8);
-		strncpy((char *)data + 16, cmd->dev->attrs->product_id, 16);
-		strncpy((char *)data + 32, cmd->dev->attrs->product_rev, 4);
+		strncpy((char *)data + 8, cmd->dev->vendor_id, 8);
+		strncpy((char *)data + 16, cmd->dev->product_id, 16);
+		strncpy((char *)data + 32, cmd->dev->product_rev, 4);
 
 		desc = (uint16_t *)(data + 58);
-		for (i = 0; i < ARRAY_SIZE(cmd->dev->attrs->version_desc); i++)
-			*desc++ = __cpu_to_be16(cmd->dev->attrs->version_desc[i]);
+		for (i = 0; i < ARRAY_SIZE(cmd->dev->version_desc); i++)
+			*desc++ = __cpu_to_be16(cmd->dev->version_desc[i]);
 
 		len = 66;
 		data[4] = len - 5;	/* Additional Length */
@@ -108,12 +108,12 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 			len = 4 + SCSI_SN_LEN;
 			ret = SAM_STAT_GOOD;
 
-			if (cmd->dev && strlen(cmd->dev->attrs->scsi_sn)) {
+			if (cmd->dev && strlen(cmd->dev->scsi_sn)) {
 				uint8_t *p;
 				char *q;
 
 				p = data + 4 + tmp - 1;
-				q = cmd->dev->attrs->scsi_sn + SCSI_SN_LEN - 1;
+				q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
 				for (; tmp > 0; tmp--, q)
 					*(p--) = *(q--);
 			}
@@ -127,7 +127,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 			data[7] = tmp;
 			if (cmd->dev)
 				strncpy((char *) data + 8,
-					cmd->dev->attrs->scsi_id, SCSI_ID_LEN);
+					cmd->dev->scsi_id, SCSI_ID_LEN);
 
 			len = tmp + 8;
 			ret = SAM_STAT_GOOD;
@@ -322,36 +322,36 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_scsiid:
-			match_strncpy(lu->attrs->scsi_id, &args[0],
-				      sizeof(lu->attrs->scsi_id) - 1);
+			match_strncpy(lu->scsi_id, &args[0],
+				      sizeof(lu->scsi_id) - 1);
 			break;
 		case Opt_scsisn:
-			match_strncpy(lu->attrs->scsi_sn, &args[0],
-				      sizeof(lu->attrs->scsi_sn) - 1);
+			match_strncpy(lu->scsi_sn, &args[0],
+				      sizeof(lu->scsi_sn) - 1);
 			break;
 		case Opt_vendorid:
-			match_strncpy(lu->attrs->vendor_id, &args[0],
-					sizeof(lu->attrs->vendor_id));
+			match_strncpy(lu->vendor_id, &args[0],
+					sizeof(lu->vendor_id));
 			break;
 		case Opt_productid:
-			match_strncpy(lu->attrs->product_id, &args[0],
-					sizeof(lu->attrs->product_id));
+			match_strncpy(lu->product_id, &args[0],
+					sizeof(lu->product_id));
 			break;
 		case Opt_productrev:
-			match_strncpy(lu->attrs->product_rev, &args[0],
-					sizeof(lu->attrs->product_rev));
+			match_strncpy(lu->product_rev, &args[0],
+					sizeof(lu->product_rev));
 			break;
 		case Opt_sense_format:
 			match_strncpy(buf, &args[0],  sizeof(buf));
-			lu->attrs->sense_format = atoi(buf);
+			lu->sense_format = atoi(buf);
 			break;
 		case Opt_removable:
 			match_strncpy(buf, &args[0],  sizeof(buf));
-			lu->attrs->removable = atoi(buf);
+			lu->removable = atoi(buf);
 			break;
 		case Opt_online:
 			match_strncpy(buf, &args[0],  sizeof(buf));
-			lu->attrs->online = atoi(buf);
+			lu->online = atoi(buf);
 			break;
 		default:
 			err = TGTADM_INVALID_REQUEST;
@@ -362,16 +362,12 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 
 int spc_lu_init(struct scsi_lu *lu)
 {
-	lu->attrs = zalloc(sizeof(struct lu_phy_attr));
-	if (!lu->attrs)
-		return -ENOMEM;
-
-	memcpy(lu->attrs->vendor_id, VENDOR_ID, 8);
-	memcpy(lu->attrs->product_rev, "0001", 4);
-	lu->attrs->removable = 0;
-	lu->attrs->sense_format = 0;
-	lu->attrs->online = 0;
-	lu->attrs->reset = 1;
+	memcpy(lu->vendor_id, VENDOR_ID, 8);
+	memcpy(lu->product_rev, "0001", 4);
+	lu->removable = 0;
+	lu->sense_format = 0;
+	lu->online = 0;
+	lu->reset = 1;
 
 	return 0;
 }
diff --git a/usr/target.c b/usr/target.c
index 5b74be1..2474f5a 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -252,9 +252,9 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
 		err = target->dev_type_template.lu_init(lu);
 
 	if (!err) {
-		snprintf(lu->attrs->scsi_id, sizeof(lu->attrs->scsi_id),
+		snprintf(lu->scsi_id, sizeof(lu->scsi_id),
 			 "deadbeaf%d:%" PRIu64, tid, lun);
-		snprintf(lu->attrs->scsi_sn, sizeof(lu->attrs->scsi_sn),
+		snprintf(lu->scsi_sn, sizeof(lu->scsi_sn),
 			 "beaf%d%" PRIu64, tid, lun);
 	}
 
@@ -1126,8 +1126,8 @@ int tgt_target_show_all(char *buf, int rest)
 				 _TAB3 "Size: %s\n"
 				 _TAB3 "Backing store: %s\n",
 				 lu->lun,
-				 lu->attrs->scsi_id,
-				 lu->attrs->scsi_sn,
+				 lu->scsi_id,
+				 lu->scsi_sn,
 				 print_disksize(lu->size),
 				 lu->path);
 
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 35645b1..a4c787b 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -30,7 +30,13 @@ struct tgt_cmd_queue {
 	struct list_head queue;
 };
 
-struct lu_phy_attr {
+struct scsi_lu {
+	int fd;
+	uint64_t addr; /* persistent mapped address */
+	uint64_t size;
+	uint64_t lun;
+	char *path;
+
 	char scsi_id[SCSI_ID_LEN];
 	char scsi_sn[SCSI_SN_LEN];
 
@@ -44,14 +50,6 @@ struct lu_phy_attr {
 	char online;		/* Logical Unit online ? */
 	char reset;		/* Power-on or reset has occured */
 	char sense_format;	/* Descrptor format sense data supported */
-};
-
-struct scsi_lu {
-	int fd;
-	uint64_t addr; /* persistent mapped address */
-	uint64_t size;
-	uint64_t lun;
-	char *path;
 
 	/* the list of devices belonging to a target */
 	struct list_head device_siblings;
@@ -63,7 +61,6 @@ struct scsi_lu {
 	uint64_t reserve_id;
 
 	/* TODO: needs a structure for lots of device parameters */
-	struct lu_phy_attr *attrs;
 };
 
 struct scsi_cmd {
-- 
1.5.2.1






From fujita.tomonori at lab.ntt.co.jp  Fri Jun 15 00:20:47 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 15 Jun 2007 07:20:47 +0900 (JST)
Subject: [Stgt-devel] [Patch 1/2] Add dynamic lu configuration.
In-Reply-To: <466FA450.2030608@gmail.com>
References: <466FA450.2030608@gmail.com>
Message-ID: <20070614233508B.fujita.tomonori@lab.ntt.co.jp>

> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>

> @@ -286,18 +286,29 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
>  }
>  
>  enum {
> -	Opt_scsiid, Opt_scsisn, Opt_err,
> +	Opt_scsiid, Opt_scsisn,
> +	Opt_vendorid, Opt_productid,
> +	Opt_productrev, Opt_sense_format,
> +	Opt_removable, Opt_online,
> +	Opt_err,
>  };
>  
>  static match_table_t tokens = {
>  	{Opt_scsiid, "scsi_id=%s"},
>  	{Opt_scsisn, "scsi_sn=%s"},
> +	{Opt_vendorid, "vendor_id=%s"},
> +	{Opt_productid, "product_id=%s"},
> +	{Opt_productrev, "product_rev=%s"},
> +	{Opt_sense_format, "sense_format=%s"},
> +	{Opt_removable, "removable=%s"},
> +	{Opt_online, "online=%s"},
>  	{Opt_err, NULL},
>  };

I want name consistency here though I'm not arguing that Opt_scsiid
and scsi_id / Opt_scsisn and scsi_sn naming is the best choice.

Previously, you used:

> +	{Opt_VendorIdent, "VendorIdent=%s"},
> +	{Opt_ProductIdent, "ProductIdent=%s"},
> +	{Opt_ProductRev, "ProductRev=%s"},
> +	{Opt_SenseFormat, "SenseFormat=%s"},
> +	{Opt_Removable, "Removable=%s"},
> +	{Opt_Online, "Online=%s"},

I'm ok with changing Opt_scsiid and scsi_id / Opt_scsisn and scsi_sn
naming.

Suggestions?


From fujita.tomonori at lab.ntt.co.jp  Fri Jun 15 00:20:47 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 15 Jun 2007 07:20:47 +0900 (JST)
Subject: [Stgt-devel] [Patch] Merge lu_phy_attr struct into scsi_lu
 struct
In-Reply-To: <4670FB6B.6020906@gmail.com>
References: <4670FB6B.6020906@gmail.com>
Message-ID: <20070614233751W.fujita.tomonori@lab.ntt.co.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch] Merge lu_phy_attr struct into scsi_lu struct
Date: Thu, 14 Jun 2007 18:25:15 +1000

> No advantage of having the lu_phy_attr structure. Moved all
> fields into the scsi_lu structure.

I think that it would be nice to have lu_phy_attr for clean
separation.

My preference is (as you did in the previous patch):

struct scsi_lu {
	...
	struct lu_phy_attr attrs;
};


After applying the 'add dynamic lu configuration' patch, I can change
and apply the your previous patch.


> diff --git a/usr/tgtd.h b/usr/tgtd.h
> index 35645b1..a4c787b 100644
> --- a/usr/tgtd.h
> +++ b/usr/tgtd.h
> @@ -30,7 +30,13 @@ struct tgt_cmd_queue {
>  	struct list_head queue;
>  };
>  
> -struct lu_phy_attr {
> +struct scsi_lu {
> +	int fd;
> +	uint64_t addr; /* persistent mapped address */
> +	uint64_t size;
> +	uint64_t lun;
> +	char *path;
> +
>  	char scsi_id[SCSI_ID_LEN];
>  	char scsi_sn[SCSI_SN_LEN];
>  
> @@ -44,14 +50,6 @@ struct lu_phy_attr {
>  	char online;		/* Logical Unit online ? */
>  	char reset;		/* Power-on or reset has occured */
>  	char sense_format;	/* Descrptor format sense data supported */
> -};
> -
> -struct scsi_lu {
> -	int fd;
> -	uint64_t addr; /* persistent mapped address */
> -	uint64_t size;
> -	uint64_t lun;
> -	char *path;
>  
>  	/* the list of devices belonging to a target */
>  	struct list_head device_siblings;
> @@ -63,7 +61,6 @@ struct scsi_lu {
>  	uint64_t reserve_id;
>  
>  	/* TODO: needs a structure for lots of device parameters */
> -	struct lu_phy_attr *attrs;
>  };
>  
>  struct scsi_cmd {
> -- 
> 1.5.2.1
> 
> 
> 
> 
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
> 


From markh794 at gmail.com  Fri Jun 15 00:25:57 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 15 Jun 2007 08:25:57 +1000
Subject: [Stgt-devel] [Patch] Merge lu_phy_attr struct into scsi_lu
	struct
In-Reply-To: <20070614233751W.fujita.tomonori@lab.ntt.co.jp>
References: <4670FB6B.6020906@gmail.com>
	<20070614233751W.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80706141525w4c656197m690fcf01db6f8e28@mail.gmail.com>

On 6/15/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: Mark Harvey <markh794 at gmail.com>
> Subject: [Stgt-devel] [Patch] Merge lu_phy_attr struct into scsi_lu struct
> Date: Thu, 14 Jun 2007 18:25:15 +1000
>
> > No advantage of having the lu_phy_attr structure. Moved all
> > fields into the scsi_lu structure.
>
> I think that it would be nice to have lu_phy_attr for clean
> separation.
>
> My preference is (as you did in the previous patch):
>
> struct scsi_lu {
>         ...
>         struct lu_phy_attr attrs;
> };
>
>
> After applying the 'add dynamic lu configuration' patch, I can change
> and apply the your previous patch.
>

OK & thanks.

Mark


From markh794 at gmail.com  Fri Jun 15 00:32:00 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 15 Jun 2007 08:32:00 +1000
Subject: [Stgt-devel] [Patch 1/2] Add dynamic lu configuration.
In-Reply-To: <20070614233508B.fujita.tomonori@lab.ntt.co.jp>
References: <466FA450.2030608@gmail.com>
	<20070614233508B.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80706141532p2937b9dfpe8d583da2613a890@mail.gmail.com>

On 6/15/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> >
> > Signed-off-by: Mark Harvey <markh794 at gmail.com>
>
> > @@ -286,18 +286,29 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
> >  }
> >
> >  enum {
> > -     Opt_scsiid, Opt_scsisn, Opt_err,
> > +     Opt_scsiid, Opt_scsisn,
> > +     Opt_vendorid, Opt_productid,
> > +     Opt_productrev, Opt_sense_format,
> > +     Opt_removable, Opt_online,
> > +     Opt_err,
> >  };
> >
> >  static match_table_t tokens = {
> >       {Opt_scsiid, "scsi_id=%s"},
> >       {Opt_scsisn, "scsi_sn=%s"},
> > +     {Opt_vendorid, "vendor_id=%s"},
> > +     {Opt_productid, "product_id=%s"},
> > +     {Opt_productrev, "product_rev=%s"},
> > +     {Opt_sense_format, "sense_format=%s"},
> > +     {Opt_removable, "removable=%s"},
> > +     {Opt_online, "online=%s"},
> >       {Opt_err, NULL},
> >  };
>
> I want name consistency here though I'm not arguing that Opt_scsiid
> and scsi_id / Opt_scsisn and scsi_sn naming is the best choice.
>
> Previously, you used:
>
> > +     {Opt_VendorIdent, "VendorIdent=%s"},
> > +     {Opt_ProductIdent, "ProductIdent=%s"},
> > +     {Opt_ProductRev, "ProductRev=%s"},
> > +     {Opt_SenseFormat, "SenseFormat=%s"},
> > +     {Opt_Removable, "Removable=%s"},
> > +     {Opt_Online, "Online=%s"},
>
> I'm ok with changing Opt_scsiid and scsi_id / Opt_scsisn and scsi_sn
> naming.
>
> Suggestions?
>

Sorry, I took the 'consistency' to reflect the Upper/Lower-case. I
missed the scsisn/scsi_sn all together.

I have no real preference either way.

I can re-do this patch with the 'Opt_scsi_sn/scsi_sn=%s' or
'Opt_scsisn/scsisn=%s' ..


From fujita.tomonori at lab.ntt.co.jp  Fri Jun 15 00:46:22 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 15 Jun 2007 07:46:22 +0900
Subject: [Stgt-devel] [Patch 1/2] Add dynamic lu configuration.
In-Reply-To: <f29db9a80706141532p2937b9dfpe8d583da2613a890@mail.gmail.com>
References: <466FA450.2030608@gmail.com>
	<20070614233508B.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80706141532p2937b9dfpe8d583da2613a890@mail.gmail.com>
Message-ID: <20070615074622L.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] [Patch 1/2] Add dynamic lu configuration.
Date: Fri, 15 Jun 2007 08:32:00 +1000

> On 6/15/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > >
> > > Signed-off-by: Mark Harvey <markh794 at gmail.com>
> >
> > > @@ -286,18 +286,29 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
> > >  }
> > >
> > >  enum {
> > > -     Opt_scsiid, Opt_scsisn, Opt_err,
> > > +     Opt_scsiid, Opt_scsisn,
> > > +     Opt_vendorid, Opt_productid,
> > > +     Opt_productrev, Opt_sense_format,
> > > +     Opt_removable, Opt_online,
> > > +     Opt_err,
> > >  };
> > >
> > >  static match_table_t tokens = {
> > >       {Opt_scsiid, "scsi_id=%s"},
> > >       {Opt_scsisn, "scsi_sn=%s"},
> > > +     {Opt_vendorid, "vendor_id=%s"},
> > > +     {Opt_productid, "product_id=%s"},
> > > +     {Opt_productrev, "product_rev=%s"},
> > > +     {Opt_sense_format, "sense_format=%s"},
> > > +     {Opt_removable, "removable=%s"},
> > > +     {Opt_online, "online=%s"},
> > >       {Opt_err, NULL},
> > >  };
> >
> > I want name consistency here though I'm not arguing that Opt_scsiid
> > and scsi_id / Opt_scsisn and scsi_sn naming is the best choice.
> >
> > Previously, you used:
> >
> > > +     {Opt_VendorIdent, "VendorIdent=%s"},
> > > +     {Opt_ProductIdent, "ProductIdent=%s"},
> > > +     {Opt_ProductRev, "ProductRev=%s"},
> > > +     {Opt_SenseFormat, "SenseFormat=%s"},
> > > +     {Opt_Removable, "Removable=%s"},
> > > +     {Opt_Online, "Online=%s"},
> >
> > I'm ok with changing Opt_scsiid and scsi_id / Opt_scsisn and scsi_sn
> > naming.
> >
> > Suggestions?
> >
> 
> Sorry, I took the 'consistency' to reflect the Upper/Lower-case. I
> missed the scsisn/scsi_sn all together.

I meant to it and Upper/Lower-case.

You prefer Upper/Lower-case? I meant you want something like SCSI_ID=%s?

This is visible to users, we shouldn't change this often.


From markh794 at gmail.com  Fri Jun 15 01:55:36 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 15 Jun 2007 09:55:36 +1000
Subject: [Stgt-devel] [Patch 1/2] Add dynamic lu configuration.
In-Reply-To: <20070615074622L.fujita.tomonori@lab.ntt.co.jp>
References: <466FA450.2030608@gmail.com>
	<20070614233508B.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80706141532p2937b9dfpe8d583da2613a890@mail.gmail.com>
	<20070615074622L.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80706141655v219ad89cn54e6861363f75e69@mail.gmail.com>

On 6/15/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: Re: [Stgt-devel] [Patch 1/2] Add dynamic lu configuration.
> Date: Fri, 15 Jun 2007 08:32:00 +1000
>
> > On 6/15/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > > >
> > > > Signed-off-by: Mark Harvey <markh794 at gmail.com>
> > >
> > > > @@ -286,18 +286,29 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
> > > >  }
> > > >
> > > >  enum {
> > > > -     Opt_scsiid, Opt_scsisn, Opt_err,
> > > > +     Opt_scsiid, Opt_scsisn,
> > > > +     Opt_vendorid, Opt_productid,
> > > > +     Opt_productrev, Opt_sense_format,
> > > > +     Opt_removable, Opt_online,
> > > > +     Opt_err,
> > > >  };
> > > >
> > > >  static match_table_t tokens = {
> > > >       {Opt_scsiid, "scsi_id=%s"},
> > > >       {Opt_scsisn, "scsi_sn=%s"},
> > > > +     {Opt_vendorid, "vendor_id=%s"},
> > > > +     {Opt_productid, "product_id=%s"},
> > > > +     {Opt_productrev, "product_rev=%s"},
> > > > +     {Opt_sense_format, "sense_format=%s"},
> > > > +     {Opt_removable, "removable=%s"},
> > > > +     {Opt_online, "online=%s"},
> > > >       {Opt_err, NULL},
> > > >  };
> > >
> > > I want name consistency here though I'm not arguing that Opt_scsiid
> > > and scsi_id / Opt_scsisn and scsi_sn naming is the best choice.
> > >
> > > Previously, you used:
> > >
> > > > +     {Opt_VendorIdent, "VendorIdent=%s"},
> > > > +     {Opt_ProductIdent, "ProductIdent=%s"},
> > > > +     {Opt_ProductRev, "ProductRev=%s"},
> > > > +     {Opt_SenseFormat, "SenseFormat=%s"},
> > > > +     {Opt_Removable, "Removable=%s"},
> > > > +     {Opt_Online, "Online=%s"},
> > >
> > > I'm ok with changing Opt_scsiid and scsi_id / Opt_scsisn and scsi_sn
> > > naming.
> > >
> > > Suggestions?
> > >
> >
> > Sorry, I took the 'consistency' to reflect the Upper/Lower-case. I
> > missed the scsisn/scsi_sn all together.
>
> I meant to it and Upper/Lower-case.
>
> You prefer Upper/Lower-case? I meant you want something like SCSI_ID=%s?

I have no preference either way.

The stgt device configuration is something I would expect will be set
up in a script and not changed very often.

If you have a preference, I'll go with that. Otherwise lets got with
the scsi_id format.
i.e. word_seperated_with_underscores.

>
> This is visible to users, we shouldn't change this often.
>

I agree 100%

And of course, it should also be consistent across all tgtadm switch options.

Cheers
Mark


From fujita.tomonori at lab.ntt.co.jp  Fri Jun 15 06:36:06 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 15 Jun 2007 13:36:06 +0900
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <20070605133826.GA32456@pentland.suse.de>
References: <20070605133826.GA32456@pentland.suse.de>
Message-ID: <20070615133606N.fujita.tomonori@lab.ntt.co.jp>

From: Hannes Reinecke <hare at suse.de>
Subject: [Stgt-devel] [PATCH] Move device type to LUN
Date: Tue, 5 Jun 2007 15:38:26 +0200

> diff --git a/usr/spc.c b/usr/spc.c
> index 6aecdeb..006d3bc 100644
> --- a/usr/spc.c
> +++ b/usr/spc.c
> @@ -43,7 +43,7 @@ int spc_inquiry(int host_no, struct scsi
>  	int len, ret = SAM_STAT_CHECK_CONDITION;
>  	uint8_t *data;
>  	uint8_t *scb = cmd->scb;
> -	unsigned char device_type = cmd->c_target->dev_type_template.type;
> +	uint8_t devtype;
>  	struct lu_phy_attr *attributes = cmd->dev->attributes;
>  	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
>  
> @@ -60,9 +60,12 @@ int spc_inquiry(int host_no, struct scsi
>  
>  	dprintf("%x %x\n", scb[1], scb[2]);
>  
> +	devtype = (attributes->qualifier & 0x7 ) << 5;
> +	devtype &= (attributes->device_type & 0x1f);

?

> +	devtype |= (attributes->device_type & 0x1f);


The rest looks ok for iSCSI, however this breaks ibmvio code badly.

I updated the patch against the latest tree
(c90113a76a377ea3c7d5345c0f185b4d9a9c8f1a).

---

From hare at suse.de  Fri Jun 15 06:22:44 2007
From: hare at suse.de (Hannes Reinecke)
Date: Fri, 15 Jun 2007 13:22:44 +0900
Subject: [PATCH] bind device type to LUN
Message-ID: <mailman.13.1331738472.12506.stgt-devel@lists.berlios.de>

The device type should be bound to the LUN, not the target.
This way we can easily support different LUN types on the
same target.

Signed-off-by: Hannes Reinecke <hare at suse.de>
---
 usr/mgmt.c   |    2 +-
 usr/mmc.c    |    2 +-
 usr/osd.c    |    2 +-
 usr/sbc.c    |    4 +-
 usr/scsi.c   |    7 +++-
 usr/spc.c    |   11 ++++--
 usr/spt.c    |    5 ++-
 usr/target.c |  111 ++++++++++++++++++++++++++++++++++++++++------------------
 usr/target.h |    3 --
 usr/tgtd.h   |   60 ++++++++++++++++++-------------
 usr/tgtif.c  |    2 +-
 11 files changed, 135 insertions(+), 74 deletions(-)

diff --git a/usr/mgmt.c b/usr/mgmt.c
index 9cda2fa..19ab738 100644
--- a/usr/mgmt.c
+++ b/usr/mgmt.c
@@ -167,7 +167,7 @@ static int device_mgmt(int lld_no, struc
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_device_create(req->tid, req->lun, params);
+		err = tgt_device_create(req->tid, req->lun, params, req->target_type);
 		break;
 	case OP_DELETE:
 		err = tgt_device_destroy(req->tid, req->lun);
diff --git a/usr/mmc.c b/usr/mmc.c
index a8aced5..ea0bd02 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -49,7 +49,7 @@ static int mmc_rw(int host_no, struct sc
 	int ret;
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << MMC_BLK_SHIFT);
-	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
+	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		cmd->offset = 0;
 		cmd->len = 0;
diff --git a/usr/osd.c b/usr/osd.c
index ac33168..d09af60 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -48,7 +48,7 @@ static int osd_varlen_cdb(int host_no, s
 	}
 
 /* 	return SAM_STAT_GOOD; */
-	return cmd->c_target->bst->bs_cmd_submit(cmd);
+	return cmd->dev->bst->bs_cmd_submit(cmd);
 }
 
 static int osd_lu_init(struct scsi_lu *lu)
diff --git a/usr/sbc.c b/usr/sbc.c
index 2924cc6..dcf4799 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -67,7 +67,7 @@ static int sbc_rw(int host_no, struct sc
 	}
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << BLK_SHIFT);
-	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
+	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		key = HARDWARE_ERROR;
 		asc = 0;
@@ -173,7 +173,7 @@ static int sbc_sync_cache(int host_no, s
 		goto sense;
 	}
 
-	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
+	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	switch (ret) {
 	case EROFS:
 	case EINVAL:
diff --git a/usr/scsi.c b/usr/scsi.c
index 50e2080..6f1b23b 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -119,6 +119,11 @@ uint64_t scsi_rw_offset(uint8_t *scb)
 int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd)
 {
 	unsigned char op = cmd->scb[0];
-	return cmd->c_target->dev_type_template.ops[op].cmd_perform(host_no, cmd);
+	if (!cmd->dev) {
+		cmd->len = 0;
+		sense_data_build(cmd, NOT_READY, 0x44, 0); /* Internal target failure */
+		return SAM_STAT_CHECK_CONDITION;
+	}
+	return cmd->dev->dev_type_template.ops[op].cmd_perform(host_no, cmd);
 }
 
diff --git a/usr/spc.c b/usr/spc.c
index 99a7df3..6028969 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -43,8 +43,8 @@ int spc_inquiry(int host_no, struct scsi
 	int len, ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data;
 	uint8_t *scb = cmd->scb;
-	unsigned char device_type = cmd->c_target->dev_type_template.type;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	uint8_t devtype = 0;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
@@ -59,11 +59,16 @@ int spc_inquiry(int host_no, struct scsi
 
 	dprintf("%x %x\n", scb[1], scb[2]);
 
+	if (cmd->dev) {
+		devtype = (cmd->dev->attrs->qualifier & 0x7 ) << 5;
+		devtype |= (cmd->dev->attrs->device_type & 0x1f);
+	}
+
 	if (!(scb[1] & 0x3) && cmd->dev) {
 		int i;
 		uint16_t *desc;
 
-		data[0] = device_type;
+		data[0] = devtype;
 		data[1] = (cmd->dev->attrs->is_removable) ? 0x80 : 0;
 		data[2] = 5;	/* SPC-3 */
 		data[3] = 0x42;
@@ -91,7 +96,7 @@ int spc_inquiry(int host_no, struct scsi
 	} else if (scb[1] & 0x1) {
 		/* EVPD bit set */
 		if (scb[2] == 0x0) {
-			data[0] = device_type;
+			data[0] = devtype;
 			data[1] = 0x0;
 			data[3] = 3;
 			data[4] = 0x0;
diff --git a/usr/spt.c b/usr/spt.c
index fe2a848..561d7d4 100644
--- a/usr/spt.c
+++ b/usr/spt.c
@@ -67,8 +67,9 @@ static int spt_cmd_perform(int host_no,
 	struct device_type_operations *ops;
 
 	if (!cmd->dev) {
-		ops = cmd->c_target->dev_type_template.ops;
-		return ops[cmd->scb[0]].cmd_perform(host_no, cmd);
+		cmd->len = 0;
+		sense_data_build(cmd, NOT_READY, 0x44, 0); /* Internal target failure */
+		return SAM_STAT_CHECK_CONDITION;
 	}
 
 	ret = spt_sg_perform(cmd);
diff --git a/usr/target.c b/usr/target.c
index 5b74be1..6f8feb0 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -174,7 +174,7 @@ static int tgt_device_path_update(struct
 	if (!path)
 		return TGTADM_NOMEM;
 
-	err = target->bst->bs_open(lu, path, &dev_fd, &size);
+	err = lu->bst->bs_open(lu, path, &dev_fd, &size);
 	if (err) {
 		free(path);
 		return TGTADM_INVALID_REQUEST;
@@ -206,7 +206,7 @@ __device_lookup(int tid, uint64_t lun, s
 	return lu;
 }
 
-int tgt_device_create(int tid, uint64_t lun, char *args)
+int tgt_device_create(int tid, uint64_t lun, char *args, int l_type)
 {
 	char *p;
 	int err;
@@ -233,10 +233,37 @@ int tgt_device_create(int tid, uint64_t
 		return TGTADM_INVALID_REQUEST;
 	p++;
 
-	lu = zalloc(sizeof(*lu) + target->bst->bs_datasize);
+	if (l_type == TYPE_SPT)
+		lu = zalloc(sizeof(*lu) + sg_bst.bs_datasize);
+	else
+		lu = zalloc(sizeof(*lu) + target->bst->bs_datasize);
+
 	if (!lu)
 		return TGTADM_NOMEM;
 
+	switch (l_type) {
+	case TYPE_DISK:
+		lu->dev_type_template = sbc_template;
+		lu->bst = target->bst;
+		break;
+	case TYPE_ROM:
+		lu->dev_type_template = mmc_template;
+		lu->bst = target->bst;
+		break;
+	case TYPE_OSD:
+		lu->dev_type_template = osd_template;
+		lu->bst = target->bst;
+		break;
+	case TYPE_SPT:
+		lu->dev_type_template = spt_template;
+		lu->bst = &sg_bst;
+		break;
+	default:
+		dprintf("Unknown device type %d\n", l_type);
+		free(lu);
+		return TGTADM_INVALID_REQUEST;
+	}
+
 	err = tgt_device_path_update(target, lu, p);
 	if (err) {
 		free(lu);
@@ -248,14 +275,17 @@ int tgt_device_create(int tid, uint64_t
 
 	tgt_cmd_queue_init(&lu->cmd_queue);
 
-	if (target->dev_type_template.lu_init)
-		err = target->dev_type_template.lu_init(lu);
+	if (lu->dev_type_template.lu_init)
+		err = lu->dev_type_template.lu_init(lu);
 
 	if (!err) {
 		snprintf(lu->attrs->scsi_id, sizeof(lu->attrs->scsi_id),
 			 "deadbeaf%d:%" PRIu64, tid, lun);
 		snprintf(lu->attrs->scsi_sn, sizeof(lu->attrs->scsi_sn),
 			 "beaf%d%" PRIu64, tid, lun);
+
+ 		lu->attrs->device_type = l_type;
+ 		lu->attrs->qualifier = 0x0;
 	}
 
 	list_for_each_entry(pos, &target->device_list, device_siblings) {
@@ -285,12 +315,12 @@ int tgt_device_destroy(int tid, uint64_t
 	if (!list_empty(&lu->cmd_queue.queue) || lu->cmd_queue.active_cmd)
 		return TGTADM_LUN_ACTIVE;
 
-	err = target->dev_type_template.lu_exit(lu);
+	err = lu->dev_type_template.lu_exit(lu);
 
 	free(lu->path);
 	list_del(&lu->device_siblings);
 
-	target->bst->bs_close(lu);
+	lu->bst->bs_close(lu);
 	free(lu);
 	return err;
 }
@@ -361,8 +391,8 @@ int tgt_device_update(int tid, uint64_t
 		return TGTADM_NO_LUN;
 	}
 
-	if (target->dev_type_template.lu_config)
-		err = target->dev_type_template.lu_config(lu, params);
+	if (lu->dev_type_template.lu_config)
+		err = lu->dev_type_template.lu_config(lu, params);
 
 	return err;
 }
@@ -1087,6 +1117,41 @@ static char *print_disksize(uint64_t siz
 	return buf;
 }
 
+static struct {
+	int value;
+	char *name;
+} disk_type_names[] = {
+	{ TYPE_DISK, "disk" },
+	{ TYPE_TAPE, "tape" },
+	{ TYPE_PRINTER, "printer" },
+	{ TYPE_PROCESSOR, "processor" },
+	{ TYPE_WORM, "worm" },
+	{ TYPE_SCANNER, "scanner" },
+	{ TYPE_MOD, "optical" },
+	{ TYPE_MEDIUM_CHANGER, "changer" },
+	{ TYPE_COMM, "comm" },
+	{ TYPE_RAID, "raid" },
+	{ TYPE_ENCLOSURE, "enc" },
+	{ TYPE_RBC, "rbc" },
+	{ TYPE_OSD, "osd" },
+	{ TYPE_NO_LUN, "No LUN" }
+};
+
+static char *print_type(int type)
+{
+	int i;
+	char *name = NULL;
+
+	for (i = 0; i < ARRAY_SIZE(disk_type_names); i++) {
+		if (disk_type_names[i].value == type) {
+			name = disk_type_names[i].name;
+			break;
+		}
+	}
+	return name;
+}
+
+
 int tgt_target_show_all(char *buf, int rest)
 {
 	int total = 0, max = rest;
@@ -1099,12 +1164,10 @@ int tgt_target_show_all(char *buf, int r
 		shprintf(total, buf, rest,
 			 "Target %d: %s\n"
 			 _TAB1 "System information:\n"
-			 _TAB2 "Type: %s\n"
 			 _TAB2 "Driver: %s\n"
 			 _TAB2 "Status: %s\n",
 			 target->tid,
 			 target->name,
-			 target->dev_type_template.name,
 			 tgt_drivers[target->lid]->name,
 			 target_state_name(target->target_state));
 
@@ -1121,11 +1184,13 @@ int tgt_target_show_all(char *buf, int r
 		list_for_each_entry(lu, &target->device_list, device_siblings)
 			shprintf(total, buf, rest,
 				 _TAB2 "LUN: %" PRIu64 "\n"
+ 				 _TAB3 "Type: %s\n"
 				 _TAB3 "SCSI ID: %s\n"
 				 _TAB3 "SCSI SN: %s\n"
 				 _TAB3 "Size: %s\n"
 				 _TAB3 "Backing store: %s\n",
 				 lu->lun,
+ 				 print_type(lu->attrs->device_type),
 				 lu->attrs->scsi_id,
 				 lu->attrs->scsi_sn,
 				 print_disksize(lu->size),
@@ -1204,24 +1269,6 @@ int tgt_target_create(int lld, int tid,
 	if (!target)
 		return TGTADM_NOMEM;
 
-	switch (t_type) {
-	case TYPE_DISK:
-		target->dev_type_template = sbc_template;
-		break;
-	case TYPE_ROM:
-		target->dev_type_template = mmc_template;
-		break;
-	case TYPE_OSD:
-		target->dev_type_template = osd_template;
-		break;
-	case TYPE_SPT:
-		target->dev_type_template = spt_template;
-		break;
-	default:
-		free(target);
-		return TGTADM_INVALID_REQUEST;
-	}
-
 	target->name = strdup(targetname);
 	if (!target->name) {
 		free(target);
@@ -1240,11 +1287,7 @@ int tgt_target_create(int lld, int tid,
 
 	INIT_LIST_HEAD(&target->device_list);
 
-	/* FIXME */
-	if (t_type == TYPE_SPT)
-		target->bst = &sg_bst;
-	else
-		target->bst = tgt_drivers[lld]->default_bst;
+	target->bst = tgt_drivers[lld]->default_bst;
 
 	target->target_state = SCSI_TARGET_RUNNING;
 	target->lid = lld;
diff --git a/usr/target.h b/usr/target.h
index a5f1faa..688f0e6 100644
--- a/usr/target.h
+++ b/usr/target.h
@@ -41,9 +41,6 @@ struct target {
 	struct list_head acl_list;
 
 	struct tgt_account account;
-
-	/* we don't use a pointer because a lld could change this. */
-	struct device_type_template dev_type_template;
 };
 
 struct it_nexus {
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 7b64655..9412da1 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -40,12 +40,41 @@ struct lu_phy_attr {
 	char product_rev[5];
 	uint16_t version_desc[VERSION_DESCRIPTOR_LEN];
 
+	char device_type;	/* Peripheral device type */
+	char qualifier;		/* Peripheral Qualifier */
 	char is_removable;	/* Removable media */
 	char online;		/* Logical Unit online ? */
 	char reset;		/* Power-on or reset has occured */
 	char sense_format;	/* Descrptor format sense data supported */
 };
 
+struct scsi_lu;
+struct scsi_cmd;
+
+struct device_type_operations {
+	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
+};
+
+struct device_type_template {
+	unsigned char type;
+	char *name;
+	char *pid;
+
+	int (*lu_init)(struct scsi_lu *lu);
+	int (*lu_exit)(struct scsi_lu *lu);
+	int (*lu_config)(struct scsi_lu *lu, char *arg);
+
+	struct device_type_operations ops[256];
+};
+
+struct backingstore_template {
+	int bs_datasize;
+	int (*bs_open)(struct scsi_lu *dev, char *path, int *fd, uint64_t *size);
+	void (*bs_close)(struct scsi_lu *dev);
+	int (*bs_cmd_submit)(struct scsi_cmd *cmd);
+	int (*bs_cmd_done) (struct scsi_cmd *cmd);
+};
+
 struct scsi_lu {
 	int fd;
 	uint64_t addr; /* persistent mapped address */
@@ -62,6 +91,11 @@ struct scsi_lu {
 
 	uint64_t reserve_id;
 
+	/* we don't use a pointer because a lld could change this. */
+	struct device_type_template dev_type_template;
+
+	struct backingstore_template *bst;
+
 	/* TODO: needs a structure for lots of device parameters */
 	struct lu_phy_attr *attrs;
 };
@@ -110,14 +144,6 @@ struct mgmt_req {
 	uint64_t itn_id;
 };
 
-struct backingstore_template {
-	int bs_datasize;
-	int (*bs_open)(struct scsi_lu *dev, char *path, int *fd, uint64_t *size);
-	void (*bs_close)(struct scsi_lu *dev);
-	int (*bs_cmd_submit)(struct scsi_cmd *cmd);
-	int (*bs_cmd_done) (struct scsi_cmd *cmd);
-};
-
 #ifdef USE_KERNEL
 extern int kreq_init(void);
 #else
@@ -127,27 +153,11 @@ static inline int kreq_init(void)	\
 }
 #endif
 
-struct device_type_operations {
-	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
-};
-
-struct device_type_template {
-	unsigned char type;
-	char *name;
-	char *pid;
-
-	int (*lu_init)(struct scsi_lu *lu);
-	int (*lu_exit)(struct scsi_lu *lu);
-	int (*lu_config)(struct scsi_lu *lu, char *arg);
-
-	struct device_type_operations ops[256];
-};
-
 extern int kspace_send_tsk_mgmt_res(struct mgmt_req *mreq);
 extern int kspace_send_cmd_res(uint64_t nid, int result, struct scsi_cmd *);
 
 extern int ipc_init(void);
-extern int tgt_device_create(int tid, uint64_t lun, char *args);
+extern int tgt_device_create(int tid, uint64_t lun, char *args, int l_type);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_device_update(int tid, uint64_t dev_id, char *name);
 extern int device_reserve(struct scsi_cmd *cmd);
diff --git a/usr/tgtif.c b/usr/tgtif.c
index caa0eeb..c8c9817 100644
--- a/usr/tgtif.c
+++ b/usr/tgtif.c
@@ -162,7 +162,7 @@ static void kern_queue_cmd(struct tgt_ev
 	kcmd->host_no = ev->p.cmd_req.host_no;
 	cmd = &kcmd->scmd;
 	cmd->cmd_itn_id = ev->p.cmd_req.itn_id;
-	cmd->scb = (char *)cmd + sizeof(*cmd);
+	cmd->scb = (unsigned char *)cmd + sizeof(*cmd);
 	memcpy(cmd->scb, ev->p.cmd_req.scb, scb_len);
 	cmd->scb_len = scb_len;
 	memcpy(cmd->lun, ev->p.cmd_req.lun, sizeof(cmd->lun));
-- 
1.4.3.2



From fujita.tomonori at lab.ntt.co.jp  Fri Jun 15 06:36:12 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 15 Jun 2007 13:36:12 +0900
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <466E9513.9030303@suse.de>
References: <466D6707.9010406@suse.de>
	<20070612213358F.fujita.tomonori@lab.ntt.co.jp>
	<466E9513.9030303@suse.de>
Message-ID: <20070615133612Q.fujita.tomonori@lab.ntt.co.jp>

From: Hannes Reinecke <hare at suse.de>
Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
Date: Tue, 12 Jun 2007 14:44:03 +0200

> FUJITA Tomonori wrote:
> > From: Hannes Reinecke <hare at suse.de>
> > Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> > Date: Mon, 11 Jun 2007 17:15:19 +0200
> > 
> >> Pete Wyckoff wrote:
> >>> hare at suse.de wrote on Tue, 05 Jun 2007 15:38 +0200:
> >>>> This patch moves the device type down to the LUN structure.
> >>>> And in doing so we now also have the proper peripheral device
> >>>> type and peripheral device qualifier attributes for the INQUIRY
> >>>> data.
> >>> Makes sense to me too.
> >>>
> >>>> One thing puzzles me, though: do we support commands with no
> >>>> LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
> >>>> If so: where is the point here? If that's our handling of a
> >>>> non-existing LUN 0 we should rather add a proper LUN 0 and
> >>>> treat cmd->dev == NULL as an error case ...
> >>> In the SCSI model, every device must have at least one LUN for
> >>> handling REPORT LUNS and a couple other commands.  It is addressed
> >>> as LUN 0 or using the "well-known" LUN for the command.  In the stgt
> >>> abstraction, though, there is no magic LUN like this.  Instead
> >>> things like spc_inqury use cmd->dev == NULL to handle this case.
> >>>
> >> Ah. Hence.
> >>
> >>> Perhaps it is reasonable to create a special device for these
> >>> commands.  Up in target.c, you could assign cmd->dev to target->dev,
> >>> where that is the special device, paralleling the way that
> >>> target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
> >>> ... else ILLEGAL_REQUEST" clauses can be removed from device code
> >>> too.
> >>>
> >> Well, I actually thought of creating a proper LUN 0 with type 0xc.
> > 
> > We still need to handle cmd->dev == NULL case though probably we can
> > remove cmd->dev == NULL case in device type code.
> > 
> > I don't have storage systems that work in your way. Is it common?
> > 
> > 
> Yes, quite common. HP and EMC (to name but a few) do it this way.
> Most storage arrays actually refuse to attach any devices to LUN0, as
> this is a pure management LUN.
> 
> I will draft up a patch which creates a proper controller LUN0.

Ok, here's a patch. This depends on the patch that I've just
submitted.

This adds scc support and fixes ibmvio. iSCSI works. ibmvio works for
me, but it detects scsi devices in a unique way, so I'm not sure it
works for everyone.

As described, a scsi controler device is automatically created as lun0
with a new target.

lily:/home/fujita# ./tgt/usr/tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
lily:/home/fujita# ./tgt/usr/tgtadm --op show --mode target
Target 1: iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
    System information:
        Driver: iscsi
        Status: running
    I_T nexus information:
    LUN information:
        LUN: 0
            Type: raid
            SCSI ID: deadbeaf1:0
            SCSI SN: beaf10
            Size: 0
            Backing store: No backing store
    Account information:
    ACL information:


The patch is still very hacky but shows how it works. Let me know this
works or not.


From fujita.tomonori at lab.ntt.co.jp  Fri Jun 15 06:24:19 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 15 Jun 2007 13:24:19 +0900
Subject: [PATCH] add scc device type support
Message-ID: <mailman.14.1331738472.12506.stgt-devel@lists.berlios.de>

A scsi controler device is automatically created as lun0 with a new
target.

Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
---
 usr/Makefile        |    2 +-
 usr/driver.h        |    2 +
 usr/ibmvio/ibmvio.c |   16 +++---
 usr/mgmt.c          |    2 +-
 usr/scc.c           |  164 +++++++++++++++++++++++++++++++++++++++++++++++++++
 usr/target.c        |   45 +++++++++-----
 usr/tgtd.h          |    2 +-
 7 files changed, 206 insertions(+), 27 deletions(-)

diff --git a/usr/Makefile b/usr/Makefile
index 7ff74cb..208967d 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -43,7 +43,7 @@ INCLUDES += -I.
 CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
 
 PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o osd.o spt.o scsi.o log.o \
+TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o osd.o spt.o scc.o scsi.o log.o \
 	driver.o util.o work.o parser.o
 
 all: $(PROGRAMS)
diff --git a/usr/driver.h b/usr/driver.h
index 598c1da..0a4648a 100644
--- a/usr/driver.h
+++ b/usr/driver.h
@@ -9,6 +9,8 @@ struct tgt_driver {
 	int (*target_create)(struct target *);
 	int (*target_destroy)(int);
 
+	int (*lu_create)(struct scsi_lu *);
+
 	int (*update)(int, int, char *);
 	int (*show)(int, int, uint64_t, uint32_t, uint64_t, char *, int);
 
diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index ff91f14..d1d8820 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -76,9 +76,12 @@ static int __ibmvio_inquiry(int host_no,
 	char system_id[256], path[256], buf[32];
 	int fd, err, partition_number;
 	unsigned int unit_address;
-	unsigned char device_type = cmd->c_target->dev_type_template.type;
+	unsigned char device_type;
 	uint64_t lun = *((uint64_t *) cmd->lun);
 
+	device_type = (cmd->dev->attrs->qualifier & 0x7 ) << 5;
+	device_type |= (cmd->dev->attrs->device_type & 0x1f);
+
 	snprintf(path, sizeof(path), IBMVSTGT_HOSTDIR "%d/system_id", host_no);
 	fd = open(path, O_RDONLY);
 	memset(system_id, 0, sizeof(system_id));
@@ -257,14 +260,11 @@ static uint64_t scsi_lun_to_int(uint8_t
 		return GETTARGET(lun);
 }
 
-static int ibmvio_target_create(struct target *target)
+static int ibmvio_lu_create(struct scsi_lu *lu)
 {
-	unsigned char device_type = target->dev_type_template.type;
-	struct device_type_operations *ops = target->dev_type_template.ops;
-
-	if (device_type == TYPE_DISK || device_type == TYPE_ROM)
-		ops[INQUIRY].cmd_perform = ibmvio_inquiry;
+	struct device_type_operations *ops =  lu->dev_type_template.ops;
 
+	ops[INQUIRY].cmd_perform = ibmvio_inquiry;
 	ops[REPORT_LUNS].cmd_perform = ibmvio_report_luns;
 
 	return 0;
@@ -274,7 +274,7 @@ struct tgt_driver ibmvio = {
 	.name			= "ibmvio",
 	.use_kernel		= 1,
 	.scsi_get_lun		= scsi_lun_to_int,
-	.target_create		= ibmvio_target_create,
+	.lu_create		= ibmvio_lu_create,
 	.cmd_end_notify		= kspace_send_cmd_res,
 	.mgmt_end_notify	= kspace_send_tsk_mgmt_res,
 	.default_bst		= &mmap_bst,
diff --git a/usr/mgmt.c b/usr/mgmt.c
index 19ab738..fc9fa46 100644
--- a/usr/mgmt.c
+++ b/usr/mgmt.c
@@ -167,7 +167,7 @@ static int device_mgmt(int lld_no, struc
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_device_create(req->tid, req->lun, params, req->target_type);
+		err = tgt_device_create(req->tid, req->lun, params, req->target_type, 1);
 		break;
 	case OP_DELETE:
 		err = tgt_device_destroy(req->tid, req->lun);
diff --git a/usr/scc.c b/usr/scc.c
new file mode 100644
index 0000000..7ab6323
--- /dev/null
+++ b/usr/scc.c
@@ -0,0 +1,164 @@
+/*
+ * SCSI Controller command processing
+ *
+ * Copyright (C) 2007 FUJITA Tomonori <tomof at acm.org>
+ * Copyright (C) 2007 Mike Christie <michaelc at cs.wisc.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <linux/fs.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "driver.h"
+#include "scsi.h"
+#include "spc.h"
+
+static int scc_lu_init(struct scsi_lu *lu)
+{
+	if (spc_lu_init(lu))
+		return -ENOMEM;
+
+	strncpy(lu->attrs->product_id, "Controler",
+		sizeof(lu->attrs->product_id));
+	lu->attrs->version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
+	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs->version_desc[2] = 0x01fb; /* SCC-2 */
+
+	return 0;
+}
+
+static int scc_lu_exit(struct scsi_lu *lu)
+{
+	return 0;
+}
+
+struct device_type_template scc_template = {
+	.type		= TYPE_RAID,
+	.name		= "controler",
+	.lu_init	= scc_lu_init,
+	.lu_exit	= scc_lu_exit,
+	.lu_config	= spc_lu_config,
+	.ops		= {
+		{spc_test_unit,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_request_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		/* 0x10 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_inquiry,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		/* 0x20 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_test_unit},
+
+		[0x30 ... 0x7f] = {spc_illegal_op,},
+
+		/* 0x80 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_test_unit},
+
+		[0x90 ... 0x9f] = {spc_illegal_op,},
+
+		/* 0xA0 */
+		{spc_report_luns,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_test_unit,},
+
+		[0xb0 ... 0xff] = {spc_illegal_op},
+	}
+};
diff --git a/usr/target.c b/usr/target.c
index 6f8feb0..750ee31 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -37,7 +37,7 @@ #include "scsi.h"
 #include "tgtadm.h"
 
 extern struct device_type_template sbc_template, mmc_template, osd_template,
-	spt_template;
+	spt_template, scc_template;
 
 static LIST_HEAD(target_list);
 
@@ -206,10 +206,10 @@ __device_lookup(int tid, uint64_t lun, s
 	return lu;
 }
 
-int tgt_device_create(int tid, uint64_t lun, char *args, int l_type)
+int tgt_device_create(int tid, uint64_t lun, char *args, int l_type, int backing)
 {
-	char *p;
-	int err;
+	char *p = NULL;
+	int err = 0;
 	struct target *target;
 	struct scsi_lu *lu, *pos;
 
@@ -225,13 +225,15 @@ int tgt_device_create(int tid, uint64_t
 		return TGTADM_LUN_EXIST;
 	}
 
-	if (!*args)
-		return TGTADM_INVALID_REQUEST;
+	if (backing) {
+		if (!*args)
+			return TGTADM_INVALID_REQUEST;
 
-	p = strchr(args, '=');
-	if (!p)
-		return TGTADM_INVALID_REQUEST;
-	p++;
+		p = strchr(args, '=');
+		if (!p)
+			return TGTADM_INVALID_REQUEST;
+		p++;
+	}
 
 	if (l_type == TYPE_SPT)
 		lu = zalloc(sizeof(*lu) + sg_bst.bs_datasize);
@@ -242,6 +244,10 @@ int tgt_device_create(int tid, uint64_t
 		return TGTADM_NOMEM;
 
 	switch (l_type) {
+	case TYPE_RAID:
+		lu->dev_type_template = scc_template;
+		lu->bst = target->bst;
+		break;
 	case TYPE_DISK:
 		lu->dev_type_template = sbc_template;
 		lu->bst = target->bst;
@@ -264,10 +270,12 @@ int tgt_device_create(int tid, uint64_t
 		return TGTADM_INVALID_REQUEST;
 	}
 
-	err = tgt_device_path_update(target, lu, p);
-	if (err) {
-		free(lu);
-		return err;
+	if (backing) {
+		err = tgt_device_path_update(target, lu, p);
+		if (err) {
+			free(lu);
+			return err;
+		}
 	}
 
 	lu->lun = lun;
@@ -288,6 +296,9 @@ int tgt_device_create(int tid, uint64_t
  		lu->attrs->qualifier = 0x0;
 	}
 
+	if (tgt_drivers[target->lid]->lu_create)
+		tgt_drivers[target->lid]->lu_create(lu);
+
 	list_for_each_entry(pos, &target->device_list, device_siblings) {
 		if (lu->lun < pos->lun)
 			break;
@@ -1194,7 +1205,7 @@ int tgt_target_show_all(char *buf, int r
 				 lu->attrs->scsi_id,
 				 lu->attrs->scsi_sn,
 				 print_disksize(lu->size),
-				 lu->path);
+				 lu->path ? : "No backing store");
 
 		if (!strcmp(tgt_drivers[target->lid]->name, "iscsi")) {
 			int i, aid;
@@ -1303,11 +1314,13 @@ int tgt_target_create(int lld, int tid,
 	INIT_LIST_HEAD(&target->acl_list);
 	INIT_LIST_HEAD(&target->it_nexus_list);
 
-	dprintf("Succeed to create a new target %d\n", tid);
+	tgt_device_create(tid, 0, NULL, TYPE_RAID, 0);
 
 	if (tgt_drivers[lld]->target_create)
 		tgt_drivers[lld]->target_create(target);
 
+	dprintf("Succeed to create a new target %d\n", tid);
+
 	return 0;
 }
 
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 9412da1..927cd70 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -157,7 +157,7 @@ extern int kspace_send_tsk_mgmt_res(stru
 extern int kspace_send_cmd_res(uint64_t nid, int result, struct scsi_cmd *);
 
 extern int ipc_init(void);
-extern int tgt_device_create(int tid, uint64_t lun, char *args, int l_type);
+extern int tgt_device_create(int tid, uint64_t lun, char *args, int l_type, int backing);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_device_update(int tid, uint64_t dev_id, char *name);
 extern int device_reserve(struct scsi_cmd *cmd);
-- 
1.4.3.2



From markh794 at gmail.com  Fri Jun 15 09:55:11 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 15 Jun 2007 17:55:11 +1000
Subject: [Stgt-devel] [Patch 1/2] Merge lu_phy_attr struct into scsi_lu
Message-ID: <467245DF.9020605@gmail.com>

>From de670fc4dc5d67584b7a84841df6a01443f23e48 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Fri, 15 Jun 2007 17:20:34 +1000
Subject: Merge lu_phy_attr struct into scsi_lu struct

Included lu_phy_attr struct 'in line' with scsi_lu structure.
 - It is a static structure and works just as well inside
   the scsi_lu struct.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/mmc.c    |   10 +++++-----
 usr/osd.c    |   10 +++++-----
 usr/sbc.c    |    8 ++++----
 usr/scsi.c   |    2 +-
 usr/spc.c    |   52 ++++++++++++++++++++++++----------------------------
 usr/target.c |    8 ++++----
 usr/tgtd.h   |    6 +++---
 7 files changed, 46 insertions(+), 50 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index a8aced5..0ac5f72 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -126,11 +126,11 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
-	memcpy(lu->attrs->product_id, "VIRTUAL-CDROM", 16);
-	lu->attrs->sense_format = 0;
-	lu->attrs->version_desc[0] = 0x02A0; /* MMC3, no version claimed */
-	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
-	lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
+	memcpy(lu->attrs.product_id, "VIRTUAL-CDROM", 16);
+	lu->attrs.sense_format = 0;
+	lu->attrs.version_desc[0] = 0x02A0; /* MMC3, no version claimed */
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
 	return 0;
 }
diff --git a/usr/osd.c b/usr/osd.c
index ac33168..33d6455 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -56,11 +56,11 @@ static int osd_lu_init(struct scsi_lu *lu)
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
-	memcpy(lu->attrs->product_id, "OSD", 16);
-	lu->attrs->sense_format = 1;
-	lu->attrs->version_desc[0] = 0x0340; /* OSD */
-	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
-	lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
+	memcpy(lu->attrs.product_id, "OSD", 16);
+	lu->attrs.sense_format = 1;
+	lu->attrs.version_desc[0] = 0x0340; /* OSD */
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
 	return 0;
 }
diff --git a/usr/sbc.c b/usr/sbc.c
index 2924cc6..8fe39e7 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -342,10 +342,10 @@ static int sbc_lu_init(struct scsi_lu *lu)
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
-	memcpy(lu->attrs->product_id, "VIRTUAL-DISK", 16);
-	lu->attrs->version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
-	lu->attrs->version_desc[1] = 0x0960; /* iSCSI */
-	lu->attrs->version_desc[2] = 0x0300; /* SPC-3 */
+	memcpy(lu->attrs.product_id, "VIRTUAL-DISK", 16);
+	lu->attrs.version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
 	return 0;
 }
diff --git a/usr/scsi.c b/usr/scsi.c
index 50e2080..c9fb7b6 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -40,7 +40,7 @@
 
 void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
 {
-	if (cmd->dev && cmd->dev->attrs->sense_format) {
+	if (cmd->dev && cmd->dev->attrs.sense_format) {
 		/* descriptor format */
 
 		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
diff --git a/usr/spc.c b/usr/spc.c
index 99a7df3..602af5d 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -64,19 +64,19 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 		uint16_t *desc;
 
 		data[0] = device_type;
-		data[1] = (cmd->dev->attrs->is_removable) ? 0x80 : 0;
+		data[1] = (cmd->dev->attrs.removable) ? 0x80 : 0;
 		data[2] = 5;	/* SPC-3 */
 		data[3] = 0x42;
 		data[7] = 0x02;
 
 		memset(data + 8, 0x20, 28);
-		strncpy((char *)data + 8, cmd->dev->attrs->vendor_id, 8);
-		strncpy((char *)data + 16, cmd->dev->attrs->product_id, 16);
-		strncpy((char *)data + 32, cmd->dev->attrs->product_rev, 4);
+		strncpy((char *)data + 8, cmd->dev->attrs.vendor_id, 8);
+		strncpy((char *)data + 16, cmd->dev->attrs.product_id, 16);
+		strncpy((char *)data + 32, cmd->dev->attrs.product_rev, 4);
 
 		desc = (uint16_t *)(data + 58);
-		for (i = 0; i < ARRAY_SIZE(cmd->dev->attrs->version_desc); i++)
-			*desc++ = __cpu_to_be16(cmd->dev->attrs->version_desc[i]);
+		for (i = 0; i < ARRAY_SIZE(cmd->dev->attrs.version_desc); i++)
+			*desc++ = __cpu_to_be16(cmd->dev->attrs.version_desc[i]);
 
 		len = 66;
 		data[4] = len - 5;	/* Additional Length */
@@ -108,12 +108,12 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 			len = 4 + SCSI_SN_LEN;
 			ret = SAM_STAT_GOOD;
 
-			if (cmd->dev && strlen(cmd->dev->attrs->scsi_sn)) {
+			if (cmd->dev && strlen(cmd->dev->attrs.scsi_sn)) {
 				uint8_t *p;
 				char *q;
 
 				p = data + 4 + tmp - 1;
-				q = cmd->dev->attrs->scsi_sn + SCSI_SN_LEN - 1;
+				q = cmd->dev->attrs.scsi_sn + SCSI_SN_LEN - 1;
 				for (; tmp > 0; tmp--, q)
 					*(p--) = *(q--);
 			}
@@ -127,7 +127,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 			data[7] = tmp;
 			if (cmd->dev)
 				strncpy((char *) data + 8,
-					cmd->dev->attrs->scsi_id, SCSI_ID_LEN);
+					cmd->dev->attrs.scsi_id, SCSI_ID_LEN);
 
 			len = tmp + 8;
 			ret = SAM_STAT_GOOD;
@@ -286,12 +286,12 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 }
 
 enum {
-	Opt_scsiid, Opt_scsisn, Opt_err,
+	Opt_scsi_id, Opt_scsi_sn, Opt_err,
 };
 
 static match_table_t tokens = {
-	{Opt_scsiid, "scsi_id=%s"},
-	{Opt_scsisn, "scsi_sn=%s"},
+	{Opt_scsi_id, "scsi_id=%s"},
+	{Opt_scsi_sn, "scsi_sn=%s"},
 	{Opt_err, NULL},
 };
 
@@ -310,13 +310,13 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 		dprintf("*p : %s\n", p);
 		token = match_token(p, tokens, args);
 		switch (token) {
-		case Opt_scsiid:
-			match_strncpy(lu->attrs->scsi_id, &args[0],
-				      sizeof(lu->attrs->scsi_id) - 1);
+		case Opt_scsi_id:
+			match_strncpy(lu->attrs.scsi_id, &args[0],
+				      sizeof(lu->attrs.scsi_id) - 1);
 			break;
-		case Opt_scsisn:
-			match_strncpy(lu->attrs->scsi_sn, &args[0],
-				      sizeof(lu->attrs->scsi_sn) - 1);
+		case Opt_scsi_sn:
+			match_strncpy(lu->attrs.scsi_sn, &args[0],
+				      sizeof(lu->attrs.scsi_sn) - 1);
 			break;
 		default:
 			err = TGTADM_INVALID_REQUEST;
@@ -327,16 +327,12 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 
 int spc_lu_init(struct scsi_lu *lu)
 {
-	lu->attrs = zalloc(sizeof(struct lu_phy_attr));
-	if (!lu->attrs)
-		return -ENOMEM;
-
-	memcpy(lu->attrs->vendor_id, VENDOR_ID, 8);
-	memcpy(lu->attrs->product_rev, "0001", 4);
-	lu->attrs->is_removable = 0;
-	lu->attrs->sense_format = 0;
-	lu->attrs->online = 0;
-	lu->attrs->reset = 1;
+	strncpy(lu->attrs.vendor_id, VENDOR_ID, strlen(VENDOR_ID));
+	memcpy(lu->attrs.product_rev, "0001", 4);
+	lu->attrs.removable = 0;
+	lu->attrs.sense_format = 0;
+	lu->attrs.online = 0;
+	lu->attrs.reset = 1;
 
 	return 0;
 }
diff --git a/usr/target.c b/usr/target.c
index 5b74be1..9170310 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -252,9 +252,9 @@ int tgt_device_create(int tid, uint64_t lun, char *args)
 		err = target->dev_type_template.lu_init(lu);
 
 	if (!err) {
-		snprintf(lu->attrs->scsi_id, sizeof(lu->attrs->scsi_id),
+		snprintf(lu->attrs.scsi_id, sizeof(lu->attrs.scsi_id),
 			 "deadbeaf%d:%" PRIu64, tid, lun);
-		snprintf(lu->attrs->scsi_sn, sizeof(lu->attrs->scsi_sn),
+		snprintf(lu->attrs.scsi_sn, sizeof(lu->attrs.scsi_sn),
 			 "beaf%d%" PRIu64, tid, lun);
 	}
 
@@ -1126,8 +1126,8 @@ int tgt_target_show_all(char *buf, int rest)
 				 _TAB3 "Size: %s\n"
 				 _TAB3 "Backing store: %s\n",
 				 lu->lun,
-				 lu->attrs->scsi_id,
-				 lu->attrs->scsi_sn,
+				 lu->attrs.scsi_id,
+				 lu->attrs.scsi_sn,
 				 print_disksize(lu->size),
 				 lu->path);
 
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 7b64655..e214fbb 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -40,8 +40,8 @@ struct lu_phy_attr {
 	char product_rev[5];
 	uint16_t version_desc[VERSION_DESCRIPTOR_LEN];
 
-	char is_removable;	/* Removable media */
-	char online;		/* Logical Unit online ? */
+	char removable;		/* Removable media */
+	char online;		/* Logical Unit online */
 	char reset;		/* Power-on or reset has occured */
 	char sense_format;	/* Descrptor format sense data supported */
 };
@@ -63,7 +63,7 @@ struct scsi_lu {
 	uint64_t reserve_id;
 
 	/* TODO: needs a structure for lots of device parameters */
-	struct lu_phy_attr *attrs;
+	struct lu_phy_attr attrs;
 };
 
 struct scsi_cmd {
-- 
1.5.2.1







From markh794 at gmail.com  Fri Jun 15 09:59:16 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 15 Jun 2007 17:59:16 +1000
Subject: [Stgt-devel] [Patch 2/2] Dynamic logical unit configuration
Message-ID: <467246D4.9020901@gmail.com>

>From e7fe3668dae6d3654b59b1f3b889431ea2d284b8 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Fri, 15 Jun 2007 17:49:25 +1000
Subject: Dynamic logical unit configuration.

Add support to set/configure:
 Vendor Identification
 Product Identification
 Product Revision
 Returned format of sense data
 Define if lu is capable of supporting removable media
 Define if lu is online/offline

Initial documentation of supported options (doc/README.lu_configuration)

Sample script to set up lu (scripts/tgt-core-test)

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 doc/README.lu_configuration |   69 +++++++++++++++++++++++++++++++++++++++
 scripts/tgt-core-test       |   76 +++++++++++++++++++++++++++++++++++++++++++
 usr/mmc.c                   |    2 +-
 usr/osd.c                   |    2 +-
 usr/sbc.c                   |    2 +-
 usr/spc.c                   |   38 ++++++++++++++++++++-
 6 files changed, 184 insertions(+), 5 deletions(-)
 create mode 100644 doc/README.lu_configuration
 create mode 100755 scripts/tgt-core-test

diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
new file mode 100644
index 0000000..1244bc0
--- /dev/null
+++ b/doc/README.lu_configuration
@@ -0,0 +1,69 @@
+Preface
+--------------
+This show a simple example to set up some logical units (lu).
+Please refer to README.iscsi on instructions to create logical unit(s).
+
+tgtadm options
+--------------
+You are able to modify some logical unit parameters as well as
+modify behaviour of SCSI Sense op code.
+
+NOTE: It is not recommended to change these parameters after the
+target/logical unit has been enabled to accept initiators.
+
+It is currently possible to change/modify the following:
+
+ Vendor Identification
+ Product Identification
+ Product Revision
+ Format of returned 'sense data'
+ Define if the lu is capable of supporting removable media
+ Define/set if the lu is online / offline.
+ Params are passed using the 'tgtadm' utility:
+
+Format of options are:
+ vendor_id="string"
+ product_id="string"
+ product_rev="string"
+ removable=<0|1> - 0 = non-removable, 1 = removable media
+ sense_format=<0|1> - 0 = Clasic sense format, 1 = Support descriptor format
+ online=<0|1> - 0 == Unit offline, 1 == Unit Online
+
+The options are passed to the logical unit via the "--params" switch to tgtadm
+
+e.g.
+tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
+            --params vendor_id=QUANTUM,product_id=HD100,product_rev=0010
+tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
+            --params removable=1,sense_format=1,online=1
+
+Or it can be performed in one go:
+tgtadm --lld iscsi --mode logicalunit --op update --tid <TID> --lun <LUN> \
+    --params vendor_id=QUANTUM,product_id=HD100,product_rev=0010,scsi_sn=FRED00,removable=1,sense_format=0,online=1
+
+
+# sg_inq -v /dev/sg5
+    inquiry cdb: 12 00 00 00 24 00
+standard INQUIRY:
+    inquiry cdb: 12 00 00 00 42 00
+  PQual=0  Device_type=0  RMB=1  version=0x05  [SPC-3]
+  [AERC=0]  [TrmTsk=1]  NormACA=0  HiSUP=0  Resp_data_format=2
+  SCCS=0  ACC=0  TGPS=0  3PC=0  Protect=0  BQue=0
+  EncServ=0  MultiP=0  [MChngr=0]  [ACKREQQ=0]  Addr16=0
+  [RelAdr=0]  WBus16=0  Sync=0  Linked=0  [TranDis=0]  CmdQue=1
+  Clocking=0x0  QAS=0  IUS=0
+    length=66 (0x42)   Peripheral device type: disk
+ Vendor identification: QUANTUM
+ Product identification: HD100
+ Product revision level: 0010
+    inquiry cdb: 12 01 00 00 fc 00
+    inquiry: requested 252 bytes but got 7 bytes
+    inquiry cdb: 12 01 80 00 fc 00
+    inquiry: requested 252 bytes but got 12 bytes
+ Unit serial number: FRED00
+
+As can be seen from above 'sg_inq' output, the RMB (removable) bit is set to 1.
+The Unit serial number page updated with 'FRED00'
+
+Please refer to scripts/tgt-core-test for a working example.
+
diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
new file mode 100755
index 0000000..1bbb404
--- /dev/null
+++ b/scripts/tgt-core-test
@@ -0,0 +1,76 @@
+#!/bin/bash
+
+# Parent directory for data files..
+HOME=/d/01
+
+P=`ps -ef|grep -v grep|grep tgtd|wc -l`
+if [ "X"$P == "X0" ]; then
+	tgtd -d 1
+	sleep 1
+fi
+
+if [ ! -d $HOME ]; then
+	mkdir -p $HOME
+fi
+
+if [ ! -f $HOME/hd_block ]; then
+	dd if=/dev/zero of=$HOME/hd_block bs=1M count=8
+fi
+if [ ! -f $HOME/cd_block0 ]; then
+	dd if=/dev/zero of=$HOME/cd_block0 bs=1M count=8
+fi
+if [ ! -f $HOME/cd_block1 ]; then
+	dd if=/dev/zero of=$HOME/cd_block1 bs=1M count=8
+fi
+if [ ! -f $HOME/cd_block2 ]; then
+	dd if=/dev/zero of=$HOME/cd_block2 bs=1M count=8
+fi
+
+set -x
+
+###################################################################################
+# Set up SBC HDD device
+###################################################################################
+TID=1
+
+tgtadm --lld iscsi --mode target --op new --tid $TID \
+		-T iqn.2007-03:marks-vtl_sbc:`hostname` --target-type disk
+
+sleep 1
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b $HOME/hd_block
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 --params scsi_sn=FRED00,scsi_id=Fred
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
+	--params vendor_id=QUANTUM,product_id=HD100,product_rev=0010,removable=1,sense_format=0
+
+
+tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
+
+
+###################################################################################
+# Set up MMC CD/DVD device
+###################################################################################
+TID=2
+
+tgtadm --lld iscsi --mode target --op new --tid $TID \
+		-T iqn.2007-03:marks-vtl_mmc:`hostname` --target-type cd
+
+sleep 1
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b $HOME/cd_block0
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
+	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY10,removable=1
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 1 -b $HOME/cd_block1
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 1 \
+	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY11,removable=1
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 2 -b $HOME/cd_block2
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 2 \
+	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY12,removable=1
+
+tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
+
+tgtadm --lld iscsi --mode target --op show
+
+
diff --git a/usr/mmc.c b/usr/mmc.c
index 0ac5f72..adecd4c 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -126,7 +126,7 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
-	memcpy(lu->attrs.product_id, "VIRTUAL-CDROM", 16);
+	strncpy(lu->attrs.product_id, "VIRTUAL-CDROM", sizeof(lu->attrs.product_id));
 	lu->attrs.sense_format = 0;
 	lu->attrs.version_desc[0] = 0x02A0; /* MMC3, no version claimed */
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
diff --git a/usr/osd.c b/usr/osd.c
index 33d6455..a7316fa 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -56,7 +56,7 @@ static int osd_lu_init(struct scsi_lu *lu)
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
-	memcpy(lu->attrs.product_id, "OSD", 16);
+	strncpy(lu->attrs.product_id, "OSD", sizeof(lu->attrs.product_id));
 	lu->attrs.sense_format = 1;
 	lu->attrs.version_desc[0] = 0x0340; /* OSD */
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
diff --git a/usr/sbc.c b/usr/sbc.c
index 8fe39e7..3d59f60 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -342,7 +342,7 @@ static int sbc_lu_init(struct scsi_lu *lu)
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
-	memcpy(lu->attrs.product_id, "VIRTUAL-DISK", 16);
+	strncpy(lu->attrs.product_id, "VIRTUAL-DISK", sizeof(lu->attrs.product_id));
 	lu->attrs.version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
 	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
diff --git a/usr/spc.c b/usr/spc.c
index 602af5d..a6234ca 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -286,18 +286,29 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 }
 
 enum {
-	Opt_scsi_id, Opt_scsi_sn, Opt_err,
+	Opt_scsi_id, Opt_scsi_sn,
+	Opt_vendor_id, Opt_product_id,
+	Opt_product_rev, Opt_sense_format,
+	Opt_removable, Opt_online,
+	Opt_err,
 };
 
 static match_table_t tokens = {
 	{Opt_scsi_id, "scsi_id=%s"},
 	{Opt_scsi_sn, "scsi_sn=%s"},
+	{Opt_vendor_id, "vendor_id=%s"},
+	{Opt_product_id, "product_id=%s"},
+	{Opt_product_rev, "product_rev=%s"},
+	{Opt_sense_format, "sense_format=%s"},
+	{Opt_removable, "removable=%s"},
+	{Opt_online, "online=%s"},
 	{Opt_err, NULL},
 };
 
 int spc_lu_config(struct scsi_lu *lu, char *params) {
 	int err = 0;
 	char *p;
+	char buf[20];
 
 	if (!strncmp("targetOps", params, 9))
 		params = params + 10;
@@ -307,7 +318,6 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 		int token;
 		if (!*p)
 			continue;
-		dprintf("*p : %s\n", p);
 		token = match_token(p, tokens, args);
 		switch (token) {
 		case Opt_scsi_id:
@@ -318,6 +328,30 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			match_strncpy(lu->attrs.scsi_sn, &args[0],
 				      sizeof(lu->attrs.scsi_sn) - 1);
 			break;
+		case Opt_vendor_id:
+			match_strncpy(lu->attrs.vendor_id, &args[0],
+					sizeof(lu->attrs.vendor_id));
+			break;
+		case Opt_product_id:
+			match_strncpy(lu->attrs.product_id, &args[0],
+					sizeof(lu->attrs.product_id));
+			break;
+		case Opt_product_rev:
+			match_strncpy(lu->attrs.product_rev, &args[0],
+					sizeof(lu->attrs.product_rev));
+			break;
+		case Opt_sense_format:
+			match_strncpy(buf, &args[0],  sizeof(buf));
+			lu->attrs.sense_format = atoi(buf);
+			break;
+		case Opt_removable:
+			match_strncpy(buf, &args[0],  sizeof(buf));
+			lu->attrs.removable = atoi(buf);
+			break;
+		case Opt_online:
+			match_strncpy(buf, &args[0],  sizeof(buf));
+			lu->attrs.online = atoi(buf);
+			break;
 		default:
 			err = TGTADM_INVALID_REQUEST;
 		}
-- 
1.5.2.1







From markh794 at gmail.com  Fri Jun 15 10:02:27 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 15 Jun 2007 18:02:27 +1000
Subject: [Stgt-devel] [Patch 0/2] Re-post after re-work
Message-ID: <46724793.5070100@gmail.com>

Re-posting previous patches after a re-work.

This time, the [Patch 1/2] 'merge phy_attr sturct' is applied before 
'[patch 2/2] Dynamic config'

Feedback (as always) welcome.

Cheers
Mark



From waldi at berlios.de  Fri Jun 15 15:03:05 2007
From: waldi at berlios.de (Bastian Blank)
Date: Fri, 15 Jun 2007 15:03:05 +0200
Subject: [Stgt-devel] [Patch 1/2] Merge lu_phy_attr struct into scsi_lu
In-Reply-To: <467245DF.9020605@gmail.com>
References: <467245DF.9020605@gmail.com>
Message-ID: <20070615130305.GA19709@wavehammer.waldi.eu.org>

On Fri, Jun 15, 2007 at 05:55:11PM +1000, Mark Harvey wrote:
> +	memcpy(lu->attrs.product_id, "OSD", 16);

This code leaks 12 bytes of memory. "OSD" is 4 bytes long and
nullterminated. The whole thing is undefined behaviour.

Bastian

-- 
	"We have the right to survive!"
	"Not by killing others."
		-- Deela and Kirk, "Wink of An Eye", stardate 5710.5


From markh794 at gmail.com  Sat Jun 16 00:16:17 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 16 Jun 2007 08:16:17 +1000
Subject: [Stgt-devel] [Patch 1/2] Merge lu_phy_attr struct into scsi_lu
In-Reply-To: <20070615130305.GA19709@wavehammer.waldi.eu.org>
References: <467245DF.9020605@gmail.com>
	<20070615130305.GA19709@wavehammer.waldi.eu.org>
Message-ID: <f29db9a80706151516i17fe61a8o81b705f6e90ef47c@mail.gmail.com>

On 6/15/07, Bastian Blank <waldi at berlios.de> wrote:
> On Fri, Jun 15, 2007 at 05:55:11PM +1000, Mark Harvey wrote:
> > +     memcpy(lu->attrs.product_id, "OSD", 16);
>
> This code leaks 12 bytes of memory. "OSD" is 4 bytes long and
> nullterminated. The whole thing is undefined behaviour.
>

Darn.. One of these days I'll get this patch generation concept worked out...

This is fixed in [Patch 2/2].. Along with other 'Dynamic Logical Unit
configuration' changes.

I'll re-do the two patches yet again. This time I plan on getting the
right bits in each patch :)

Thanks for pointing this out.

Mark

> Bastian
>
> --
>         "We have the right to survive!"
>         "Not by killing others."
>                 -- Deela and Kirk, "Wink of An Eye", stardate 5710.5
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
>


From fujita.tomonori at lab.ntt.co.jp  Sat Jun 16 07:46:49 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 16 Jun 2007 14:46:49 +0900
Subject: [Stgt-devel] [Patch 0/2]
In-Reply-To: <466FA31E.8000106@gmail.com>
References: <466FA31E.8000106@gmail.com>
Message-ID: <200706160546.l5G5koVw020156@mbox.iij4u.or.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 0/2]
Date: Wed, 13 Jun 2007 17:56:14 +1000

> Patch 1 : Add dynamic lu configuration.
> Patch 2 : Move lu_phy_attr into scsi_lu structure.
> 
> Patch 2 depends on patch 1 being applied first.
> It would probably have made more sense to do it the other way around...
> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>

Applied, thanks a lot.

BTW, seems that you found the proper way to send patches with
gmail. How do you do that?


From markh794 at gmail.com  Sat Jun 16 07:53:11 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 16 Jun 2007 15:53:11 +1000
Subject: [Stgt-devel] [Patch 0/2]
In-Reply-To: <200706160546.l5G5koVw020156@mbox.iij4u.or.jp>
References: <466FA31E.8000106@gmail.com>
	<200706160546.l5G5koVw020156@mbox.iij4u.or.jp>
Message-ID: <f29db9a80706152253p15a0e5c4re7cc32a516af5fb5@mail.gmail.com>

On 6/16/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: Mark Harvey <markh794 at gmail.com>
> Subject: [Stgt-devel] [Patch 0/2]
> Date: Wed, 13 Jun 2007 17:56:14 +1000
>
> > Patch 1 : Add dynamic lu configuration.
> > Patch 2 : Move lu_phy_attr into scsi_lu structure.
> >
> > Patch 2 depends on patch 1 being applied first.
> > It would probably have made more sense to do it the other way around...
> >
> > Signed-off-by: Mark Harvey <markh794 at gmail.com>
>
> Applied, thanks a lot.
>
> BTW, seems that you found the proper way to send patches with
> gmail. How do you do that?
>

http://www.linux-mips.org/wiki/Mailing-patches

I use Thunderbird / gmail pop access &  'Thunderbird recipe #1' from above page.

Which means I have to wait until I access the net from home to submit
patches due to firewall rules from work's network.

Thanks for confirming this works correctly.

Mark


From fujita.tomonori at lab.ntt.co.jp  Sun Jun 17 06:29:33 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 17 Jun 2007 13:29:33 +0900
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <20070615133612Q.fujita.tomonori@lab.ntt.co.jp>
References: <20070612213358F.fujita.tomonori@lab.ntt.co.jp>
	<466E9513.9030303@suse.de>
	<20070615133612Q.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <200706170429.l5H4TY4x030387@mbox.iij4u.or.jp>

From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
Date: Fri, 15 Jun 2007 13:36:12 +0900

> From: Hannes Reinecke <hare at suse.de>
> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> Date: Tue, 12 Jun 2007 14:44:03 +0200
> 
> > FUJITA Tomonori wrote:
> > > From: Hannes Reinecke <hare at suse.de>
> > > Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> > > Date: Mon, 11 Jun 2007 17:15:19 +0200
> > > 
> > >> Pete Wyckoff wrote:
> > >>> hare at suse.de wrote on Tue, 05 Jun 2007 15:38 +0200:
> > >>>> This patch moves the device type down to the LUN structure.
> > >>>> And in doing so we now also have the proper peripheral device
> > >>>> type and peripheral device qualifier attributes for the INQUIRY
> > >>>> data.
> > >>> Makes sense to me too.
> > >>>
> > >>>> One thing puzzles me, though: do we support commands with no
> > >>>> LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
> > >>>> If so: where is the point here? If that's our handling of a
> > >>>> non-existing LUN 0 we should rather add a proper LUN 0 and
> > >>>> treat cmd->dev == NULL as an error case ...
> > >>> In the SCSI model, every device must have at least one LUN for
> > >>> handling REPORT LUNS and a couple other commands.  It is addressed
> > >>> as LUN 0 or using the "well-known" LUN for the command.  In the stgt
> > >>> abstraction, though, there is no magic LUN like this.  Instead
> > >>> things like spc_inqury use cmd->dev == NULL to handle this case.
> > >>>
> > >> Ah. Hence.
> > >>
> > >>> Perhaps it is reasonable to create a special device for these
> > >>> commands.  Up in target.c, you could assign cmd->dev to target->dev,
> > >>> where that is the special device, paralleling the way that
> > >>> target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
> > >>> ... else ILLEGAL_REQUEST" clauses can be removed from device code
> > >>> too.
> > >>>
> > >> Well, I actually thought of creating a proper LUN 0 with type 0xc.
> > > 
> > > We still need to handle cmd->dev == NULL case though probably we can
> > > remove cmd->dev == NULL case in device type code.
> > > 
> > > I don't have storage systems that work in your way. Is it common?
> > > 
> > > 
> > Yes, quite common. HP and EMC (to name but a few) do it this way.
> > Most storage arrays actually refuse to attach any devices to LUN0, as
> > this is a pure management LUN.
> > 
> > I will draft up a patch which creates a proper controller LUN0.
> 
> Ok, here's a patch. This depends on the patch that I've just
> submitted.
> 
> This adds scc support and fixes ibmvio. iSCSI works. ibmvio works for
> me, but it detects scsi devices in a unique way, so I'm not sure it
> works for everyone.
> 
> As described, a scsi controler device is automatically created as lun0
> with a new target.
> 
> lily:/home/fujita# ./tgt/usr/tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
> lily:/home/fujita# ./tgt/usr/tgtadm --op show --mode target
> Target 1: iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
>     System information:
>         Driver: iscsi
>         Status: running
>     I_T nexus information:
>     LUN information:
>         LUN: 0
>             Type: raid
>             SCSI ID: deadbeaf1:0
>             SCSI SN: beaf10
>             Size: 0
>             Backing store: No backing store
>     Account information:
>     ACL information:
> 
> 
> The patch is still very hacky but shows how it works. Let me know this
> works or not.

I did some cleanups.

http://git.kernel.org/?p=linux/kernel/git/tomo/tgt.git;a=shortlog;h=scc



From hare at suse.de  Mon Jun 18 08:29:13 2007
From: hare at suse.de (Hannes Reinecke)
Date: Mon, 18 Jun 2007 08:29:13 +0200
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <200706170429.l5H4TY4x030387@mbox.iij4u.or.jp>
References: <20070612213358F.fujita.tomonori@lab.ntt.co.jp>	<466E9513.9030303@suse.de>	<20070615133612Q.fujita.tomonori@lab.ntt.co.jp>
	<200706170429.l5H4TY4x030387@mbox.iij4u.or.jp>
Message-ID: <46762639.7000301@suse.de>

FUJITA Tomonori wrote:
> From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> Date: Fri, 15 Jun 2007 13:36:12 +0900
> 
>> From: Hannes Reinecke <hare at suse.de>
>> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
>> Date: Tue, 12 Jun 2007 14:44:03 +0200
>>
>>> FUJITA Tomonori wrote:
>>>> From: Hannes Reinecke <hare at suse.de>
>>>> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
>>>> Date: Mon, 11 Jun 2007 17:15:19 +0200
>>>>
>>>>> Pete Wyckoff wrote:
>>>>>> hare at suse.de wrote on Tue, 05 Jun 2007 15:38 +0200:
>>>>>>> This patch moves the device type down to the LUN structure.
>>>>>>> And in doing so we now also have the proper peripheral device
>>>>>>> type and peripheral device qualifier attributes for the INQUIRY
>>>>>>> data.
>>>>>> Makes sense to me too.
>>>>>>
>>>>>>> One thing puzzles me, though: do we support commands with no
>>>>>>> LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
>>>>>>> If so: where is the point here? If that's our handling of a
>>>>>>> non-existing LUN 0 we should rather add a proper LUN 0 and
>>>>>>> treat cmd->dev == NULL as an error case ...
>>>>>> In the SCSI model, every device must have at least one LUN for
>>>>>> handling REPORT LUNS and a couple other commands.  It is addressed
>>>>>> as LUN 0 or using the "well-known" LUN for the command.  In the stgt
>>>>>> abstraction, though, there is no magic LUN like this.  Instead
>>>>>> things like spc_inqury use cmd->dev == NULL to handle this case.
>>>>>>
>>>>> Ah. Hence.
>>>>>
>>>>>> Perhaps it is reasonable to create a special device for these
>>>>>> commands.  Up in target.c, you could assign cmd->dev to target->dev,
>>>>>> where that is the special device, paralleling the way that
>>>>>> target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
>>>>>> ... else ILLEGAL_REQUEST" clauses can be removed from device code
>>>>>> too.
>>>>>>
>>>>> Well, I actually thought of creating a proper LUN 0 with type 0xc.
>>>> We still need to handle cmd->dev == NULL case though probably we can
>>>> remove cmd->dev == NULL case in device type code.
>>>>
>>>> I don't have storage systems that work in your way. Is it common?
>>>>
>>>>
>>> Yes, quite common. HP and EMC (to name but a few) do it this way.
>>> Most storage arrays actually refuse to attach any devices to LUN0, as
>>> this is a pure management LUN.
>>>
>>> I will draft up a patch which creates a proper controller LUN0.
>> Ok, here's a patch. This depends on the patch that I've just
>> submitted.
>>
>> This adds scc support and fixes ibmvio. iSCSI works. ibmvio works for
>> me, but it detects scsi devices in a unique way, so I'm not sure it
>> works for everyone.
>>
>> As described, a scsi controler device is automatically created as lun0
>> with a new target.
>>
>> lily:/home/fujita# ./tgt/usr/tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
>> lily:/home/fujita# ./tgt/usr/tgtadm --op show --mode target
>> Target 1: iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
>>     System information:
>>         Driver: iscsi
>>         Status: running
>>     I_T nexus information:
>>     LUN information:
>>         LUN: 0
>>             Type: raid
>>             SCSI ID: deadbeaf1:0
>>             SCSI SN: beaf10
>>             Size: 0
>>             Backing store: No backing store
>>     Account information:
>>     ACL information:
>>
>>
>> The patch is still very hacky but shows how it works. Let me know this
>> works or not.
> 
> I did some cleanups.
> 
> http://git.kernel.org/?p=linux/kernel/git/tomo/tgt.git;a=shortlog;h=scc
> 
Regarding the disk_type_names cleanups:
- What is the rationale for this? Just truncating the full name to
something unintelligible doesn't seem like the smartest move to me,
especially as we're not facing any string length restrictions here ...

Regarding device type registration cleanups:
- We're losing the ability to select sg_bst for passthrough during
  registration. Is that intentional?

Cheers,

Hannes
-- 
Dr. Hannes Reinecke		      zSeries & Storage
hare at suse.de			      +49 911 74053 688
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
GF: Markus Rex, HRB 16746 (AG N?rnberg)


From fujita.tomonori at lab.ntt.co.jp  Mon Jun 18 08:41:32 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 18 Jun 2007 15:41:32 +0900
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <46762639.7000301@suse.de>
References: <20070615133612Q.fujita.tomonori@lab.ntt.co.jp>
	<200706170429.l5H4TY4x030387@mbox.iij4u.or.jp>
	<46762639.7000301@suse.de>
Message-ID: <20070618154132P.fujita.tomonori@lab.ntt.co.jp>

From: Hannes Reinecke <hare at suse.de>
Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
Date: Mon, 18 Jun 2007 08:29:13 +0200

> FUJITA Tomonori wrote:
> > From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
> > Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> > Date: Fri, 15 Jun 2007 13:36:12 +0900
> > 
> >> From: Hannes Reinecke <hare at suse.de>
> >> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> >> Date: Tue, 12 Jun 2007 14:44:03 +0200
> >>
> >>> FUJITA Tomonori wrote:
> >>>> From: Hannes Reinecke <hare at suse.de>
> >>>> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> >>>> Date: Mon, 11 Jun 2007 17:15:19 +0200
> >>>>
> >>>>> Pete Wyckoff wrote:
> >>>>>> hare at suse.de wrote on Tue, 05 Jun 2007 15:38 +0200:
> >>>>>>> This patch moves the device type down to the LUN structure.
> >>>>>>> And in doing so we now also have the proper peripheral device
> >>>>>>> type and peripheral device qualifier attributes for the INQUIRY
> >>>>>>> data.
> >>>>>> Makes sense to me too.
> >>>>>>
> >>>>>>> One thing puzzles me, though: do we support commands with no
> >>>>>>> LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
> >>>>>>> If so: where is the point here? If that's our handling of a
> >>>>>>> non-existing LUN 0 we should rather add a proper LUN 0 and
> >>>>>>> treat cmd->dev == NULL as an error case ...
> >>>>>> In the SCSI model, every device must have at least one LUN for
> >>>>>> handling REPORT LUNS and a couple other commands.  It is addressed
> >>>>>> as LUN 0 or using the "well-known" LUN for the command.  In the stgt
> >>>>>> abstraction, though, there is no magic LUN like this.  Instead
> >>>>>> things like spc_inqury use cmd->dev == NULL to handle this case.
> >>>>>>
> >>>>> Ah. Hence.
> >>>>>
> >>>>>> Perhaps it is reasonable to create a special device for these
> >>>>>> commands.  Up in target.c, you could assign cmd->dev to target->dev,
> >>>>>> where that is the special device, paralleling the way that
> >>>>>> target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
> >>>>>> ... else ILLEGAL_REQUEST" clauses can be removed from device code
> >>>>>> too.
> >>>>>>
> >>>>> Well, I actually thought of creating a proper LUN 0 with type 0xc.
> >>>> We still need to handle cmd->dev == NULL case though probably we can
> >>>> remove cmd->dev == NULL case in device type code.
> >>>>
> >>>> I don't have storage systems that work in your way. Is it common?
> >>>>
> >>>>
> >>> Yes, quite common. HP and EMC (to name but a few) do it this way.
> >>> Most storage arrays actually refuse to attach any devices to LUN0, as
> >>> this is a pure management LUN.
> >>>
> >>> I will draft up a patch which creates a proper controller LUN0.
> >> Ok, here's a patch. This depends on the patch that I've just
> >> submitted.
> >>
> >> This adds scc support and fixes ibmvio. iSCSI works. ibmvio works for
> >> me, but it detects scsi devices in a unique way, so I'm not sure it
> >> works for everyone.
> >>
> >> As described, a scsi controler device is automatically created as lun0
> >> with a new target.
> >>
> >> lily:/home/fujita# ./tgt/usr/tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
> >> lily:/home/fujita# ./tgt/usr/tgtadm --op show --mode target
> >> Target 1: iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
> >>     System information:
> >>         Driver: iscsi
> >>         Status: running
> >>     I_T nexus information:
> >>     LUN information:
> >>         LUN: 0
> >>             Type: raid
> >>             SCSI ID: deadbeaf1:0
> >>             SCSI SN: beaf10
> >>             Size: 0
> >>             Backing store: No backing store
> >>     Account information:
> >>     ACL information:
> >>
> >>
> >> The patch is still very hacky but shows how it works. Let me know this
> >> works or not.
> > 
> > I did some cleanups.
> > 
> > http://git.kernel.org/?p=linux/kernel/git/tomo/tgt.git;a=shortlog;h=scc
> > 
> Regarding the disk_type_names cleanups:
> - What is the rationale for this? Just truncating the full name to
> something unintelligible doesn't seem like the smartest move to me,
> especially as we're not facing any string length restrictions here ...

They are the names that lsscsi uses. But I don't have strong
preference.


> Regarding device type registration cleanups:
> - We're losing the ability to select sg_bst for passthrough during
>   registration. Is that intentional?

Yeah. I plan to fix it though I'm not hurry since it needs bsg, which
is supposed to be merged into 2.6.23.


From hare at suse.de  Mon Jun 18 09:33:38 2007
From: hare at suse.de (Hannes Reinecke)
Date: Mon, 18 Jun 2007 09:33:38 +0200
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <20070618154132P.fujita.tomonori@lab.ntt.co.jp>
References: <20070615133612Q.fujita.tomonori@lab.ntt.co.jp>	<200706170429.l5H4TY4x030387@mbox.iij4u.or.jp>	<46762639.7000301@suse.de>
	<20070618154132P.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <46763552.9010804@suse.de>

FUJITA Tomonori wrote:
> From: Hannes Reinecke <hare at suse.de>
> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> Date: Mon, 18 Jun 2007 08:29:13 +0200
> 
>> FUJITA Tomonori wrote:
>>> From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
>>> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
>>> Date: Fri, 15 Jun 2007 13:36:12 +0900
>>>
>>>> From: Hannes Reinecke <hare at suse.de>
>>>> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
>>>> Date: Tue, 12 Jun 2007 14:44:03 +0200
>>>>
>>>>> FUJITA Tomonori wrote:
>>>>>> From: Hannes Reinecke <hare at suse.de>
>>>>>> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
>>>>>> Date: Mon, 11 Jun 2007 17:15:19 +0200
>>>>>>
>>>>>>> Pete Wyckoff wrote:
>>>>>>>> hare at suse.de wrote on Tue, 05 Jun 2007 15:38 +0200:
>>>>>>>>> This patch moves the device type down to the LUN structure.
>>>>>>>>> And in doing so we now also have the proper peripheral device
>>>>>>>>> type and peripheral device qualifier attributes for the INQUIRY
>>>>>>>>> data.
>>>>>>>> Makes sense to me too.
>>>>>>>>
>>>>>>>>> One thing puzzles me, though: do we support commands with no
>>>>>>>>> LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
>>>>>>>>> If so: where is the point here? If that's our handling of a
>>>>>>>>> non-existing LUN 0 we should rather add a proper LUN 0 and
>>>>>>>>> treat cmd->dev == NULL as an error case ...
>>>>>>>> In the SCSI model, every device must have at least one LUN for
>>>>>>>> handling REPORT LUNS and a couple other commands.  It is addressed
>>>>>>>> as LUN 0 or using the "well-known" LUN for the command.  In the stgt
>>>>>>>> abstraction, though, there is no magic LUN like this.  Instead
>>>>>>>> things like spc_inqury use cmd->dev == NULL to handle this case.
>>>>>>>>
>>>>>>> Ah. Hence.
>>>>>>>
>>>>>>>> Perhaps it is reasonable to create a special device for these
>>>>>>>> commands.  Up in target.c, you could assign cmd->dev to target->dev,
>>>>>>>> where that is the special device, paralleling the way that
>>>>>>>> target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
>>>>>>>> ... else ILLEGAL_REQUEST" clauses can be removed from device code
>>>>>>>> too.
>>>>>>>>
>>>>>>> Well, I actually thought of creating a proper LUN 0 with type 0xc.
>>>>>> We still need to handle cmd->dev == NULL case though probably we can
>>>>>> remove cmd->dev == NULL case in device type code.
>>>>>>
>>>>>> I don't have storage systems that work in your way. Is it common?
>>>>>>
>>>>>>
>>>>> Yes, quite common. HP and EMC (to name but a few) do it this way.
>>>>> Most storage arrays actually refuse to attach any devices to LUN0, as
>>>>> this is a pure management LUN.
>>>>>
>>>>> I will draft up a patch which creates a proper controller LUN0.
>>>> Ok, here's a patch. This depends on the patch that I've just
>>>> submitted.
>>>>
>>>> This adds scc support and fixes ibmvio. iSCSI works. ibmvio works for
>>>> me, but it detects scsi devices in a unique way, so I'm not sure it
>>>> works for everyone.
>>>>
>>>> As described, a scsi controler device is automatically created as lun0
>>>> with a new target.
>>>>
>>>> lily:/home/fujita# ./tgt/usr/tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
>>>> lily:/home/fujita# ./tgt/usr/tgtadm --op show --mode target
>>>> Target 1: iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
>>>>     System information:
>>>>         Driver: iscsi
>>>>         Status: running
>>>>     I_T nexus information:
>>>>     LUN information:
>>>>         LUN: 0
>>>>             Type: raid
>>>>             SCSI ID: deadbeaf1:0
>>>>             SCSI SN: beaf10
>>>>             Size: 0
>>>>             Backing store: No backing store
>>>>     Account information:
>>>>     ACL information:
>>>>
>>>>
>>>> The patch is still very hacky but shows how it works. Let me know this
>>>> works or not.
>>> I did some cleanups.
>>>
>>> http://git.kernel.org/?p=linux/kernel/git/tomo/tgt.git;a=shortlog;h=scc
>>>
>> Regarding the disk_type_names cleanups:
>> - What is the rationale for this? Just truncating the full name to
>> something unintelligible doesn't seem like the smartest move to me,
>> especially as we're not facing any string length restrictions here ...
> 
> They are the names that lsscsi uses. But I don't have strong
> preference.
> 
Well, lsscsi has string length limitations as the output has to be
neatly arranged in colums; we're not facing these limitations here.
So I'd prefer to have legible names.

> 
>> Regarding device type registration cleanups:
>> - We're losing the ability to select sg_bst for passthrough during
>>   registration. Is that intentional?
> 
> Yeah. I plan to fix it though I'm not hurry since it needs bsg, which
> is supposed to be merged into 2.6.23.
Ah. Cool. I'll wait for it, then.

The other patches look ok to me. I see if I manage to give them a spin.

Cheers,

Hannes
-- 
Dr. Hannes Reinecke		      zSeries & Storage
hare at suse.de			      +49 911 74053 688
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
GF: Markus Rex, HRB 16746 (AG N?rnberg)


From fujita.tomonori at lab.ntt.co.jp  Mon Jun 18 10:32:18 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 18 Jun 2007 17:32:18 +0900 (JST)
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <46763552.9010804@suse.de>
References: <46762639.7000301@suse.de>
	<20070618154132P.fujita.tomonori@lab.ntt.co.jp>
	<46763552.9010804@suse.de>
Message-ID: <20070618090311Q.fujita.tomonori@lab.ntt.co.jp>

From: Hannes Reinecke <hare at suse.de>
Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
Date: Mon, 18 Jun 2007 09:33:38 +0200

> FUJITA Tomonori wrote:
> > From: Hannes Reinecke <hare at suse.de>
> > Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> > Date: Mon, 18 Jun 2007 08:29:13 +0200
> > 
> >> FUJITA Tomonori wrote:
> >>> From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
> >>> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> >>> Date: Fri, 15 Jun 2007 13:36:12 +0900
> >>>
> >>>> From: Hannes Reinecke <hare at suse.de>
> >>>> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> >>>> Date: Tue, 12 Jun 2007 14:44:03 +0200
> >>>>
> >>>>> FUJITA Tomonori wrote:
> >>>>>> From: Hannes Reinecke <hare at suse.de>
> >>>>>> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> >>>>>> Date: Mon, 11 Jun 2007 17:15:19 +0200
> >>>>>>
> >>>>>>> Pete Wyckoff wrote:
> >>>>>>>> hare at suse.de wrote on Tue, 05 Jun 2007 15:38 +0200:
> >>>>>>>>> This patch moves the device type down to the LUN structure.
> >>>>>>>>> And in doing so we now also have the proper peripheral device
> >>>>>>>>> type and peripheral device qualifier attributes for the INQUIRY
> >>>>>>>>> data.
> >>>>>>>> Makes sense to me too.
> >>>>>>>>
> >>>>>>>>> One thing puzzles me, though: do we support commands with no
> >>>>>>>>> LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
> >>>>>>>>> If so: where is the point here? If that's our handling of a
> >>>>>>>>> non-existing LUN 0 we should rather add a proper LUN 0 and
> >>>>>>>>> treat cmd->dev == NULL as an error case ...
> >>>>>>>> In the SCSI model, every device must have at least one LUN for
> >>>>>>>> handling REPORT LUNS and a couple other commands.  It is addressed
> >>>>>>>> as LUN 0 or using the "well-known" LUN for the command.  In the stgt
> >>>>>>>> abstraction, though, there is no magic LUN like this.  Instead
> >>>>>>>> things like spc_inqury use cmd->dev == NULL to handle this case.
> >>>>>>>>
> >>>>>>> Ah. Hence.
> >>>>>>>
> >>>>>>>> Perhaps it is reasonable to create a special device for these
> >>>>>>>> commands.  Up in target.c, you could assign cmd->dev to target->dev,
> >>>>>>>> where that is the special device, paralleling the way that
> >>>>>>>> target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
> >>>>>>>> ... else ILLEGAL_REQUEST" clauses can be removed from device code
> >>>>>>>> too.
> >>>>>>>>
> >>>>>>> Well, I actually thought of creating a proper LUN 0 with type 0xc.
> >>>>>> We still need to handle cmd->dev == NULL case though probably we can
> >>>>>> remove cmd->dev == NULL case in device type code.
> >>>>>>
> >>>>>> I don't have storage systems that work in your way. Is it common?
> >>>>>>
> >>>>>>
> >>>>> Yes, quite common. HP and EMC (to name but a few) do it this way.
> >>>>> Most storage arrays actually refuse to attach any devices to LUN0, as
> >>>>> this is a pure management LUN.
> >>>>>
> >>>>> I will draft up a patch which creates a proper controller LUN0.
> >>>> Ok, here's a patch. This depends on the patch that I've just
> >>>> submitted.
> >>>>
> >>>> This adds scc support and fixes ibmvio. iSCSI works. ibmvio works for
> >>>> me, but it detects scsi devices in a unique way, so I'm not sure it
> >>>> works for everyone.
> >>>>
> >>>> As described, a scsi controler device is automatically created as lun0
> >>>> with a new target.
> >>>>
> >>>> lily:/home/fujita# ./tgt/usr/tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
> >>>> lily:/home/fujita# ./tgt/usr/tgtadm --op show --mode target
> >>>> Target 1: iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
> >>>>     System information:
> >>>>         Driver: iscsi
> >>>>         Status: running
> >>>>     I_T nexus information:
> >>>>     LUN information:
> >>>>         LUN: 0
> >>>>             Type: raid
> >>>>             SCSI ID: deadbeaf1:0
> >>>>             SCSI SN: beaf10
> >>>>             Size: 0
> >>>>             Backing store: No backing store
> >>>>     Account information:
> >>>>     ACL information:
> >>>>
> >>>>
> >>>> The patch is still very hacky but shows how it works. Let me know this
> >>>> works or not.
> >>> I did some cleanups.
> >>>
> >>> http://git.kernel.org/?p=linux/kernel/git/tomo/tgt.git;a=shortlog;h=scc
> >>>
> >> Regarding the disk_type_names cleanups:
> >> - What is the rationale for this? Just truncating the full name to
> >> something unintelligible doesn't seem like the smartest move to me,
> >> especially as we're not facing any string length restrictions here ...
> > 
> > They are the names that lsscsi uses. But I don't have strong
> > preference.
> > 
> Well, lsscsi has string length limitations as the output has to be
> neatly arranged in colums; we're not facing these limitations here.
> So I'd prefer to have legible names.

ok, how about the following names:

static struct {
	int value;
	char *name;
} disk_type_names[] = {
	{TYPE_DISK, "disk"},
	{TYPE_TAPE, "tape"},
	{TYPE_PRINTER, "printer"},
	{TYPE_PROCESSOR, "processor"},
	{TYPE_WORM, "worm"},
	{TYPE_ROM, "cd/dvd"},
	{TYPE_SCANNER, "scanner"},
	{TYPE_MOD, "optical"},
	{TYPE_MEDIUM_CHANGER, "changer"},
	{TYPE_COMM, "communication"},
	{TYPE_RAID, "controller"},
	{TYPE_ENCLOSURE, "enclosure"},
	{TYPE_RBC, "rbc"},
	{TYPE_OSD, "osd"},
	{TYPE_NO_LUN, "No LUN"}
};


> >> Regarding device type registration cleanups:
> >> - We're losing the ability to select sg_bst for passthrough during
> >>   registration. Is that intentional?
> > 
> > Yeah. I plan to fix it though I'm not hurry since it needs bsg, which
> > is supposed to be merged into 2.6.23.
> Ah. Cool. I'll wait for it, then.
> 
> The other patches look ok to me. I see if I manage to give them a spin.

Let me know the results. Thanks.


From markh794 at gmail.com  Sun Jun 17 23:21:31 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Mon, 18 Jun 2007 07:21:31 +1000
Subject: [Stgt-devel] [Patch 1/2] Fix potential memory leak with ibmvio
Message-ID: <4675A5DB.8090206@gmail.com>

>From 61ceaf62a3e896f86c65f6ea81c80b619f29d001 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Mon, 18 Jun 2007 06:50:39 +1000
Subject: Fix memory leak in ibmvio -> spc_inquiry() path

Allocating data = valloc() twice when calling spc_inquiry()

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/ibmvio/ibmvio.c |   15 +++++++--------
 1 files changed, 7 insertions(+), 8 deletions(-)

diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index ff91f14..ab2c0f2 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -142,17 +142,16 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
 
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = 0;
-		goto sense;
-	}
-	memset(data, 0, pagesize);
-
 	dprintf("%x %x\n", scb[1], scb[2]);
 
 	if (!(scb[1] & 0x3)) {
+		data = valloc(pagesize);
+		if (!data) {
+			key = HARDWARE_ERROR;
+			asc = 0;
+			goto sense;
+		}
+		memset(data, 0, pagesize);
 		cmd->len = __ibmvio_inquiry(host_no, cmd, data);
 		ret = SAM_STAT_GOOD;
 	} else
-- 
1.5.2.1







From markh794 at gmail.com  Sun Jun 17 23:23:41 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Mon, 18 Jun 2007 07:23:41 +1000
Subject: [Stgt-devel] [Patch 2/2] Removed unnecessary test.
Message-ID: <4675A65D.4060601@gmail.com>

>From 69ea0949825629b1e7a844686fb104cb764549a3 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Mon, 18 Jun 2007 06:54:09 +1000
Subject: Removed unused test condition.

Removed test for SAM_STAT_GOOD as this is the only possible condition.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/ibmvio/ibmvio.c |    5 -----
 1 files changed, 0 insertions(+), 5 deletions(-)

diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index ab2c0f2..e4744a8 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -135,7 +135,6 @@ static int __ibmvio_inquiry(int host_no, struct scsi_cmd *cmd, uint8_t *data)
 
 static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 {
-	int ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data, *scb = cmd->scb;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
@@ -153,13 +152,9 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 		}
 		memset(data, 0, pagesize);
 		cmd->len = __ibmvio_inquiry(host_no, cmd, data);
-		ret = SAM_STAT_GOOD;
 	} else
 		return spc_inquiry(host_no, cmd);
 
-	if (ret != SAM_STAT_GOOD)
-		goto sense;
-
 	cmd->len = min_t(int, cmd->len, scb[4]);
 	cmd->uaddr = (unsigned long) data;
 
-- 
1.5.2.1






From markh794 at gmail.com  Mon Jun 18 11:00:52 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Mon, 18 Jun 2007 19:00:52 +1000
Subject: [Stgt-devel] [Patch 1/1] Update SCSI ASC/ASCQ to use a single
	nmemonic value.
Message-ID: <467649C4.7030409@gmail.com>

This patch changes numerical values to use a 16bit define for ASC/ASCQ values.

Due to the lack of imagination, I prefix all ASC/ASCQ with a 'E_'

(I welcome better naming recommendations)

To be applied on top of earlier 'potential memory leak' & 'remove unnecessary test' patches.


>From 51050e165cc371f28164eac9e8eaf64bc4f635ca Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Mon, 18 Jun 2007 18:53:27 +1000
Subject: Use nmemonic codes for SENSE codes instead of numeric value.

Using nmemonic representation for ASC/ASCQ as a 16bit value.
 nmemonic values defined in sense_codes.h
 Updated sense_data_build to accept asc_ascq value.
 Updated spc_request_sense() so it returns some data.
  spc_request_sense() needs more investigation as:
   sg_requests /dev/sgX => returns old (SCSI-1) sense.
   At least it no longer returns an error.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/bs_sync.c       |    3 +-
 usr/ibmvio/ibmvio.c |   15 ++++---
 usr/mmc.c           |    7 ++-
 usr/osd.c           |    5 +-
 usr/sbc.c           |   39 +++++++++++--------
 usr/scsi.c          |   13 +++---
 usr/sense_codes.h   |  103 +++++++++++++++++++++++++++++++++++++++++++++++++++
 usr/spc.c           |   52 ++++++++++++++++++++-----
 usr/spt.c           |    3 +-
 usr/tgtd.h          |    3 +-
 10 files changed, 193 insertions(+), 50 deletions(-)
 create mode 100644 usr/sense_codes.h

diff --git a/usr/bs_sync.c b/usr/bs_sync.c
index 6789b5b..b275720 100644
--- a/usr/bs_sync.c
+++ b/usr/bs_sync.c
@@ -37,6 +37,7 @@
 #include "util.h"
 #include "tgtd.h"
 #include "scsi.h"
+#include "sense_codes.h"
 
 #define NR_WORKER_THREADS	4
 
@@ -161,7 +162,7 @@ static void *bs_sync_worker_fn(void *arg)
 			eprintf("io error %p %x %d %d %" PRIu64 ", %m\n",
 				cmd, cmd->scb[0], ret, cmd->len, cmd->offset);
 			cmd->result = SAM_STAT_CHECK_CONDITION;
-			sense_data_build(cmd, MEDIUM_ERROR, 0x11, 0x0);
+			sense_data_build(cmd, MEDIUM_ERROR, E_READ_ERROR);
 		}
 
 		pthread_mutex_lock(&info->finished_lock);
diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index e4744a8..93bf9de 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -44,6 +44,7 @@
 #include "target.h"
 #include "driver.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
 #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
@@ -136,7 +137,8 @@ static int __ibmvio_inquiry(int host_no, struct scsi_cmd *cmd, uint8_t *data)
 static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	uint8_t *data, *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_INVALID_FIELD_IN_CDB;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
@@ -147,7 +149,7 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 		data = valloc(pagesize);
 		if (!data) {
 			key = HARDWARE_ERROR;
-			asc = 0;
+			asc = E_INTERNAL_TGT_FAILURE;
 			goto sense;
 		}
 		memset(data, 0, pagesize);
@@ -164,7 +166,7 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -185,7 +187,8 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 	int idx, alen, oalen, nr_luns, rbuflen = 4096;
 	int *len = &cmd->len;
 	uint8_t *lun_buf = cmd->lun;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_INVALID_FIELD_IN_CDB;
 
 	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
 	if (alen < 16)
@@ -194,7 +197,7 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -232,7 +235,7 @@ done:
 	return SAM_STAT_GOOD;
 sense:
 	*len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
diff --git a/usr/mmc.c b/usr/mmc.c
index adecd4c..5edd994 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -41,6 +41,7 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define MMC_BLK_SHIFT 11
 
@@ -53,7 +54,7 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 	if (ret) {
 		cmd->offset = 0;
 		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, E_LUN_NOT_SUPPORTED);
 		return SAM_STAT_CHECK_CONDITION;
 	} else {
 		cmd->mmapped = 1;
@@ -69,7 +70,7 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		cmd->len = 0;
-		sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		sense_data_build(cmd, HARDWARE_ERROR, E_INTERNAL_TGT_FAILURE);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
@@ -105,7 +106,7 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		cmd->len = 0;
-		sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		sense_data_build(cmd, HARDWARE_ERROR, E_INTERNAL_TGT_FAILURE);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
diff --git a/usr/osd.c b/usr/osd.c
index a7316fa..3f8b54d 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -33,16 +33,15 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 {
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
-
 	dprintf("cdb[0] %x datalen %u\n", cmd->scb[0], cmd->len);
 	if (cmd->scb[7] != 200 - 8) {
 		eprintf("request size %d wrong, should be 200\n",
 			cmd->scb[7] + 8);
-		sense_data_build(cmd, key, asc, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, E_LUN_NOT_SUPPORTED);
 		cmd->len = 0;
 		return SAM_STAT_CHECK_CONDITION;
 	}
diff --git a/usr/sbc.c b/usr/sbc.c
index 3d59f60..6e56598 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -38,13 +38,15 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define BLK_SHIFT	9
 
 static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_LUN_NOT_SUPPORTED;
 
 	if (cmd->dev) {
 		ret = device_reserved(cmd);
@@ -70,7 +72,7 @@ static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 	} else {
 		cmd->mmapped = 1;
 		return SAM_STAT_GOOD;
@@ -79,7 +81,7 @@ sense:
 	cmd->rw = READ;
 	cmd->offset = 0;
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -95,7 +97,7 @@ static int sbc_reserve(int host_no, struct scsi_cmd *cmd)
 			ret = SAM_STAT_GOOD;
 	} else {
 		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, E_LUN_NOT_SUPPORTED);
 		ret = SAM_STAT_CHECK_CONDITION;
 	}
 	return ret;
@@ -114,7 +116,7 @@ static int sbc_release(int host_no, struct scsi_cmd *cmd)
 			ret = SAM_STAT_GOOD;
 	} else {
 		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, E_LUN_NOT_SUPPORTED);
 		ret = SAM_STAT_CHECK_CONDITION;
 	}
 	return ret;
@@ -125,7 +127,8 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	uint32_t *data;
 	uint64_t size;
 	uint8_t *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_LUN_NOT_SUPPORTED;
 
 	if (cmd->dev) {
 		if (device_reserved(cmd))
@@ -134,14 +137,14 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 		goto sense;
 
 	if (!(scb[8] & 0x1) & (scb[2] | scb[3] | scb[4] | scb[5])) {
-		asc = 0x24;
+		asc = E_INVALID_FIELD_IN_CDB;
 		goto sense;
 	}
 
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	cmd->uaddr = (unsigned long) data;
@@ -156,20 +159,21 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
 static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 {
 	int ret, len;
-	uint8_t key = ILLEGAL_REQUEST, asc;
+	uint8_t key = ILLEGAL_REQUEST;
+	uint16_t asc;
 
 	if (cmd->dev) {
 		if (device_reserved(cmd))
 			return SAM_STAT_RESERVATION_CONFLICT;
 	} else {
-		asc = 0x25;
+		asc = E_LUN_NOT_SUPPORTED;
 		goto sense;
 	}
 
@@ -184,7 +188,7 @@ static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 		 * what should I put for the asc/ascq?
 		 */
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 		goto sense;
 	default:
 		len = 0;
@@ -193,7 +197,7 @@ static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -264,7 +268,8 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	uint8_t pcode = cmd->scb[2] & 0x3f;
 	uint64_t size;
 	uint8_t *data = NULL;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_LUN_NOT_SUPPORTED;
 
 	if (cmd->dev) {
 		if (device_reserved(cmd))
@@ -275,7 +280,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -323,7 +328,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 		len += insert_iec_m_pg(data + len);
 		break;
 	default:
-		asc = 0x24;
+		asc = E_INVALID_FIELD_IN_CDB;
 		goto sense;
 	}
 
@@ -333,7 +338,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	return ret;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
diff --git a/usr/scsi.c b/usr/scsi.c
index c9fb7b6..ba119bf 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -38,27 +38,28 @@
 #include "scsi.h"
 #include "spc.h"
 
-void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
+void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t asc)
 {
+	uint16_t *sense_code;
+
 	if (cmd->dev && cmd->dev->attrs.sense_format) {
 		/* descriptor format */
+		sense_code = (uint16_t *)&cmd->sense_buffer[2];
 
 		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
 		cmd->sense_buffer[1] = key;
-		cmd->sense_buffer[2] = asc;
-		cmd->sense_buffer[3] = asq;
 		cmd->sense_len = 8;
 	} else {
 		/* fixed format */
+		sense_code = (uint16_t *)&cmd->sense_buffer[12];
 
 		int len = 0xa;
-		cmd->sense_buffer[0] = 0x70;
+		cmd->sense_buffer[0] = 0x70;  /* current, not deferred */
 		cmd->sense_buffer[2] = key;
 		cmd->sense_buffer[7] = len;
-		cmd->sense_buffer[12] = asc;
-		cmd->sense_buffer[13] = asq;
 		cmd->sense_len = len + 8;
 	}
+	*sense_code = __cpu_to_be16(asc);
 }
 
 #define        TGT_INVALID_DEV_ID      ~0ULL
diff --git a/usr/sense_codes.h b/usr/sense_codes.h
new file mode 100644
index 0000000..3668a43
--- /dev/null
+++ b/usr/sense_codes.h
@@ -0,0 +1,103 @@
+/*
+ * The SCSI sense key Additional Sense Code / Additional Sense Code Qualifier
+ *
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * SENSE keys
+ */
+#define NO_SENSE		0x00
+#define	RECOVERED_ERROR		0x01
+#define NOT_READY		0x02
+#define MEDIUM_ERROR		0x03
+#define	HARDWARE_ERROR		0x04
+#define ILLEGAL_REQUEST		0x05
+#define UNIT_ATTENTION		0x06
+#define DATA_PROTECT		0x07
+#define	BLANK_CHECK		0x08
+
+/* Key 0: No Sense Errors */
+#define NO_ADDITIONAL_SENSE		0x0000
+#define E_MARK				0x0001
+#define E_EOM				0x0002
+#define E_BOM				0x0004
+#define E_END_OF_DATA			0x0005
+#define E_OP_IN_PROGRESS		0x0016
+#define E_DRIVE_REQUIRES_CLEANING	0x8282
+
+/* Key 1: Recovered Errors */
+#define E_WRITE_ERROR			0x0c00
+#define E_READ_ERROR			0x1100
+#define E_RECOVERED_WITH_RETRYS		0x1701
+#define E_MEDIA_LOAD_EJECT_ERROR	0x5300
+#define E_FAILURE_PREDICTION		0x5d00
+
+/* Key 2: Not ready */
+#define E_CAUSE_NOT_REPORTABLE		0x0400
+#define E_BECOMING_READY		0x0401
+#define E_INITIALIZING_REQUIRED		0x0402
+#define E_CLEANING_CART_INSTALLED	0x3003
+#define E_CLEANING_FAILURE		0x3007
+#define E_MEDIUM_NOT_PRESENT		0x3a00
+#define E_LOGICAL_UNIT_NOT_CONFIG	0x3e00
+
+/* Key 3: Medium Errors */
+#define E_WRITE_ERROR			0x0c00
+#define E_UNRECOVERED_READ		0x1100
+#define E_RECORDED_ENTITY_NOT_FOUND	0x1400
+#define E_UNKNOWN_FORMAT		0x3001
+#define E_IMCOMPATIBLE_FORMAT		0x3002
+#define E_MEDIUM_FORMAT_CORRUPT		0x3100
+#define E_SEQUENTIAL_POSITION_ERR	0x3b00
+#define E_WRITE_APPEND_ERR		0x5000
+#define E_CARTRIDGE_FAULT		0x5200
+#define E_MEDIA_LOAD_OR_EJECT_FAILED	0x5300
+
+/* Key 4: Hardware Failure */
+#define E_COMPRESSION_CHECK		0x0c04
+#define E_DECOMPRESSION_CRC		0x110d
+#define E_MECHANICAL_POSITIONING_ERROR	0x1501
+#define E_MANUAL_INTERVENTION_REQ	0x0403
+#define E_HARDWARE_FAILURE		0x4000
+#define E_INTERNAL_TGT_FAILURE		0x4400
+#define E_ERASE_FAILURE			0x5100
+
+/* Key 5: Illegal Request */
+#define E_PARAMETER_LIST_LENGTH_ERR	0x1a00
+#define E_INVALID_OP_CODE		0x2000
+#define E_INVALID_FIELD_IN_CDB		0x2400
+#define E_LUN_NOT_SUPPORTED		0x2500
+#define E_INVALID_FIELD_IN_PARMS	0x2600
+#define E_SAVING_PARMS_UNSUP		0x3900
+#define E_MEDIUM_DEST_FULL		0x3b0d
+#define E_MEDIUM_SRC_EMPTY		0x3b0e
+#define E_POSITION_PAST_BOM		0x3b0c
+#define E_MEDIUM_REMOVAL_PREVENTED	0x5302
+#define E_BAD_MICROCODE_DETECTED	0x8283
+
+/* Key 6: Unit Attention */
+#define E_NOT_READY_TO_TRANSITION	0x2800
+#define E_POWERON_RESET			0x2900
+#define E_MODE_PARAMETERS_CHANGED	0x2a01
+#define E_INSUFFICIENT_TIME_FOR_OPERATION	0x2e00
+#define E_MICROCODE_DOWNLOADED		0x3f01
+#define E_FAILURE_PREDICTION_FALSE	0x5dff
+#define E_INQUIRY_DATA_HAS_CHANGED	0x3f03
+
+/* Data Protect */
+#define E_WRITE_PROTECT			0x2700
+#define E_MEDIUM_OVERWRITE_ATTEMPTED	0x300c
diff --git a/usr/spc.c b/usr/spc.c
index a6234ca..061a4dd 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -34,6 +34,7 @@
 #include "tgtadm_error.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define PRODUCT_REV	"0"
 #define BLK_SHIFT	9
@@ -44,7 +45,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	uint8_t *data;
 	uint8_t *scb = cmd->scb;
 	unsigned char device_type = cmd->c_target->dev_type_template.type;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_INVALID_FIELD_IN_CDB;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
@@ -52,7 +54,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -146,7 +148,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -156,7 +158,8 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	struct list_head *dev_list = &cmd->c_target->device_list;
 	uint64_t lun, *data;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096, overflow;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_INVALID_FIELD_IN_CDB;
 
 	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
 	if (alen < 16)
@@ -165,7 +168,7 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -202,7 +205,7 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -214,7 +217,7 @@ int spc_start_stop(int host_no, struct scsi_cmd *cmd)
 		if (device_reserved(cmd))
 			return SAM_STAT_RESERVATION_CONFLICT;
 	} else {
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, E_LUN_NOT_SUPPORTED);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	return SAM_STAT_GOOD;
@@ -232,7 +235,7 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
 			ret = SAM_STAT_RESERVATION_CONFLICT;
 	} else {
 		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x24, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, E_INVALID_FIELD_IN_CDB);
 		ret = SAM_STAT_CHECK_CONDITION;
 	}
 	return ret;
@@ -240,9 +243,36 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
 
 int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
-	cmd->len = 0;
-	sense_data_build(cmd, NO_SENSE, 0, 0);
+	uint8_t *data;
+	uint8_t key = NO_SENSE;
+	uint16_t asc = NO_ADDITIONAL_SENSE;
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = E_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	/* SPC4: 6.28 - Check if we support the DESC bit */
+	if (cmd->scb[1] && 1) {
+		if (!cmd->dev->attrs.sense_format) {
+			key = ILLEGAL_REQUEST;
+			asc = E_INVALID_FIELD_IN_CDB;
+			goto sense;
+		}
+	}
+
+	sense_data_build(cmd, key, asc);
+	cmd->len = cmd->sense_len;
+	memcpy(data, cmd->sense_buffer, cmd->sense_len);
 	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
 }
 
 void dump_cdb(struct scsi_cmd *cmd)
@@ -281,7 +311,7 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 {
 	dump_cdb(cmd);
 	cmd->len = 0;
-	sense_data_build(cmd, ILLEGAL_REQUEST, 0x20, 0);
+	sense_data_build(cmd, ILLEGAL_REQUEST, E_INVALID_OP_CODE);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
diff --git a/usr/spt.c b/usr/spt.c
index fe2a848..540fc80 100644
--- a/usr/spt.c
+++ b/usr/spt.c
@@ -40,6 +40,7 @@
 #include "target.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 extern int spt_sg_open(struct scsi_lu *lu, char *path, int *fd, uint64_t *size);
 extern int spt_sg_perform(struct scsi_cmd *cmd);
@@ -74,7 +75,7 @@ static int spt_cmd_perform(int host_no, struct scsi_cmd *cmd)
 	ret = spt_sg_perform(cmd);
 	if (ret) {
 		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, E_LUN_NOT_SUPPORTED);
 		return SAM_STAT_CHECK_CONDITION;
 	} else
 		return SAM_STAT_GOOD;
diff --git a/usr/tgtd.h b/usr/tgtd.h
index e214fbb..65f4a03 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -178,8 +178,7 @@ extern void target_cmd_io_done(struct scsi_cmd *cmd, int result);
 
 extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
 extern int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd);
-extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc,
-			     uint8_t asq);
+extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t asc);
 extern uint64_t scsi_rw_offset(uint8_t *scb);
 
 extern enum scsi_target_state tgt_get_target_state(int tid);
-- 
1.5.2.1






From waldi at berlios.de  Tue Jun 19 19:18:38 2007
From: waldi at berlios.de (Bastian Blank)
Date: Tue, 19 Jun 2007 19:18:38 +0200
Subject: [Stgt-devel] ibmvio is slow
Message-ID: <20070619171838.GA13219@wavehammer.waldi.eu.org>

Hi folks

I tried the ibmvio target on a busy vioserver on a power5 machine. It
works fine, I got no problem. It provides services to 7 initiators with
at least 2 luns each.

But it is slow. I can write at most 15MiB/s to the disks, regardless of
the count of the initiators and disks.

I used strace and saw the following:

| mmap2(NULL, 131072, PROT_READ|PROT_WRITE, MAP_SHARED, 14, 0xc6185) = 0xf7e28000 <0.000026>
| write(8, "\0", 1)                       = 1 <0.002088>
| munmap(0xf7f5e000, 12288)               = 0 <0.000022>
| mmap2(NULL, 131072, PROT_READ|PROT_WRITE, MAP_SHARED, 14, 0xc61a5) = 0xf7e08000 <0.000025>
| write(8, "\0", 1)                       = 1 <0.002060>
| munmap(0xf7fde000, 4096)                = 0 <0.000022>
| mmap2(NULL, 131072, PROT_READ|PROT_WRITE, MAP_SHARED, 14, 0xc61c5) = 0xf7de8000 <0.000023>
| write(8, "\0", 1)                       = 1 <0.002130>
| munmap(0xf7f12000, 73728)               = 0 <0.000031>

Each request produces a mmap, a write and a unmap. The time needed for the
write, which seems to be a request available flag, needs 2ms, which means at
most 50 requests/s.

Bastian

-- 
Bones: "The man's DEAD, Jim!"


From fujita.tomonori at lab.ntt.co.jp  Wed Jun 20 01:40:51 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 20 Jun 2007 08:40:51 +0900
Subject: [Stgt-devel] ibmvio is slow
In-Reply-To: <20070619171838.GA13219@wavehammer.waldi.eu.org>
References: <20070619171838.GA13219@wavehammer.waldi.eu.org>
Message-ID: <20070620084051R.fujita.tomonori@lab.ntt.co.jp>

From: Bastian Blank <waldi at berlios.de>
Subject: [Stgt-devel] ibmvio is slow
Date: Tue, 19 Jun 2007 19:18:38 +0200

> Hi folks
> 
> I tried the ibmvio target on a busy vioserver on a power5 machine. It
> works fine, I got no problem. It provides services to 7 initiators with
> at least 2 luns each.

Nice.


> But it is slow. I can write at most 15MiB/s to the disks, regardless of
> the count of the initiators and disks.
> 
> I used strace and saw the following:
> 
> | mmap2(NULL, 131072, PROT_READ|PROT_WRITE, MAP_SHARED, 14, 0xc6185) = 0xf7e28000 <0.000026>
> | write(8, "\0", 1)                       = 1 <0.002088>
> | munmap(0xf7f5e000, 12288)               = 0 <0.000022>
> | mmap2(NULL, 131072, PROT_READ|PROT_WRITE, MAP_SHARED, 14, 0xc61a5) = 0xf7e08000 <0.000025>
> | write(8, "\0", 1)                       = 1 <0.002060>
> | munmap(0xf7fde000, 4096)                = 0 <0.000022>
> | mmap2(NULL, 131072, PROT_READ|PROT_WRITE, MAP_SHARED, 14, 0xc61c5) = 0xf7de8000 <0.000023>
> | write(8, "\0", 1)                       = 1 <0.002130>
> | munmap(0xf7f12000, 73728)               = 0 <0.000031>
> 
> Each request produces a mmap, a write and a unmap. The time needed for the
> write, which seems to be a request available flag, needs 2ms, which means at
> most 50 requests/s.

We don't need to call mmap/unmap per request though this hack is
disable to keep the code simple. We need to find a way to avoid
registering/de-registering memory region for more high performance.

But we are not ready for them yet. I need to fix the patches in
the scsi-target tree and send them to upstream first.


From fujita.tomonori at lab.ntt.co.jp  Wed Jun 20 01:45:45 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 20 Jun 2007 08:45:45 +0900
Subject: [Stgt-devel] [PATCH] Move device type to LUN
In-Reply-To: <200706170429.l5H4TY4x030387@mbox.iij4u.or.jp>
References: <466E9513.9030303@suse.de>
	<20070615133612Q.fujita.tomonori@lab.ntt.co.jp>
	<200706170429.l5H4TY4x030387@mbox.iij4u.or.jp>
Message-ID: <20070620084545Y.fujita.tomonori@lab.ntt.co.jp>

From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
Date: Sun, 17 Jun 2007 13:29:33 +0900

> From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
> Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> Date: Fri, 15 Jun 2007 13:36:12 +0900
> 
> > From: Hannes Reinecke <hare at suse.de>
> > Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> > Date: Tue, 12 Jun 2007 14:44:03 +0200
> > 
> > > FUJITA Tomonori wrote:
> > > > From: Hannes Reinecke <hare at suse.de>
> > > > Subject: Re: [Stgt-devel] [PATCH] Move device type to LUN
> > > > Date: Mon, 11 Jun 2007 17:15:19 +0200
> > > > 
> > > >> Pete Wyckoff wrote:
> > > >>> hare at suse.de wrote on Tue, 05 Jun 2007 15:38 +0200:
> > > >>>> This patch moves the device type down to the LUN structure.
> > > >>>> And in doing so we now also have the proper peripheral device
> > > >>>> type and peripheral device qualifier attributes for the INQUIRY
> > > >>>> data.
> > > >>> Makes sense to me too.
> > > >>>
> > > >>>> One thing puzzles me, though: do we support commands with no
> > > >>>> LUN attached to it? IE is it valid to have 'cmd->dev == NULL'?
> > > >>>> If so: where is the point here? If that's our handling of a
> > > >>>> non-existing LUN 0 we should rather add a proper LUN 0 and
> > > >>>> treat cmd->dev == NULL as an error case ...
> > > >>> In the SCSI model, every device must have at least one LUN for
> > > >>> handling REPORT LUNS and a couple other commands.  It is addressed
> > > >>> as LUN 0 or using the "well-known" LUN for the command.  In the stgt
> > > >>> abstraction, though, there is no magic LUN like this.  Instead
> > > >>> things like spc_inqury use cmd->dev == NULL to handle this case.
> > > >>>
> > > >> Ah. Hence.
> > > >>
> > > >>> Perhaps it is reasonable to create a special device for these
> > > >>> commands.  Up in target.c, you could assign cmd->dev to target->dev,
> > > >>> where that is the special device, paralleling the way that
> > > >>> target->cmd_queue is used.  As a side effect, lots of "if (cmd->dev)
> > > >>> ... else ILLEGAL_REQUEST" clauses can be removed from device code
> > > >>> too.
> > > >>>
> > > >> Well, I actually thought of creating a proper LUN 0 with type 0xc.
> > > > 
> > > > We still need to handle cmd->dev == NULL case though probably we can
> > > > remove cmd->dev == NULL case in device type code.
> > > > 
> > > > I don't have storage systems that work in your way. Is it common?
> > > > 
> > > > 
> > > Yes, quite common. HP and EMC (to name but a few) do it this way.
> > > Most storage arrays actually refuse to attach any devices to LUN0, as
> > > this is a pure management LUN.
> > > 
> > > I will draft up a patch which creates a proper controller LUN0.
> > 
> > Ok, here's a patch. This depends on the patch that I've just
> > submitted.
> > 
> > This adds scc support and fixes ibmvio. iSCSI works. ibmvio works for
> > me, but it detects scsi devices in a unique way, so I'm not sure it
> > works for everyone.
> > 
> > As described, a scsi controler device is automatically created as lun0
> > with a new target.
> > 
> > lily:/home/fujita# ./tgt/usr/tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
> > lily:/home/fujita# ./tgt/usr/tgtadm --op show --mode target
> > Target 1: iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
> >     System information:
> >         Driver: iscsi
> >         Status: running
> >     I_T nexus information:
> >     LUN information:
> >         LUN: 0
> >             Type: raid
> >             SCSI ID: deadbeaf1:0
> >             SCSI SN: beaf10
> >             Size: 0
> >             Backing store: No backing store
> >     Account information:
> >     ACL information:
> > 
> > 
> > The patch is still very hacky but shows how it works. Let me know this
> > works or not.
> 
> I did some cleanups.
> 
> http://git.kernel.org/?p=linux/kernel/git/tomo/tgt.git;a=shortlog;h=scc

Applied with Hannes' proposal to the scsi device names and
README.iSCSI updates.


From markh794 at gmail.com  Wed Jun 20 09:57:44 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 20 Jun 2007 17:57:44 +1000
Subject: [Stgt-devel] [Patch 1/6] Fix potential memory leak
Message-ID: <4678DDF8.5070601@gmail.com>

>From f25303a09128973d77df0bb49926001212548f1d Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Wed, 20 Jun 2007 17:31:32 +1000
Subject: Fix memory leak in ibmvio -> spc_inquiry() path

Allocating data = valloc() twice when calling spc_inquiry()

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/ibmvio/ibmvio.c |   15 +++++++--------
 1 files changed, 7 insertions(+), 8 deletions(-)

diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index 5a2f8fe..1b1785d 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -145,17 +145,16 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
 
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = 0;
-		goto sense;
-	}
-	memset(data, 0, pagesize);
-
 	dprintf("%x %x\n", scb[1], scb[2]);
 
 	if (!(scb[1] & 0x3)) {
+		data = valloc(pagesize);
+		if (!data) {
+			key = HARDWARE_ERROR;
+			asc = 0;
+			goto sense;
+		}
+		memset(data, 0, pagesize);
 		cmd->len = __ibmvio_inquiry(host_no, cmd, data);
 		ret = SAM_STAT_GOOD;
 	} else
-- 
1.5.2.1








From markh794 at gmail.com  Wed Jun 20 09:59:45 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 20 Jun 2007 17:59:45 +1000
Subject: [Stgt-devel] [Patch 2/6] Remove test condition with only one outcome
Message-ID: <4678DE71.8090203@gmail.com>

>From 4bd3578626e448426de12cb6918f02627f305d11 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Wed, 20 Jun 2007 17:32:42 +1000
Subject: Removed unused test condition

Removed test for SAM_STAT_GOOD as this is the only possible outcome.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/ibmvio/ibmvio.c |    5 -----
 1 files changed, 0 insertions(+), 5 deletions(-)

diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index 1b1785d..b784f3e 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -138,7 +138,6 @@ static int __ibmvio_inquiry(int host_no, struct scsi_cmd *cmd, uint8_t *data)
 
 static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 {
-	int ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data, *scb = cmd->scb;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
@@ -156,13 +155,9 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 		}
 		memset(data, 0, pagesize);
 		cmd->len = __ibmvio_inquiry(host_no, cmd, data);
-		ret = SAM_STAT_GOOD;
 	} else
 		return spc_inquiry(host_no, cmd);
 
-	if (ret != SAM_STAT_GOOD)
-		goto sense;
-
 	cmd->len = min_t(int, cmd->len, scb[4]);
 	cmd->uaddr = (unsigned long) data;
 
-- 
1.5.2.1







From markh794 at gmail.com  Wed Jun 20 10:01:30 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 20 Jun 2007 18:01:30 +1000
Subject: [Stgt-devel] [Patch 3/6] Update sample script to new lu layout.
Message-ID: <4678DEDA.2080401@gmail.com>

>From 42b2eaf57103613b67cefe2d0a47b281ee3ceccd Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Wed, 20 Jun 2007 17:34:26 +1000
Subject: Updated sample script to suit new Logical Unit creation

As LU are no longer tied to the target type, the sample script
required a rework to suit new layout.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 scripts/tgt-core-test |   56 ++++++++++++++++++++++++------------------------
 1 files changed, 28 insertions(+), 28 deletions(-)

diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
index 1bbb404..a90fc9d 100755
--- a/scripts/tgt-core-test
+++ b/scripts/tgt-core-test
@@ -28,49 +28,49 @@ fi
 
 set -x
 
-###################################################################################
+###############################################################################
 # Set up SBC HDD device
-###################################################################################
+###############################################################################
 TID=1
 
+# Create Target ID 1..
 tgtadm --lld iscsi --mode target --op new --tid $TID \
-		-T iqn.2007-03:marks-vtl_sbc:`hostname` --target-type disk
-
+		-T iqn.2007-03:marks-vtl_sbc:`hostname`
 sleep 1
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b $HOME/hd_block
-
-tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 --params scsi_sn=FRED00,scsi_id=Fred
-
-tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
-	--params vendor_id=QUANTUM,product_id=HD100,product_rev=0010,removable=1,sense_format=0
-
-
-tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
 
+# Create first LUN - Disk
+LUN=1
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/hd_block --device-type=disk
 
-###################################################################################
-# Set up MMC CD/DVD device
-###################################################################################
-TID=2
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params scsi_sn=FRED00,scsi_id=Fred
 
-tgtadm --lld iscsi --mode target --op new --tid $TID \
-		-T iqn.2007-03:marks-vtl_mmc:`hostname` --target-type cd
-
-sleep 1
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 0 -b $HOME/cd_block0
-tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 0 \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY10,removable=1
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params vendor_id=QUANTUM,product_id=HD100,product_rev=0010,removable=1,sense_format=0
 
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 1 -b $HOME/cd_block1
-tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 1 \
+# Create 2nd LUN - CD/ROM
+LUN=2
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY11,removable=1
 
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun 2 -b $HOME/cd_block2
-tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun 2 \
+# Create 3rd LUN - CD/ROM
+LUN=3
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY12,removable=1
 
+# Create 4th LUN - CD/ROM
+LUN=4
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY13,removable=1
+
+# Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
 
+
+# Show all our good work.
 tgtadm --lld iscsi --mode target --op show
 
 
-- 
1.5.2.1








From markh794 at gmail.com  Wed Jun 20 10:05:45 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 20 Jun 2007 18:05:45 +1000
Subject: [Stgt-devel] [Patch 4/6] Use mnemonic value for ASC/ASCQ values
Message-ID: <4678DFD9.2040407@gmail.com>

A better prefix to the defines instead of 'E_' would be nice.

Any recommendations for a good naming convention  ? 

   ----------------------------

>From 422b9f6efedc0a18888a556c258a16ee6ffd9960 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Wed, 20 Jun 2007 17:44:09 +1000
Subject: Use nmemonic codes for SENSE codes instead of numeric value.

Using nmemonic representation for ASC/ASCQ as a 16bit value.
 Values defined in sense_codes.h
 Updated sense_data_build() to accept a single 16bit
 combined asc/ascq value.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/bs_sync.c       |    3 +-
 usr/ibmvio/ibmvio.c |   15 ++++---
 usr/mmc.c           |    7 ++-
 usr/osd.c           |    5 +-
 usr/sbc.c           |   33 +++++++++-------
 usr/scsi.c          |   13 +++---
 usr/sense_codes.h   |  103 +++++++++++++++++++++++++++++++++++++++++++++++++++
 usr/spc.c           |   19 +++++----
 usr/spt.c           |    5 +-
 usr/tgtd.h          |    3 +-
 10 files changed, 161 insertions(+), 45 deletions(-)
 create mode 100644 usr/sense_codes.h

diff --git a/usr/bs_sync.c b/usr/bs_sync.c
index 6789b5b..b275720 100644
--- a/usr/bs_sync.c
+++ b/usr/bs_sync.c
@@ -37,6 +37,7 @@
 #include "util.h"
 #include "tgtd.h"
 #include "scsi.h"
+#include "sense_codes.h"
 
 #define NR_WORKER_THREADS	4
 
@@ -161,7 +162,7 @@ static void *bs_sync_worker_fn(void *arg)
 			eprintf("io error %p %x %d %d %" PRIu64 ", %m\n",
 				cmd, cmd->scb[0], ret, cmd->len, cmd->offset);
 			cmd->result = SAM_STAT_CHECK_CONDITION;
-			sense_data_build(cmd, MEDIUM_ERROR, 0x11, 0x0);
+			sense_data_build(cmd, MEDIUM_ERROR, E_READ_ERROR);
 		}
 
 		pthread_mutex_lock(&info->finished_lock);
diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index b784f3e..5db57af 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -44,6 +44,7 @@
 #include "target.h"
 #include "driver.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
 #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
@@ -139,7 +140,8 @@ static int __ibmvio_inquiry(int host_no, struct scsi_cmd *cmd, uint8_t *data)
 static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	uint8_t *data, *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_INVALID_FIELD_IN_CDB;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
@@ -150,7 +152,7 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 		data = valloc(pagesize);
 		if (!data) {
 			key = HARDWARE_ERROR;
-			asc = 0;
+			asc = E_INTERNAL_TGT_FAILURE;
 			goto sense;
 		}
 		memset(data, 0, pagesize);
@@ -167,7 +169,7 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -188,7 +190,8 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 	int idx, alen, oalen, nr_luns, rbuflen = 4096;
 	int *len = &cmd->len;
 	uint8_t *lun_buf = cmd->lun;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_INVALID_FIELD_IN_CDB;
 
 	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
 	if (alen < 16)
@@ -197,7 +200,7 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -235,7 +238,7 @@ done:
 	return SAM_STAT_GOOD;
 sense:
 	*len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
diff --git a/usr/mmc.c b/usr/mmc.c
index 10b0e3f..bfcf76e 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -41,6 +41,7 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define MMC_BLK_SHIFT 11
 
@@ -53,7 +54,7 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 	if (ret) {
 		cmd->offset = 0;
 		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, E_LUN_NOT_SUPPORTED);
 		return SAM_STAT_CHECK_CONDITION;
 	} else {
 		cmd->mmapped = 1;
@@ -69,7 +70,7 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		cmd->len = 0;
-		sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		sense_data_build(cmd, HARDWARE_ERROR, E_INTERNAL_TGT_FAILURE);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
@@ -105,7 +106,7 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		cmd->len = 0;
-		sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		sense_data_build(cmd, HARDWARE_ERROR, E_INTERNAL_TGT_FAILURE);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
diff --git a/usr/osd.c b/usr/osd.c
index a7b92ba..e571ebf 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -33,16 +33,15 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 {
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
-
 	dprintf("cdb[0] %x datalen %u\n", cmd->scb[0], cmd->len);
 	if (cmd->scb[7] != 200 - 8) {
 		eprintf("request size %d wrong, should be 200\n",
 			cmd->scb[7] + 8);
-		sense_data_build(cmd, key, asc, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, E_LUN_NOT_SUPPORTED);
 		cmd->len = 0;
 		return SAM_STAT_CHECK_CONDITION;
 	}
diff --git a/usr/sbc.c b/usr/sbc.c
index c0075e4..9d03ea4 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -38,13 +38,15 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define BLK_SHIFT	9
 
 static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_LUN_NOT_SUPPORTED;
 
 	ret = device_reserved(cmd);
 	if (ret)
@@ -65,7 +67,7 @@ static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 	} else {
 		cmd->mmapped = 1;
 		return SAM_STAT_GOOD;
@@ -74,7 +76,7 @@ static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 	cmd->rw = READ;
 	cmd->offset = 0;
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -101,20 +103,21 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	uint32_t *data;
 	uint64_t size;
 	uint8_t *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_LUN_NOT_SUPPORTED;
 
 	if (device_reserved(cmd))
 		return SAM_STAT_RESERVATION_CONFLICT;
 
 	if (!(scb[8] & 0x1) & (scb[2] | scb[3] | scb[4] | scb[5])) {
-		asc = 0x24;
+		asc = E_INVALID_FIELD_IN_CDB;
 		goto sense;
 	}
 
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	cmd->uaddr = (unsigned long) data;
@@ -129,14 +132,15 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
 static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 {
 	int ret, len;
-	uint8_t key = ILLEGAL_REQUEST, asc;
+	uint8_t key = ILLEGAL_REQUEST;
+	uint16_t asc = E_LUN_NOT_SUPPORTED;
 
 	if (device_reserved(cmd))
 		return SAM_STAT_RESERVATION_CONFLICT;
@@ -152,7 +156,7 @@ static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 		 * what should I put for the asc/ascq?
 		 */
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 		goto sense;
 	default:
 		len = 0;
@@ -161,7 +165,7 @@ static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -232,7 +236,8 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	uint8_t pcode = cmd->scb[2] & 0x3f;
 	uint64_t size;
 	uint8_t *data = NULL;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_LUN_NOT_SUPPORTED;
 
 	if (device_reserved(cmd))
 		return SAM_STAT_RESERVATION_CONFLICT;
@@ -240,7 +245,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -288,7 +293,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 		len += insert_iec_m_pg(data + len);
 		break;
 	default:
-		asc = 0x24;
+		asc = E_INVALID_FIELD_IN_CDB;
 		goto sense;
 	}
 
@@ -298,7 +303,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	return ret;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
diff --git a/usr/scsi.c b/usr/scsi.c
index 36722e1..5ddc94c 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -38,27 +38,28 @@
 #include "scsi.h"
 #include "spc.h"
 
-void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
+void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t asc)
 {
+	uint16_t *sense_code;
+
 	if (cmd->dev->attrs.sense_format) {
 		/* descriptor format */
+		sense_code = (uint16_t *)&cmd->sense_buffer[2];
 
 		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
 		cmd->sense_buffer[1] = key;
-		cmd->sense_buffer[2] = asc;
-		cmd->sense_buffer[3] = asq;
 		cmd->sense_len = 8;
 	} else {
 		/* fixed format */
+		sense_code = (uint16_t *)&cmd->sense_buffer[12];
 
 		int len = 0xa;
-		cmd->sense_buffer[0] = 0x70;
+		cmd->sense_buffer[0] = 0x70;  /* current, not deferred */
 		cmd->sense_buffer[2] = key;
 		cmd->sense_buffer[7] = len;
-		cmd->sense_buffer[12] = asc;
-		cmd->sense_buffer[13] = asq;
 		cmd->sense_len = len + 8;
 	}
+	*sense_code = __cpu_to_be16(asc);
 }
 
 #define        TGT_INVALID_DEV_ID      ~0ULL
diff --git a/usr/sense_codes.h b/usr/sense_codes.h
new file mode 100644
index 0000000..3668a43
--- /dev/null
+++ b/usr/sense_codes.h
@@ -0,0 +1,103 @@
+/*
+ * The SCSI sense key Additional Sense Code / Additional Sense Code Qualifier
+ *
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * SENSE keys
+ */
+#define NO_SENSE		0x00
+#define	RECOVERED_ERROR		0x01
+#define NOT_READY		0x02
+#define MEDIUM_ERROR		0x03
+#define	HARDWARE_ERROR		0x04
+#define ILLEGAL_REQUEST		0x05
+#define UNIT_ATTENTION		0x06
+#define DATA_PROTECT		0x07
+#define	BLANK_CHECK		0x08
+
+/* Key 0: No Sense Errors */
+#define NO_ADDITIONAL_SENSE		0x0000
+#define E_MARK				0x0001
+#define E_EOM				0x0002
+#define E_BOM				0x0004
+#define E_END_OF_DATA			0x0005
+#define E_OP_IN_PROGRESS		0x0016
+#define E_DRIVE_REQUIRES_CLEANING	0x8282
+
+/* Key 1: Recovered Errors */
+#define E_WRITE_ERROR			0x0c00
+#define E_READ_ERROR			0x1100
+#define E_RECOVERED_WITH_RETRYS		0x1701
+#define E_MEDIA_LOAD_EJECT_ERROR	0x5300
+#define E_FAILURE_PREDICTION		0x5d00
+
+/* Key 2: Not ready */
+#define E_CAUSE_NOT_REPORTABLE		0x0400
+#define E_BECOMING_READY		0x0401
+#define E_INITIALIZING_REQUIRED		0x0402
+#define E_CLEANING_CART_INSTALLED	0x3003
+#define E_CLEANING_FAILURE		0x3007
+#define E_MEDIUM_NOT_PRESENT		0x3a00
+#define E_LOGICAL_UNIT_NOT_CONFIG	0x3e00
+
+/* Key 3: Medium Errors */
+#define E_WRITE_ERROR			0x0c00
+#define E_UNRECOVERED_READ		0x1100
+#define E_RECORDED_ENTITY_NOT_FOUND	0x1400
+#define E_UNKNOWN_FORMAT		0x3001
+#define E_IMCOMPATIBLE_FORMAT		0x3002
+#define E_MEDIUM_FORMAT_CORRUPT		0x3100
+#define E_SEQUENTIAL_POSITION_ERR	0x3b00
+#define E_WRITE_APPEND_ERR		0x5000
+#define E_CARTRIDGE_FAULT		0x5200
+#define E_MEDIA_LOAD_OR_EJECT_FAILED	0x5300
+
+/* Key 4: Hardware Failure */
+#define E_COMPRESSION_CHECK		0x0c04
+#define E_DECOMPRESSION_CRC		0x110d
+#define E_MECHANICAL_POSITIONING_ERROR	0x1501
+#define E_MANUAL_INTERVENTION_REQ	0x0403
+#define E_HARDWARE_FAILURE		0x4000
+#define E_INTERNAL_TGT_FAILURE		0x4400
+#define E_ERASE_FAILURE			0x5100
+
+/* Key 5: Illegal Request */
+#define E_PARAMETER_LIST_LENGTH_ERR	0x1a00
+#define E_INVALID_OP_CODE		0x2000
+#define E_INVALID_FIELD_IN_CDB		0x2400
+#define E_LUN_NOT_SUPPORTED		0x2500
+#define E_INVALID_FIELD_IN_PARMS	0x2600
+#define E_SAVING_PARMS_UNSUP		0x3900
+#define E_MEDIUM_DEST_FULL		0x3b0d
+#define E_MEDIUM_SRC_EMPTY		0x3b0e
+#define E_POSITION_PAST_BOM		0x3b0c
+#define E_MEDIUM_REMOVAL_PREVENTED	0x5302
+#define E_BAD_MICROCODE_DETECTED	0x8283
+
+/* Key 6: Unit Attention */
+#define E_NOT_READY_TO_TRANSITION	0x2800
+#define E_POWERON_RESET			0x2900
+#define E_MODE_PARAMETERS_CHANGED	0x2a01
+#define E_INSUFFICIENT_TIME_FOR_OPERATION	0x2e00
+#define E_MICROCODE_DOWNLOADED		0x3f01
+#define E_FAILURE_PREDICTION_FALSE	0x5dff
+#define E_INQUIRY_DATA_HAS_CHANGED	0x3f03
+
+/* Data Protect */
+#define E_WRITE_PROTECT			0x2700
+#define E_MEDIUM_OVERWRITE_ATTEMPTED	0x300c
diff --git a/usr/spc.c b/usr/spc.c
index 1c363cd..6dbe013 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -34,6 +34,7 @@
 #include "tgtadm_error.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define PRODUCT_REV	"0"
 #define BLK_SHIFT	9
@@ -43,7 +44,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	int len, ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data;
 	uint8_t *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_INVALID_FIELD_IN_CDB;
 	uint8_t devtype = 0;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
@@ -52,7 +54,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -148,7 +150,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -158,7 +160,8 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	struct list_head *dev_list = &cmd->c_target->device_list;
 	uint64_t lun, *data;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096, overflow;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_INVALID_FIELD_IN_CDB;
 
 	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
 	if (alen < 16)
@@ -167,7 +170,7 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = E_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -204,7 +207,7 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -231,7 +234,7 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
 int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
 	cmd->len = 0;
-	sense_data_build(cmd, NO_SENSE, 0, 0);
+	sense_data_build(cmd, NO_SENSE, NO_ADDITIONAL_SENSE);
 	return SAM_STAT_GOOD;
 }
 
@@ -271,7 +274,7 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 {
 	dump_cdb(cmd);
 	cmd->len = 0;
-	sense_data_build(cmd, ILLEGAL_REQUEST, 0x20, 0);
+	sense_data_build(cmd, ILLEGAL_REQUEST, E_INVALID_OP_CODE);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
diff --git a/usr/spt.c b/usr/spt.c
index c882fd0..8d7f751 100644
--- a/usr/spt.c
+++ b/usr/spt.c
@@ -40,6 +40,7 @@
 #include "target.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 extern int spt_sg_open(struct scsi_lu *lu, char *path, int *fd, uint64_t *size);
 extern int spt_sg_perform(struct scsi_cmd *cmd);
@@ -68,14 +69,14 @@ static int spt_cmd_perform(int host_no, struct scsi_cmd *cmd)
 
 	if (!cmd->dev) {
 		cmd->len = 0;
-		sense_data_build(cmd, NOT_READY, 0x44, 0); /* Internal target failure */
+		sense_data_build(cmd, NOT_READY, E_INTERNAL_TGT_FAILURE);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 
 	ret = spt_sg_perform(cmd);
 	if (ret) {
 		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, E_LUN_NOT_SUPPORTED);
 		return SAM_STAT_CHECK_CONDITION;
 	} else
 		return SAM_STAT_GOOD;
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 15ae2e1..8e66d60 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -190,8 +190,7 @@ extern void target_cmd_io_done(struct scsi_cmd *cmd, int result);
 
 extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
 extern int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd);
-extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc,
-			     uint8_t asq);
+extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t asc);
 extern uint64_t scsi_rw_offset(uint8_t *scb);
 
 extern enum scsi_target_state tgt_get_target_state(int tid);
-- 
1.5.2.1







From markh794 at gmail.com  Wed Jun 20 10:07:42 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 20 Jun 2007 18:07:42 +1000
Subject: [Stgt-devel] [Patch 5/6] Update spc_request_sense() to return some
	sense data.
Message-ID: <4678E04E.5020707@gmail.com>

>From ff2ab514b13173c6e6fc515c2b3a7bf10b100feb Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Wed, 20 Jun 2007 17:49:33 +1000
Subject: update spc_request_sense() to return some sort of sense data.

Updated spc_request_sense() so it returns some data.
- spc_request_sense() needs more investigation as:
   sg_requests /dev/sgX => returns old (SCSI-1) sense.
   At least it no longer returns an error.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/spc.c |   31 +++++++++++++++++++++++++++++--
 1 files changed, 29 insertions(+), 2 deletions(-)

diff --git a/usr/spc.c b/usr/spc.c
index 6dbe013..6530e73 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -233,9 +233,36 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
 
 int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
-	cmd->len = 0;
-	sense_data_build(cmd, NO_SENSE, NO_ADDITIONAL_SENSE);
+	uint8_t *data;
+	uint8_t key = NO_SENSE;
+	uint16_t asc = NO_ADDITIONAL_SENSE;
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = E_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	/* SPC4: 6.28 - Check if we support the DESC bit */
+	if (cmd->scb[1] && 1) {
+		if (!cmd->dev->attrs.sense_format) {
+			key = ILLEGAL_REQUEST;
+			asc = E_INVALID_FIELD_IN_CDB;
+			goto sense;
+		}
+	}
+
+	sense_data_build(cmd, key, asc);
+	cmd->len = cmd->sense_len;
+	memcpy(data, cmd->sense_buffer, cmd->sense_len);
 	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
 }
 
 void dump_cdb(struct scsi_cmd *cmd)
-- 
1.5.2.1







From markh794 at gmail.com  Wed Jun 20 10:09:13 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 20 Jun 2007 18:09:13 +1000
Subject: [Stgt-devel] [Patch 6/6] Create mode page information at runtime
Message-ID: <4678E0A9.8060208@gmail.com>

>From 9f725d6f1dc62143c0d7cba54db8a612a7fb5bd4 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Wed, 20 Jun 2007 17:52:46 +1000
Subject: Dynamic mode page creation.

Mode pages are now built at run time.

Initial configuration via the 'tgtadm --params mode_page'
Page information is seperated by ':'
e.g.
 --params mode_page=10:1:11:2:0:0:0:0:0:0:0:2:0:0
Where '10' is mode page 10
      '1'  is the subpage
      '11' is the length of the page data (11 bytes of information follow)

The example script 'scripts/tgt-core-test' contains an executable example.

The 'doc/README.lu_configuration' updated for mode page informaiton.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 doc/README.lu_configuration |   20 +++++
 scripts/tgt-core-test       |   61 ++++++++++++----
 usr/Makefile                |    2 +-
 usr/mmc.c                   |   32 ++++++++-
 usr/mode_page.c             |  141 ++++++++++++++++++++++++++++++++++
 usr/mode_page.h             |   37 +++++++++
 usr/osd.c                   |    3 +
 usr/sbc.c                   |  174 +++++++++----------------------------------
 usr/spc.c                   |   86 +++++++++++++++++++++-
 usr/spc.h                   |    1 +
 usr/tgtd.h                  |    4 +
 11 files changed, 405 insertions(+), 156 deletions(-)
 create mode 100644 usr/mode_page.c
 create mode 100644 usr/mode_page.h

diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
index 1244bc0..d63668a 100644
--- a/doc/README.lu_configuration
+++ b/doc/README.lu_configuration
@@ -65,5 +65,25 @@ standard INQUIRY:
 As can be seen from above 'sg_inq' output, the RMB (removable) bit is set to 1.
 The Unit serial number page updated with 'FRED00'
 
+Mode Page Creation
+------------------
+Create mode page '2', subpage 0 and 14 bytes of data.
+tgtadm --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+
+Create mode page '3', subpage 0 and 22 bytes of data.
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
+
+Create mode page '10', subpage 0 and 10 bytes of data.
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
+
+Create mode page '0x1c', subpage 0 and 10 bytes of data.
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+
+
+
 Please refer to scripts/tgt-core-test for a working example.
 
diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
index a90fc9d..8f4d6ea 100755
--- a/scripts/tgt-core-test
+++ b/scripts/tgt-core-test
@@ -3,6 +3,7 @@
 # Parent directory for data files..
 HOME=/d/01
 
+# Start tgtd if not running..
 P=`ps -ef|grep -v grep|grep tgtd|wc -l`
 if [ "X"$P == "X0" ]; then
 	tgtd -d 1
@@ -48,23 +49,55 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 	--params vendor_id=QUANTUM,product_id=HD100,product_rev=0010,removable=1,sense_format=0
 
-# Create 2nd LUN - CD/ROM
-LUN=2
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
-tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY11,removable=1
+#### Set up mode pages ####
+# First try a couple of attempts with incorrect data..
 
-# Create 3rd LUN - CD/ROM
-LUN=3
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
+# - Length too long & Incorrect value (300) as one if the params...
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY12,removable=1
-
-# Create 4th LUN - CD/ROM
-LUN=4
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:300:0:0:0:0:0:0:0:0:3
+# - Length too short...
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0
+# - Just right...
+# Vendor Uniq - Mode page 0..
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0:0:0
+# Disconnect page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+# Format mode page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
+# Geo mode page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=4:0:22:0:0:0:0x40:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0x3a:0x98:0:0
+# Caching Page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=8:0:18:0x14:0:0xff:0xff:0:0:0xff:0xff:0xff:0xff:0x80:0x14:0:0:0:0:0:0
+# ctrl mode page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
+# Informational Exceptions Control Mode Page
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY13,removable=1
+	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+
+
+
+for LUN in 2 3 4; do
+	# Create LUN - CD/ROM
+	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY1$LUN,removable=1
+	# Vendor Uniq - Mode page 0..
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params mode_page=0:0:0
+	# ctrl mode page
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
+	# Informational Exceptions Control Mode Page
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+done
 
 # Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
diff --git a/usr/Makefile b/usr/Makefile
index 14be34b..43a0fe6 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -44,7 +44,7 @@ CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDE
 
 PROGRAMS += tgtd tgtadm
 TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o osd.o spt.o scc.o scsi.o log.o \
-	driver.o util.o work.o parser.o
+	driver.o util.o work.o parser.o mode_page.o
 
 all: $(PROGRAMS)
 
diff --git a/usr/mmc.c b/usr/mmc.c
index bfcf76e..75d419a 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -122,6 +122,15 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 }
 
+static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)
+{
+	uint8_t *scb = cmd->scb;
+
+	/* MMC devices always return descriptor block */
+	scb[1] |= 8;
+	return spc_mode_sense(host_no, cmd);
+}
+
 static int mmc_lu_init(struct scsi_lu *lu)
 {
 	if (spc_lu_init(lu))
@@ -133,6 +142,8 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
 	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
+	INIT_LIST_HEAD(&lu->mode_pages);
+
 	return 0;
 }
 
@@ -218,7 +229,26 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 
-		[0x50 ... 0x9f] = {spc_illegal_op,},
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{mmc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x9f] = {spc_illegal_op,},
 
 		/* 0xA0 */
 		{spc_report_luns,},
diff --git a/usr/mode_page.c b/usr/mode_page.c
new file mode 100644
index 0000000..708115b
--- /dev/null
+++ b/usr/mode_page.c
@@ -0,0 +1,141 @@
+/*
+ * Common routines with regards to SCSI mode op codes.
+ *
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <linux/fs.h>
+#include <string.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "tgtadm_error.h"
+#include "mode_page.h"
+
+/*
+ * Init and alloc space for the supported mode page structures
+ */
+int insert_mode_page(struct list_head *head, int page, int subpage, int sz)
+{
+	struct mode *m;
+
+	if ((m = zalloc(sizeof(struct mode))) == NULL)
+		return -ENOMEM;
+	if ((m->mode_data = zalloc(sz)) == NULL) {
+		free(m);
+		return -ENOMEM;
+	}
+	m->pcode = page;
+	m->subpcode = subpage;
+	m->pcode_sz = (uint16_t)sz;
+	list_add_tail(&m->mode_siblings, head);
+	return 0;
+}
+
+struct mode *mode_page_lookup(struct list_head *head, uint8_t page)
+{
+	struct mode *m;
+
+	list_for_each_entry(m, head, mode_siblings)
+		if (m->pcode == page)
+			return m;
+
+	return NULL;
+}
+
+/*
+ * Return:
+ * 	0 on success
+ *	TGTADM_INVALID_REQUEST on error
+ */
+int add_mode_page(struct scsi_lu *lu, char *params)
+{
+	char *p = NULL;
+	int i = 0;
+	int tmp;
+	uint8_t page = 0;
+	uint8_t subpage = 0;
+	uint8_t *data = NULL;
+	uint16_t sz = 0;
+	struct mode *m = NULL;
+
+	while ((p = strsep(&params, ":")) != NULL) {
+		switch (i) {
+		case 0:
+			page = strtol(p, NULL, 0);
+			break;
+		case 1:
+			subpage = strtol(p, NULL, 0);
+			break;
+		case 2:
+			sz = strtol(p, NULL, 0);
+			insert_mode_page(&lu->mode_pages, page, subpage, sz);
+			m = mode_page_lookup(&lu->mode_pages, page);
+			data = m->mode_data;
+			break;
+		default:
+			if (i < (sz + 3)) {
+				tmp = strtol(p, NULL, 0);
+				if (tmp > 255)
+					dprintf("Error : Incorrect value %d "
+					"Mode page %d (0x%02x), index: %d\n",
+						tmp, page, page, i - 3);
+				data[i - 3] = (uint8_t)tmp;
+			}
+			break;
+		}
+		i++;
+	}
+	if (i != (sz + 3)) {
+		dprintf("Mode Page %d (0x%02x): param_count %d != "
+					" MODE PAGE size : %d\n",
+				page, page, i, sz + 3);
+		return TGTADM_INVALID_REQUEST;
+	} else
+		return TGTADM_SUCCESS;
+}
+
+/*
+ * Copy mode page data from list into SCSI data so it can be returned
+ * to the initiator
+ *
+ * *data -> target address (destination)
+ * mode -> Pointer to mode page information (source)
+ *
+ * Returns number of bytes copied.
+ */
+int build_mode_page(uint8_t *data, struct mode *m)
+{
+	uint8_t *p;
+	int len;
+
+	data[0] = m->pcode;
+	len = m->pcode_sz;
+	data[1] = len;
+	p = &data[2];
+	len += 2;
+	dprintf("Page: 0x%02x (%d)\n", m->pcode, m->pcode);
+	memcpy(p, m->mode_data, m->pcode_sz);
+
+return len;
+}
diff --git a/usr/mode_page.h b/usr/mode_page.h
new file mode 100644
index 0000000..31eafd3
--- /dev/null
+++ b/usr/mode_page.h
@@ -0,0 +1,37 @@
+/*
+ * SCSI Medium Changer Command
+ *
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+#ifndef _SPC_MODE_PG_H_
+#define _SPC_MODE_PG_H_
+
+struct mode {
+	struct list_head mode_siblings;
+	uint8_t pcode;		/* Page code */
+	uint8_t subpcode;	/* Sub page code */
+	int16_t pcode_sz;	/* Size of page code data. */
+	uint8_t *mode_data;	/* Rest of mode page info */
+};
+
+int insert_mode_page(struct list_head *head, int page, int subpage, int sz);
+struct mode *mode_page_lookup(struct list_head *head, uint8_t page);
+int add_mode_page(struct scsi_lu *lu, char *params);
+int build_mode_page(uint8_t *data, struct mode *m);
+
+#endif /* _SPC_MODE_PG_H_ */
diff --git a/usr/osd.c b/usr/osd.c
index e571ebf..684be4d 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -61,6 +61,9 @@ static int osd_lu_init(struct scsi_lu *lu)
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
 	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
+	/* not used - but initialise anyway... */
+	INIT_LIST_HEAD(&lu->mode_pages);
+
 	return 0;
 }
 
diff --git a/usr/sbc.c b/usr/sbc.c
index 9d03ea4..db11381 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -39,6 +39,7 @@
 #include "scsi.h"
 #include "spc.h"
 #include "sense_codes.h"
+#include "mode_page.h"
 
 #define BLK_SHIFT	9
 
@@ -169,146 +170,11 @@ sense:
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int insert_disconnect_pg(uint8_t *ptr)
-{
-	unsigned char disconnect_pg[] = {0x02, 0x0e, 0x80, 0x80, 0x00, 0x0a, 0x00, 0x00,
-                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, disconnect_pg, sizeof(disconnect_pg));
-	return sizeof(disconnect_pg);
-}
-
-static int insert_caching_pg(uint8_t *ptr)
-{
-	unsigned char caching_pg[] = {0x08, 0x12, 0x14, 0x00, 0xff, 0xff, 0x00, 0x00,
-				      0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0x00, 0x00,
-				      0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, caching_pg, sizeof(caching_pg));
-	return sizeof(caching_pg);
-}
-
-static int insert_ctrl_m_pg(uint8_t *ptr)
-{
-	unsigned char ctrl_m_pg[] = {0x0a, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
-				     0x00, 0x00, 0x02, 0x4b};
-
-	memcpy(ptr, ctrl_m_pg, sizeof(ctrl_m_pg));
-	return sizeof(ctrl_m_pg);
-}
-
-static int insert_iec_m_pg(uint8_t *ptr)
-{
-	unsigned char iec_m_pg[] = {0x1c, 0xa, 0x08, 0x00, 0x00, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, iec_m_pg, sizeof(iec_m_pg));
-	return sizeof(iec_m_pg);
-}
-
-static int insert_format_m_pg(uint8_t *ptr)
-{
-	unsigned char format_m_pg[] = {0x03, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-				       0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
-				       0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00};
-	memcpy(ptr, format_m_pg, sizeof(format_m_pg));
-	return sizeof(format_m_pg);
-}
-
-static int insert_geo_m_pg(uint8_t *ptr, uint64_t sec)
-{
-	unsigned char geo_m_pg[] = {0x04, 0x16, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x3a, 0x98, 0x00, 0x00};
-	uint32_t ncyl, *p;
-
-	/* assume 0xff heads, 15krpm. */
-	memcpy(ptr, geo_m_pg, sizeof(geo_m_pg));
-	ncyl = sec >> 14; /* 256 * 64 */
-	p = (uint32_t *)(ptr + 1);
-	*p = *p | __cpu_to_be32(ncyl);
-	return sizeof(geo_m_pg);
-}
-
-static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
+static int sbc_lu_init(struct scsi_lu *lu)
 {
-	int ret = SAM_STAT_GOOD, len;
-	uint8_t pcode = cmd->scb[2] & 0x3f;
 	uint64_t size;
-	uint8_t *data = NULL;
-	unsigned char key = ILLEGAL_REQUEST;
-	uint16_t asc = E_LUN_NOT_SUPPORTED;
-
-	if (device_reserved(cmd))
-		return SAM_STAT_RESERVATION_CONFLICT;
-
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = E_INTERNAL_TGT_FAILURE;
-		goto sense;
-	}
-	memset(data, 0, pagesize);
-
-	len = 4;
-	size = cmd->dev->size >> BLK_SHIFT;
-
-	if ((cmd->scb[1] & 0x8))
-		data[3] = 0;
-	else {
-		data[3] = 8;
-		len += 8;
-		*(uint32_t *)(data + 4) = (size >> 32) ?
-			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
-		*(uint32_t *)(data + 8) = __cpu_to_be32(1 << BLK_SHIFT);
-	}
-
-	switch (pcode) {
-	case 0x0:
-		break;
-	case 0x2:
-		len += insert_disconnect_pg(data + len);
-		break;
-	case 0x3:
-		len += insert_format_m_pg(data + len);
-		break;
-	case 0x4:
-		len += insert_geo_m_pg(data + len, size);
-		break;
-	case 0x8:
-		len += insert_caching_pg(data + len);
-		break;
-	case 0xa:
-		len += insert_ctrl_m_pg(data + len);
-		break;
-	case 0x1c:
-		len += insert_iec_m_pg(data + len);
-		break;
-	case 0x3f:
-		len += insert_disconnect_pg(data + len);
-		len += insert_format_m_pg(data + len);
-		len += insert_geo_m_pg(data + len, size);
-		len += insert_caching_pg(data + len);
-		len += insert_ctrl_m_pg(data + len);
-		len += insert_iec_m_pg(data + len);
-		break;
-	default:
-		asc = E_INVALID_FIELD_IN_CDB;
-		goto sense;
-	}
+	uint8_t *data;
 
-	data[0] = len - 1;
-	cmd->len = len;
-	cmd->uaddr = (unsigned long) data;
-	return ret;
-sense:
-	cmd->len = 0;
-	sense_data_build(cmd, key, asc);
-	return SAM_STAT_CHECK_CONDITION;
-}
-
-static int sbc_lu_init(struct scsi_lu *lu)
-{
 	if (spc_lu_init(lu))
 		return -ENOMEM;
 
@@ -317,6 +183,15 @@ static int sbc_lu_init(struct scsi_lu *lu)
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
 	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
+	INIT_LIST_HEAD(&lu->mode_pages);
+
+	data = lu->mode_block_descriptor;
+	size = lu->size >> BLK_SHIFT;
+
+	*(uint32_t *)(data) = (size >> 32) ?
+			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
+	*(uint32_t *)(data + 4) = __cpu_to_be32(1 << BLK_SHIFT);
+
 	return 0;
 }
 
@@ -355,7 +230,7 @@ static struct device_type_template sbc_template = {
 
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_mode_sense,},
+		{spc_mode_sense,},
 		{spc_start_stop,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -400,7 +275,28 @@ static struct device_type_template sbc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 
-		[0x40 ... 0x7f] = {spc_illegal_op,},
+		[0x40 ... 0x4f] = {spc_illegal_op,},
+
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x7f] = {spc_illegal_op,},
 
 		/* 0x80 */
 		{spc_illegal_op,},
diff --git a/usr/spc.c b/usr/spc.c
index 6530e73..32dac79 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -35,6 +35,7 @@
 #include "scsi.h"
 #include "spc.h"
 #include "sense_codes.h"
+#include "mode_page.h"
 
 #define PRODUCT_REV	"0"
 #define BLK_SHIFT	9
@@ -231,6 +232,82 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
 		return SAM_STAT_GOOD;
 }
 
+/*
+ * Reference : SPC4r11
+ * 6.11 - MODE SENSE(6)
+ * 6.12 - MODE SENSE(10)
+ */
+int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
+{
+	int	len = 0;
+	uint8_t *data;
+	uint8_t *scb = cmd->scb;
+	uint8_t	mode6 = (scb[0] == 0x1a) ? 1 : 0;
+	uint8_t dbd = (scb[1] & 8) ? 1 : 0;	/* Disable Block Descriptors */
+	uint8_t page_code = scb[2] & 0x3f;
+	uint8_t subpage = scb[3];
+	uint16_t alloc_len;
+	struct	mode	* m;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = E_INVALID_FIELD_IN_CDB;
+
+	if (subpage)
+		goto sense;	/* Currently not implemented */
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = E_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+	if (mode6) {
+		alloc_len = scb[4];
+		len = 4;
+	} else {
+		alloc_len = (scb[7] << 8) + scb[8];
+		len = 8;
+	}
+	if (alloc_len > pagesize)
+		goto sense;
+
+	if (!dbd) {
+		memcpy(data + len, cmd->dev->mode_block_descriptor,
+				BLOCK_DESCRIPTOR_LEN);
+		len += 8;
+	}
+
+	if (page_code == 0x3f) {	/* All pages */
+		int	i;
+		for (i=0; i < 0x3f; i++) {
+			m = mode_page_lookup(&cmd->dev->mode_pages, i);
+			if (m)
+				len += build_mode_page(data + len, m);
+		}
+	} else {
+		m = mode_page_lookup(&cmd->dev->mode_pages, page_code);
+		if (!m)
+			goto sense;
+		len += build_mode_page(data + len, m);
+	}
+	if (mode6) {
+		data[0] = len - 1;
+		data[3] = (dbd) ? 0 : BLOCK_DESCRIPTOR_LEN;
+	} else {
+		*(uint16_t *)(data) = __cpu_to_be16(len - 3);
+		data[7] = (dbd) ? 0 : BLOCK_DESCRIPTOR_LEN;
+	}
+
+	cmd->len = len;
+	cmd->uaddr = (unsigned long)data;
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
 int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
 	uint8_t *data;
@@ -269,6 +346,7 @@ void dump_cdb(struct scsi_cmd *cmd)
 {
 	uint8_t *cdb = cmd->scb;
 
+	dprintf("cmd->cdb_len: %d\n", cmd->scb_len);
 	switch(cmd->scb_len) {
 	case 6:
 		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x",
@@ -310,6 +388,7 @@ enum {
 	Opt_vendor_id, Opt_product_id,
 	Opt_product_rev, Opt_sense_format,
 	Opt_removable, Opt_online,
+	Opt_mode_page,
 	Opt_err,
 };
 
@@ -322,13 +401,14 @@ static match_table_t tokens = {
 	{Opt_sense_format, "sense_format=%s"},
 	{Opt_removable, "removable=%s"},
 	{Opt_online, "online=%s"},
+	{Opt_mode_page, "mode_page=%s"},
 	{Opt_err, NULL},
 };
 
 int spc_lu_config(struct scsi_lu *lu, char *params) {
 	int err = 0;
 	char *p;
-	char buf[20];
+	char buf[256];
 
 	if (!strncmp("targetOps", params, 9))
 		params = params + 10;
@@ -372,6 +452,10 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			match_strncpy(buf, &args[0],  sizeof(buf));
 			lu->attrs.online = atoi(buf);
 			break;
+		case Opt_mode_page:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			err = add_mode_page(lu, buf);
+			break;
 		default:
 			err = TGTADM_INVALID_REQUEST;
 		}
diff --git a/usr/spc.h b/usr/spc.h
index 1036b70..c7b8652 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -10,5 +10,6 @@ extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
 extern int spc_lu_init(struct scsi_lu *lu);
 extern int spc_lu_config(struct scsi_lu *lu, char * params);
 extern void dump_cdb(struct scsi_cmd *cmd);
+extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
 
 #endif
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 8e66d60..bbacae2 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -5,6 +5,7 @@
 
 #define SCSI_ID_LEN	24
 #define SCSI_SN_LEN	8
+#define BLOCK_DESCRIPTOR_LEN 8
 #define VERSION_DESCRIPTOR_LEN 8
 
 #define VENDOR_ID	"IET"
@@ -96,6 +97,9 @@ struct scsi_lu {
 
 	struct backingstore_template *bst;
 
+	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
+	struct list_head mode_pages;
+
 	/* TODO: needs a structure for lots of device parameters */
 	struct lu_phy_attr attrs;
 };
-- 
1.5.2.1







From markh794 at gmail.com  Wed Jun 20 10:32:29 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 20 Jun 2007 18:32:29 +1000
Subject: [Stgt-devel] [Patch 0/6] patch set rebuilt on to of latest 'git
	head'
Message-ID: <4678E61D.20803@gmail.com>

Patches have bee re-formatted on top of latest git head
  ============================
commit 22b66b622433a6426514ca69063e0370f223f0e1
Author: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
Date:   Tue Jun 19 13:32:21 2007 +0900

    update README.iSCSI for scc device
   
    Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
  ============================


Patch 1:
As far as I can see, if ibmvio ibmvio_inquiry() is called AND
bits 1 & 2 of sbc[1] are set, then spc_inquiry() will be called.

data = valloc() will be called twice. Once in ibmvio_inquiry()
and again in spc_inquiry()

Fix: Only valloc() memory if spc_inquiry is not to be called.


Patch 2:
Remove an unnecessary test. SAM_STAT_GOOD is the only value possible.

Note: Patch 1 & 2 have NOT been tested as I don't have platform to test on.


Patch 3:
Update the 'tgt-core-test' script to handle new tgt lu setup.


Patch 4:
Instead of using numeric values for ASC & ASCQ, I have defined most common
values into a 16bit value.

while there is no immediate advantage of these defines, the SMC & SSC 
modules make
much greater use of sense codes and should make these modules more 
'readable'

Note: Due to the lack of any imagination on my behalf, the defines have 
an 'E_'
prefix. Suggestions for better prefix most welcome.


Patch 5:
While testing code for 'Patch 4', I noticed the spc_request_sense() returns
0 bytes of data.
Updated this SCSI OP code to at least return some data.
Not perfect but at least no errors any more.

I used the sg_requests command from sg3_utils package to test.


Patch 6:
SCSI OP code : MODE SENSE

Implemented both 6 & 10 byte MODE SENSE SCSI OP code.

At logical unit setup time, each required mode page can be configured using
tgtadm command.

This results in more setup work for the user, however I would expect most
people will setup up the creation of the stgt devices in a script.
(sample tgt-core-test supplied)

i.e. Offloading hard-coding mode page information to the user at lu 
setup time.


Thoughts & suggestions always welcome.

Mark Harvey




From fujita.tomonori at lab.ntt.co.jp  Wed Jun 20 12:45:51 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 20 Jun 2007 19:45:51 +0900
Subject: [Stgt-devel] [Patch 3/6] Update sample script to new lu layout.
In-Reply-To: <4678DEDA.2080401@gmail.com>
References: <4678DEDA.2080401@gmail.com>
Message-ID: <20070620194551E.fujita.tomonori@lab.ntt.co.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 3/6] Update sample script to new lu layout.
Date: Wed, 20 Jun 2007 18:01:30 +1000

> >From 42b2eaf57103613b67cefe2d0a47b281ee3ceccd Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Wed, 20 Jun 2007 17:34:26 +1000
> Subject: Updated sample script to suit new Logical Unit creation
> 
> As LU are no longer tied to the target type, the sample script
> required a rework to suit new layout.

Thanks. The patch looks ok. I'll apply this.

Is the currrent device-type-lun code working for you?


From fujita.tomonori at lab.ntt.co.jp  Wed Jun 20 12:45:44 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 20 Jun 2007 19:45:44 +0900
Subject: [Stgt-devel] [Patch 1/6] Fix potential memory leak
In-Reply-To: <4678DDF8.5070601@gmail.com>
References: <4678DDF8.5070601@gmail.com>
Message-ID: <20070620194544F.fujita.tomonori@lab.ntt.co.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 1/6] Fix potential memory leak
Date: Wed, 20 Jun 2007 17:57:44 +1000

> >From f25303a09128973d77df0bb49926001212548f1d Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Wed, 20 Jun 2007 17:31:32 +1000
> Subject: Fix memory leak in ibmvio -> spc_inquiry() path
> 
> Allocating data = valloc() twice when calling spc_inquiry()

Thanks for finding this bug.

__ibmvio_inquiry should handle errors properly so I'll fix this in a
different way.

> Signed-off-by: Mark Harvey <markh794 at gmail.com>
> ---
>  usr/ibmvio/ibmvio.c |   15 +++++++--------
>  1 files changed, 7 insertions(+), 8 deletions(-)
> 
> diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
> index 5a2f8fe..1b1785d 100644
> --- a/usr/ibmvio/ibmvio.c
> +++ b/usr/ibmvio/ibmvio.c
> @@ -145,17 +145,16 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
>  	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
>  		goto sense;
>  
> -	data = valloc(pagesize);
> -	if (!data) {
> -		key = HARDWARE_ERROR;
> -		asc = 0;
> -		goto sense;
> -	}
> -	memset(data, 0, pagesize);
> -
>  	dprintf("%x %x\n", scb[1], scb[2]);
>  
>  	if (!(scb[1] & 0x3)) {
> +		data = valloc(pagesize);
> +		if (!data) {
> +			key = HARDWARE_ERROR;
> +			asc = 0;
> +			goto sense;
> +		}
> +		memset(data, 0, pagesize);
>  		cmd->len = __ibmvio_inquiry(host_no, cmd, data);
>  		ret = SAM_STAT_GOOD;
>  	} else
> -- 
> 1.5.2.1
> 
> 
> 
> 
> 
> 
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
> 


From fujita.tomonori at lab.ntt.co.jp  Wed Jun 20 12:45:54 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 20 Jun 2007 19:45:54 +0900
Subject: [Stgt-devel] [Patch 4/6] Use mnemonic value for ASC/ASCQ values
In-Reply-To: <4678DFD9.2040407@gmail.com>
References: <4678DFD9.2040407@gmail.com>
Message-ID: <20070620194554R.fujita.tomonori@lab.ntt.co.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 4/6] Use mnemonic value for ASC/ASCQ values
Date: Wed, 20 Jun 2007 18:05:45 +1000

> A better prefix to the defines instead of 'E_' would be nice.
> 
> Any recommendations for a good naming convention  ? 

I don't have a good proposal now but E_ doesn't look nice. Let's wait
for a while to see we could have a better name.


From fujita.tomonori at lab.ntt.co.jp  Wed Jun 20 12:45:56 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 20 Jun 2007 19:45:56 +0900
Subject: [Stgt-devel] [Patch 6/6] Create mode page information at runtime
In-Reply-To: <4678E0A9.8060208@gmail.com>
References: <4678E0A9.8060208@gmail.com>
Message-ID: <20070620194556G.fujita.tomonori@lab.ntt.co.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 6/6] Create mode page information at runtime
Date: Wed, 20 Jun 2007 18:09:13 +1000

> >From 9f725d6f1dc62143c0d7cba54db8a612a7fb5bd4 Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Wed, 20 Jun 2007 17:52:46 +1000
> Subject: Dynamic mode page creation.
> 
> Mode pages are now built at run time.
> 
> Initial configuration via the 'tgtadm --params mode_page'
> Page information is seperated by ':'
> e.g.
>  --params mode_page=10:1:11:2:0:0:0:0:0:0:0:2:0:0
> Where '10' is mode page 10
>       '1'  is the subpage
>       '11' is the length of the page data (11 bytes of information follow)
> 
> The example script 'scripts/tgt-core-test' contains an executable example.
> 
> The 'doc/README.lu_configuration' updated for mode page informaiton.
> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>
> ---
>  doc/README.lu_configuration |   20 +++++
>  scripts/tgt-core-test       |   61 ++++++++++++----
>  usr/Makefile                |    2 +-
>  usr/mmc.c                   |   32 ++++++++-
>  usr/mode_page.c             |  141 ++++++++++++++++++++++++++++++++++
>  usr/mode_page.h             |   37 +++++++++

Why can't we just put them to spc.[ch]?

>  usr/osd.c                   |    3 +
>  usr/sbc.c                   |  174 +++++++++----------------------------------
>  usr/spc.c                   |   86 +++++++++++++++++++++-
>  usr/spc.h                   |    1 +
>  usr/tgtd.h                  |    4 +
>  11 files changed, 405 insertions(+), 156 deletions(-)
>  create mode 100644 usr/mode_page.c
>  create mode 100644 usr/mode_page.h
> 
> diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
> index 1244bc0..d63668a 100644
> --- a/doc/README.lu_configuration
> +++ b/doc/README.lu_configuration
> @@ -65,5 +65,25 @@ standard INQUIRY:
>  As can be seen from above 'sg_inq' output, the RMB (removable) bit is set to 1.
>  The Unit serial number page updated with 'FRED00'
>  
> +Mode Page Creation
> +------------------
> +Create mode page '2', subpage 0 and 14 bytes of data.
> +tgtadm --mode logicalunit --op update --tid 1 --lun 2 \
> +         --params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
> +
> +Create mode page '3', subpage 0 and 22 bytes of data.
> +tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
> +         --params mode_page=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
> +
> +Create mode page '10', subpage 0 and 10 bytes of data.
> +tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
> +         --params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
> +
> +Create mode page '0x1c', subpage 0 and 10 bytes of data.
> +tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
> +         --params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
> +
> +
> +
>  Please refer to scripts/tgt-core-test for a working example.
>  
> diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
> index a90fc9d..8f4d6ea 100755
> --- a/scripts/tgt-core-test
> +++ b/scripts/tgt-core-test
> @@ -3,6 +3,7 @@
>  # Parent directory for data files..
>  HOME=/d/01
>  
> +# Start tgtd if not running..
>  P=`ps -ef|grep -v grep|grep tgtd|wc -l`
>  if [ "X"$P == "X0" ]; then
>  	tgtd -d 1
> @@ -48,23 +49,55 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>  tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>  	--params vendor_id=QUANTUM,product_id=HD100,product_rev=0010,removable=1,sense_format=0
>  
> -# Create 2nd LUN - CD/ROM
> -LUN=2
> -tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
> -tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> -	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY11,removable=1
> +#### Set up mode pages ####
> +# First try a couple of attempts with incorrect data..
>  
> -# Create 3rd LUN - CD/ROM
> -LUN=3
> -tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
> +# - Length too long & Incorrect value (300) as one if the params...
>  tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> -	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY12,removable=1
> -
> -# Create 4th LUN - CD/ROM
> -LUN=4
> -tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
> +	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:300:0:0:0:0:0:0:0:0:3
> +# - Length too short...
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0
> +# - Just right...
> +# Vendor Uniq - Mode page 0..
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +	--params mode_page=0:0:0
> +# Disconnect page
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
> +# Format mode page
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +	--params mode_page=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
> +# Geo mode page
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +	--params mode_page=4:0:22:0:0:0:0x40:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0x3a:0x98:0:0
> +# Caching Page
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +	--params mode_page=8:0:18:0x14:0:0xff:0xff:0:0:0xff:0xff:0xff:0xff:0x80:0x14:0:0:0:0:0:0
> +# ctrl mode page
> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +	--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
> +# Informational Exceptions Control Mode Page
>  tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> -	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY13,removable=1
> +	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
> +
> +
> +
> +for LUN in 2 3 4; do
> +	# Create LUN - CD/ROM
> +	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
> +	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +		--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY1$LUN,removable=1
> +	# Vendor Uniq - Mode page 0..
> +	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +		--params mode_page=0:0:0
> +	# ctrl mode page
> +	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +		--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
> +	# Informational Exceptions Control Mode Page
> +	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
> +		--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
> +done
>  
>  # Allow ALL initiators to connect to this target
>  tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
> diff --git a/usr/Makefile b/usr/Makefile
> index 14be34b..43a0fe6 100644
> --- a/usr/Makefile
> +++ b/usr/Makefile
> @@ -44,7 +44,7 @@ CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDE
>  
>  PROGRAMS += tgtd tgtadm
>  TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o osd.o spt.o scc.o scsi.o log.o \
> -	driver.o util.o work.o parser.o
> +	driver.o util.o work.o parser.o mode_page.o
>  
>  all: $(PROGRAMS)
>  
> diff --git a/usr/mmc.c b/usr/mmc.c
> index bfcf76e..75d419a 100644
> --- a/usr/mmc.c
> +++ b/usr/mmc.c
> @@ -122,6 +122,15 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
>  	return SAM_STAT_GOOD;
>  }
>  
> +static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)
> +{
> +	uint8_t *scb = cmd->scb;
> +
> +	/* MMC devices always return descriptor block */
> +	scb[1] |= 8;
> +	return spc_mode_sense(host_no, cmd);
> +}
> +
>  static int mmc_lu_init(struct scsi_lu *lu)
>  {
>  	if (spc_lu_init(lu))
> @@ -133,6 +142,8 @@ static int mmc_lu_init(struct scsi_lu *lu)
>  	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
>  	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
>  
> +	INIT_LIST_HEAD(&lu->mode_pages);
> +
>  	return 0;
>  }
>  
> @@ -218,7 +229,26 @@ static struct device_type_template mmc_template = {
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
>  
> -		[0x50 ... 0x9f] = {spc_illegal_op,},
> +		/* 0x50 */
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{mmc_mode_sense,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +
> +		[0x60 ... 0x9f] = {spc_illegal_op,},
>  
>  		/* 0xA0 */
>  		{spc_report_luns,},
> diff --git a/usr/mode_page.c b/usr/mode_page.c
> new file mode 100644
> index 0000000..708115b
> --- /dev/null
> +++ b/usr/mode_page.c
> @@ -0,0 +1,141 @@
> +/*
> + * Common routines with regards to SCSI mode op codes.
> + *
> + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; version 2 of the License.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, write to the Free Software
> + * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
> + */
> +
> +#include <errno.h>
> +#include <stdio.h>
> +#include <stdlib.h>
> +#include <string.h>
> +#include <stdint.h>
> +#include <unistd.h>
> +#include <linux/fs.h>
> +#include <string.h>
> +
> +#include "list.h"
> +#include "util.h"
> +#include "tgtd.h"
> +#include "tgtadm_error.h"
> +#include "mode_page.h"
> +
> +/*
> + * Init and alloc space for the supported mode page structures
> + */
> +int insert_mode_page(struct list_head *head, int page, int subpage, int sz)
> +{
> +	struct mode *m;
> +
> +	if ((m = zalloc(sizeof(struct mode))) == NULL)
> +		return -ENOMEM;
> +	if ((m->mode_data = zalloc(sz)) == NULL) {
> +		free(m);
> +		return -ENOMEM;
> +	}
> +	m->pcode = page;
> +	m->subpcode = subpage;
> +	m->pcode_sz = (uint16_t)sz;
> +	list_add_tail(&m->mode_siblings, head);
> +	return 0;
> +}
> +
> +struct mode *mode_page_lookup(struct list_head *head, uint8_t page)
> +{
> +	struct mode *m;
> +
> +	list_for_each_entry(m, head, mode_siblings)
> +		if (m->pcode == page)
> +			return m;
> +
> +	return NULL;
> +}
> +
> +/*
> + * Return:
> + * 	0 on success
> + *	TGTADM_INVALID_REQUEST on error
> + */
> +int add_mode_page(struct scsi_lu *lu, char *params)
> +{
> +	char *p = NULL;
> +	int i = 0;
> +	int tmp;
> +	uint8_t page = 0;
> +	uint8_t subpage = 0;
> +	uint8_t *data = NULL;
> +	uint16_t sz = 0;
> +	struct mode *m = NULL;
> +
> +	while ((p = strsep(&params, ":")) != NULL) {
> +		switch (i) {
> +		case 0:
> +			page = strtol(p, NULL, 0);
> +			break;
> +		case 1:
> +			subpage = strtol(p, NULL, 0);
> +			break;
> +		case 2:
> +			sz = strtol(p, NULL, 0);
> +			insert_mode_page(&lu->mode_pages, page, subpage, sz);
> +			m = mode_page_lookup(&lu->mode_pages, page);
> +			data = m->mode_data;
> +			break;
> +		default:
> +			if (i < (sz + 3)) {
> +				tmp = strtol(p, NULL, 0);
> +				if (tmp > 255)
> +					dprintf("Error : Incorrect value %d "
> +					"Mode page %d (0x%02x), index: %d\n",
> +						tmp, page, page, i - 3);
> +				data[i - 3] = (uint8_t)tmp;
> +			}
> +			break;
> +		}
> +		i++;
> +	}
> +	if (i != (sz + 3)) {
> +		dprintf("Mode Page %d (0x%02x): param_count %d != "
> +					" MODE PAGE size : %d\n",
> +				page, page, i, sz + 3);
> +		return TGTADM_INVALID_REQUEST;
> +	} else
> +		return TGTADM_SUCCESS;
> +}
> +
> +/*
> + * Copy mode page data from list into SCSI data so it can be returned
> + * to the initiator
> + *
> + * *data -> target address (destination)
> + * mode -> Pointer to mode page information (source)
> + *
> + * Returns number of bytes copied.
> + */
> +int build_mode_page(uint8_t *data, struct mode *m)
> +{
> +	uint8_t *p;
> +	int len;
> +
> +	data[0] = m->pcode;
> +	len = m->pcode_sz;
> +	data[1] = len;
> +	p = &data[2];
> +	len += 2;
> +	dprintf("Page: 0x%02x (%d)\n", m->pcode, m->pcode);
> +	memcpy(p, m->mode_data, m->pcode_sz);
> +
> +return len;
> +}
> diff --git a/usr/mode_page.h b/usr/mode_page.h
> new file mode 100644
> index 0000000..31eafd3
> --- /dev/null
> +++ b/usr/mode_page.h
> @@ -0,0 +1,37 @@
> +/*
> + * SCSI Medium Changer Command
> + *
> + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; version 2 of the License.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, write to the Free Software
> + * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
> + */
> +
> +
> +#ifndef _SPC_MODE_PG_H_
> +#define _SPC_MODE_PG_H_
> +
> +struct mode {
> +	struct list_head mode_siblings;
> +	uint8_t pcode;		/* Page code */
> +	uint8_t subpcode;	/* Sub page code */
> +	int16_t pcode_sz;	/* Size of page code data. */
> +	uint8_t *mode_data;	/* Rest of mode page info */
> +};
> +
> +int insert_mode_page(struct list_head *head, int page, int subpage, int sz);
> +struct mode *mode_page_lookup(struct list_head *head, uint8_t page);
> +int add_mode_page(struct scsi_lu *lu, char *params);
> +int build_mode_page(uint8_t *data, struct mode *m);
> +
> +#endif /* _SPC_MODE_PG_H_ */
> diff --git a/usr/osd.c b/usr/osd.c
> index e571ebf..684be4d 100644
> --- a/usr/osd.c
> +++ b/usr/osd.c
> @@ -61,6 +61,9 @@ static int osd_lu_init(struct scsi_lu *lu)
>  	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
>  	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
>  
> +	/* not used - but initialise anyway... */
> +	INIT_LIST_HEAD(&lu->mode_pages);
> +
>  	return 0;
>  }
>  
> diff --git a/usr/sbc.c b/usr/sbc.c
> index 9d03ea4..db11381 100644
> --- a/usr/sbc.c
> +++ b/usr/sbc.c
> @@ -39,6 +39,7 @@
>  #include "scsi.h"
>  #include "spc.h"
>  #include "sense_codes.h"
> +#include "mode_page.h"
>  
>  #define BLK_SHIFT	9
>  
> @@ -169,146 +170,11 @@ sense:
>  	return SAM_STAT_CHECK_CONDITION;
>  }
>  
> -static int insert_disconnect_pg(uint8_t *ptr)
> -{
> -	unsigned char disconnect_pg[] = {0x02, 0x0e, 0x80, 0x80, 0x00, 0x0a, 0x00, 0x00,
> -                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
> -
> -	memcpy(ptr, disconnect_pg, sizeof(disconnect_pg));
> -	return sizeof(disconnect_pg);
> -}
> -
> -static int insert_caching_pg(uint8_t *ptr)
> -{
> -	unsigned char caching_pg[] = {0x08, 0x12, 0x14, 0x00, 0xff, 0xff, 0x00, 0x00,
> -				      0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0x00, 0x00,
> -				      0x00, 0x00, 0x00, 0x00};
> -
> -	memcpy(ptr, caching_pg, sizeof(caching_pg));
> -	return sizeof(caching_pg);
> -}
> -
> -static int insert_ctrl_m_pg(uint8_t *ptr)
> -{
> -	unsigned char ctrl_m_pg[] = {0x0a, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
> -				     0x00, 0x00, 0x02, 0x4b};
> -
> -	memcpy(ptr, ctrl_m_pg, sizeof(ctrl_m_pg));
> -	return sizeof(ctrl_m_pg);
> -}
> -
> -static int insert_iec_m_pg(uint8_t *ptr)
> -{
> -	unsigned char iec_m_pg[] = {0x1c, 0xa, 0x08, 0x00, 0x00, 0x00, 0x00,
> -				    0x00, 0x00, 0x00, 0x00, 0x00};
> -
> -	memcpy(ptr, iec_m_pg, sizeof(iec_m_pg));
> -	return sizeof(iec_m_pg);
> -}
> -
> -static int insert_format_m_pg(uint8_t *ptr)
> -{
> -	unsigned char format_m_pg[] = {0x03, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
> -				       0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
> -				       0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00};
> -	memcpy(ptr, format_m_pg, sizeof(format_m_pg));
> -	return sizeof(format_m_pg);
> -}
> -
> -static int insert_geo_m_pg(uint8_t *ptr, uint64_t sec)
> -{
> -	unsigned char geo_m_pg[] = {0x04, 0x16, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
> -				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
> -				    0x00, 0x00, 0x00, 0x00, 0x3a, 0x98, 0x00, 0x00};
> -	uint32_t ncyl, *p;
> -
> -	/* assume 0xff heads, 15krpm. */
> -	memcpy(ptr, geo_m_pg, sizeof(geo_m_pg));
> -	ncyl = sec >> 14; /* 256 * 64 */
> -	p = (uint32_t *)(ptr + 1);
> -	*p = *p | __cpu_to_be32(ncyl);
> -	return sizeof(geo_m_pg);
> -}
> -
> -static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
> +static int sbc_lu_init(struct scsi_lu *lu)
>  {
> -	int ret = SAM_STAT_GOOD, len;
> -	uint8_t pcode = cmd->scb[2] & 0x3f;
>  	uint64_t size;
> -	uint8_t *data = NULL;
> -	unsigned char key = ILLEGAL_REQUEST;
> -	uint16_t asc = E_LUN_NOT_SUPPORTED;
> -
> -	if (device_reserved(cmd))
> -		return SAM_STAT_RESERVATION_CONFLICT;
> -
> -	data = valloc(pagesize);
> -	if (!data) {
> -		key = HARDWARE_ERROR;
> -		asc = E_INTERNAL_TGT_FAILURE;
> -		goto sense;
> -	}
> -	memset(data, 0, pagesize);
> -
> -	len = 4;
> -	size = cmd->dev->size >> BLK_SHIFT;
> -
> -	if ((cmd->scb[1] & 0x8))
> -		data[3] = 0;
> -	else {
> -		data[3] = 8;
> -		len += 8;
> -		*(uint32_t *)(data + 4) = (size >> 32) ?
> -			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
> -		*(uint32_t *)(data + 8) = __cpu_to_be32(1 << BLK_SHIFT);
> -	}
> -
> -	switch (pcode) {
> -	case 0x0:
> -		break;
> -	case 0x2:
> -		len += insert_disconnect_pg(data + len);
> -		break;
> -	case 0x3:
> -		len += insert_format_m_pg(data + len);
> -		break;
> -	case 0x4:
> -		len += insert_geo_m_pg(data + len, size);
> -		break;
> -	case 0x8:
> -		len += insert_caching_pg(data + len);
> -		break;
> -	case 0xa:
> -		len += insert_ctrl_m_pg(data + len);
> -		break;
> -	case 0x1c:
> -		len += insert_iec_m_pg(data + len);
> -		break;
> -	case 0x3f:
> -		len += insert_disconnect_pg(data + len);
> -		len += insert_format_m_pg(data + len);
> -		len += insert_geo_m_pg(data + len, size);
> -		len += insert_caching_pg(data + len);
> -		len += insert_ctrl_m_pg(data + len);
> -		len += insert_iec_m_pg(data + len);
> -		break;
> -	default:
> -		asc = E_INVALID_FIELD_IN_CDB;
> -		goto sense;
> -	}
> +	uint8_t *data;
>  
> -	data[0] = len - 1;
> -	cmd->len = len;
> -	cmd->uaddr = (unsigned long) data;
> -	return ret;
> -sense:
> -	cmd->len = 0;
> -	sense_data_build(cmd, key, asc);
> -	return SAM_STAT_CHECK_CONDITION;
> -}
> -
> -static int sbc_lu_init(struct scsi_lu *lu)
> -{
>  	if (spc_lu_init(lu))
>  		return -ENOMEM;
>  
> @@ -317,6 +183,15 @@ static int sbc_lu_init(struct scsi_lu *lu)
>  	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
>  	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
>  
> +	INIT_LIST_HEAD(&lu->mode_pages);
> +
> +	data = lu->mode_block_descriptor;
> +	size = lu->size >> BLK_SHIFT;
> +
> +	*(uint32_t *)(data) = (size >> 32) ?
> +			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
> +	*(uint32_t *)(data + 4) = __cpu_to_be32(1 << BLK_SHIFT);
> +
>  	return 0;
>  }
>  
> @@ -355,7 +230,7 @@ static struct device_type_template sbc_template = {
>  
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
> -		{sbc_mode_sense,},
> +		{spc_mode_sense,},
>  		{spc_start_stop,},
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
> @@ -400,7 +275,28 @@ static struct device_type_template sbc_template = {
>  		{spc_illegal_op,},
>  		{spc_illegal_op,},
>  
> -		[0x40 ... 0x7f] = {spc_illegal_op,},
> +		[0x40 ... 0x4f] = {spc_illegal_op,},
> +
> +		/* 0x50 */
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_mode_sense,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +		{spc_illegal_op,},
> +
> +		[0x60 ... 0x7f] = {spc_illegal_op,},
>  
>  		/* 0x80 */
>  		{spc_illegal_op,},
> diff --git a/usr/spc.c b/usr/spc.c
> index 6530e73..32dac79 100644
> --- a/usr/spc.c
> +++ b/usr/spc.c
> @@ -35,6 +35,7 @@
>  #include "scsi.h"
>  #include "spc.h"
>  #include "sense_codes.h"
> +#include "mode_page.h"
>  
>  #define PRODUCT_REV	"0"
>  #define BLK_SHIFT	9
> @@ -231,6 +232,82 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
>  		return SAM_STAT_GOOD;
>  }
>  
> +/*
> + * Reference : SPC4r11
> + * 6.11 - MODE SENSE(6)
> + * 6.12 - MODE SENSE(10)
> + */
> +int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
> +{
> +	int	len = 0;
> +	uint8_t *data;
> +	uint8_t *scb = cmd->scb;
> +	uint8_t	mode6 = (scb[0] == 0x1a) ? 1 : 0;
> +	uint8_t dbd = (scb[1] & 8) ? 1 : 0;	/* Disable Block Descriptors */
> +	uint8_t page_code = scb[2] & 0x3f;
> +	uint8_t subpage = scb[3];
> +	uint16_t alloc_len;
> +	struct	mode	* m;
> +	unsigned char key = ILLEGAL_REQUEST;
> +	uint16_t asc = E_INVALID_FIELD_IN_CDB;
> +
> +	if (subpage)
> +		goto sense;	/* Currently not implemented */
> +
> +	data = valloc(pagesize);
> +	if (!data) {
> +		key = HARDWARE_ERROR;
> +		asc = E_INTERNAL_TGT_FAILURE;
> +		goto sense;
> +	}
> +	memset(data, 0, pagesize);
> +	if (mode6) {
> +		alloc_len = scb[4];
> +		len = 4;
> +	} else {
> +		alloc_len = (scb[7] << 8) + scb[8];
> +		len = 8;
> +	}
> +	if (alloc_len > pagesize)
> +		goto sense;
> +
> +	if (!dbd) {
> +		memcpy(data + len, cmd->dev->mode_block_descriptor,
> +				BLOCK_DESCRIPTOR_LEN);
> +		len += 8;
> +	}
> +
> +	if (page_code == 0x3f) {	/* All pages */
> +		int	i;
> +		for (i=0; i < 0x3f; i++) {
> +			m = mode_page_lookup(&cmd->dev->mode_pages, i);
> +			if (m)
> +				len += build_mode_page(data + len, m);
> +		}
> +	} else {
> +		m = mode_page_lookup(&cmd->dev->mode_pages, page_code);
> +		if (!m)
> +			goto sense;
> +		len += build_mode_page(data + len, m);
> +	}
> +	if (mode6) {
> +		data[0] = len - 1;
> +		data[3] = (dbd) ? 0 : BLOCK_DESCRIPTOR_LEN;
> +	} else {
> +		*(uint16_t *)(data) = __cpu_to_be16(len - 3);
> +		data[7] = (dbd) ? 0 : BLOCK_DESCRIPTOR_LEN;
> +	}
> +
> +	cmd->len = len;
> +	cmd->uaddr = (unsigned long)data;
> +	return SAM_STAT_GOOD;
> +
> +sense:
> +	cmd->len = 0;
> +	sense_data_build(cmd, key, asc);
> +	return SAM_STAT_CHECK_CONDITION;
> +}
> +
>  int spc_request_sense(int host_no, struct scsi_cmd *cmd)
>  {
>  	uint8_t *data;
> @@ -269,6 +346,7 @@ void dump_cdb(struct scsi_cmd *cmd)
>  {
>  	uint8_t *cdb = cmd->scb;
>  
> +	dprintf("cmd->cdb_len: %d\n", cmd->scb_len);
>  	switch(cmd->scb_len) {
>  	case 6:
>  		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x",
> @@ -310,6 +388,7 @@ enum {
>  	Opt_vendor_id, Opt_product_id,
>  	Opt_product_rev, Opt_sense_format,
>  	Opt_removable, Opt_online,
> +	Opt_mode_page,
>  	Opt_err,
>  };
>  
> @@ -322,13 +401,14 @@ static match_table_t tokens = {
>  	{Opt_sense_format, "sense_format=%s"},
>  	{Opt_removable, "removable=%s"},
>  	{Opt_online, "online=%s"},
> +	{Opt_mode_page, "mode_page=%s"},
>  	{Opt_err, NULL},
>  };
>  
>  int spc_lu_config(struct scsi_lu *lu, char *params) {
>  	int err = 0;
>  	char *p;
> -	char buf[20];
> +	char buf[256];
>  
>  	if (!strncmp("targetOps", params, 9))
>  		params = params + 10;
> @@ -372,6 +452,10 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
>  			match_strncpy(buf, &args[0],  sizeof(buf));
>  			lu->attrs.online = atoi(buf);
>  			break;
> +		case Opt_mode_page:
> +			match_strncpy(buf, &args[0], sizeof(buf));
> +			err = add_mode_page(lu, buf);
> +			break;
>  		default:
>  			err = TGTADM_INVALID_REQUEST;
>  		}
> diff --git a/usr/spc.h b/usr/spc.h
> index 1036b70..c7b8652 100644
> --- a/usr/spc.h
> +++ b/usr/spc.h
> @@ -10,5 +10,6 @@ extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
>  extern int spc_lu_init(struct scsi_lu *lu);
>  extern int spc_lu_config(struct scsi_lu *lu, char * params);
>  extern void dump_cdb(struct scsi_cmd *cmd);
> +extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
>  
>  #endif
> diff --git a/usr/tgtd.h b/usr/tgtd.h
> index 8e66d60..bbacae2 100644
> --- a/usr/tgtd.h
> +++ b/usr/tgtd.h
> @@ -5,6 +5,7 @@
>  
>  #define SCSI_ID_LEN	24
>  #define SCSI_SN_LEN	8
> +#define BLOCK_DESCRIPTOR_LEN 8
>  #define VERSION_DESCRIPTOR_LEN 8
>  
>  #define VENDOR_ID	"IET"
> @@ -96,6 +97,9 @@ struct scsi_lu {
>  
>  	struct backingstore_template *bst;
>  
> +	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
> +	struct list_head mode_pages;
> +
>  	/* TODO: needs a structure for lots of device parameters */
>  	struct lu_phy_attr attrs;
>  };
> -- 
> 1.5.2.1
> 
> 
> 
> 
> 
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
> 


From markh794 at gmail.com  Wed Jun 20 13:00:25 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 20 Jun 2007 21:00:25 +1000
Subject: [Stgt-devel] [Patch 1/6] Fix potential memory leak
In-Reply-To: <20070620194544F.fujita.tomonori@lab.ntt.co.jp>
References: <4678DDF8.5070601@gmail.com>
	<20070620194544F.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <467908C9.2010204@gmail.com>

FUJITA Tomonori wrote:
> From: Mark Harvey <markh794 at gmail.com>
> Subject: [Stgt-devel] [Patch 1/6] Fix potential memory leak
> Date: Wed, 20 Jun 2007 17:57:44 +1000
>
>   
>> >From f25303a09128973d77df0bb49926001212548f1d Mon Sep 17 00:00:00 2001
>> From: Mark Harvey <markh794 at gmail.com>
>> Date: Wed, 20 Jun 2007 17:31:32 +1000
>> Subject: Fix memory leak in ibmvio -> spc_inquiry() path
>>
>> Allocating data = valloc() twice when calling spc_inquiry()
>>     
>
> Thanks for finding this bug.
>
> __ibmvio_inquiry should handle errors properly so I'll fix this in a
> different way.
>
>   

No problems... I found it while looking thru the code updating the 
ASC/ASCQ stuff.

BTW: Can the ibmvio be complied on an x86 linux host ?

Or am I doing something wrong.

>> Signed-off-by: Mark Harvey <markh794 at gmail.com>
>> ---
>>  usr/ibmvio/ibmvio.c |   15 +++++++--------
>>  1 files changed, 7 insertions(+), 8 deletions(-)
>>
>> diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
>> index 5a2f8fe..1b1785d 100644
>> --- a/usr/ibmvio/ibmvio.c
>> +++ b/usr/ibmvio/ibmvio.c
>> @@ -145,17 +145,16 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
>>  	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
>>  		goto sense;
>>  
>> -	data = valloc(pagesize);
>> -	if (!data) {
>> -		key = HARDWARE_ERROR;
>> -		asc = 0;
>> -		goto sense;
>> -	}
>> -	memset(data, 0, pagesize);
>> -
>>  	dprintf("%x %x\n", scb[1], scb[2]);
>>  
>>  	if (!(scb[1] & 0x3)) {
>> +		data = valloc(pagesize);
>> +		if (!data) {
>> +			key = HARDWARE_ERROR;
>> +			asc = 0;
>> +			goto sense;
>> +		}
>> +		memset(data, 0, pagesize);
>>  		cmd->len = __ibmvio_inquiry(host_no, cmd, data);
>>  		ret = SAM_STAT_GOOD;
>>  	} else
>> -- 
>> 1.5.2.1
>>
>>
>>
>>
>>
>>
>> _______________________________________________
>> Stgt-devel mailing list
>> Stgt-devel at lists.berlios.de
>> https://lists.berlios.de/mailman/listinfo/stgt-devel
>>
>>     
>
>   



From fujita.tomonori at lab.ntt.co.jp  Wed Jun 20 13:13:20 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 20 Jun 2007 20:13:20 +0900
Subject: [Stgt-devel] [Patch 1/6] Fix potential memory leak
In-Reply-To: <467908C9.2010204@gmail.com>
References: <4678DDF8.5070601@gmail.com>
	<20070620194544F.fujita.tomonori@lab.ntt.co.jp>
	<467908C9.2010204@gmail.com>
Message-ID: <20070620201320S.fujita.tomonori@lab.ntt.co.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: Re: [Stgt-devel] [Patch 1/6] Fix potential memory leak
Date: Wed, 20 Jun 2007 21:00:25 +1000

> FUJITA Tomonori wrote:
> > From: Mark Harvey <markh794 at gmail.com>
> > Subject: [Stgt-devel] [Patch 1/6] Fix potential memory leak
> > Date: Wed, 20 Jun 2007 17:57:44 +1000
> >
> >   
> >> >From f25303a09128973d77df0bb49926001212548f1d Mon Sep 17 00:00:00 2001
> >> From: Mark Harvey <markh794 at gmail.com>
> >> Date: Wed, 20 Jun 2007 17:31:32 +1000
> >> Subject: Fix memory leak in ibmvio -> spc_inquiry() path
> >>
> >> Allocating data = valloc() twice when calling spc_inquiry()
> >>     
> >
> > Thanks for finding this bug.
> >
> > __ibmvio_inquiry should handle errors properly so I'll fix this in a
> > different way.
> >
> >   
> 
> No problems... I found it while looking thru the code updating the 
> ASC/ASCQ stuff.
> 
> BTW: Can the ibmvio be complied on an x86 linux host ?

Yeah, but it doesn't work.


From markh794 at gmail.com  Wed Jun 20 13:13:56 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 20 Jun 2007 21:13:56 +1000
Subject: [Stgt-devel] [Patch 6/6] Create mode page information at runtime
In-Reply-To: <20070620194556G.fujita.tomonori@lab.ntt.co.jp>
References: <4678E0A9.8060208@gmail.com>
	<20070620194556G.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <46790BF4.3030905@gmail.com>

FUJITA Tomonori wrote:
> From: Mark Harvey <markh794 at gmail.com>
> Subject: [Stgt-devel] [Patch 6/6] Create mode page information at runtime
> Date: Wed, 20 Jun 2007 18:09:13 +1000
>
>   
>> >From 9f725d6f1dc62143c0d7cba54db8a612a7fb5bd4 Mon Sep 17 00:00:00 2001
>> From: Mark Harvey <markh794 at gmail.com>
>> Date: Wed, 20 Jun 2007 17:52:46 +1000
>> Subject: Dynamic mode page creation.
>>
>> Mode pages are now built at run time.
>>
>> Initial configuration via the 'tgtadm --params mode_page'
>> Page information is seperated by ':'
>> e.g.
>>  --params mode_page=10:1:11:2:0:0:0:0:0:0:0:2:0:0
>> Where '10' is mode page 10
>>       '1'  is the subpage
>>       '11' is the length of the page data (11 bytes of information follow)
>>
>> The example script 'scripts/tgt-core-test' contains an executable example.
>>
>> The 'doc/README.lu_configuration' updated for mode page informaiton.
>>
>> Signed-off-by: Mark Harvey <markh794 at gmail.com>
>> ---
>>  doc/README.lu_configuration |   20 +++++
>>  scripts/tgt-core-test       |   61 ++++++++++++----
>>  usr/Makefile                |    2 +-
>>  usr/mmc.c                   |   32 ++++++++-
>>  usr/mode_page.c             |  141 ++++++++++++++++++++++++++++++++++
>>  usr/mode_page.h             |   37 +++++++++
>>     
>
> Why can't we just put them to spc.[ch]?
>
>   

No reason why not. It was just the way I did it at the time.

I'll do another patch with this merged into the spc.

Eventually, there will also be something similar to this to add LOG 
SENSE/LOG SELECT support.

I'll also add this to the spc code.


My current plan on merging code (as I write it) is:

- MODE SENSE
- Update Test unit ready to correctly handle 'removable' media flag & 
online/offline concept.
- SMC module

At this point I should be able to demonstrate a Virtual CD library.

Then add tape drive support (SSC module).

Followed by 'nice to have' SCSI OP codes like LOG SENSE / LOG SELECT & 
MODE SELECT.


Cheers
Mark

>>  usr/osd.c                   |    3 +
>>  usr/sbc.c                   |  174 +++++++++----------------------------------
>>  usr/spc.c                   |   86 +++++++++++++++++++++-
>>  usr/spc.h                   |    1 +
>>  usr/tgtd.h                  |    4 +
>>  11 files changed, 405 insertions(+), 156 deletions(-)
>>  create mode 100644 usr/mode_page.c
>>  create mode 100644 usr/mode_page.h
>>
>> diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
>> index 1244bc0..d63668a 100644
>> --- a/doc/README.lu_configuration
>> +++ b/doc/README.lu_configuration
>> @@ -65,5 +65,25 @@ standard INQUIRY:
>>  As can be seen from above 'sg_inq' output, the RMB (removable) bit is set to 1.
>>  The Unit serial number page updated with 'FRED00'
>>  
>> +Mode Page Creation
>> +------------------
>> +Create mode page '2', subpage 0 and 14 bytes of data.
>> +tgtadm --mode logicalunit --op update --tid 1 --lun 2 \
>> +         --params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
>> +
>> +Create mode page '3', subpage 0 and 22 bytes of data.
>> +tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
>> +         --params mode_page=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
>> +
>> +Create mode page '10', subpage 0 and 10 bytes of data.
>> +tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
>> +         --params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
>> +
>> +Create mode page '0x1c', subpage 0 and 10 bytes of data.
>> +tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
>> +         --params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
>> +
>> +
>> +
>>  Please refer to scripts/tgt-core-test for a working example.
>>  
>> diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
>> index a90fc9d..8f4d6ea 100755
>> --- a/scripts/tgt-core-test
>> +++ b/scripts/tgt-core-test
>> @@ -3,6 +3,7 @@
>>  # Parent directory for data files..
>>  HOME=/d/01
>>  
>> +# Start tgtd if not running..
>>  P=`ps -ef|grep -v grep|grep tgtd|wc -l`
>>  if [ "X"$P == "X0" ]; then
>>  	tgtd -d 1
>> @@ -48,23 +49,55 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>>  tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>>  	--params vendor_id=QUANTUM,product_id=HD100,product_rev=0010,removable=1,sense_format=0
>>  
>> -# Create 2nd LUN - CD/ROM
>> -LUN=2
>> -tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
>> -tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> -	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY11,removable=1
>> +#### Set up mode pages ####
>> +# First try a couple of attempts with incorrect data..
>>  
>> -# Create 3rd LUN - CD/ROM
>> -LUN=3
>> -tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
>> +# - Length too long & Incorrect value (300) as one if the params...
>>  tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> -	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY12,removable=1
>> -
>> -# Create 4th LUN - CD/ROM
>> -LUN=4
>> -tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
>> +	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:300:0:0:0:0:0:0:0:0:3
>> +# - Length too short...
>> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> +	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0
>> +# - Just right...
>> +# Vendor Uniq - Mode page 0..
>> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> +	--params mode_page=0:0:0
>> +# Disconnect page
>> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> +	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
>> +# Format mode page
>> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> +	--params mode_page=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
>> +# Geo mode page
>> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> +	--params mode_page=4:0:22:0:0:0:0x40:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0x3a:0x98:0:0
>> +# Caching Page
>> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> +	--params mode_page=8:0:18:0x14:0:0xff:0xff:0:0:0xff:0xff:0xff:0xff:0x80:0x14:0:0:0:0:0:0
>> +# ctrl mode page
>> +tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> +	--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
>> +# Informational Exceptions Control Mode Page
>>  tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> -	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY13,removable=1
>> +	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
>> +
>> +
>> +
>> +for LUN in 2 3 4; do
>> +	# Create LUN - CD/ROM
>> +	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
>> +	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> +		--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY1$LUN,removable=1
>> +	# Vendor Uniq - Mode page 0..
>> +	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> +		--params mode_page=0:0:0
>> +	# ctrl mode page
>> +	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> +		--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
>> +	# Informational Exceptions Control Mode Page
>> +	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
>> +		--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
>> +done
>>  
>>  # Allow ALL initiators to connect to this target
>>  tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
>> diff --git a/usr/Makefile b/usr/Makefile
>> index 14be34b..43a0fe6 100644
>> --- a/usr/Makefile
>> +++ b/usr/Makefile
>> @@ -44,7 +44,7 @@ CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDE
>>  
>>  PROGRAMS += tgtd tgtadm
>>  TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o osd.o spt.o scc.o scsi.o log.o \
>> -	driver.o util.o work.o parser.o
>> +	driver.o util.o work.o parser.o mode_page.o
>>  
>>  all: $(PROGRAMS)
>>  
>> diff --git a/usr/mmc.c b/usr/mmc.c
>> index bfcf76e..75d419a 100644
>> --- a/usr/mmc.c
>> +++ b/usr/mmc.c
>> @@ -122,6 +122,15 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
>>  	return SAM_STAT_GOOD;
>>  }
>>  
>> +static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)
>> +{
>> +	uint8_t *scb = cmd->scb;
>> +
>> +	/* MMC devices always return descriptor block */
>> +	scb[1] |= 8;
>> +	return spc_mode_sense(host_no, cmd);
>> +}
>> +
>>  static int mmc_lu_init(struct scsi_lu *lu)
>>  {
>>  	if (spc_lu_init(lu))
>> @@ -133,6 +142,8 @@ static int mmc_lu_init(struct scsi_lu *lu)
>>  	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
>>  	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
>>  
>> +	INIT_LIST_HEAD(&lu->mode_pages);
>> +
>>  	return 0;
>>  }
>>  
>> @@ -218,7 +229,26 @@ static struct device_type_template mmc_template = {
>>  		{spc_illegal_op,},
>>  		{spc_illegal_op,},
>>  
>> -		[0x50 ... 0x9f] = {spc_illegal_op,},
>> +		/* 0x50 */
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{mmc_mode_sense,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +
>> +		[0x60 ... 0x9f] = {spc_illegal_op,},
>>  
>>  		/* 0xA0 */
>>  		{spc_report_luns,},
>> diff --git a/usr/mode_page.c b/usr/mode_page.c
>> new file mode 100644
>> index 0000000..708115b
>> --- /dev/null
>> +++ b/usr/mode_page.c
>> @@ -0,0 +1,141 @@
>> +/*
>> + * Common routines with regards to SCSI mode op codes.
>> + *
>> + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
>> + *
>> + * This program is free software; you can redistribute it and/or modify
>> + * it under the terms of the GNU General Public License as published by
>> + * the Free Software Foundation; version 2 of the License.
>> + *
>> + * This program is distributed in the hope that it will be useful,
>> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
>> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>> + * GNU General Public License for more details.
>> + *
>> + * You should have received a copy of the GNU General Public License
>> + * along with this program; if not, write to the Free Software
>> + * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
>> + */
>> +
>> +#include <errno.h>
>> +#include <stdio.h>
>> +#include <stdlib.h>
>> +#include <string.h>
>> +#include <stdint.h>
>> +#include <unistd.h>
>> +#include <linux/fs.h>
>> +#include <string.h>
>> +
>> +#include "list.h"
>> +#include "util.h"
>> +#include "tgtd.h"
>> +#include "tgtadm_error.h"
>> +#include "mode_page.h"
>> +
>> +/*
>> + * Init and alloc space for the supported mode page structures
>> + */
>> +int insert_mode_page(struct list_head *head, int page, int subpage, int sz)
>> +{
>> +	struct mode *m;
>> +
>> +	if ((m = zalloc(sizeof(struct mode))) == NULL)
>> +		return -ENOMEM;
>> +	if ((m->mode_data = zalloc(sz)) == NULL) {
>> +		free(m);
>> +		return -ENOMEM;
>> +	}
>> +	m->pcode = page;
>> +	m->subpcode = subpage;
>> +	m->pcode_sz = (uint16_t)sz;
>> +	list_add_tail(&m->mode_siblings, head);
>> +	return 0;
>> +}
>> +
>> +struct mode *mode_page_lookup(struct list_head *head, uint8_t page)
>> +{
>> +	struct mode *m;
>> +
>> +	list_for_each_entry(m, head, mode_siblings)
>> +		if (m->pcode == page)
>> +			return m;
>> +
>> +	return NULL;
>> +}
>> +
>> +/*
>> + * Return:
>> + * 	0 on success
>> + *	TGTADM_INVALID_REQUEST on error
>> + */
>> +int add_mode_page(struct scsi_lu *lu, char *params)
>> +{
>> +	char *p = NULL;
>> +	int i = 0;
>> +	int tmp;
>> +	uint8_t page = 0;
>> +	uint8_t subpage = 0;
>> +	uint8_t *data = NULL;
>> +	uint16_t sz = 0;
>> +	struct mode *m = NULL;
>> +
>> +	while ((p = strsep(&params, ":")) != NULL) {
>> +		switch (i) {
>> +		case 0:
>> +			page = strtol(p, NULL, 0);
>> +			break;
>> +		case 1:
>> +			subpage = strtol(p, NULL, 0);
>> +			break;
>> +		case 2:
>> +			sz = strtol(p, NULL, 0);
>> +			insert_mode_page(&lu->mode_pages, page, subpage, sz);
>> +			m = mode_page_lookup(&lu->mode_pages, page);
>> +			data = m->mode_data;
>> +			break;
>> +		default:
>> +			if (i < (sz + 3)) {
>> +				tmp = strtol(p, NULL, 0);
>> +				if (tmp > 255)
>> +					dprintf("Error : Incorrect value %d "
>> +					"Mode page %d (0x%02x), index: %d\n",
>> +						tmp, page, page, i - 3);
>> +				data[i - 3] = (uint8_t)tmp;
>> +			}
>> +			break;
>> +		}
>> +		i++;
>> +	}
>> +	if (i != (sz + 3)) {
>> +		dprintf("Mode Page %d (0x%02x): param_count %d != "
>> +					" MODE PAGE size : %d\n",
>> +				page, page, i, sz + 3);
>> +		return TGTADM_INVALID_REQUEST;
>> +	} else
>> +		return TGTADM_SUCCESS;
>> +}
>> +
>> +/*
>> + * Copy mode page data from list into SCSI data so it can be returned
>> + * to the initiator
>> + *
>> + * *data -> target address (destination)
>> + * mode -> Pointer to mode page information (source)
>> + *
>> + * Returns number of bytes copied.
>> + */
>> +int build_mode_page(uint8_t *data, struct mode *m)
>> +{
>> +	uint8_t *p;
>> +	int len;
>> +
>> +	data[0] = m->pcode;
>> +	len = m->pcode_sz;
>> +	data[1] = len;
>> +	p = &data[2];
>> +	len += 2;
>> +	dprintf("Page: 0x%02x (%d)\n", m->pcode, m->pcode);
>> +	memcpy(p, m->mode_data, m->pcode_sz);
>> +
>> +return len;
>> +}
>> diff --git a/usr/mode_page.h b/usr/mode_page.h
>> new file mode 100644
>> index 0000000..31eafd3
>> --- /dev/null
>> +++ b/usr/mode_page.h
>> @@ -0,0 +1,37 @@
>> +/*
>> + * SCSI Medium Changer Command
>> + *
>> + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
>> + *
>> + * This program is free software; you can redistribute it and/or modify
>> + * it under the terms of the GNU General Public License as published by
>> + * the Free Software Foundation; version 2 of the License.
>> + *
>> + * This program is distributed in the hope that it will be useful,
>> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
>> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
>> + * GNU General Public License for more details.
>> + *
>> + * You should have received a copy of the GNU General Public License
>> + * along with this program; if not, write to the Free Software
>> + * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
>> + */
>> +
>> +
>> +#ifndef _SPC_MODE_PG_H_
>> +#define _SPC_MODE_PG_H_
>> +
>> +struct mode {
>> +	struct list_head mode_siblings;
>> +	uint8_t pcode;		/* Page code */
>> +	uint8_t subpcode;	/* Sub page code */
>> +	int16_t pcode_sz;	/* Size of page code data. */
>> +	uint8_t *mode_data;	/* Rest of mode page info */
>> +};
>> +
>> +int insert_mode_page(struct list_head *head, int page, int subpage, int sz);
>> +struct mode *mode_page_lookup(struct list_head *head, uint8_t page);
>> +int add_mode_page(struct scsi_lu *lu, char *params);
>> +int build_mode_page(uint8_t *data, struct mode *m);
>> +
>> +#endif /* _SPC_MODE_PG_H_ */
>> diff --git a/usr/osd.c b/usr/osd.c
>> index e571ebf..684be4d 100644
>> --- a/usr/osd.c
>> +++ b/usr/osd.c
>> @@ -61,6 +61,9 @@ static int osd_lu_init(struct scsi_lu *lu)
>>  	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
>>  	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
>>  
>> +	/* not used - but initialise anyway... */
>> +	INIT_LIST_HEAD(&lu->mode_pages);
>> +
>>  	return 0;
>>  }
>>  
>> diff --git a/usr/sbc.c b/usr/sbc.c
>> index 9d03ea4..db11381 100644
>> --- a/usr/sbc.c
>> +++ b/usr/sbc.c
>> @@ -39,6 +39,7 @@
>>  #include "scsi.h"
>>  #include "spc.h"
>>  #include "sense_codes.h"
>> +#include "mode_page.h"
>>  
>>  #define BLK_SHIFT	9
>>  
>> @@ -169,146 +170,11 @@ sense:
>>  	return SAM_STAT_CHECK_CONDITION;
>>  }
>>  
>> -static int insert_disconnect_pg(uint8_t *ptr)
>> -{
>> -	unsigned char disconnect_pg[] = {0x02, 0x0e, 0x80, 0x80, 0x00, 0x0a, 0x00, 0x00,
>> -                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
>> -
>> -	memcpy(ptr, disconnect_pg, sizeof(disconnect_pg));
>> -	return sizeof(disconnect_pg);
>> -}
>> -
>> -static int insert_caching_pg(uint8_t *ptr)
>> -{
>> -	unsigned char caching_pg[] = {0x08, 0x12, 0x14, 0x00, 0xff, 0xff, 0x00, 0x00,
>> -				      0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0x00, 0x00,
>> -				      0x00, 0x00, 0x00, 0x00};
>> -
>> -	memcpy(ptr, caching_pg, sizeof(caching_pg));
>> -	return sizeof(caching_pg);
>> -}
>> -
>> -static int insert_ctrl_m_pg(uint8_t *ptr)
>> -{
>> -	unsigned char ctrl_m_pg[] = {0x0a, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
>> -				     0x00, 0x00, 0x02, 0x4b};
>> -
>> -	memcpy(ptr, ctrl_m_pg, sizeof(ctrl_m_pg));
>> -	return sizeof(ctrl_m_pg);
>> -}
>> -
>> -static int insert_iec_m_pg(uint8_t *ptr)
>> -{
>> -	unsigned char iec_m_pg[] = {0x1c, 0xa, 0x08, 0x00, 0x00, 0x00, 0x00,
>> -				    0x00, 0x00, 0x00, 0x00, 0x00};
>> -
>> -	memcpy(ptr, iec_m_pg, sizeof(iec_m_pg));
>> -	return sizeof(iec_m_pg);
>> -}
>> -
>> -static int insert_format_m_pg(uint8_t *ptr)
>> -{
>> -	unsigned char format_m_pg[] = {0x03, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
>> -				       0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
>> -				       0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00};
>> -	memcpy(ptr, format_m_pg, sizeof(format_m_pg));
>> -	return sizeof(format_m_pg);
>> -}
>> -
>> -static int insert_geo_m_pg(uint8_t *ptr, uint64_t sec)
>> -{
>> -	unsigned char geo_m_pg[] = {0x04, 0x16, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
>> -				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
>> -				    0x00, 0x00, 0x00, 0x00, 0x3a, 0x98, 0x00, 0x00};
>> -	uint32_t ncyl, *p;
>> -
>> -	/* assume 0xff heads, 15krpm. */
>> -	memcpy(ptr, geo_m_pg, sizeof(geo_m_pg));
>> -	ncyl = sec >> 14; /* 256 * 64 */
>> -	p = (uint32_t *)(ptr + 1);
>> -	*p = *p | __cpu_to_be32(ncyl);
>> -	return sizeof(geo_m_pg);
>> -}
>> -
>> -static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
>> +static int sbc_lu_init(struct scsi_lu *lu)
>>  {
>> -	int ret = SAM_STAT_GOOD, len;
>> -	uint8_t pcode = cmd->scb[2] & 0x3f;
>>  	uint64_t size;
>> -	uint8_t *data = NULL;
>> -	unsigned char key = ILLEGAL_REQUEST;
>> -	uint16_t asc = E_LUN_NOT_SUPPORTED;
>> -
>> -	if (device_reserved(cmd))
>> -		return SAM_STAT_RESERVATION_CONFLICT;
>> -
>> -	data = valloc(pagesize);
>> -	if (!data) {
>> -		key = HARDWARE_ERROR;
>> -		asc = E_INTERNAL_TGT_FAILURE;
>> -		goto sense;
>> -	}
>> -	memset(data, 0, pagesize);
>> -
>> -	len = 4;
>> -	size = cmd->dev->size >> BLK_SHIFT;
>> -
>> -	if ((cmd->scb[1] & 0x8))
>> -		data[3] = 0;
>> -	else {
>> -		data[3] = 8;
>> -		len += 8;
>> -		*(uint32_t *)(data + 4) = (size >> 32) ?
>> -			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
>> -		*(uint32_t *)(data + 8) = __cpu_to_be32(1 << BLK_SHIFT);
>> -	}
>> -
>> -	switch (pcode) {
>> -	case 0x0:
>> -		break;
>> -	case 0x2:
>> -		len += insert_disconnect_pg(data + len);
>> -		break;
>> -	case 0x3:
>> -		len += insert_format_m_pg(data + len);
>> -		break;
>> -	case 0x4:
>> -		len += insert_geo_m_pg(data + len, size);
>> -		break;
>> -	case 0x8:
>> -		len += insert_caching_pg(data + len);
>> -		break;
>> -	case 0xa:
>> -		len += insert_ctrl_m_pg(data + len);
>> -		break;
>> -	case 0x1c:
>> -		len += insert_iec_m_pg(data + len);
>> -		break;
>> -	case 0x3f:
>> -		len += insert_disconnect_pg(data + len);
>> -		len += insert_format_m_pg(data + len);
>> -		len += insert_geo_m_pg(data + len, size);
>> -		len += insert_caching_pg(data + len);
>> -		len += insert_ctrl_m_pg(data + len);
>> -		len += insert_iec_m_pg(data + len);
>> -		break;
>> -	default:
>> -		asc = E_INVALID_FIELD_IN_CDB;
>> -		goto sense;
>> -	}
>> +	uint8_t *data;
>>  
>> -	data[0] = len - 1;
>> -	cmd->len = len;
>> -	cmd->uaddr = (unsigned long) data;
>> -	return ret;
>> -sense:
>> -	cmd->len = 0;
>> -	sense_data_build(cmd, key, asc);
>> -	return SAM_STAT_CHECK_CONDITION;
>> -}
>> -
>> -static int sbc_lu_init(struct scsi_lu *lu)
>> -{
>>  	if (spc_lu_init(lu))
>>  		return -ENOMEM;
>>  
>> @@ -317,6 +183,15 @@ static int sbc_lu_init(struct scsi_lu *lu)
>>  	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
>>  	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
>>  
>> +	INIT_LIST_HEAD(&lu->mode_pages);
>> +
>> +	data = lu->mode_block_descriptor;
>> +	size = lu->size >> BLK_SHIFT;
>> +
>> +	*(uint32_t *)(data) = (size >> 32) ?
>> +			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
>> +	*(uint32_t *)(data + 4) = __cpu_to_be32(1 << BLK_SHIFT);
>> +
>>  	return 0;
>>  }
>>  
>> @@ -355,7 +230,7 @@ static struct device_type_template sbc_template = {
>>  
>>  		{spc_illegal_op,},
>>  		{spc_illegal_op,},
>> -		{sbc_mode_sense,},
>> +		{spc_mode_sense,},
>>  		{spc_start_stop,},
>>  		{spc_illegal_op,},
>>  		{spc_illegal_op,},
>> @@ -400,7 +275,28 @@ static struct device_type_template sbc_template = {
>>  		{spc_illegal_op,},
>>  		{spc_illegal_op,},
>>  
>> -		[0x40 ... 0x7f] = {spc_illegal_op,},
>> +		[0x40 ... 0x4f] = {spc_illegal_op,},
>> +
>> +		/* 0x50 */
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_mode_sense,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +		{spc_illegal_op,},
>> +
>> +		[0x60 ... 0x7f] = {spc_illegal_op,},
>>  
>>  		/* 0x80 */
>>  		{spc_illegal_op,},
>> diff --git a/usr/spc.c b/usr/spc.c
>> index 6530e73..32dac79 100644
>> --- a/usr/spc.c
>> +++ b/usr/spc.c
>> @@ -35,6 +35,7 @@
>>  #include "scsi.h"
>>  #include "spc.h"
>>  #include "sense_codes.h"
>> +#include "mode_page.h"
>>  
>>  #define PRODUCT_REV	"0"
>>  #define BLK_SHIFT	9
>> @@ -231,6 +232,82 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
>>  		return SAM_STAT_GOOD;
>>  }
>>  
>> +/*
>> + * Reference : SPC4r11
>> + * 6.11 - MODE SENSE(6)
>> + * 6.12 - MODE SENSE(10)
>> + */
>> +int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
>> +{
>> +	int	len = 0;
>> +	uint8_t *data;
>> +	uint8_t *scb = cmd->scb;
>> +	uint8_t	mode6 = (scb[0] == 0x1a) ? 1 : 0;
>> +	uint8_t dbd = (scb[1] & 8) ? 1 : 0;	/* Disable Block Descriptors */
>> +	uint8_t page_code = scb[2] & 0x3f;
>> +	uint8_t subpage = scb[3];
>> +	uint16_t alloc_len;
>> +	struct	mode	* m;
>> +	unsigned char key = ILLEGAL_REQUEST;
>> +	uint16_t asc = E_INVALID_FIELD_IN_CDB;
>> +
>> +	if (subpage)
>> +		goto sense;	/* Currently not implemented */
>> +
>> +	data = valloc(pagesize);
>> +	if (!data) {
>> +		key = HARDWARE_ERROR;
>> +		asc = E_INTERNAL_TGT_FAILURE;
>> +		goto sense;
>> +	}
>> +	memset(data, 0, pagesize);
>> +	if (mode6) {
>> +		alloc_len = scb[4];
>> +		len = 4;
>> +	} else {
>> +		alloc_len = (scb[7] << 8) + scb[8];
>> +		len = 8;
>> +	}
>> +	if (alloc_len > pagesize)
>> +		goto sense;
>> +
>> +	if (!dbd) {
>> +		memcpy(data + len, cmd->dev->mode_block_descriptor,
>> +				BLOCK_DESCRIPTOR_LEN);
>> +		len += 8;
>> +	}
>> +
>> +	if (page_code == 0x3f) {	/* All pages */
>> +		int	i;
>> +		for (i=0; i < 0x3f; i++) {
>> +			m = mode_page_lookup(&cmd->dev->mode_pages, i);
>> +			if (m)
>> +				len += build_mode_page(data + len, m);
>> +		}
>> +	} else {
>> +		m = mode_page_lookup(&cmd->dev->mode_pages, page_code);
>> +		if (!m)
>> +			goto sense;
>> +		len += build_mode_page(data + len, m);
>> +	}
>> +	if (mode6) {
>> +		data[0] = len - 1;
>> +		data[3] = (dbd) ? 0 : BLOCK_DESCRIPTOR_LEN;
>> +	} else {
>> +		*(uint16_t *)(data) = __cpu_to_be16(len - 3);
>> +		data[7] = (dbd) ? 0 : BLOCK_DESCRIPTOR_LEN;
>> +	}
>> +
>> +	cmd->len = len;
>> +	cmd->uaddr = (unsigned long)data;
>> +	return SAM_STAT_GOOD;
>> +
>> +sense:
>> +	cmd->len = 0;
>> +	sense_data_build(cmd, key, asc);
>> +	return SAM_STAT_CHECK_CONDITION;
>> +}
>> +
>>  int spc_request_sense(int host_no, struct scsi_cmd *cmd)
>>  {
>>  	uint8_t *data;
>> @@ -269,6 +346,7 @@ void dump_cdb(struct scsi_cmd *cmd)
>>  {
>>  	uint8_t *cdb = cmd->scb;
>>  
>> +	dprintf("cmd->cdb_len: %d\n", cmd->scb_len);
>>  	switch(cmd->scb_len) {
>>  	case 6:
>>  		dprintf("SCSI CMD: %02x %02x %02x %02x %02d %02x",
>> @@ -310,6 +388,7 @@ enum {
>>  	Opt_vendor_id, Opt_product_id,
>>  	Opt_product_rev, Opt_sense_format,
>>  	Opt_removable, Opt_online,
>> +	Opt_mode_page,
>>  	Opt_err,
>>  };
>>  
>> @@ -322,13 +401,14 @@ static match_table_t tokens = {
>>  	{Opt_sense_format, "sense_format=%s"},
>>  	{Opt_removable, "removable=%s"},
>>  	{Opt_online, "online=%s"},
>> +	{Opt_mode_page, "mode_page=%s"},
>>  	{Opt_err, NULL},
>>  };
>>  
>>  int spc_lu_config(struct scsi_lu *lu, char *params) {
>>  	int err = 0;
>>  	char *p;
>> -	char buf[20];
>> +	char buf[256];
>>  
>>  	if (!strncmp("targetOps", params, 9))
>>  		params = params + 10;
>> @@ -372,6 +452,10 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
>>  			match_strncpy(buf, &args[0],  sizeof(buf));
>>  			lu->attrs.online = atoi(buf);
>>  			break;
>> +		case Opt_mode_page:
>> +			match_strncpy(buf, &args[0], sizeof(buf));
>> +			err = add_mode_page(lu, buf);
>> +			break;
>>  		default:
>>  			err = TGTADM_INVALID_REQUEST;
>>  		}
>> diff --git a/usr/spc.h b/usr/spc.h
>> index 1036b70..c7b8652 100644
>> --- a/usr/spc.h
>> +++ b/usr/spc.h
>> @@ -10,5 +10,6 @@ extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
>>  extern int spc_lu_init(struct scsi_lu *lu);
>>  extern int spc_lu_config(struct scsi_lu *lu, char * params);
>>  extern void dump_cdb(struct scsi_cmd *cmd);
>> +extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
>>  
>>  #endif
>> diff --git a/usr/tgtd.h b/usr/tgtd.h
>> index 8e66d60..bbacae2 100644
>> --- a/usr/tgtd.h
>> +++ b/usr/tgtd.h
>> @@ -5,6 +5,7 @@
>>  
>>  #define SCSI_ID_LEN	24
>>  #define SCSI_SN_LEN	8
>> +#define BLOCK_DESCRIPTOR_LEN 8
>>  #define VERSION_DESCRIPTOR_LEN 8
>>  
>>  #define VENDOR_ID	"IET"
>> @@ -96,6 +97,9 @@ struct scsi_lu {
>>  
>>  	struct backingstore_template *bst;
>>  
>> +	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
>> +	struct list_head mode_pages;
>> +
>>  	/* TODO: needs a structure for lots of device parameters */
>>  	struct lu_phy_attr attrs;
>>  };
>> -- 
>> 1.5.2.1
>>
>>
>>
>>
>>
>> _______________________________________________
>> Stgt-devel mailing list
>> Stgt-devel at lists.berlios.de
>> https://lists.berlios.de/mailman/listinfo/stgt-devel
>>
>>     
>
>   



From yonic at voltaire.com  Wed Jun 20 13:40:08 2007
From: yonic at voltaire.com (yonatan cohen)
Date: Wed, 20 Jun 2007 14:40:08 +0300
Subject: [Stgt-devel] getting started.
Message-ID: <46791218.3070405@voltaire.com>

Hi
Can someone please point me to a tutorial on how to get started
installing and using the target.
thanks.




From fujita.tomonori at lab.ntt.co.jp  Wed Jun 20 14:01:44 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 20 Jun 2007 21:01:44 +0900
Subject: [Stgt-devel] getting started.
In-Reply-To: <46791218.3070405@voltaire.com>
References: <46791218.3070405@voltaire.com>
Message-ID: <20070620210144N.fujita.tomonori@lab.ntt.co.jp>

From: yonatan cohen <yonic at voltaire.com>
Subject: [Stgt-devel] getting started.
Date: Wed, 20 Jun 2007 14:40:08 +0300

> Hi
> Can someone please point me to a tutorial on how to get started
> installing and using the target.
> thanks.

Feel free to ask a question on the mailing list after reading README
and doc/README.iSCSI.

Make sure that you have the latest code from the git tree.


From markh794 at gmail.com  Thu Jun 21 10:03:37 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 21 Jun 2007 18:03:37 +1000
Subject: [Stgt-devel] SCC vs SES
Message-ID: <467A30D9.8030101@gmail.com>

Hello One and all.

Just brushing up on the recent changes to the stgt with regards to the 
SCC module.

The most recent draft doco at the T10 site I could locate is dated 12 
Sept 1997 (scc2r04.pdf)

 From my 10 minute read of these standards, the 'scc' device appears to 
be aimed at the RAID Disk array and fine grain control of disks within a 
RAID array (hot-swap spares, redirecting SCSI commands to a device 
within an array, etc).

While this model will suit the existing SBC / MMC modules, the SES (SCSI 
Enclosure Service) model would IMO be a better 'fit'.

i.e. The target 'owner' is an enclosure, rather than a SCSI Controller..

This way, the enclosure can be parent to all devices within the target.

Having the SES be the 'parent' for all LUN within the target, a SCC 
module could then become a LUN within the SES framework (if this 
functionality is required) to direct SCSI commands to the SBC/MMC type 
devices within the target.

The SES model would be a better fit with regards to virtual libraries. 
i.e. Each stgt target is an Enclosure with x number of logical units 
within the enclosure.


 From a practical point of view - As there is no SCC unique code behind 
the SCC target, both the SCC or SES models will work.

I could see potential issues where a (unknown / as yet untested) SCSI 
initiators finding a SCC controlling a set of LUNs which happened to be 
tape drives and/or medium changer may fail...


Thoughts ?


Regards
Mark Harvey





From waldi at berlios.de  Thu Jun 21 14:30:23 2007
From: waldi at berlios.de (Bastian Blank)
Date: Thu, 21 Jun 2007 14:30:23 +0200
Subject: [Stgt-devel] ibmvio is slow
In-Reply-To: <20070620084051R.fujita.tomonori@lab.ntt.co.jp>
References: <20070619171838.GA13219@wavehammer.waldi.eu.org>
	<20070620084051R.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070621123023.GA31029@wavehammer.waldi.eu.org>

On Wed, Jun 20, 2007 at 08:40:51AM +0900, FUJITA Tomonori wrote:
> > I tried the ibmvio target on a busy vioserver on a power5 machine. It
> > works fine, I got no problem. It provides services to 7 initiators with
> > at least 2 luns each.
> Nice.

Okay, not completely without problems. Using iscsi and ibmvio at the
same time produces:
|  connection1:0: iscsi: detected conn error (1011)
| iscsi: host reset succeeded
|  connection1:0: iscsi: detected conn error (1011)
| iscsi: host reset succeeded
| sd 5:0:0:1: scsi: Device offlined - not ready after error recovery
| sd 5:0:0:1: [sdc] Result: hostbyte=DID_BUS_BUSY driverbyte=DRIVER_OK,SUGGEST_OK

> We don't need to call mmap/unmap per request though this hack is
> disable to keep the code simple. We need to find a way to avoid
> registering/de-registering memory region for more high performance.

I think the hurd filesystem daemons had to face the same problem.

Bastian

-- 
One does not thank logic.
		-- Sarek, "Journey to Babel", stardate 3842.4


From fujita.tomonori at lab.ntt.co.jp  Thu Jun 21 14:58:36 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 21 Jun 2007 21:58:36 +0900
Subject: [Stgt-devel] ibmvio is slow
In-Reply-To: <20070621123023.GA31029@wavehammer.waldi.eu.org>
References: <20070619171838.GA13219@wavehammer.waldi.eu.org>
	<20070620084051R.fujita.tomonori@lab.ntt.co.jp>
	<20070621123023.GA31029@wavehammer.waldi.eu.org>
Message-ID: <200706211258.l5LCwbak029424@mbox.iij4u.or.jp>

From: Bastian Blank <waldi at berlios.de>
Subject: Re: [Stgt-devel] ibmvio is slow
Date: Thu, 21 Jun 2007 14:30:23 +0200

> On Wed, Jun 20, 2007 at 08:40:51AM +0900, FUJITA Tomonori wrote:
> > > I tried the ibmvio target on a busy vioserver on a power5 machine. It
> > > works fine, I got no problem. It provides services to 7 initiators with
> > > at least 2 luns each.
> > Nice.
> 
> Okay, not completely without problems. Using iscsi and ibmvio at the
> same time produces:
> |  connection1:0: iscsi: detected conn error (1011)
> | iscsi: host reset succeeded
> |  connection1:0: iscsi: detected conn error (1011)
> | iscsi: host reset succeeded
> | sd 5:0:0:1: scsi: Device offlined - not ready after error recovery
> | sd 5:0:0:1: [sdc] Result: hostbyte=DID_BUS_BUSY driverbyte=DRIVER_OK,SUGGEST_OK

Do you mean that iscsi and ibmvio use the same target?


From fujita.tomonori at lab.ntt.co.jp  Thu Jun 21 15:19:32 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 21 Jun 2007 22:19:32 +0900
Subject: [Stgt-devel] ibmvio is slow
In-Reply-To: <20070621130855.GB31029@wavehammer.waldi.eu.org>
References: <20070621123023.GA31029@wavehammer.waldi.eu.org>
	<200706211258.l5LCwbak029424@mbox.iij4u.or.jp>
	<20070621130855.GB31029@wavehammer.waldi.eu.org>
Message-ID: <20070621221932X.fujita.tomonori@lab.ntt.co.jp>

From: Bastian Blank <waldi at berlios.de>
Subject: Re: [Stgt-devel] ibmvio is slow
Date: Thu, 21 Jun 2007 15:08:55 +0200

> On Thu, Jun 21, 2007 at 09:58:36PM +0900, FUJITA Tomonori wrote:
> > Do you mean that iscsi and ibmvio use the same target?
> 
> Yes.

It's not supported and will not be suppoted in the near future since
we need to rewrite backing storage code to support it.


From blackmagic02881 at gmail.com  Thu Jun 21 15:36:29 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 21 Jun 2007 09:36:29 -0400
Subject: [Stgt-devel] SCC vs SES
In-Reply-To: <467A30D9.8030101@gmail.com>
References: <467A30D9.8030101@gmail.com>
Message-ID: <1182432989.3847.11.camel@dhcp-145.ibrix.com>

On Thu, 2007-06-21 at 18:03 +1000, Mark Harvey wrote:
> Hello One and all.
> 
> Just brushing up on the recent changes to the stgt with regards to the 
> SCC module.
> 
> The most recent draft doco at the T10 site I could locate is dated 12 
> Sept 1997 (scc2r04.pdf)
> 
>  From my 10 minute read of these standards, the 'scc' device appears to 
> be aimed at the RAID Disk array and fine grain control of disks within a 
> RAID array (hot-swap spares, redirecting SCSI commands to a device 
> within an array, etc).
> 
> While this model will suit the existing SBC / MMC modules, the SES (SCSI 
> Enclosure Service) model would IMO be a better 'fit'.
> 
> i.e. The target 'owner' is an enclosure, rather than a SCSI Controller..
> 
> This way, the enclosure can be parent to all devices within the target.
> 
> Having the SES be the 'parent' for all LUN within the target, a SCC 
> module could then become a LUN within the SES framework (if this 
> functionality is required) to direct SCSI commands to the SBC/MMC type 
> devices within the target.
> 
> The SES model would be a better fit with regards to virtual libraries. 
> i.e. Each stgt target is an Enclosure with x number of logical units 
> within the enclosure.
> 
> 
>  From a practical point of view - As there is no SCC unique code behind 
> the SCC target, both the SCC or SES models will work.
> 
> I could see potential issues where a (unknown / as yet untested) SCSI 
> initiators finding a SCC controlling a set of LUNs which happened to be 
> tape drives and/or medium changer may fail...
> 

i would ignore the SCC and only take care about SES. actually one step a
time, have SMC and SSC in tgt already a big success. SES can be treated
as some enterprise feature added later.


> 
> Thoughts ?
> 
> 
> Regards
> Mark Harvey
> 
> 
> 
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From markh794 at gmail.com  Fri Jun 22 01:05:17 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 22 Jun 2007 09:05:17 +1000
Subject: [Stgt-devel] [Patch 4/6] Use mnemonic value for ASC/ASCQ values
In-Reply-To: <20070620194554R.fujita.tomonori@lab.ntt.co.jp>
References: <4678DFD9.2040407@gmail.com>
	<20070620194554R.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80706211605m46c6c455yc5aefd055ac25df1@mail.gmail.com>

On 6/20/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: Mark Harvey <markh794 at gmail.com>
> Subject: [Stgt-devel] [Patch 4/6] Use mnemonic value for ASC/ASCQ values
> Date: Wed, 20 Jun 2007 18:05:45 +1000
>
> > A better prefix to the defines instead of 'E_' would be nice.
> >
> > Any recommendations for a good naming convention  ?
>
> I don't have a good proposal now but E_ doesn't look nice. Let's wait
> for a while to see we could have a better name.
>

Would a prefix of ASC_ instead of E_ be more suitable...

Cheers
Mark


From blackmagic02881 at gmail.com  Fri Jun 22 02:19:00 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Thu, 21 Jun 2007 20:19:00 -0400
Subject: [Stgt-devel] [Patch 4/6] Use mnemonic value for ASC/ASCQ values
In-Reply-To: <f29db9a80706211605m46c6c455yc5aefd055ac25df1@mail.gmail.com>
References: <4678DFD9.2040407@gmail.com>
	<20070620194554R.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80706211605m46c6c455yc5aefd055ac25df1@mail.gmail.com>
Message-ID: <1182471540.3802.9.camel@localhost.localdomain>

On Fri, 2007-06-22 at 09:05 +1000, Mark Harvey wrote:
> On 6/20/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > From: Mark Harvey <markh794 at gmail.com>
> > Subject: [Stgt-devel] [Patch 4/6] Use mnemonic value for ASC/ASCQ values
> > Date: Wed, 20 Jun 2007 18:05:45 +1000
> >
> > > A better prefix to the defines instead of 'E_' would be nice.
> > >
> > > Any recommendations for a good naming convention  ?
> >
> > I don't have a good proposal now but E_ doesn't look nice. Let's wait
> > for a while to see we could have a better name.
> >
> 
> Would a prefix of ASC_ instead of E_ be more suitable...

ASC is better. E_ is exception and not all ASCQ are exception or error.

> 
> Cheers
> Mark
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
-- 
Ming Zhang


@#$%^ purging memory... (*!%
http://blackmagic02881.wordpress.com/
http://www.linkedin.com/in/blackmagic02881
--------------------------------------------



From albert.pauw at gmail.com  Fri Jun 22 21:06:10 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Fri, 22 Jun 2007 21:06:10 +0200
Subject: [Stgt-devel] Some remarks on current git version
Message-ID: <467C1DA2.8090106@gmail.com>

Here are a few loose ends, some of which are very simple, some are remarks:

- ssc.c uses the word Controler, should be Controller, just a typo (yes, 
I am just being picky).

- when configuring just a disk target I still get harrassed by this Lun 
0 Controller,
  I understand you need one when you are doing vtl, but there should be 
a way to get rid of it when not needed.

- I am not able to define a cdrom anymore (using an cd iso as backing 
store),  --device-type cdrom doesn't work.

Albert



From blackmagic02881 at gmail.com  Fri Jun 22 21:10:39 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Fri, 22 Jun 2007 15:10:39 -0400
Subject: [Stgt-devel] Some remarks on current git version
In-Reply-To: <467C1DA2.8090106@gmail.com>
References: <467C1DA2.8090106@gmail.com>
Message-ID: <1182539439.3794.74.camel@localhost.localdomain>

On Fri, 2007-06-22 at 21:06 +0200, Albert Pauw wrote:
> Here are a few loose ends, some of which are very simple, some are remarks:
> 
> - ssc.c uses the word Controler, should be Controller, just a typo (yes, 
> I am just being picky).
> 
> - when configuring just a disk target I still get harrassed by this Lun 
> 0 Controller,
>   I understand you need one when you are doing vtl, but there should be 
> a way to get rid of it when not needed.

my 2c. even for disk, it might be needed.

> 
> - I am not able to define a cdrom anymore (using an cd iso as backing 
> store),  --device-type cdrom doesn't work.
> 
> Albert
> 
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
-- 
Ming Zhang


@#$%^ purging memory... (*!%
http://blackmagic02881.wordpress.com/
http://www.linkedin.com/in/blackmagic02881
--------------------------------------------



From albert.pauw at gmail.com  Fri Jun 22 22:10:03 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Fri, 22 Jun 2007 22:10:03 +0200
Subject: [Stgt-devel] Some remarks on current git version
In-Reply-To: <1182539439.3794.74.camel@localhost.localdomain>
References: <467C1DA2.8090106@gmail.com>
	<1182539439.3794.74.camel@localhost.localdomain>
Message-ID: <467C2C9B.3040807@gmail.com>


>> - I am not able to define a cdrom anymore (using an cd iso as backing 
>> store),  --device-type cdrom doesn't work.
Using the command:

tgtadm --lld iscsi --mode logicalunit --op new --tid 2 --lun 1 
--backing-store /tmp/cd.iso --device-type cd/dvd

But it looks like the --device-type command doesn't recognise the cd/dvd 
type. Tried it within quotes (i.e. "cd/dvd") but that doesn't help.
In target.c it is defined as a possible type, like e.g. disk, but it 
doesn't work here.


From mark_harvey at symantec.com  Sat Jun 23 00:54:10 2007
From: mark_harvey at symantec.com (Mark Harvey)
Date: Fri, 22 Jun 2007 15:54:10 -0700
Subject: [Stgt-devel] Some remarks on current git version
In-Reply-To: <467C2C9B.3040807@gmail.com>
References: <467C1DA2.8090106@gmail.com><1182539439.3794.74.camel@localhost.localdomain>
	<467C2C9B.3040807@gmail.com>
Message-ID: <B3E98EAC5926D5498DDD341AE4B7D21C016B4339@TUS1XCHCLUPIN06.enterprise.veritas.com>

Hi Albert,

Try : "--device-type=cd" 

It works for me.

Cheers
Mark

-----Original Message-----
From: stgt-devel-bounces at lists.berlios.de
[mailto:stgt-devel-bounces at lists.berlios.de] On Behalf Of Albert Pauw
Sent: Saturday, 23 June 2007 6:10 AM
To: STGT list
Subject: Re: [Stgt-devel] Some remarks on current git version


>> - I am not able to define a cdrom anymore (using an cd iso as backing

>> store),  --device-type cdrom doesn't work.
Using the command:

tgtadm --lld iscsi --mode logicalunit --op new --tid 2 --lun 1 
--backing-store /tmp/cd.iso --device-type cd/dvd

But it looks like the --device-type command doesn't recognise the cd/dvd

type. Tried it within quotes (i.e. "cd/dvd") but that doesn't help.
In target.c it is defined as a possible type, like e.g. disk, but it 
doesn't work here.
_______________________________________________
Stgt-devel mailing list
Stgt-devel at lists.berlios.de
https://lists.berlios.de/mailman/listinfo/stgt-devel


From fujita.tomonori at lab.ntt.co.jp  Sat Jun 23 03:26:24 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 23 Jun 2007 10:26:24 +0900
Subject: [Stgt-devel] Some remarks on current git version
In-Reply-To: <467C1DA2.8090106@gmail.com>
References: <467C1DA2.8090106@gmail.com>
Message-ID: <200706230126.l5N1QOIr031221@mbox.iij4u.or.jp>

From: Albert Pauw <albert.pauw at gmail.com>
Subject: [Stgt-devel] Some remarks on current git version
Date: Fri, 22 Jun 2007 21:06:10 +0200

> Here are a few loose ends, some of which are very simple, some are remarks:
> 
> - ssc.c uses the word Controler, should be Controller, just a typo (yes, 
> I am just being picky).

Thanks, fixed.


> - when configuring just a disk target I still get harrassed by this Lun 
> 0 Controller,
>   I understand you need one when you are doing vtl, but there should be 
> a way to get rid of it when not needed.

Only if the current code doesn't work, we should implement a feature
to remove I want to keep the code simple.


> - I am not able to define a cdrom anymore (using an cd iso as backing 
> store),  --device-type cdrom doesn't work.

Try Mark's way. It should work. Patches to improve the manpage and
documents are welcome.


From markh794 at gmail.com  Sat Jun 23 04:07:26 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 23 Jun 2007 12:07:26 +1000
Subject: [Stgt-devel] Some remarks on current git version
In-Reply-To: <200706230126.l5N1QOIr031221@mbox.iij4u.or.jp>
References: <467C1DA2.8090106@gmail.com>
	<200706230126.l5N1QOIr031221@mbox.iij4u.or.jp>
Message-ID: <f29db9a80706221907u5e53d9aahdc439b55ff76986c@mail.gmail.com>

On 6/23/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: Albert Pauw <albert.pauw at gmail.com>
> Subject: [Stgt-devel] Some remarks on current git version
> Date: Fri, 22 Jun 2007 21:06:10 +0200
>
> > Here are a few loose ends, some of which are very simple, some are remarks:
> >
> > - ssc.c uses the word Controler, should be Controller, just a typo (yes,
> > I am just being picky).
>
> Thanks, fixed.

One other 'nit-pick' :

cc -DISCSI -Wall -g -O2 -Wstrict-prototypes -fPIC
-D_LARGEFILE64_SOURCE -I../include -I/usr/src/linux-2.6.20.1/include
-I.   -c -o spt.o spt.c
spt.c: In function 'spt_cmd_perform':
spt.c:68: warning: unused variable 'ops'

I can create a patch if required..

Cheers
Mark


From fujita.tomonori at lab.ntt.co.jp  Sat Jun 23 04:13:31 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 23 Jun 2007 11:13:31 +0900
Subject: [Stgt-devel] Some remarks on current git version
In-Reply-To: <f29db9a80706221907u5e53d9aahdc439b55ff76986c@mail.gmail.com>
References: <467C1DA2.8090106@gmail.com>
	<200706230126.l5N1QOIr031221@mbox.iij4u.or.jp>
	<f29db9a80706221907u5e53d9aahdc439b55ff76986c@mail.gmail.com>
Message-ID: <200706230213.l5N2Dvdr022413@mbox.iij4u.or.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] Some remarks on current git version
Date: Sat, 23 Jun 2007 12:07:26 +1000

> On 6/23/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > From: Albert Pauw <albert.pauw at gmail.com>
> > Subject: [Stgt-devel] Some remarks on current git version
> > Date: Fri, 22 Jun 2007 21:06:10 +0200
> >
> > > Here are a few loose ends, some of which are very simple, some are remarks:
> > >
> > > - ssc.c uses the word Controler, should be Controller, just a typo (yes,
> > > I am just being picky).
> >
> > Thanks, fixed.
> 
> One other 'nit-pick' :
> 
> cc -DISCSI -Wall -g -O2 -Wstrict-prototypes -fPIC
> -D_LARGEFILE64_SOURCE -I../include -I/usr/src/linux-2.6.20.1/include
> -I.   -c -o spt.o spt.c
> spt.c: In function 'spt_cmd_perform':
> spt.c:68: warning: unused variable 'ops'
> 
> I can create a patch if required..

I know it but leave it alone since spt is broken anyway.


From albert.pauw at gmail.com  Sat Jun 23 07:21:34 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Sat, 23 Jun 2007 07:21:34 +0200
Subject: [Stgt-devel] Some remarks on current git version
In-Reply-To: <200706230126.l5N1QOIr031221@mbox.iij4u.or.jp>
References: <467C1DA2.8090106@gmail.com>
	<200706230126.l5N1QOIr031221@mbox.iij4u.or.jp>
Message-ID: <467CADDE.6020900@gmail.com>

FUJITA Tomonori wrote:
> From: Albert Pauw <albert.pauw at gmail.com>
> Subject: [Stgt-devel] Some remarks on current git version
> Date: Fri, 22 Jun 2007 21:06:10 +0200
>
>   
>> Here are a few loose ends, some of which are very simple, some are remarks:
>>
>> - ssc.c uses the word Controler, should be Controller, just a typo (yes, 
>> I am just being picky).
>>     
>
> Thanks, fixed.
>
>
>   
>> - when configuring just a disk target I still get harrassed by this Lun 
>> 0 Controller,
>>   I understand you need one when you are doing vtl, but there should be 
>> a way to get rid of it when not needed.
>>     
>
> Only if the current code doesn't work, we should implement a feature
> to remove I want to keep the code simple.
>
>
>   
>> - I am not able to define a cdrom anymore (using an cd iso as backing 
>> store),  --device-type cdrom doesn't work.
>>     
>
> Try Mark's way. It should work. Patches to improve the manpage and
> documents are welcome.
>   
Thanks Mark and Fujita,

using "cd" works fine, tried other descriptions but not this one.

I guess I have to live with the conroller, I am ok with it, as long as 
it doesn't bite :-)

Thanks again guys,

Albert


From markh794 at gmail.com  Sat Jun 23 10:11:52 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 23 Jun 2007 18:11:52 +1000
Subject: [Stgt-devel] [Patch 1/3] Rework of mnemonic ASC/ASCQ values
Message-ID: <467CD5C8.2090108@gmail.com>

>From d163aa03f036609ac5343c2d8983aba38ecec679 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Fri, 22 Jun 2007 18:20:54 +1000
Subject: Use nmemonic codes for SENSE codes instead of numeric value.

Using nmemonic representation for ASC/ASCQ as a 16bit value.
 - Values defined in sense_codes.h
 - Updated sense_data_build() to accept a single 16bit
   combined asc/ascq value.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 usr/bs_sync.c       |    3 +-
 usr/ibmvio/ibmvio.c |   15 ++++---
 usr/mmc.c           |    7 ++-
 usr/osd.c           |    5 +-
 usr/sbc.c           |   33 +++++++++-------
 usr/scsi.c          |   13 +++---
 usr/sense_codes.h   |  103 +++++++++++++++++++++++++++++++++++++++++++++++++++
 usr/spc.c           |   19 +++++----
 usr/spt.c           |    5 +-
 usr/tgtd.h          |    3 +-
 10 files changed, 161 insertions(+), 45 deletions(-)
 create mode 100644 usr/sense_codes.h

diff --git a/usr/bs_sync.c b/usr/bs_sync.c
index 6789b5b..4986c59 100644
--- a/usr/bs_sync.c
+++ b/usr/bs_sync.c
@@ -37,6 +37,7 @@
 #include "util.h"
 #include "tgtd.h"
 #include "scsi.h"
+#include "sense_codes.h"
 
 #define NR_WORKER_THREADS	4
 
@@ -161,7 +162,7 @@ static void *bs_sync_worker_fn(void *arg)
 			eprintf("io error %p %x %d %d %" PRIu64 ", %m\n",
 				cmd, cmd->scb[0], ret, cmd->len, cmd->offset);
 			cmd->result = SAM_STAT_CHECK_CONDITION;
-			sense_data_build(cmd, MEDIUM_ERROR, 0x11, 0x0);
+			sense_data_build(cmd, MEDIUM_ERROR, ASC_READ_ERROR);
 		}
 
 		pthread_mutex_lock(&info->finished_lock);
diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index 5a2f8fe..8cfc8d6 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -44,6 +44,7 @@
 #include "target.h"
 #include "driver.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
 #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
@@ -140,7 +141,8 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data, *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
@@ -148,7 +150,7 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -173,7 +175,7 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -194,7 +196,8 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 	int idx, alen, oalen, nr_luns, rbuflen = 4096;
 	int *len = &cmd->len;
 	uint8_t *lun_buf = cmd->lun;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 
 	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
 	if (alen < 16)
@@ -203,7 +206,7 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -241,7 +244,7 @@ done:
 	return SAM_STAT_GOOD;
 sense:
 	*len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
diff --git a/usr/mmc.c b/usr/mmc.c
index 10b0e3f..defe60b 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -41,6 +41,7 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define MMC_BLK_SHIFT 11
 
@@ -53,7 +54,7 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 	if (ret) {
 		cmd->offset = 0;
 		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LUN_NOT_SUPPORTED);
 		return SAM_STAT_CHECK_CONDITION;
 	} else {
 		cmd->mmapped = 1;
@@ -69,7 +70,7 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		cmd->len = 0;
-		sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		sense_data_build(cmd, HARDWARE_ERROR, ASC_INTERNAL_TGT_FAILURE);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
@@ -105,7 +106,7 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		cmd->len = 0;
-		sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		sense_data_build(cmd, HARDWARE_ERROR, ASC_INTERNAL_TGT_FAILURE);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
diff --git a/usr/osd.c b/usr/osd.c
index a7b92ba..048d0c8 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -33,16 +33,15 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 {
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
-
 	dprintf("cdb[0] %x datalen %u\n", cmd->scb[0], cmd->len);
 	if (cmd->scb[7] != 200 - 8) {
 		eprintf("request size %d wrong, should be 200\n",
 			cmd->scb[7] + 8);
-		sense_data_build(cmd, key, asc, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LUN_NOT_SUPPORTED);
 		cmd->len = 0;
 		return SAM_STAT_CHECK_CONDITION;
 	}
diff --git a/usr/sbc.c b/usr/sbc.c
index c0075e4..a62e6d8 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -38,13 +38,15 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define BLK_SHIFT	9
 
 static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_LUN_NOT_SUPPORTED;
 
 	ret = device_reserved(cmd);
 	if (ret)
@@ -65,7 +67,7 @@ static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 	} else {
 		cmd->mmapped = 1;
 		return SAM_STAT_GOOD;
@@ -74,7 +76,7 @@ static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 	cmd->rw = READ;
 	cmd->offset = 0;
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -101,20 +103,21 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	uint32_t *data;
 	uint64_t size;
 	uint8_t *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_LUN_NOT_SUPPORTED;
 
 	if (device_reserved(cmd))
 		return SAM_STAT_RESERVATION_CONFLICT;
 
 	if (!(scb[8] & 0x1) & (scb[2] | scb[3] | scb[4] | scb[5])) {
-		asc = 0x24;
+		asc = ASC_INVALID_FIELD_IN_CDB;
 		goto sense;
 	}
 
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	cmd->uaddr = (unsigned long) data;
@@ -129,14 +132,15 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
 static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 {
 	int ret, len;
-	uint8_t key = ILLEGAL_REQUEST, asc;
+	uint8_t key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_LUN_NOT_SUPPORTED;
 
 	if (device_reserved(cmd))
 		return SAM_STAT_RESERVATION_CONFLICT;
@@ -152,7 +156,7 @@ static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 		 * what should I put for the asc/ascq?
 		 */
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	default:
 		len = 0;
@@ -161,7 +165,7 @@ static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -232,7 +236,8 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	uint8_t pcode = cmd->scb[2] & 0x3f;
 	uint64_t size;
 	uint8_t *data = NULL;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_LUN_NOT_SUPPORTED;
 
 	if (device_reserved(cmd))
 		return SAM_STAT_RESERVATION_CONFLICT;
@@ -240,7 +245,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -288,7 +293,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 		len += insert_iec_m_pg(data + len);
 		break;
 	default:
-		asc = 0x24;
+		asc = ASC_INVALID_FIELD_IN_CDB;
 		goto sense;
 	}
 
@@ -298,7 +303,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	return ret;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
diff --git a/usr/scsi.c b/usr/scsi.c
index 36722e1..5ddc94c 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -38,27 +38,28 @@
 #include "scsi.h"
 #include "spc.h"
 
-void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
+void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t asc)
 {
+	uint16_t *sense_code;
+
 	if (cmd->dev->attrs.sense_format) {
 		/* descriptor format */
+		sense_code = (uint16_t *)&cmd->sense_buffer[2];
 
 		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
 		cmd->sense_buffer[1] = key;
-		cmd->sense_buffer[2] = asc;
-		cmd->sense_buffer[3] = asq;
 		cmd->sense_len = 8;
 	} else {
 		/* fixed format */
+		sense_code = (uint16_t *)&cmd->sense_buffer[12];
 
 		int len = 0xa;
-		cmd->sense_buffer[0] = 0x70;
+		cmd->sense_buffer[0] = 0x70;  /* current, not deferred */
 		cmd->sense_buffer[2] = key;
 		cmd->sense_buffer[7] = len;
-		cmd->sense_buffer[12] = asc;
-		cmd->sense_buffer[13] = asq;
 		cmd->sense_len = len + 8;
 	}
+	*sense_code = __cpu_to_be16(asc);
 }
 
 #define        TGT_INVALID_DEV_ID      ~0ULL
diff --git a/usr/sense_codes.h b/usr/sense_codes.h
new file mode 100644
index 0000000..ea8eebc
--- /dev/null
+++ b/usr/sense_codes.h
@@ -0,0 +1,103 @@
+/*
+ * The SCSI sense key Additional Sense Code / Additional Sense Code Qualifier
+ *
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * SENSE keys
+ */
+#define NO_SENSE			0x00
+#define	RECOVERED_ERROR			0x01
+#define NOT_READY			0x02
+#define MEDIUM_ERROR			0x03
+#define	HARDWARE_ERROR			0x04
+#define ILLEGAL_REQUEST			0x05
+#define UNIT_ATTENTION			0x06
+#define DATA_PROTECT			0x07
+#define	BLANK_CHECK			0x08
+
+/* Key 0: No Sense Errors */
+#define NO_ADDITIONAL_SENSE			0x0000
+#define ASC_MARK				0x0001
+#define ASC_EOM					0x0002
+#define ASC_BOM					0x0004
+#define ASC_END_OF_DATA				0x0005
+#define ASC_OP_IN_PROGRESS			0x0016
+#define ASC_DRIVASC_REQUIRES_CLEANING		0x8282
+
+/* Key 1: Recovered Errors */
+#define ASC_WRITASC_ERROR			0x0c00
+#define ASC_READ_ERROR				0x1100
+#define ASC_RECOVERED_WITH_RETRYS		0x1701
+#define ASC_MEDIA_LOAD_EJECT_ERROR		0x5300
+#define ASC_FAILURASC_PREDICTION		0x5d00
+
+/* Key 2: Not ready */
+#define ASC_CAUSASC_NOT_REPORTABLE		0x0400
+#define ASC_BECOMING_READY			0x0401
+#define ASC_INITIALIZING_REQUIRED		0x0402
+#define ASC_CLEANING_CART_INSTALLED		0x3003
+#define ASC_CLEANING_FAILURE			0x3007
+#define ASC_MEDIUM_NOT_PRESENT			0x3a00
+#define ASC_LOGICAL_UNIT_NOT_CONFIG		0x3e00
+
+/* Key 3: Medium Errors */
+#define ASC_WRITE_ERROR			0x0c00
+#define ASC_UNRECOVERED_READ			0x1100
+#define ASC_RECORDED_ENTITY_NOT_FOUND		0x1400
+#define ASC_UNKNOWN_FORMAT			0x3001
+#define ASC_IMCOMPATIBLE_FORMAT		0x3002
+#define ASC_MEDIUM_FORMAT_CORRUPT		0x3100
+#define ASC_SEQUENTIAL_POSITION_ERR		0x3b00
+#define ASC_WRITE_APPEND_ERR			0x5000
+#define ASC_CARTRIDGE_FAULT			0x5200
+#define ASC_MEDIA_LOAD_OR_EJECT_FAILED		0x5300
+
+/* Key 4: Hardware Failure */
+#define ASC_COMPRESSION_CHECK			0x0c04
+#define ASC_DECOMPRESSION_CRC			0x110d
+#define ASC_MECHANICAL_POSITIONING_ERROR	0x1501
+#define ASC_MANUAL_INTERVENTION_REQ		0x0403
+#define ASC_HARDWARE_FAILURE			0x4000
+#define ASC_INTERNAL_TGT_FAILURE		0x4400
+#define ASC_ERASE_FAILURE			0x5100
+
+/* Key 5: Illegal Request */
+#define ASC_PARAMETER_LIST_LENGTH_ERR		0x1a00
+#define ASC_INVALID_OP_CODE			0x2000
+#define ASC_INVALID_FIELD_IN_CDB		0x2400
+#define ASC_LUN_NOT_SUPPORTED			0x2500
+#define ASC_INVALID_FIELD_IN_PARMS		0x2600
+#define ASC_SAVING_PARMS_UNSUP			0x3900
+#define ASC_MEDIUM_DEST_FULL			0x3b0d
+#define ASC_MEDIUM_SRC_EMPTY			0x3b0e
+#define ASC_POSITION_PAST_BOM			0x3b0c
+#define ASC_MEDIUM_REMOVAL_PREVENTED		0x5302
+#define ASC_BAD_MICROCODE_DETECTED		0x8283
+
+/* Key 6: Unit Attention */
+#define ASC_NOT_READY_TO_TRANSITION		0x2800
+#define ASC_POWERON_RESET			0x2900
+#define ASC_MODE_PARAMETERS_CHANGED		0x2a01
+#define ASC_INSUFFICIENT_TIME_FOR_OPERATION	0x2e00
+#define ASC_MICROCODE_DOWNLOADED		0x3f01
+#define ASC_FAILURE_PREDICTION_FALSE		0x5dff
+#define ASC_INQUIRY_DATA_HAS_CHANGED		0x3f03
+
+/* Data Protect */
+#define ASC_WRITE_PROTECT			0x2700
+#define ASC_MEDIUM_OVERWRITE_ATTEMPTED		0x300c
diff --git a/usr/spc.c b/usr/spc.c
index 1c363cd..6560e98 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -34,6 +34,7 @@
 #include "tgtadm_error.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define PRODUCT_REV	"0"
 #define BLK_SHIFT	9
@@ -43,7 +44,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	int len, ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data;
 	uint8_t *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 	uint8_t devtype = 0;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
@@ -52,7 +54,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -148,7 +150,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -158,7 +160,8 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	struct list_head *dev_list = &cmd->c_target->device_list;
 	uint64_t lun, *data;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096, overflow;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 
 	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
 	if (alen < 16)
@@ -167,7 +170,7 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -204,7 +207,7 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -231,7 +234,7 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
 int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
 	cmd->len = 0;
-	sense_data_build(cmd, NO_SENSE, 0, 0);
+	sense_data_build(cmd, NO_SENSE, NO_ADDITIONAL_SENSE);
 	return SAM_STAT_GOOD;
 }
 
@@ -271,7 +274,7 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 {
 	dump_cdb(cmd);
 	cmd->len = 0;
-	sense_data_build(cmd, ILLEGAL_REQUEST, 0x20, 0);
+	sense_data_build(cmd, ILLEGAL_REQUEST, ASC_INVALID_OP_CODE);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
diff --git a/usr/spt.c b/usr/spt.c
index c882fd0..9115d7f 100644
--- a/usr/spt.c
+++ b/usr/spt.c
@@ -40,6 +40,7 @@
 #include "target.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 extern int spt_sg_open(struct scsi_lu *lu, char *path, int *fd, uint64_t *size);
 extern int spt_sg_perform(struct scsi_cmd *cmd);
@@ -68,14 +69,14 @@ static int spt_cmd_perform(int host_no, struct scsi_cmd *cmd)
 
 	if (!cmd->dev) {
 		cmd->len = 0;
-		sense_data_build(cmd, NOT_READY, 0x44, 0); /* Internal target failure */
+		sense_data_build(cmd, NOT_READY, ASC_INTERNAL_TGT_FAILURE);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 
 	ret = spt_sg_perform(cmd);
 	if (ret) {
 		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LUN_NOT_SUPPORTED);
 		return SAM_STAT_CHECK_CONDITION;
 	} else
 		return SAM_STAT_GOOD;
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 15ae2e1..8e66d60 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -190,8 +190,7 @@ extern void target_cmd_io_done(struct scsi_cmd *cmd, int result);
 
 extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
 extern int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd);
-extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc,
-			     uint8_t asq);
+extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t asc);
 extern uint64_t scsi_rw_offset(uint8_t *scb);
 
 extern enum scsi_target_state tgt_get_target_state(int tid);
-- 
1.5.2.1






From markh794 at gmail.com  Sat Jun 23 10:13:05 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 23 Jun 2007 18:13:05 +1000
Subject: [Stgt-devel] [Patch 2/3] Rework of Dynamic mode page support
Message-ID: <467CD611.7090606@gmail.com>


>From a0c4b2a1c13151b2e2f5e6758485b8ca9acbc180 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Fri, 22 Jun 2007 18:27:09 +1000
Subject: Initial commit of Dynamic MODE SENSE support

Add support for:
 - MODE SENSE (6)
 - MODE SENSE (10)

Add ability to add mode pages 'on the fly'. i.e. At setup time.

Configuration/creation of mode pages via the 'tgtadm --params mode_page'

Page data information is seperated by ':'
e.g.
 --params mode_page=10:1:11:2:0:0:0:0:0:0:0:2:0:0
Where '10' is mode page 10
      '1'  is the subpage
      '11' is the length of the page data (11 bytes of information follow)

SBC & MMC devices set up some default pages at lu creation time.

The example script 'scripts/tgt-core-test' contains an executable example.

The 'doc/README.lu_configuration' updated for mode page informaiton.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 doc/README.lu_configuration |   20 ++++
 scripts/tgt-core-test       |   64 ++++++++++---
 usr/mmc.c                   |   61 ++++++++++++-
 usr/osd.c                   |    6 +-
 usr/sbc.c                   |  199 ++++++++++++----------------------------
 usr/scc.c                   |    3 +-
 usr/spc.c                   |  213 ++++++++++++++++++++++++++++++++++++++++++-
 usr/spc.h                   |   11 ++
 usr/tgtd.h                  |    4 +
 9 files changed, 424 insertions(+), 157 deletions(-)

diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
index 1244bc0..d63668a 100644
--- a/doc/README.lu_configuration
+++ b/doc/README.lu_configuration
@@ -65,5 +65,25 @@ standard INQUIRY:
 As can be seen from above 'sg_inq' output, the RMB (removable) bit is set to 1.
 The Unit serial number page updated with 'FRED00'
 
+Mode Page Creation
+------------------
+Create mode page '2', subpage 0 and 14 bytes of data.
+tgtadm --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+
+Create mode page '3', subpage 0 and 22 bytes of data.
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
+
+Create mode page '10', subpage 0 and 10 bytes of data.
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
+
+Create mode page '0x1c', subpage 0 and 10 bytes of data.
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+
+
+
 Please refer to scripts/tgt-core-test for a working example.
 
diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
index a90fc9d..dce8d3c 100755
--- a/scripts/tgt-core-test
+++ b/scripts/tgt-core-test
@@ -3,6 +3,7 @@
 # Parent directory for data files..
 HOME=/d/01
 
+# Start tgtd if not running..
 P=`ps -ef|grep -v grep|grep tgtd|wc -l`
 if [ "X"$P == "X0" ]; then
 	tgtd -d 1
@@ -35,7 +36,7 @@ TID=1
 
 # Create Target ID 1..
 tgtadm --lld iscsi --mode target --op new --tid $TID \
-		-T iqn.2007-03:marks-vtl_sbc:`hostname`
+		-T iqn.2007-03:marks-vtl_tgt:`hostname`
 sleep 1
 
 # Create first LUN - Disk
@@ -48,23 +49,58 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 	--params vendor_id=QUANTUM,product_id=HD100,product_rev=0010,removable=1,sense_format=0
 
-# Create 2nd LUN - CD/ROM
-LUN=2
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
+#### Set up mode pages ####
+# First try a couple of attempts with incorrect data..
+# i.e. Expect the first two to fail!
+# - Length too long & Incorrect value (300) as one if the params...
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY11,removable=1
-
-# Create 3rd LUN - CD/ROM
-LUN=3
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:300:0:0:0:0:0:0:0:0:3
+# - Length too short...
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY12,removable=1
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0
+#
+# From here on - should work OK..
+#
 
-# Create 4th LUN - CD/ROM
-LUN=4
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
+# Vendor Uniq - Mode page 0..
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0:0:0
+# Disconnect page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+# Format mode page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
+# Geo mode page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=4:0:22:0:0:0:0x40:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0x3a:0x98:0:0
+# Caching Page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=8:0:18:0x14:0:0xff:0xff:0:0:0xff:0xff:0xff:0xff:0x80:0x14:0:0:0:0:0:0
+# ctrl mode page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
+# Informational Exceptions Control Mode Page
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY13,removable=1
+	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+
+
+
+for LUN in 2 3 4; do
+	# Create LUN - CD/ROM
+	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY1$LUN,removable=1
+	# Vendor Uniq - Mode page 0..
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params mode_page=0:0:0
+	# ctrl mode page
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
+	# Informational Exceptions Control Mode Page
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+done
 
 # Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
diff --git a/usr/mmc.c b/usr/mmc.c
index defe60b..891cb60 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -41,6 +41,7 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "tgtadm_error.h"
 #include "sense_codes.h"
 
 #define MMC_BLK_SHIFT 11
@@ -122,10 +123,19 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 }
 
+static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)
+{
+	uint8_t *scb = cmd->scb;
+
+	/* MMC devices always return descriptor block */
+	scb[1] |= 8;
+	return spc_mode_sense(host_no, cmd);
+}
+
 static int mmc_lu_init(struct scsi_lu *lu)
 {
 	if (spc_lu_init(lu))
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "VIRTUAL-CDROM", sizeof(lu->attrs.product_id));
 	lu->attrs.sense_format = 0;
@@ -133,6 +143,34 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
 	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
+/*
+ * Set up default mode pages
+ * Ref: mmc6r00.pdf 7.2.2 (Table 649)
+ */
+	INIT_LIST_HEAD(&lu->mode_pages);
+
+	/* Vendor uniq - However most apps seem to call for mode page 0*/
+	add_mode_page(lu, "0:0:0");
+	/* Read/Write Error Recovery */
+	add_mode_page(lu, "1:0:10:0:8:0:0:0:0:8:0:0:0");
+	/* MRW */
+	add_mode_page(lu, "3:0:6:0:0:0:0:0:0");
+	/* Write Parameter
+	 * Somebody who knows more about this mode page should be setting
+	 * defaults.
+	add_mode_page(lu, "5:0:0");
+	 */
+	/* Caching Page */
+	add_mode_page(lu, "8:0:10:0:0:0:0:0:0:0:0:0:0");
+	/* Control page */
+	add_mode_page(lu, "10:0:10:2:0:0:0:0:0:0:0:2:0");
+	/* Power Condition */
+	add_mode_page(lu, "0x1a:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Informational Exceptions Control page */
+	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Timeout & Protect */
+	add_mode_page(lu, "0x1d:0:10:0:0:7:0:0:2:0:2:0:20");
+
 	return 0;
 }
 
@@ -218,7 +256,26 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 
-		[0x50 ... 0x9f] = {spc_illegal_op,},
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{mmc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x9f] = {spc_illegal_op,},
 
 		/* 0xA0 */
 		{spc_report_luns,},
diff --git a/usr/osd.c b/usr/osd.c
index 048d0c8..a48db32 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -33,6 +33,7 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "tgtadm_error.h"
 #include "sense_codes.h"
 
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
@@ -53,7 +54,7 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 static int osd_lu_init(struct scsi_lu *lu)
 {
 	if (spc_lu_init(lu))
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "OSD", sizeof(lu->attrs.product_id));
 	lu->attrs.sense_format = 1;
@@ -61,6 +62,9 @@ static int osd_lu_init(struct scsi_lu *lu)
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
 	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
+	/* not used - but initialise anyway... */
+	INIT_LIST_HEAD(&lu->mode_pages);
+
 	return 0;
 }
 
diff --git a/usr/sbc.c b/usr/sbc.c
index a62e6d8..5996081 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -38,6 +38,7 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "tgtadm_error.h"
 #include "sense_codes.h"
 
 #define BLK_SHIFT	9
@@ -169,153 +170,54 @@ sense:
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int insert_disconnect_pg(uint8_t *ptr)
-{
-	unsigned char disconnect_pg[] = {0x02, 0x0e, 0x80, 0x80, 0x00, 0x0a, 0x00, 0x00,
-                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, disconnect_pg, sizeof(disconnect_pg));
-	return sizeof(disconnect_pg);
-}
-
-static int insert_caching_pg(uint8_t *ptr)
-{
-	unsigned char caching_pg[] = {0x08, 0x12, 0x14, 0x00, 0xff, 0xff, 0x00, 0x00,
-				      0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0x00, 0x00,
-				      0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, caching_pg, sizeof(caching_pg));
-	return sizeof(caching_pg);
-}
-
-static int insert_ctrl_m_pg(uint8_t *ptr)
-{
-	unsigned char ctrl_m_pg[] = {0x0a, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
-				     0x00, 0x00, 0x02, 0x4b};
-
-	memcpy(ptr, ctrl_m_pg, sizeof(ctrl_m_pg));
-	return sizeof(ctrl_m_pg);
-}
-
-static int insert_iec_m_pg(uint8_t *ptr)
-{
-	unsigned char iec_m_pg[] = {0x1c, 0xa, 0x08, 0x00, 0x00, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, iec_m_pg, sizeof(iec_m_pg));
-	return sizeof(iec_m_pg);
-}
-
-static int insert_format_m_pg(uint8_t *ptr)
-{
-	unsigned char format_m_pg[] = {0x03, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-				       0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
-				       0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00};
-	memcpy(ptr, format_m_pg, sizeof(format_m_pg));
-	return sizeof(format_m_pg);
-}
-
-static int insert_geo_m_pg(uint8_t *ptr, uint64_t sec)
-{
-	unsigned char geo_m_pg[] = {0x04, 0x16, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x3a, 0x98, 0x00, 0x00};
-	uint32_t ncyl, *p;
-
-	/* assume 0xff heads, 15krpm. */
-	memcpy(ptr, geo_m_pg, sizeof(geo_m_pg));
-	ncyl = sec >> 14; /* 256 * 64 */
-	p = (uint32_t *)(ptr + 1);
-	*p = *p | __cpu_to_be32(ncyl);
-	return sizeof(geo_m_pg);
-}
-
-static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
+static int sbc_lu_init(struct scsi_lu *lu)
 {
-	int ret = SAM_STAT_GOOD, len;
-	uint8_t pcode = cmd->scb[2] & 0x3f;
 	uint64_t size;
-	uint8_t *data = NULL;
-	unsigned char key = ILLEGAL_REQUEST;
-	uint16_t asc = ASC_LUN_NOT_SUPPORTED;
+	uint8_t *data;
 
-	if (device_reserved(cmd))
-		return SAM_STAT_RESERVATION_CONFLICT;
+	if (spc_lu_init(lu))
+		return TGTADM_NOMEM;
 
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = ASC_INTERNAL_TGT_FAILURE;
-		goto sense;
-	}
-	memset(data, 0, pagesize);
+	strncpy(lu->attrs.product_id, "VIRTUAL-DISK", sizeof(lu->attrs.product_id));
+	lu->attrs.version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
-	len = 4;
-	size = cmd->dev->size >> BLK_SHIFT;
+	data = lu->mode_block_descriptor;
+	size = lu->size >> BLK_SHIFT;
 
-	if ((cmd->scb[1] & 0x8))
-		data[3] = 0;
-	else {
-		data[3] = 8;
-		len += 8;
-		*(uint32_t *)(data + 4) = (size >> 32) ?
+	*(uint32_t *)(data) = (size >> 32) ?
 			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
-		*(uint32_t *)(data + 8) = __cpu_to_be32(1 << BLK_SHIFT);
-	}
+	*(uint32_t *)(data + 4) = __cpu_to_be32(1 << BLK_SHIFT);
 
-	switch (pcode) {
-	case 0x0:
-		break;
-	case 0x2:
-		len += insert_disconnect_pg(data + len);
-		break;
-	case 0x3:
-		len += insert_format_m_pg(data + len);
-		break;
-	case 0x4:
-		len += insert_geo_m_pg(data + len, size);
-		break;
-	case 0x8:
-		len += insert_caching_pg(data + len);
-		break;
-	case 0xa:
-		len += insert_ctrl_m_pg(data + len);
-		break;
-	case 0x1c:
-		len += insert_iec_m_pg(data + len);
-		break;
-	case 0x3f:
-		len += insert_disconnect_pg(data + len);
-		len += insert_format_m_pg(data + len);
-		len += insert_geo_m_pg(data + len, size);
-		len += insert_caching_pg(data + len);
-		len += insert_ctrl_m_pg(data + len);
-		len += insert_iec_m_pg(data + len);
-		break;
-	default:
-		asc = ASC_INVALID_FIELD_IN_CDB;
-		goto sense;
-	}
+	INIT_LIST_HEAD(&lu->mode_pages);
 
-	data[0] = len - 1;
-	cmd->len = len;
-	cmd->uaddr = (unsigned long) data;
-	return ret;
-sense:
-	cmd->len = 0;
-	sense_data_build(cmd, key, asc);
-	return SAM_STAT_CHECK_CONDITION;
-}
+	data = lu->mode_block_descriptor;
+	size = lu->size >> BLK_SHIFT;
 
-static int sbc_lu_init(struct scsi_lu *lu)
-{
-	if (spc_lu_init(lu))
-		return -ENOMEM;
+	*(uint32_t *)(data) = (size >> 32) ?
+			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
+	*(uint32_t *)(data + 4) = __cpu_to_be32(1 << BLK_SHIFT);
 
-	strncpy(lu->attrs.product_id, "VIRTUAL-DISK", sizeof(lu->attrs.product_id));
-	lu->attrs.version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
-	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
-	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
+/*
+ * Set up default mode pages
+ */
+	INIT_LIST_HEAD(&lu->mode_pages);
+
+	/* Vendor uniq - However most apps seem to call for mode page 0*/
+	add_mode_page(lu, "0:0:0");
+	/* Disconnect page */
+	add_mode_page(lu, "2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0");
+	/* Format page */
+	add_mode_page(lu, "3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0");
+	/* GEO page */
+	add_mode_page(lu, "4:0:22:0:0:0:0x40:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0x3a:0x98:0:0");
+	/* Caching Page */
+	add_mode_page(lu, "8:0:18:0x14:0:0xff:0xff:0:0:0xff:0xff:0xff:0xff:0x80:0x14:0:0:0:0:0:0");
+	/* Control page */
+	add_mode_page(lu, "10:0:10:2:0:0:0:0:0:0:0:2:0");
+	/* Informational Exceptions Control page */
+	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
 
 	return 0;
 }
@@ -355,7 +257,7 @@ static struct device_type_template sbc_template = {
 
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_mode_sense,},
+		{spc_mode_sense,},
 		{spc_start_stop,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -400,7 +302,28 @@ static struct device_type_template sbc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 
-		[0x40 ... 0x7f] = {spc_illegal_op,},
+		[0x40 ... 0x4f] = {spc_illegal_op,},
+
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x7f] = {spc_illegal_op,},
 
 		/* 0x80 */
 		{spc_illegal_op,},
diff --git a/usr/scc.c b/usr/scc.c
index be5019c..28cd813 100644
--- a/usr/scc.c
+++ b/usr/scc.c
@@ -33,12 +33,13 @@
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
+#include "tgtadm_error.h"
 #include "spc.h"
 
 static int scc_lu_init(struct scsi_lu *lu)
 {
 	if (spc_lu_init(lu))
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "Controler",
 		sizeof(lu->attrs.product_id));
diff --git a/usr/spc.c b/usr/spc.c
index 6560e98..3eb605c 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -231,6 +231,106 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
 		return SAM_STAT_GOOD;
 }
 
+/*
+ * Copy mode page data from list into SCSI data so it can be returned
+ * to the initiator
+ *
+ * *data -> target address (destination)
+ * mode -> Pointer to mode page information (source)
+ *
+ * Returns number of bytes copied.
+ */
+static int build_mode_page(uint8_t *data, struct mode *m)
+{
+	uint8_t *p;
+	int len;
+
+	data[0] = m->pcode;
+	len = m->pcode_sz;
+	data[1] = len;
+	p = &data[2];
+	len += 2;
+	memcpy(p, m->mode_data, m->pcode_sz);
+
+return len;
+}
+
+/*
+ * Reference : SPC4r11
+ * 6.11 - MODE SENSE(6)
+ * 6.12 - MODE SENSE(10)
+ */
+int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
+{
+	int	len = 0;
+	uint8_t *data;
+	uint8_t *scb = cmd->scb;
+	uint8_t	mode6 = (scb[0] == 0x1a) ? 1 : 0;
+	uint8_t dbd = (scb[1] & 8) ? 1 : 0;	/* Disable Block Descriptors */
+	uint8_t page_code = scb[2] & 0x3f;
+	uint8_t subpage = scb[3];
+	uint16_t alloc_len;
+	struct	mode	* m;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+
+	if (subpage)
+		goto sense;	/* Currently not implemented */
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+	if (mode6) {
+		alloc_len = scb[4];
+		len = 4;
+	} else {
+		alloc_len = (scb[7] << 8) + scb[8];
+		len = 8;
+	}
+	if (alloc_len > pagesize)
+		goto sense;
+
+	if (!dbd) {
+		memcpy(data + len, cmd->dev->mode_block_descriptor,
+				BLOCK_DESCRIPTOR_LEN);
+		len += 8;
+	}
+
+	if (page_code == 0x3f) {	/* All pages */
+		int	i;
+		for (i=0; i < 0x3f; i++) {
+			m = mode_page_lookup(&cmd->dev->mode_pages, i);
+			if (m)
+				len += build_mode_page(data + len, m);
+		}
+	} else {
+		m = mode_page_lookup(&cmd->dev->mode_pages, page_code);
+		if (!m)
+			goto sense;
+		len += build_mode_page(data + len, m);
+	}
+	if (mode6) {
+		data[0] = len - 1;
+		data[3] = (dbd) ? 0 : BLOCK_DESCRIPTOR_LEN;
+	} else {
+		*(uint16_t *)(data) = __cpu_to_be16(len - 3);
+		data[7] = (dbd) ? 0 : BLOCK_DESCRIPTOR_LEN;
+	}
+
+	cmd->len = len;
+	cmd->uaddr = (unsigned long)data;
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
 int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
 	cmd->len = 0;
@@ -238,6 +338,106 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 }
 
+/*
+ * Init and alloc space for the supported mode page structures
+ */
+static struct mode *insert_mode_page(struct list_head *head, int page, int subpage, int sz)
+{
+	struct mode *m;
+
+	if ((m = zalloc(sizeof(struct mode))) == NULL)
+		return NULL;
+	if ((m->mode_data = zalloc(sz)) == NULL) {
+		free(m);
+		return NULL;
+	}
+	m->pcode = page;
+	m->subpcode = subpage;
+	m->pcode_sz = (uint16_t)sz;
+	list_add_tail(&m->mode_siblings, head);
+	return m;
+}
+
+struct mode *mode_page_lookup(struct list_head *head, uint8_t page)
+{
+	struct mode *m;
+
+	list_for_each_entry(m, head, mode_siblings)
+		if (m->pcode == page)
+			return m;
+
+	return NULL;
+}
+
+/*
+ * Return:
+ * 	0 on success
+ *	TGTADM_INVALID_REQUEST on error
+ */
+int add_mode_page(struct scsi_lu *lu, char *params)
+{
+	int i = 0;
+	int tmp;
+	uint8_t page = 0;
+	uint8_t subpage = 0;
+	uint8_t *data = NULL;
+	uint16_t sz = 0;
+	struct mode *m = NULL;
+	char *buf;
+	char *p = NULL;
+	int err = TGTADM_NOMEM;
+
+	buf = malloc(strlen(params) + 1);
+	strcpy(buf, params);
+
+	while ((p = strsep(&buf, ":")) != NULL) {
+		switch (i) {
+		case 0:
+			page = strtol(p, NULL, 0);
+			break;
+		case 1:
+			subpage = strtol(p, NULL, 0);
+			break;
+		case 2:
+			sz = strtol(p, NULL, 0);
+			/* Try find existing mode page */
+			m = mode_page_lookup(&lu->mode_pages, page);
+			/* If not found, create the mode page */
+			if (!m)
+				m = insert_mode_page(&lu->mode_pages, page,
+								subpage, sz);
+			/* Still no mode page, fail */
+			if (!m)
+				goto exit;
+
+			data = m->mode_data;
+			break;
+		default:
+			if (i < (sz + 3)) {
+				tmp = strtol(p, NULL, 0);
+				if (tmp > 255)
+					dprintf("Error : Incorrect value %d "
+					"Mode page %d (0x%02x), index: %d\n",
+						tmp, page, page, i - 3);
+				data[i - 3] = (uint8_t)tmp;
+			}
+			break;
+		}
+		i++;
+	}
+
+	err = (i != (sz + 3)) ? TGTADM_INVALID_REQUEST : TGTADM_SUCCESS;
+
+	if (i != (sz + 3))
+		dprintf("Mode Page %d (0x%02x): param_count %d != "
+					" MODE PAGE size : %d\n",
+				page, page, i, sz + 3);
+
+exit:
+	free(buf);
+	return err;
+}
+
 void dump_cdb(struct scsi_cmd *cmd)
 {
 	uint8_t *cdb = cmd->scb;
@@ -283,6 +483,7 @@ enum {
 	Opt_vendor_id, Opt_product_id,
 	Opt_product_rev, Opt_sense_format,
 	Opt_removable, Opt_online,
+	Opt_mode_page,
 	Opt_err,
 };
 
@@ -295,13 +496,14 @@ static match_table_t tokens = {
 	{Opt_sense_format, "sense_format=%s"},
 	{Opt_removable, "removable=%s"},
 	{Opt_online, "online=%s"},
+	{Opt_mode_page, "mode_page=%s"},
 	{Opt_err, NULL},
 };
 
 int spc_lu_config(struct scsi_lu *lu, char *params) {
 	int err = 0;
 	char *p;
-	char buf[20];
+	char buf[256];
 
 	if (!strncmp("targetOps", params, 9))
 		params = params + 10;
@@ -345,6 +547,10 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			match_strncpy(buf, &args[0],  sizeof(buf));
 			lu->attrs.online = atoi(buf);
 			break;
+		case Opt_mode_page:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			err = add_mode_page(lu, buf);
+			break;
 		default:
 			err = TGTADM_INVALID_REQUEST;
 		}
@@ -352,6 +558,11 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 	return err;
 }
 
+/*
+ * Set initial power-on defaults for lu
+ *
+ * Currently always return '0'
+ */
 int spc_lu_init(struct scsi_lu *lu)
 {
 	strncpy(lu->attrs.vendor_id, VENDOR_ID, sizeof(lu->attrs.vendor_id));
diff --git a/usr/spc.h b/usr/spc.h
index 1036b70..c7e38c0 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -1,6 +1,14 @@
 #ifndef __SPC_H
 #define __SPC_H
 
+struct mode {
+	struct list_head mode_siblings;
+	uint8_t pcode;		/* Page code */
+	uint8_t subpcode;	/* Sub page code */
+	int16_t pcode_sz;	/* Size of page code data. */
+	uint8_t *mode_data;	/* Rest of mode page info */
+};
+
 extern int spc_inquiry(int host_no, struct scsi_cmd *cmd);
 extern int spc_report_luns(int host_no, struct scsi_cmd *cmd);
 extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
@@ -10,5 +18,8 @@ extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
 extern int spc_lu_init(struct scsi_lu *lu);
 extern int spc_lu_config(struct scsi_lu *lu, char * params);
 extern void dump_cdb(struct scsi_cmd *cmd);
+extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
+struct mode *mode_page_lookup(struct list_head *head, uint8_t page);
+int add_mode_page(struct scsi_lu *lu, char *params);
 
 #endif
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 8e66d60..bbacae2 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -5,6 +5,7 @@
 
 #define SCSI_ID_LEN	24
 #define SCSI_SN_LEN	8
+#define BLOCK_DESCRIPTOR_LEN 8
 #define VERSION_DESCRIPTOR_LEN 8
 
 #define VENDOR_ID	"IET"
@@ -96,6 +97,9 @@ struct scsi_lu {
 
 	struct backingstore_template *bst;
 
+	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
+	struct list_head mode_pages;
+
 	/* TODO: needs a structure for lots of device parameters */
 	struct lu_phy_attr attrs;
 };
-- 
1.5.2.1






From markh794 at gmail.com  Sat Jun 23 10:15:14 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 23 Jun 2007 18:15:14 +1000
Subject: [Stgt-devel] [Patch 0/3] Re-work based against
	6868d6adb37295722d6cbe4c4212c910a1e44a54
Message-ID: <467CD692.8010305@gmail.com>

Re-worked patches against latest head...

Regards
Mark Harvey

commit 6868d6adb37295722d6cbe4c4212c910a1e44a54
Author: Mark Harvey <markh794 at gmail.com>
Date:   Wed Jun 20 17:34:26 2007 +1000

    update the sample script to suit new Logical Unit creation
    
    As LU are no longer tied to the target type, the sample script
    required a rework to suit new layout.
    
    Signed-off-by: Mark Harvey <markh794 at gmail.com>
    Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>





From markh794 at gmail.com  Sat Jun 23 10:14:04 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 23 Jun 2007 18:14:04 +1000
Subject: [Stgt-devel] [Patch 3/3] Re-work of SMC support
Message-ID: <467CD64C.9060606@gmail.com>

>From 921b883ce4bb5f015d9d950c2f9b7e4fc89b1ba6 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Sat, 23 Jun 2007 17:34:03 +1000
Subject: Initial commit of SMC module.

Includes all SCSI op codes defined in SSC as MANDATORY.

As yet, does not contain any way of signaling the DATA TRANSFER DEVICE
a piece of medium has been moved / loaded.

doc/README.lu_configuration updated with SMC specific options.

scripts/tgt-core-test updated to create an SMC device as well.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 doc/README.lu_configuration |   43 +++
 scripts/tgt-core-test       |   96 +++++-
 usr/Makefile                |    5 +-
 usr/media.h                 |   30 ++
 usr/mmc.c                   |   19 +-
 usr/osd.c                   |   18 +
 usr/sbc.c                   |   19 +-
 usr/scc.c                   |   18 +-
 usr/smc.c                   |  811 +++++++++++++++++++++++++++++++++++++++++++
 usr/smc.h                   |   77 ++++
 usr/spc.c                   |   18 +-
 usr/spc.h                   |    2 +-
 usr/tgtadm.c                |    2 +
 usr/tgtd.h                  |    5 +-
 14 files changed, 1143 insertions(+), 20 deletions(-)
 create mode 100644 usr/media.h
 create mode 100644 usr/smc.c
 create mode 100644 usr/smc.h

diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
index d63668a..47e4912 100644
--- a/doc/README.lu_configuration
+++ b/doc/README.lu_configuration
@@ -84,6 +84,49 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
          --params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 
 
+SMC unique options
+------------------
+
+--params have several unique key=value pairs ontop of all other modules.
+ - element_type=<1|2|3|4>
+ - start_address=Number between 1 & 65535
+ - quantity=Number between 1 & 65535
+ - sides=1|2
+ - address=Number between 1 & 65535
+ - barcode="Char string up to 10 chars"
+ - tid=<number>
+ - lun=<number>
+
+Several of these parameters 'work together'
+
+e.g. To add 'quantity' slots as 'element_type' starting at 'start_address'
+ - element_type=<1|2|3|4>
+ - start_address=Number between 1 & 65535
+ - quantity=Number between 1 & 65535
+
+Note: start_address + quantity should not overlap with any other slots..
+
+
+While 'configuring slot 'address' of 'element_type':
+ - Set barcode of meda (occupy slot)
+ - If element type is DATA TRANSFER DEVICE, then define TID & LUN of device.
+
+ - element_type=<1|2|3|4>
+ - address=Number between 1 & 65535
+ - barcode="String up to 10 chars"
+ - sides=<1|2>
+ - tid=<tid of device which belongs at this address>
+ - lun=<lun of device which belongs at this address>
+
+
+It is the responsibility of the user not to configure overlapping slots
+of differing types.
+
+Slot types:
+ 1 -> Medium Transport (picker arm)
+ 2 -> Storage Element
+ 3 -> Import/Export Element
+ 4 -> Data Transfer device (CD drive, tape drive, MO drive etc)
 
 Please refer to scripts/tgt-core-test for a working example.
 
diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
index dce8d3c..bd168dc 100755
--- a/scripts/tgt-core-test
+++ b/scripts/tgt-core-test
@@ -17,15 +17,6 @@ fi
 if [ ! -f $HOME/hd_block ]; then
 	dd if=/dev/zero of=$HOME/hd_block bs=1M count=8
 fi
-if [ ! -f $HOME/cd_block0 ]; then
-	dd if=/dev/zero of=$HOME/cd_block0 bs=1M count=8
-fi
-if [ ! -f $HOME/cd_block1 ]; then
-	dd if=/dev/zero of=$HOME/cd_block1 bs=1M count=8
-fi
-if [ ! -f $HOME/cd_block2 ]; then
-	dd if=/dev/zero of=$HOME/cd_block2 bs=1M count=8
-fi
 
 set -x
 
@@ -85,10 +76,13 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 
 
-
 for LUN in 2 3 4; do
+	if [ ! -f $HOME/cdrom$LUN ]; then
+		dd if=/dev/zero of=$HOME/cdrom$LUN bs=1M count=8
+	fi
+
 	# Create LUN - CD/ROM
-	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
+	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cdrom$LUN --device-type=cd
 	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 		--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY1$LUN,removable=1
 	# Vendor Uniq - Mode page 0..
@@ -102,6 +96,86 @@ for LUN in 2 3 4; do
 		--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 done
 
+###############################################################################
+# Set up SMC Medium Changer
+###############################################################################
+LUN=5
+if [ ! -f $HOME/smc ]; then
+	dd if=/dev/zero of=$HOME/smc bs=1k count=1
+fi
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN \
+			-b $HOME/smc --device-type=changer
+
+#### Set up mode pages ####
+# From smc3-06.pdf
+# Page 0x02: Disconnect/Reconnect SPC-3
+# Page 0x0a: Control SPC-3
+# Page 0x18: Protocol Specific LUN SPC-3
+# Page 0x19: Protocol Specific Port SPC-3
+# Page 0x1a: Power Condition SPC-3
+# Page 0x1c: Informational Exceptions Control SPC-3
+# Page 0x1d: Element Address Assignment SMC-3 7.3.4
+# Page 0x1e: Transport Geometry Parameters SMC-3 7.3.5
+# Page 0x1f: Device Capabilities SMC-3 7.3.2
+# Page 0x1f/Subpage 0x41: Extended Device Capabilities SMC-3 7.3.3
+
+# Dummy 'page 0'
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0:0:0
+# Disconnect/Reconnect
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+# Power Condition
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1a:0:18:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
+# Informational Exceptions Control Mode Page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+# Element Address Assignment - Setup afterwards.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1d:0:0x12:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
+# Transport Geometry Parameters
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1e:0:2:0:0
+# Device Capabilities
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1f:0:0x12:0x0f:7:0x0f:0x0f:0x0f:0x0f:0:0:0:0:0x0f:0x0f:0x0f:0x0f:0:0:0:0
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params vendor_id=STK,product_id=L700,product_rev=0010,scsi_sn=XYZZY_0,removable=1
+
+
+## Add Data Transfer devices (3 drives)
+# Define slot address for devices.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,start_address=1,quantity=3
+# Now define which device at each address.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,address=1,tid=1,lun=2
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,address=2,tid=1,lun=3
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,address=3,tid=1,lun=4
+
+# Medium Transport Elements (robot arm / picker)
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=1,start_address=16,quantity=1
+
+## Storage Elements - 8 starting at addr 1024
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=2,start_address=1024,quantity=8
+# Add 'media' to slots
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=2,address=1024,barcode=ABC123,Sides=1
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=2,address=1026,barcode=ULT001L3,Sides=1
+
+# Import/Export Elements - 5 starting at addr 32
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=3,start_address=32,quantity=5
+
+
 # Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
 
diff --git a/usr/Makefile b/usr/Makefile
index 14be34b..c7fb2ca 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -43,8 +43,9 @@ INCLUDES += -I.
 CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
 
 PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o osd.o spt.o scc.o scsi.o log.o \
-	driver.o util.o work.o parser.o
+TGTD_OBJS += tgtd.o mgmt.o target.o \
+	spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o \
+	scsi.o log.o driver.o util.o work.o parser.o
 
 all: $(PROGRAMS)
 
diff --git a/usr/media.h b/usr/media.h
new file mode 100644
index 0000000..a04a27c
--- /dev/null
+++ b/usr/media.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef _MEDIA_H_
+#define _MEDIA_H_
+
+enum c_type {	/* Cartridge Types - Ref: smc3r06 - Table 20, page 37 */
+	CART_UNSPECIFIED,
+	CART_DATA,
+	CART_CLEAN,
+	CART_DIAGNOSTICS,
+	CART_WORM,
+	CART_MICROCODE,
+};
+
+#endif /* _MEDIA_H_ */
+
diff --git a/usr/mmc.c b/usr/mmc.c
index 891cb60..0672877 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -38,6 +38,7 @@
 #include "util.h"
 #include "tgtd.h"
 #include "target.h"
+#include "tgtadm_error.h"
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
@@ -174,10 +175,26 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+static int mmc_lu_config(struct scsi_lu *lu, char * params)
+{
+	char	* mmc_params;
+	int	ret;
+
+	mmc_params = malloc(strlen(params) + 1);
+	if (!mmc_params)
+		return -ENOMEM;
+	mmc_params[0] = '\0';
+	ret = spc_lu_config(lu, params, mmc_params);
+	if (strlen(mmc_params))	/* We should not have any params left over */
+		ret = TGTADM_INVALID_REQUEST;
+	free(mmc_params);
+	return ret;
+}
+
 static struct device_type_template mmc_template = {
 	.type		= TYPE_ROM,
 	.lu_init	= mmc_lu_init,
-	.lu_config	= spc_lu_config,
+	.lu_config	= mmc_lu_config,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/osd.c b/usr/osd.c
index a48db32..2574086 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -29,6 +29,7 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "tgtadm_error.h"
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
@@ -68,9 +69,26 @@ static int osd_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+static int osd_lu_config(struct scsi_lu *lu, char * params)
+{
+	char	* osd_params;
+	int	ret;
+
+	osd_params = malloc(strlen(params) + 1);
+	if (!osd_params)
+		return -ENOMEM;
+	osd_params[0] = '\0';
+	ret = spc_lu_config(lu, params, osd_params);
+	if (strlen(osd_params))	/* We should not have any params left over */
+		ret = TGTADM_INVALID_REQUEST;
+	free(osd_params);
+	return ret;
+}
+
 static struct device_type_template osd_template = {
 	.type		= TYPE_OSD,
 	.lu_init	= osd_lu_init,
+	.lu_config	= osd_lu_config,
 	.ops		= {
 		[0x00 ... 0x0f] = {spc_illegal_op},
 
diff --git a/usr/sbc.c b/usr/sbc.c
index 5996081..739f25c 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -34,6 +34,7 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "tgtadm_error.h"
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
@@ -222,10 +223,26 @@ static int sbc_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+static int sbc_lu_config(struct scsi_lu *lu, char *params)
+{
+	char *sbc_params;
+	int ret;
+
+	sbc_params = malloc(strlen(params) + 1);
+	if (!sbc_params)
+		return TGTADM_NOMEM;
+	sbc_params[0] = '\0';
+	ret = spc_lu_config(lu, params, sbc_params);
+	if (strlen(sbc_params))	/* We should not have any params left over */
+		ret = TGTADM_INVALID_REQUEST;
+	free(sbc_params);
+	return ret;
+}
+
 static struct device_type_template sbc_template = {
 	.type		= TYPE_DISK,
 	.lu_init	= sbc_lu_init,
-	.lu_config	= spc_lu_config,
+	.lu_config	= sbc_lu_config,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/scc.c b/usr/scc.c
index 28cd813..38d892e 100644
--- a/usr/scc.c
+++ b/usr/scc.c
@@ -50,10 +50,26 @@ static int scc_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+static int scc_lu_config(struct scsi_lu *lu, char *params)
+{
+	char *scc_params;
+	int ret;
+
+	scc_params = malloc(strlen(params) + 1);
+	if (!scc_params)
+		return TGTADM_NOMEM;
+	scc_params[0] = '\0';
+	ret = spc_lu_config(lu, params, scc_params);
+	if (strlen(scc_params))	/* We should not have any params left over */
+		ret = TGTADM_INVALID_REQUEST;
+	free(scc_params);
+	return ret;
+}
+
 static struct device_type_template scc_template = {
 	.type		= TYPE_RAID,
 	.lu_init	= scc_lu_init,
-	.lu_config	= spc_lu_config,
+	.lu_config	= scc_lu_config,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/smc.c b/usr/smc.c
new file mode 100644
index 0000000..c94be41
--- /dev/null
+++ b/usr/smc.c
@@ -0,0 +1,811 @@
+/*
+ * SCSI Medium Changer command processing
+ * Based on smc3r06.pdf document from t10.org
+ *
+ * (C) 2004-2007 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
+ * (C) 2007      Mark Harvey <markh794 at gmail.com>
+ *
+ * SCSI target emulation code is based on Ardis's iSCSI implementation.
+ *   http://www.ardistech.com/iscsi/
+ *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
+ *   licensed under the terms of the GNU GPL v2.0,
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <linux/fs.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "driver.h"
+#include "tgtadm_error.h"
+#include "scsi.h"
+#include "spc.h"
+#include "sense_codes.h"
+#include "parser.h"
+#include "smc.h"
+#include "media.h"
+
+struct slot *slot_lookup(struct list_head *head, int element_type, int address);
+static void set_slot_full(struct slot *s, uint16_t src);
+static void set_slot_empty(struct slot *s);
+static int test_slot_full(struct slot *s);
+
+/* ********************************************************
+ * READ_ELEMENT_STATUS
+ *
+ * Ref: Working Draft SCSI Media Changer-3 (smc3r06.pdf), chapter 6.10
+ *
+ * The READ ELEMENT STATUS command request that the device server report the
+ * status of its internal elements to the application client.
+ * Support for READ ELEMENT STATUS command is mandatory.
+ * ******************************************************** */
+static int determine_element_sz(uint8_t dvcid, uint8_t vol_tag)
+{
+	if (vol_tag)
+		return (dvcid) ? 86 : 52;
+	else
+		return (dvcid) ? 50 : 16;
+}
+
+/* Fill in Element Status Header - Always 8 bytes long */
+static int element_status_data_hdr(uint8_t *data, uint8_t dvcid,
+					uint8_t vol_tag, int start, int count)
+{
+	int element_sz;
+	int size;
+
+	element_sz = determine_element_sz(dvcid, vol_tag);
+
+	/* First Element address reported */
+	*(uint16_t *)(data) = __cpu_to_be16(start);
+
+	/* Number of elements available */
+	*(uint16_t *)(data + 2) = __cpu_to_be16(count);
+
+	/* Byte count is the length required to return all valid data.
+	 * Allocated length is how much data the initiator will accept */
+	size = ((8 + (count * element_sz)) & 0xffffff);
+	*(uint32_t *)(data + 4) = __cpu_to_be32(size);
+
+return size;
+}
+
+static int add_element_descriptor(uint8_t *data, struct slot *s,
+			uint8_t element_type, uint8_t dvcid, uint8_t vol_tag)
+{
+	int ret = determine_element_sz(dvcid, vol_tag);
+
+	*(uint16_t *)(data) = __cpu_to_be16(s->slot_addr);
+	data[2] = s->status;
+	data[3] = 0;	/* Reserved */
+	data[4] = (s->asc >> 8) & 0xff;	/* Additional Sense Code */
+	data[5] = s->asc & 0xff;	/* Additional Sense Code Qualifier */
+	/* [6], [7] & [8] reserved */
+	data[9] = (s->cart_type & 0xf);
+	if (s->last_addr) {	/* Source address is valid ? */
+		data[9] |= 0x80;
+		*(uint16_t *)(data + 10) = __cpu_to_be16(s->last_addr);
+	}
+	if (vol_tag) {
+		if (s->barcode[0] == ' ')
+			memset( &data[12], 0x20, 32); /* Pad with spaces */
+		else
+			snprintf((char *)&data[12], 32, "%-32s", s->barcode);
+	}
+
+return ret;
+}
+
+/* Fill in Element details
+ *
+ * Fill each Element Descriptor for slot *s
+ *
+ * data : pointer
+ * head : Slot struct head
+ * element_type : Slot type we are interested in.
+ * first : Return address of first slot found
+ * start : Start processing from this element #
+ * dvcid : Device ID
+ * vol_tag : Volume tag (barcode)
+ *
+ * Return number of elements
+ */
+static int build_element_descriptors(uint8_t *data, struct list_head *head,
+					uint8_t elem_type, int *first,
+					uint16_t start,
+					uint8_t dvcid, uint8_t vol_tag)
+{
+	struct slot *s;
+	int count = 0;
+	int len = 0;
+	int elem_sz = determine_element_sz(dvcid, vol_tag);
+
+	list_for_each_entry(s, head, slot_siblings) {
+		if (s->element_type == elem_type) {
+			if (s->slot_addr >= start) {
+				count++;
+				len += add_element_descriptor(&data[8+len],
+						s, elem_type, dvcid, vol_tag);
+			}
+		}
+		if (count == 1)	/* Record first found slot Address */
+			*first = s->slot_addr;
+	}
+
+	/* Fill in Element Status Page Header */
+	data[0] = elem_type;
+	data[1] = (vol_tag) ? 0x80 : 0;	/* Primary Vol Tag set */
+	*(uint16_t *)(data + 2) = __cpu_to_be16(elem_sz);
+
+	/* Total number of bytes in all element descriptors */
+	*(uint32_t *)(data + 4) = __cpu_to_be32((elem_sz * count) & 0xffffff);
+
+return count;
+}
+
+/* *********************************************
+ * READ ELEMENT STATUS op code
+ * ********************************************* */
+static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
+{
+	struct smc_info *smc = (struct smc_info *)cmd->dev->smc_p;
+	uint8_t *data;
+	uint8_t *scb;
+	uint8_t element_type;
+	uint8_t vol_tag;
+	uint16_t req_start_elem;
+//	FIXME: Take into account number of slots requested..
+//	uint16_t	number = __be16_to_cpu(*(uint16_t *)(scb[4]));
+	uint8_t dvcid;		/* Device ID */
+	uint32_t alloc_len;
+	uint16_t count = 0;
+	int first = 0;		/* First valid slot location */
+	int len = 8;
+	int elementSize;
+	int ret;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+
+	scb = cmd->scb;
+	element_type = scb[1] & 0x0f;
+	vol_tag	= (scb[1] & 0x10) >> 4;
+	dvcid = scb[6] & 0x01;
+	req_start_elem = __be16_to_cpu(*(uint16_t *)(scb + 2));
+	alloc_len = 0xffffff & __be32_to_cpu(*(uint32_t *)(scb + 6));
+
+	elementSize = determine_element_sz(dvcid, vol_tag);
+
+	cmd->len = 0;
+	if (cmd->dev) {
+		ret = device_reserved(cmd);
+		if (ret) {
+			dprintf("Reservation Conflict\n");
+			return SAM_STAT_RESERVATION_CONFLICT;
+		}
+	}
+
+	if (pagesize < alloc_len) {
+		dprintf("Can't allocate enough memory for cmd\n");
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	if ((data = valloc(pagesize)) == NULL) {
+		dprintf("valloc(%lu) failed\n", pagesize);
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	if (scb[11])	/* Reserved byte */
+		goto sense;
+
+	switch(element_type) {
+	case ELEMENT_ANY:
+		/* Return element in type order */
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MEDIUM_TRANSPORT, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		len = count * elementSize;
+		count += build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_STORAGE, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		len += count * elementSize;
+		count += build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MAP, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		len += count * elementSize;
+		count += build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_DATA_TRANSFER, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		break;
+	case ELEMENT_MEDIUM_TRANSPORT:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MEDIUM_TRANSPORT, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		break;
+	case ELEMENT_STORAGE:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_STORAGE, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		break;
+	case ELEMENT_MAP:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MAP, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		break;
+	case ELEMENT_DATA_TRANSFER:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_DATA_TRANSFER, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		break;
+	default:
+		goto sense;
+		break;
+	}
+
+	/* Lastly, fill in data header */
+	len = element_status_data_hdr(data, dvcid, vol_tag, first, count);
+
+	cmd->len = min_t(int, len, alloc_len);
+	cmd->uaddr = (unsigned long) data;
+	cmd->rw = READ;
+
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+/* *********************************************
+ * MOVE MEDIUM op code
+ * ********************************************* */
+static int smc_move_medium(int host_no, struct scsi_cmd *cmd)
+{
+	struct smc_info *smc = (struct smc_info *)cmd->dev->smc_p;
+	uint8_t *scb;
+	uint16_t src;
+	uint16_t dest;
+	uint8_t invert;
+	struct slot *src_slot = NULL;
+	struct slot *dest_slot = NULL;
+	struct slot *s;
+	int key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+
+	scb = cmd->scb;
+	src = __be16_to_cpu(*(uint16_t *)(scb + 4));
+	dest = __be16_to_cpu(*(uint16_t *)(scb + 6));
+	invert = scb[10] & 1;
+
+	list_for_each_entry(s, &smc->slots, slot_siblings) {
+		if (s->slot_addr == src)
+			src_slot = s;
+		if (s->slot_addr == dest)
+			dest_slot = s;
+	}
+
+	if (src_slot) {
+		if (!test_slot_full(src_slot)) {
+			asc = ASC_MEDIUM_SRC_EMPTY;
+			goto sense;
+		}
+	} else	/* Could not find src slot - Error */
+		goto sense;
+
+	if (dest_slot) {
+		if (test_slot_full(dest_slot)) {
+			asc = ASC_MEDIUM_DEST_FULL;
+			goto sense;
+		}
+	} else	/* Could not find dest slot - Error */
+		goto sense;
+
+	if (invert)
+		if (s->sides == 1)	/* Use default INVALID FIELD IN CDB */
+			goto sense;
+
+	memcpy(&dest_slot->barcode, &src_slot->barcode, sizeof(s->barcode));
+	set_slot_empty(src_slot);
+	set_slot_full(dest_slot, src);
+	cmd->len = 0;
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+/* *********************************************
+ * ****       House keeping routines        ****
+ * ********************************************* */
+
+/* Any housekeeping required at logical unit setup */
+static int smc_lu_init(struct scsi_lu *lu)
+{
+	struct smc_info *smc;
+
+	smc = zalloc(sizeof(struct smc_info));
+	if (smc)
+		lu->smc_p = smc;
+	else
+		return -ENOMEM;
+
+	spc_lu_init(lu);
+
+	strncpy(lu->attrs.product_id, "VIRTUAL-CHANGER",
+						sizeof(lu->attrs.product_id));
+	lu->attrs.version_desc[0] = 0x0480; /* SMC-3 no version claimed */
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
+
+	INIT_LIST_HEAD(&lu->mode_pages);
+
+	/* Vendor uniq - However most apps seem to call for mode page 0*/
+	add_mode_page(lu, "0:0:0");
+	/* Control page */
+	add_mode_page(lu, "10:0:10:2:0:0:0:0:0:0:0:2:0");
+	/* Power Condition */
+	add_mode_page(lu, "0x1a:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Informational Exceptions Control page */
+	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Address Assignment */
+	add_mode_page(lu, "0x1d:0:0x12:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0");
+	/* Transport Geometry Params */
+	add_mode_page(lu, "0x1e:0:2:0:0");
+	/* Device Capabilities */
+	add_mode_page(lu, "0x1f:0:0x12:15:7:15:15:15:15:0:0:0:0:15:15:15:15:0:0:0:0");
+
+	INIT_LIST_HEAD(&smc->slots);
+
+	lu->attrs.online = 1;	/* Library will now report as Online */
+	lu->attrs.reset = 1;	/* Poweron/reset occurred */
+	lu->attrs.removable = 1; /* Default to removable media */
+
+	return 0;
+}
+
+/* Any housekeeping required at shutdown */
+static void smc_lu_exit(struct scsi_lu *lu)
+{
+	struct smc_info *smc = lu->smc_p;
+
+	dprintf("Medium Changer shutdown() called\n");
+
+	free(smc);
+}
+
+/* **************************************
+ * General utilities related to slot(s)
+ * **************************************/
+/* Set slot status to full */
+static void set_slot_full(struct slot *s, uint16_t src)
+{
+	s->status |= 1;
+	s->last_addr=src;
+}
+
+/* Set slot status to empty */
+static void set_slot_empty(struct slot *s)
+{
+	s-> status &= 0xfe;
+	s->last_addr=0;
+	memset(s->barcode, ' ', sizeof(s->barcode));
+}
+
+static int test_slot_full(struct slot *s)
+{
+	return s->status && 1;
+}
+
+static int slot_insert(struct list_head *head, int element_type, int address)
+{
+	struct slot *s;
+
+	if ((s = zalloc(sizeof(struct slot))) == NULL)
+		return TGTADM_NOMEM;
+
+	s->slot_addr = address;
+	s->element_type = element_type;
+	s->sides = 1;
+	if (element_type == ELEMENT_DATA_TRANSFER)	/* Drive */
+		s->asc = ASC_INITIALIZING_REQUIRED;
+
+	list_add_tail(&s->slot_siblings, head);
+
+	return 0;
+}
+
+/*
+ * If both address & element type specified, check both values,
+ * else just check param that is defined.
+ *
+ * Return NULL if record not found.
+ */
+struct slot *slot_lookup(struct list_head *head, int element_type, int address)
+{
+	struct slot *s;
+
+	list_for_each_entry(s, head, slot_siblings) {
+		if (element_type && address) {
+			if ((s->slot_addr == address) &&
+					(s->element_type == element_type))
+				return s;
+		} else if (element_type) {
+			if (s->element_type == element_type)
+				return s;
+		} else if (address) {
+			if (s->slot_addr == address)
+				return s;
+		}
+	}
+	return NULL;
+}
+
+static void slot_dump(struct list_head *head)
+{
+	struct slot *s;
+
+	list_for_each_entry(s, head, slot_siblings)
+		if (s) {
+			dprintf("Slot %d Information\n", s->slot_addr);
+			dprintf("  Last Addr: %d\n", s->last_addr);
+			dprintf("  Type: %d\n", s->element_type);
+			dprintf("  Barcode: %s\n", s->barcode);
+			dprintf("  TID : %d\n", s->drive_tid);
+			dprintf("  LUN : %d\n", s->drive_lun);
+			dprintf("  ASC/ASCQ : %d\n\n", s->asc);
+		}
+}
+
+/* **************************************
+ * Adding Slots within the SMC device
+ * **************************************/
+static int add_slt(struct scsi_lu *lu, int element_type, int start_addr, int quantity)
+{
+	struct smc_info *smc = lu->smc_p;
+	int ret = TGTADM_INVALID_REQUEST;
+	struct mode *m;
+	struct slot *s;
+	uint16_t *element;
+	int sv_addr;
+	int qnty_save;
+	int i;
+
+	/* Update MODE PAGE 0x1d params */
+	if ((m = mode_page_lookup(&lu->mode_pages, 0x1d)) == NULL) {
+		dprintf("Failed to find Element Address Assignment mode pg\n");
+		return TGTADM_UNKNOWN_ERR;
+	}
+	element = (uint16_t *)m->mode_data;
+
+	if (element_type && start_addr && quantity) {
+		/* Fiddle with element offset.*/
+		switch(element_type) {
+		case ELEMENT_MEDIUM_TRANSPORT:	/* Medium Transport */
+			break;
+		case ELEMENT_MAP:		/* Import/Export Elements */
+			element += 4;
+			break;
+		case ELEMENT_STORAGE:		/* Storage Elements */
+			element += 2;
+			break;
+		case ELEMENT_DATA_TRANSFER:	/* Data Transfer Elements */
+			element += 6;
+			break;
+		default:
+			goto dont_do_slots;
+			break;
+		}
+
+		/* Get existing values */
+		sv_addr = __be16_to_cpu(element[0]);
+		qnty_save  = __be16_to_cpu(element[1]);
+
+		/* Add existing values + passed params to config */
+		if (sv_addr)
+			element[0] =
+				__cpu_to_be16(min_t(int, start_addr, sv_addr));
+		else
+			element[0] = __cpu_to_be16(start_addr);
+		element[1] = __cpu_to_be16(quantity + qnty_save);
+
+		s = slot_lookup(&smc->slots, element_type, start_addr);
+		if (s)	// Opps... Found a slot at this address..
+			goto dont_do_slots;
+
+		ret = TGTADM_SUCCESS;
+		for(i=start_addr; i < (start_addr + quantity); i++)
+			if (slot_insert(&smc->slots, element_type, i))
+				ret = TGTADM_INVALID_REQUEST;
+	}
+
+dont_do_slots:
+	return ret;
+}
+
+/* **************************************
+ * Configuring Slots within the SMC device
+ * **************************************/
+static int config_slot(struct scsi_lu *lu, int element_type,
+		int address, int tid, int lun, char *barcode, int sides)
+{
+	struct smc_info *smc = lu->smc_p;
+	struct mode *m = NULL;
+	struct slot *s = NULL;
+	int ret = TGTADM_INVALID_REQUEST;
+
+	switch(element_type) {
+	case ELEMENT_MEDIUM_TRANSPORT:
+		/* If medium has more than one side, set the 'rotate' bit */
+		m = mode_page_lookup(&lu->mode_pages, 0x1e);
+		if (m) {
+			m->mode_data[0] = (sides > 1) ? 1 : 0;
+			ret = TGTADM_SUCCESS;
+		}
+		break;
+	case ELEMENT_STORAGE:
+	case ELEMENT_MAP:
+		if ((s = slot_lookup(&smc->slots, element_type, address)) == NULL)
+			break;	// Slot not found..
+		strncpy(s->barcode, barcode, sizeof(s->barcode));
+		set_slot_full(s, 0);
+		ret = TGTADM_SUCCESS;
+		break;
+	case ELEMENT_DATA_TRANSFER:
+		if (!tid)
+			break;	/* Fail if no TID specified */
+		if ((s = slot_lookup(&smc->slots, element_type, address)) == NULL)
+			break;	// Slot not found..
+		s->asc  = NO_ADDITIONAL_SENSE;
+		s->drive_tid = tid;
+		s->drive_lun = lun;
+		ret = TGTADM_SUCCESS;
+		break;
+	}
+	return ret;
+}
+
+/* ***********************************
+ * Command argument processing
+ * ***********************************/
+#define ADD	1
+#define CONFIGURE 2
+
+static int smc_lu_config(struct scsi_lu *lu, char *params)
+{
+	struct smc_info *smc = (struct smc_info *)lu->smc_p;
+	int err = 0;
+	char *p;
+	char barcode[20] = "";
+	char buf[20];
+	int operation = 0;
+	int element_type = 0;
+	int start_addr = 0;
+	int quantity = 0;
+	int sides = 1;
+	int address = 0;
+	int tid = 0;
+	int lun = 0;
+	char *smc_params;
+
+	smc_params = malloc(strlen(params) + 1);
+	if (!smc_params)
+		return TGTADM_NOMEM;
+	smc_params[0] = '\0';
+	err = spc_lu_config(lu, params, smc_params);
+
+	if (!strncmp("targetOps", smc_params, 9))
+		smc_params = smc_params + 10;
+
+	while ((p = strsep(&smc_params, ",")) != NULL) {
+		substring_t args[MAX_OPT_ARGS];
+		int token;
+		if (!*p)
+			continue;
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case Opt_element_type:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			element_type = atoi(buf);
+			break;
+		case Opt_start_address:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			start_addr = atoi(buf);
+			operation = ADD;
+			break;
+		case Opt_quantity:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			quantity = atoi(buf);
+			break;
+		case Opt_sides:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sides = atoi(buf);
+			break;
+		case Opt_address:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			address = atoi(buf);
+			operation = CONFIGURE;
+			break;
+		case Opt_barcode:
+			match_strncpy(barcode, &args[0], sizeof(barcode));
+			break;
+		case Opt_tid:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			tid = atoi(buf);
+			break;
+		case Opt_lun:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			lun = atoi(buf);
+			break;
+		case Opt_dump:
+			slot_dump(&smc->slots);
+			break;
+		default:
+			err = TGTADM_UNKNOWN_PARAM;
+		}
+	}
+
+	free(smc_params);
+
+	switch(operation) {
+		case ADD:
+			err = add_slt(lu, element_type, start_addr, quantity);
+			break;
+		case CONFIGURE:
+			err = config_slot(lu, element_type, address, tid,
+							lun, barcode, sides);
+			break;
+	}
+	return err;
+}
+
+/* ***********************************
+ * Device Template - entry routines
+ * ***********************************/
+struct device_type_template smc_template = {
+	.type		= TYPE_MEDIUM_CHANGER,
+	.lu_init	= smc_lu_init,
+	.lu_exit 	= smc_lu_exit,
+	.lu_config	= smc_lu_config,
+	.ops	= {
+		{spc_test_unit,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_request_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		/* 0x10 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_inquiry,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x20 ... 0x4f] = {spc_illegal_op,},
+
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x9f] = {spc_illegal_op,},
+
+		/* 0xA0 */
+		{spc_report_luns,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{smc_move_medium,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_test_unit,},
+
+		/* 0xB0 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{smc_read_element_status,},	// Mandatory
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0xc0 ... 0xff] = {spc_illegal_op},
+	}
+};
+
+__attribute__((constructor)) static void smc_init(void)
+{
+	device_type_register(&smc_template);
+}
diff --git a/usr/smc.h b/usr/smc.h
new file mode 100644
index 0000000..fc37f9d
--- /dev/null
+++ b/usr/smc.h
@@ -0,0 +1,77 @@
+/*
+ * SCSI Medium Changer Command
+ *
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _SMC_H_
+#define _SMC_H_
+
+/**************************************************
+ * Slot description
+ **************************************************/
+#define ELEMENT_ANY		0
+#define	ELEMENT_MEDIUM_TRANSPORT	1
+#define	ELEMENT_STORAGE		2
+#define	ELEMENT_MAP		3
+#define	ELEMENT_DATA_TRANSFER	4
+
+struct slot {
+	struct	list_head	slot_siblings;
+	uint8_t		element_type;	/* Element Type 1, 2, 3 or 4 */
+	uint8_t		cart_type;	/* 0 Unspecified, 1 Data, 2 Cleaning */
+	uint16_t	slot_addr;	/* 65535 slots should be enough.. */
+	uint16_t	last_addr;	/* Where the media came from.. */
+	uint16_t	asc;		/* Additional sense code */
+	uint8_t		status;		/* Used for MAP status bits */
+	uint8_t		sides;		/* Number of sides this media. */
+	char		barcode[11];	/* Up to 10 char barcode */
+	/* Only used if slot contains a drive. */
+	uint8_t		drive_tid;
+	uint8_t		drive_lun;
+};
+
+/**************************************************
+ * Data structure for SMC device
+ * Top of the 'tree'
+ **************************************************/
+struct smc_info {
+	struct	list_head	slots;
+};
+
+enum {
+	Opt_element_type, Opt_start_address,
+	Opt_quantity, Opt_sides,
+	Opt_address, Opt_barcode,
+	Opt_tid, Opt_lun,
+	Opt_type, Opt_dump,
+	Opt_err,
+};
+
+static match_table_t tokens = {
+	{Opt_element_type, "element_type=%s"},
+	{Opt_start_address, "start_address=%s"},
+	{Opt_quantity, "quantity=%s"},
+	{Opt_sides, "sides=%s"},
+	{Opt_address, "address=%s"},
+	{Opt_barcode, "barcode=%s"},
+	{Opt_tid, "tid=%s"},
+	{Opt_lun, "lun=%s"},
+	{Opt_type, "type=%s"},
+	{Opt_dump, "dump=%s"},
+	{Opt_err, NULL},
+};
+#endif // _SMC_H_
diff --git a/usr/spc.c b/usr/spc.c
index 3eb605c..19a0403 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -500,7 +500,19 @@ static match_table_t tokens = {
 	{Opt_err, NULL},
 };
 
-int spc_lu_config(struct scsi_lu *lu, char *params) {
+/*
+ * Parse options received from user.
+ *
+ * User options are in 'char * params', while any unprocessed options
+ * are copied into 'char * ret_param' for further processing by the
+ * 'target' from which it was called.
+ *
+ * Note: It is the callers responsibility to make sure *ret_param has enough
+ * room to store up to "strlen(params) + 1" - In case we can not parse any
+ * params locally.
+ */
+int spc_lu_config(struct scsi_lu *lu, char *params, char *ret_param)
+{
 	int err = 0;
 	char *p;
 	char buf[256];
@@ -551,7 +563,9 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			match_strncpy(buf, &args[0], sizeof(buf));
 			err = add_mode_page(lu, buf);
 			break;
-		default:
+		default:	/* Append any unprocessed args to ret_param */
+			strcat(ret_param, p);
+			strcat(ret_param, ",");
 			err = TGTADM_INVALID_REQUEST;
 		}
 	}
diff --git a/usr/spc.h b/usr/spc.h
index c7e38c0..559a14e 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -16,7 +16,7 @@ extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
 extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
 extern int spc_lu_init(struct scsi_lu *lu);
-extern int spc_lu_config(struct scsi_lu *lu, char * params);
+extern int spc_lu_config(struct scsi_lu *lu, char *params, char *ret_params);
 extern void dump_cdb(struct scsi_cmd *cmd);
 extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
 struct mode *mode_page_lookup(struct list_head *head, uint8_t page);
diff --git a/usr/tgtadm.c b/usr/tgtadm.c
index c2315b6..0631a7d 100644
--- a/usr/tgtadm.c
+++ b/usr/tgtadm.c
@@ -300,6 +300,8 @@ static int str_to_device_type(char *str)
 		exit(EINVAL);
 	} else if (!strcmp(str, "cd"))
 		return TYPE_ROM;
+	else if (!strcmp(str, "changer"))
+		return TYPE_MEDIUM_CHANGER;
 	else if (!strcmp(str, "osd"))
 		return TYPE_OSD;
 	else if (!strcmp(str, "pt"))
diff --git a/usr/tgtd.h b/usr/tgtd.h
index bbacae2..271b260 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -100,8 +100,11 @@ struct scsi_lu {
 	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
 	struct list_head mode_pages;
 
-	/* TODO: needs a structure for lots of device parameters */
 	struct lu_phy_attr attrs;
+
+	/* TODO: needs a structure for lots of device parameters */
+	/* Currently only used by smc module */
+	void *smc_p;
 };
 
 struct scsi_cmd {
-- 
1.5.2.1






From hare at suse.de  Mon Jun 25 09:23:39 2007
From: hare at suse.de (Hannes Reinecke)
Date: Mon, 25 Jun 2007 09:23:39 +0200
Subject: [Stgt-devel] Some remarks on current git version
In-Reply-To: <467CADDE.6020900@gmail.com>
References: <467C1DA2.8090106@gmail.com>	<200706230126.l5N1QOIr031221@mbox.iij4u.or.jp>
	<467CADDE.6020900@gmail.com>
Message-ID: <467F6D7B.3090201@suse.de>

Albert Pauw wrote:
> FUJITA Tomonori wrote:
>> From: Albert Pauw <albert.pauw at gmail.com>
>> Subject: [Stgt-devel] Some remarks on current git version
>> Date: Fri, 22 Jun 2007 21:06:10 +0200
>>
>>   
>>> Here are a few loose ends, some of which are very simple, some are remarks:
>>>
>>> - ssc.c uses the word Controler, should be Controller, just a typo (yes, 
>>> I am just being picky).
>>>     
>> Thanks, fixed.
>>
>>
>>   
>>> - when configuring just a disk target I still get harrassed by this Lun 
>>> 0 Controller,
>>>   I understand you need one when you are doing vtl, but there should be 
>>> a way to get rid of it when not needed.
>>>     
>> Only if the current code doesn't work, we should implement a feature
>> to remove I want to keep the code simple.
>>
>>
>>   
>>> - I am not able to define a cdrom anymore (using an cd iso as backing 
>>> store),  --device-type cdrom doesn't work.
>>>     
>> Try Mark's way. It should work. Patches to improve the manpage and
>> documents are welcome.
>>   
> Thanks Mark and Fujita,
> 
> using "cd" works fine, tried other descriptions but not this one.
> 
> I guess I have to live with the conroller, I am ok with it, as long as 
> it doesn't bite :-)
> 
There is actually an easy way around this: 
Allow the LUN0 default LUN to be overwritten by later configuration.
This way we'll have the default LUN only if not configured (ie avoid the
lun==0 checks) but we have the highest flexibility.
And it'll work with existing setups.

Cheers,

Hannes
-- 
Dr. Hannes Reinecke		      zSeries & Storage
hare at suse.de			      +49 911 74053 688
SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
GF: Markus Rex, HRB 16746 (AG N?rnberg)


From albert.pauw at gmail.com  Mon Jun 25 10:41:12 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Mon, 25 Jun 2007 10:41:12 +0200
Subject: [Stgt-devel] Some remarks on current git version
In-Reply-To: <467F6D7B.3090201@suse.de>
References: <467C1DA2.8090106@gmail.com>
	<200706230126.l5N1QOIr031221@mbox.iij4u.or.jp>
	<467CADDE.6020900@gmail.com> <467F6D7B.3090201@suse.de>
Message-ID: <b2919bc20706250141m20ceeff5o68c92e45ea6b28b0@mail.gmail.com>

That's the thing I tried (redefine LUN 0) but for the moment that doesn't
work.
But it sounds like a good compromise to me.

I'm all for it.

Albert

On 6/25/07, Hannes Reinecke <hare at suse.de> wrote:
>
> Albert Pauw wrote:
> > FUJITA Tomonori wrote:
> >> From: Albert Pauw <albert.pauw at gmail.com>
> >> Subject: [Stgt-devel] Some remarks on current git version
> >> Date: Fri, 22 Jun 2007 21:06:10 +0200
> >>
> >>
> >>> Here are a few loose ends, some of which are very simple, some are
> remarks:
> >>>
> >>> - ssc.c uses the word Controler, should be Controller, just a typo
> (yes,
> >>> I am just being picky).
> >>>
> >> Thanks, fixed.
> >>
> >>
> >>
> >>> - when configuring just a disk target I still get harrassed by this
> Lun
> >>> 0 Controller,
> >>>   I understand you need one when you are doing vtl, but there should
> be
> >>> a way to get rid of it when not needed.
> >>>
> >> Only if the current code doesn't work, we should implement a feature
> >> to remove I want to keep the code simple.
> >>
> >>
> >>
> >>> - I am not able to define a cdrom anymore (using an cd iso as backing
> >>> store),  --device-type cdrom doesn't work.
> >>>
> >> Try Mark's way. It should work. Patches to improve the manpage and
> >> documents are welcome.
> >>
> > Thanks Mark and Fujita,
> >
> > using "cd" works fine, tried other descriptions but not this one.
> >
> > I guess I have to live with the conroller, I am ok with it, as long as
> > it doesn't bite :-)
> >
> There is actually an easy way around this:
> Allow the LUN0 default LUN to be overwritten by later configuration.
> This way we'll have the default LUN only if not configured (ie avoid the
> lun==0 checks) but we have the highest flexibility.
> And it'll work with existing setups.
>
> Cheers,
>
> Hannes
> --
> Dr. Hannes Reinecke                   zSeries & Storage
> hare at suse.de                          +49 911 74053 688
> SUSE LINUX Products GmbH, Maxfeldstr. 5, 90409 N?rnberg
> GF: Markus Rex, HRB 16746 (AG N?rnberg)
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070625/5bbcb929/attachment.html>

From mark_harvey at symantec.com  Tue Jun 26 01:23:07 2007
From: mark_harvey at symantec.com (Mark Harvey)
Date: Mon, 25 Jun 2007 16:23:07 -0700
Subject: [Stgt-devel] [Patch 3/3] Re-work of SMC support
In-Reply-To: <467CD64C.9060606@gmail.com>
References: <467CD64C.9060606@gmail.com>
Message-ID: <B3E98EAC5926D5498DDD341AE4B7D21C016E9074@TUS1XCHCLUPIN06.enterprise.veritas.com>

Darn,

A typo in patch description:
"Includes all SCSI op codes defined in SSC as MANDATORY."
Should read:
"Includes all SCSI op codes defined in SMC as MANDATORY."

Regards
Mark

-----Original Message-----
From: stgt-devel-bounces at lists.berlios.de
[mailto:stgt-devel-bounces at lists.berlios.de] On Behalf Of Mark Harvey
Sent: Saturday, 23 June 2007 6:14 PM
To: stgt-devel at lists.berlios.de
Subject: [Stgt-devel] [Patch 3/3] Re-work of SMC support

>From 921b883ce4bb5f015d9d950c2f9b7e4fc89b1ba6 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Sat, 23 Jun 2007 17:34:03 +1000
Subject: Initial commit of SMC module.

Includes all SCSI op codes defined in SSC as MANDATORY.

As yet, does not contain any way of signaling the DATA TRANSFER DEVICE
a piece of medium has been moved / loaded.

doc/README.lu_configuration updated with SMC specific options.

scripts/tgt-core-test updated to create an SMC device as well.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 doc/README.lu_configuration |   43 +++
 scripts/tgt-core-test       |   96 +++++-
 usr/Makefile                |    5 +-
 usr/media.h                 |   30 ++
 usr/mmc.c                   |   19 +-
 usr/osd.c                   |   18 +
 usr/sbc.c                   |   19 +-
 usr/scc.c                   |   18 +-
 usr/smc.c                   |  811
+++++++++++++++++++++++++++++++++++++++++++
 usr/smc.h                   |   77 ++++
 usr/spc.c                   |   18 +-
 usr/spc.h                   |    2 +-
 usr/tgtadm.c                |    2 +
 usr/tgtd.h                  |    5 +-
 14 files changed, 1143 insertions(+), 20 deletions(-)
 create mode 100644 usr/media.h
 create mode 100644 usr/smc.c
 create mode 100644 usr/smc.h

diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
index d63668a..47e4912 100644
--- a/doc/README.lu_configuration
+++ b/doc/README.lu_configuration
@@ -84,6 +84,49 @@ tgtadm --lld iscsi --mode logicalunit --op update
--tid 1 --lun 2 \
          --params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 
 
+SMC unique options
+------------------
+
+--params have several unique key=value pairs ontop of all other
modules.
+ - element_type=<1|2|3|4>
+ - start_address=Number between 1 & 65535
+ - quantity=Number between 1 & 65535
+ - sides=1|2
+ - address=Number between 1 & 65535
+ - barcode="Char string up to 10 chars"
+ - tid=<number>
+ - lun=<number>
+
+Several of these parameters 'work together'
+
+e.g. To add 'quantity' slots as 'element_type' starting at
'start_address'
+ - element_type=<1|2|3|4>
+ - start_address=Number between 1 & 65535
+ - quantity=Number between 1 & 65535
+
+Note: start_address + quantity should not overlap with any other
slots..
+
+
+While 'configuring slot 'address' of 'element_type':
+ - Set barcode of meda (occupy slot)
+ - If element type is DATA TRANSFER DEVICE, then define TID & LUN of
device.
+
+ - element_type=<1|2|3|4>
+ - address=Number between 1 & 65535
+ - barcode="String up to 10 chars"
+ - sides=<1|2>
+ - tid=<tid of device which belongs at this address>
+ - lun=<lun of device which belongs at this address>
+
+
+It is the responsibility of the user not to configure overlapping slots
+of differing types.
+
+Slot types:
+ 1 -> Medium Transport (picker arm)
+ 2 -> Storage Element
+ 3 -> Import/Export Element
+ 4 -> Data Transfer device (CD drive, tape drive, MO drive etc)
 
 Please refer to scripts/tgt-core-test for a working example.
 
diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
index dce8d3c..bd168dc 100755
--- a/scripts/tgt-core-test
+++ b/scripts/tgt-core-test
@@ -17,15 +17,6 @@ fi
 if [ ! -f $HOME/hd_block ]; then
 	dd if=/dev/zero of=$HOME/hd_block bs=1M count=8
 fi
-if [ ! -f $HOME/cd_block0 ]; then
-	dd if=/dev/zero of=$HOME/cd_block0 bs=1M count=8
-fi
-if [ ! -f $HOME/cd_block1 ]; then
-	dd if=/dev/zero of=$HOME/cd_block1 bs=1M count=8
-fi
-if [ ! -f $HOME/cd_block2 ]; then
-	dd if=/dev/zero of=$HOME/cd_block2 bs=1M count=8
-fi
 
 set -x
 
@@ -85,10 +76,13 @@ tgtadm --lld iscsi --mode logicalunit --op update
--tid $TID --lun $LUN \
 	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 
 
-
 for LUN in 2 3 4; do
+	if [ ! -f $HOME/cdrom$LUN ]; then
+		dd if=/dev/zero of=$HOME/cdrom$LUN bs=1M count=8
+	fi
+
 	# Create LUN - CD/ROM
-	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun
$LUN -b $HOME/cd_block0 --device-type=cd
+	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun
$LUN -b $HOME/cdrom$LUN --device-type=cd
 	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID
--lun $LUN \
 		--params
vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY1$LUN
,removable=1
 	# Vendor Uniq - Mode page 0..
@@ -102,6 +96,86 @@ for LUN in 2 3 4; do
 		--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 done
 
+#######################################################################
########
+# Set up SMC Medium Changer
+#######################################################################
########
+LUN=5
+if [ ! -f $HOME/smc ]; then
+	dd if=/dev/zero of=$HOME/smc bs=1k count=1
+fi
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN \
+			-b $HOME/smc --device-type=changer
+
+#### Set up mode pages ####
+# From smc3-06.pdf
+# Page 0x02: Disconnect/Reconnect SPC-3
+# Page 0x0a: Control SPC-3
+# Page 0x18: Protocol Specific LUN SPC-3
+# Page 0x19: Protocol Specific Port SPC-3
+# Page 0x1a: Power Condition SPC-3
+# Page 0x1c: Informational Exceptions Control SPC-3
+# Page 0x1d: Element Address Assignment SMC-3 7.3.4
+# Page 0x1e: Transport Geometry Parameters SMC-3 7.3.5
+# Page 0x1f: Device Capabilities SMC-3 7.3.2
+# Page 0x1f/Subpage 0x41: Extended Device Capabilities SMC-3 7.3.3
+
+# Dummy 'page 0'
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params mode_page=0:0:0
+# Disconnect/Reconnect
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+# Power Condition
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params mode_page=0x1a:0:18:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
+# Informational Exceptions Control Mode Page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+# Element Address Assignment - Setup afterwards.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params
mode_page=0x1d:0:0x12:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
+# Transport Geometry Parameters
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params mode_page=0x1e:0:2:0:0
+# Device Capabilities
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params
mode_page=0x1f:0:0x12:0x0f:7:0x0f:0x0f:0x0f:0x0f:0:0:0:0:0x0f:0x0f:0x0f:
0x0f:0:0:0:0
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params
vendor_id=STK,product_id=L700,product_rev=0010,scsi_sn=XYZZY_0,removable
=1
+
+
+## Add Data Transfer devices (3 drives)
+# Define slot address for devices.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params element_type=4,start_address=1,quantity=3
+# Now define which device at each address.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params element_type=4,address=1,tid=1,lun=2
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params element_type=4,address=2,tid=1,lun=3
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params element_type=4,address=3,tid=1,lun=4
+
+# Medium Transport Elements (robot arm / picker)
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params element_type=1,start_address=16,quantity=1
+
+## Storage Elements - 8 starting at addr 1024
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params element_type=2,start_address=1024,quantity=8
+# Add 'media' to slots
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params element_type=2,address=1024,barcode=ABC123,Sides=1
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params element_type=2,address=1026,barcode=ULT001L3,Sides=1
+
+# Import/Export Elements - 5 starting at addr 32
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN
\
+	--params element_type=3,start_address=32,quantity=5
+
+
 # Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
 
diff --git a/usr/Makefile b/usr/Makefile
index 14be34b..c7fb2ca 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -43,8 +43,9 @@ INCLUDES += -I.
 CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE
$(INCLUDES)
 
 PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o osd.o spt.o scc.o
scsi.o log.o \
-	driver.o util.o work.o parser.o
+TGTD_OBJS += tgtd.o mgmt.o target.o \
+	spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o \
+	scsi.o log.o driver.o util.o work.o parser.o
 
 all: $(PROGRAMS)
 
diff --git a/usr/media.h b/usr/media.h
new file mode 100644
index 0000000..a04a27c
--- /dev/null
+++ b/usr/media.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef _MEDIA_H_
+#define _MEDIA_H_
+
+enum c_type {	/* Cartridge Types - Ref: smc3r06 - Table 20, page 37 */
+	CART_UNSPECIFIED,
+	CART_DATA,
+	CART_CLEAN,
+	CART_DIAGNOSTICS,
+	CART_WORM,
+	CART_MICROCODE,
+};
+
+#endif /* _MEDIA_H_ */
+
diff --git a/usr/mmc.c b/usr/mmc.c
index 891cb60..0672877 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -38,6 +38,7 @@
 #include "util.h"
 #include "tgtd.h"
 #include "target.h"
+#include "tgtadm_error.h"
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
@@ -174,10 +175,26 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+static int mmc_lu_config(struct scsi_lu *lu, char * params)
+{
+	char	* mmc_params;
+	int	ret;
+
+	mmc_params = malloc(strlen(params) + 1);
+	if (!mmc_params)
+		return -ENOMEM;
+	mmc_params[0] = '\0';
+	ret = spc_lu_config(lu, params, mmc_params);
+	if (strlen(mmc_params))	/* We should not have any params left
over */
+		ret = TGTADM_INVALID_REQUEST;
+	free(mmc_params);
+	return ret;
+}
+
 static struct device_type_template mmc_template = {
 	.type		= TYPE_ROM,
 	.lu_init	= mmc_lu_init,
-	.lu_config	= spc_lu_config,
+	.lu_config	= mmc_lu_config,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/osd.c b/usr/osd.c
index a48db32..2574086 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -29,6 +29,7 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "tgtadm_error.h"
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
@@ -68,9 +69,26 @@ static int osd_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+static int osd_lu_config(struct scsi_lu *lu, char * params)
+{
+	char	* osd_params;
+	int	ret;
+
+	osd_params = malloc(strlen(params) + 1);
+	if (!osd_params)
+		return -ENOMEM;
+	osd_params[0] = '\0';
+	ret = spc_lu_config(lu, params, osd_params);
+	if (strlen(osd_params))	/* We should not have any params left
over */
+		ret = TGTADM_INVALID_REQUEST;
+	free(osd_params);
+	return ret;
+}
+
 static struct device_type_template osd_template = {
 	.type		= TYPE_OSD,
 	.lu_init	= osd_lu_init,
+	.lu_config	= osd_lu_config,
 	.ops		= {
 		[0x00 ... 0x0f] = {spc_illegal_op},
 
diff --git a/usr/sbc.c b/usr/sbc.c
index 5996081..739f25c 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -34,6 +34,7 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "tgtadm_error.h"
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
@@ -222,10 +223,26 @@ static int sbc_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+static int sbc_lu_config(struct scsi_lu *lu, char *params)
+{
+	char *sbc_params;
+	int ret;
+
+	sbc_params = malloc(strlen(params) + 1);
+	if (!sbc_params)
+		return TGTADM_NOMEM;
+	sbc_params[0] = '\0';
+	ret = spc_lu_config(lu, params, sbc_params);
+	if (strlen(sbc_params))	/* We should not have any params left
over */
+		ret = TGTADM_INVALID_REQUEST;
+	free(sbc_params);
+	return ret;
+}
+
 static struct device_type_template sbc_template = {
 	.type		= TYPE_DISK,
 	.lu_init	= sbc_lu_init,
-	.lu_config	= spc_lu_config,
+	.lu_config	= sbc_lu_config,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/scc.c b/usr/scc.c
index 28cd813..38d892e 100644
--- a/usr/scc.c
+++ b/usr/scc.c
@@ -50,10 +50,26 @@ static int scc_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+static int scc_lu_config(struct scsi_lu *lu, char *params)
+{
+	char *scc_params;
+	int ret;
+
+	scc_params = malloc(strlen(params) + 1);
+	if (!scc_params)
+		return TGTADM_NOMEM;
+	scc_params[0] = '\0';
+	ret = spc_lu_config(lu, params, scc_params);
+	if (strlen(scc_params))	/* We should not have any params left
over */
+		ret = TGTADM_INVALID_REQUEST;
+	free(scc_params);
+	return ret;
+}
+
 static struct device_type_template scc_template = {
 	.type		= TYPE_RAID,
 	.lu_init	= scc_lu_init,
-	.lu_config	= spc_lu_config,
+	.lu_config	= scc_lu_config,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/smc.c b/usr/smc.c
new file mode 100644
index 0000000..c94be41
--- /dev/null
+++ b/usr/smc.c
@@ -0,0 +1,811 @@
+/*
+ * SCSI Medium Changer command processing
+ * Based on smc3r06.pdf document from t10.org
+ *
+ * (C) 2004-2007 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
+ * (C) 2007      Mark Harvey <markh794 at gmail.com>
+ *
+ * SCSI target emulation code is based on Ardis's iSCSI implementation.
+ *   http://www.ardistech.com/iscsi/
+ *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
+ *   licensed under the terms of the GNU GPL v2.0,
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <linux/fs.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "driver.h"
+#include "tgtadm_error.h"
+#include "scsi.h"
+#include "spc.h"
+#include "sense_codes.h"
+#include "parser.h"
+#include "smc.h"
+#include "media.h"
+
+struct slot *slot_lookup(struct list_head *head, int element_type, int
address);
+static void set_slot_full(struct slot *s, uint16_t src);
+static void set_slot_empty(struct slot *s);
+static int test_slot_full(struct slot *s);
+
+/* ********************************************************
+ * READ_ELEMENT_STATUS
+ *
+ * Ref: Working Draft SCSI Media Changer-3 (smc3r06.pdf), chapter 6.10
+ *
+ * The READ ELEMENT STATUS command request that the device server
report the
+ * status of its internal elements to the application client.
+ * Support for READ ELEMENT STATUS command is mandatory.
+ * ******************************************************** */
+static int determine_element_sz(uint8_t dvcid, uint8_t vol_tag)
+{
+	if (vol_tag)
+		return (dvcid) ? 86 : 52;
+	else
+		return (dvcid) ? 50 : 16;
+}
+
+/* Fill in Element Status Header - Always 8 bytes long */
+static int element_status_data_hdr(uint8_t *data, uint8_t dvcid,
+					uint8_t vol_tag, int start, int
count)
+{
+	int element_sz;
+	int size;
+
+	element_sz = determine_element_sz(dvcid, vol_tag);
+
+	/* First Element address reported */
+	*(uint16_t *)(data) = __cpu_to_be16(start);
+
+	/* Number of elements available */
+	*(uint16_t *)(data + 2) = __cpu_to_be16(count);
+
+	/* Byte count is the length required to return all valid data.
+	 * Allocated length is how much data the initiator will accept
*/
+	size = ((8 + (count * element_sz)) & 0xffffff);
+	*(uint32_t *)(data + 4) = __cpu_to_be32(size);
+
+return size;
+}
+
+static int add_element_descriptor(uint8_t *data, struct slot *s,
+			uint8_t element_type, uint8_t dvcid, uint8_t
vol_tag)
+{
+	int ret = determine_element_sz(dvcid, vol_tag);
+
+	*(uint16_t *)(data) = __cpu_to_be16(s->slot_addr);
+	data[2] = s->status;
+	data[3] = 0;	/* Reserved */
+	data[4] = (s->asc >> 8) & 0xff;	/* Additional Sense Code */
+	data[5] = s->asc & 0xff;	/* Additional Sense Code
Qualifier */
+	/* [6], [7] & [8] reserved */
+	data[9] = (s->cart_type & 0xf);
+	if (s->last_addr) {	/* Source address is valid ? */
+		data[9] |= 0x80;
+		*(uint16_t *)(data + 10) = __cpu_to_be16(s->last_addr);
+	}
+	if (vol_tag) {
+		if (s->barcode[0] == ' ')
+			memset( &data[12], 0x20, 32); /* Pad with spaces
*/
+		else
+			snprintf((char *)&data[12], 32, "%-32s",
s->barcode);
+	}
+
+return ret;
+}
+
+/* Fill in Element details
+ *
+ * Fill each Element Descriptor for slot *s
+ *
+ * data : pointer
+ * head : Slot struct head
+ * element_type : Slot type we are interested in.
+ * first : Return address of first slot found
+ * start : Start processing from this element #
+ * dvcid : Device ID
+ * vol_tag : Volume tag (barcode)
+ *
+ * Return number of elements
+ */
+static int build_element_descriptors(uint8_t *data, struct list_head
*head,
+					uint8_t elem_type, int *first,
+					uint16_t start,
+					uint8_t dvcid, uint8_t vol_tag)
+{
+	struct slot *s;
+	int count = 0;
+	int len = 0;
+	int elem_sz = determine_element_sz(dvcid, vol_tag);
+
+	list_for_each_entry(s, head, slot_siblings) {
+		if (s->element_type == elem_type) {
+			if (s->slot_addr >= start) {
+				count++;
+				len +=
add_element_descriptor(&data[8+len],
+						s, elem_type, dvcid,
vol_tag);
+			}
+		}
+		if (count == 1)	/* Record first found slot Address */
+			*first = s->slot_addr;
+	}
+
+	/* Fill in Element Status Page Header */
+	data[0] = elem_type;
+	data[1] = (vol_tag) ? 0x80 : 0;	/* Primary Vol Tag set */
+	*(uint16_t *)(data + 2) = __cpu_to_be16(elem_sz);
+
+	/* Total number of bytes in all element descriptors */
+	*(uint32_t *)(data + 4) = __cpu_to_be32((elem_sz * count) &
0xffffff);
+
+return count;
+}
+
+/* *********************************************
+ * READ ELEMENT STATUS op code
+ * ********************************************* */
+static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
+{
+	struct smc_info *smc = (struct smc_info *)cmd->dev->smc_p;
+	uint8_t *data;
+	uint8_t *scb;
+	uint8_t element_type;
+	uint8_t vol_tag;
+	uint16_t req_start_elem;
+//	FIXME: Take into account number of slots requested..
+//	uint16_t	number = __be16_to_cpu(*(uint16_t *)(scb[4]));
+	uint8_t dvcid;		/* Device ID */
+	uint32_t alloc_len;
+	uint16_t count = 0;
+	int first = 0;		/* First valid slot location */
+	int len = 8;
+	int elementSize;
+	int ret;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+
+	scb = cmd->scb;
+	element_type = scb[1] & 0x0f;
+	vol_tag	= (scb[1] & 0x10) >> 4;
+	dvcid = scb[6] & 0x01;
+	req_start_elem = __be16_to_cpu(*(uint16_t *)(scb + 2));
+	alloc_len = 0xffffff & __be32_to_cpu(*(uint32_t *)(scb + 6));
+
+	elementSize = determine_element_sz(dvcid, vol_tag);
+
+	cmd->len = 0;
+	if (cmd->dev) {
+		ret = device_reserved(cmd);
+		if (ret) {
+			dprintf("Reservation Conflict\n");
+			return SAM_STAT_RESERVATION_CONFLICT;
+		}
+	}
+
+	if (pagesize < alloc_len) {
+		dprintf("Can't allocate enough memory for cmd\n");
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	if ((data = valloc(pagesize)) == NULL) {
+		dprintf("valloc(%lu) failed\n", pagesize);
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	if (scb[11])	/* Reserved byte */
+		goto sense;
+
+	switch(element_type) {
+	case ELEMENT_ANY:
+		/* Return element in type order */
+		count = build_element_descriptors(&data[len],
&smc->slots,
+					ELEMENT_MEDIUM_TRANSPORT,
&first,
+					req_start_elem,
+					dvcid, vol_tag);
+		len = count * elementSize;
+		count += build_element_descriptors(&data[len],
&smc->slots,
+					ELEMENT_STORAGE, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		len += count * elementSize;
+		count += build_element_descriptors(&data[len],
&smc->slots,
+					ELEMENT_MAP, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		len += count * elementSize;
+		count += build_element_descriptors(&data[len],
&smc->slots,
+					ELEMENT_DATA_TRANSFER, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		break;
+	case ELEMENT_MEDIUM_TRANSPORT:
+		count = build_element_descriptors(&data[len],
&smc->slots,
+					ELEMENT_MEDIUM_TRANSPORT,
&first,
+					req_start_elem,
+					dvcid, vol_tag);
+		break;
+	case ELEMENT_STORAGE:
+		count = build_element_descriptors(&data[len],
&smc->slots,
+					ELEMENT_STORAGE, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		break;
+	case ELEMENT_MAP:
+		count = build_element_descriptors(&data[len],
&smc->slots,
+					ELEMENT_MAP, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		break;
+	case ELEMENT_DATA_TRANSFER:
+		count = build_element_descriptors(&data[len],
&smc->slots,
+					ELEMENT_DATA_TRANSFER, &first,
+					req_start_elem,
+					dvcid, vol_tag);
+		break;
+	default:
+		goto sense;
+		break;
+	}
+
+	/* Lastly, fill in data header */
+	len = element_status_data_hdr(data, dvcid, vol_tag, first,
count);
+
+	cmd->len = min_t(int, len, alloc_len);
+	cmd->uaddr = (unsigned long) data;
+	cmd->rw = READ;
+
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+/* *********************************************
+ * MOVE MEDIUM op code
+ * ********************************************* */
+static int smc_move_medium(int host_no, struct scsi_cmd *cmd)
+{
+	struct smc_info *smc = (struct smc_info *)cmd->dev->smc_p;
+	uint8_t *scb;
+	uint16_t src;
+	uint16_t dest;
+	uint8_t invert;
+	struct slot *src_slot = NULL;
+	struct slot *dest_slot = NULL;
+	struct slot *s;
+	int key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+
+	scb = cmd->scb;
+	src = __be16_to_cpu(*(uint16_t *)(scb + 4));
+	dest = __be16_to_cpu(*(uint16_t *)(scb + 6));
+	invert = scb[10] & 1;
+
+	list_for_each_entry(s, &smc->slots, slot_siblings) {
+		if (s->slot_addr == src)
+			src_slot = s;
+		if (s->slot_addr == dest)
+			dest_slot = s;
+	}
+
+	if (src_slot) {
+		if (!test_slot_full(src_slot)) {
+			asc = ASC_MEDIUM_SRC_EMPTY;
+			goto sense;
+		}
+	} else	/* Could not find src slot - Error */
+		goto sense;
+
+	if (dest_slot) {
+		if (test_slot_full(dest_slot)) {
+			asc = ASC_MEDIUM_DEST_FULL;
+			goto sense;
+		}
+	} else	/* Could not find dest slot - Error */
+		goto sense;
+
+	if (invert)
+		if (s->sides == 1)	/* Use default INVALID FIELD IN
CDB */
+			goto sense;
+
+	memcpy(&dest_slot->barcode, &src_slot->barcode,
sizeof(s->barcode));
+	set_slot_empty(src_slot);
+	set_slot_full(dest_slot, src);
+	cmd->len = 0;
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+/* *********************************************
+ * ****       House keeping routines        ****
+ * ********************************************* */
+
+/* Any housekeeping required at logical unit setup */
+static int smc_lu_init(struct scsi_lu *lu)
+{
+	struct smc_info *smc;
+
+	smc = zalloc(sizeof(struct smc_info));
+	if (smc)
+		lu->smc_p = smc;
+	else
+		return -ENOMEM;
+
+	spc_lu_init(lu);
+
+	strncpy(lu->attrs.product_id, "VIRTUAL-CHANGER",
+
sizeof(lu->attrs.product_id));
+	lu->attrs.version_desc[0] = 0x0480; /* SMC-3 no version claimed
*/
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
+
+	INIT_LIST_HEAD(&lu->mode_pages);
+
+	/* Vendor uniq - However most apps seem to call for mode page
0*/
+	add_mode_page(lu, "0:0:0");
+	/* Control page */
+	add_mode_page(lu, "10:0:10:2:0:0:0:0:0:0:0:2:0");
+	/* Power Condition */
+	add_mode_page(lu, "0x1a:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Informational Exceptions Control page */
+	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Address Assignment */
+	add_mode_page(lu,
"0x1d:0:0x12:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0");
+	/* Transport Geometry Params */
+	add_mode_page(lu, "0x1e:0:2:0:0");
+	/* Device Capabilities */
+	add_mode_page(lu,
"0x1f:0:0x12:15:7:15:15:15:15:0:0:0:0:15:15:15:15:0:0:0:0");
+
+	INIT_LIST_HEAD(&smc->slots);
+
+	lu->attrs.online = 1;	/* Library will now report as Online */
+	lu->attrs.reset = 1;	/* Poweron/reset occurred */
+	lu->attrs.removable = 1; /* Default to removable media */
+
+	return 0;
+}
+
+/* Any housekeeping required at shutdown */
+static void smc_lu_exit(struct scsi_lu *lu)
+{
+	struct smc_info *smc = lu->smc_p;
+
+	dprintf("Medium Changer shutdown() called\n");
+
+	free(smc);
+}
+
+/* **************************************
+ * General utilities related to slot(s)
+ * **************************************/
+/* Set slot status to full */
+static void set_slot_full(struct slot *s, uint16_t src)
+{
+	s->status |= 1;
+	s->last_addr=src;
+}
+
+/* Set slot status to empty */
+static void set_slot_empty(struct slot *s)
+{
+	s-> status &= 0xfe;
+	s->last_addr=0;
+	memset(s->barcode, ' ', sizeof(s->barcode));
+}
+
+static int test_slot_full(struct slot *s)
+{
+	return s->status && 1;
+}
+
+static int slot_insert(struct list_head *head, int element_type, int
address)
+{
+	struct slot *s;
+
+	if ((s = zalloc(sizeof(struct slot))) == NULL)
+		return TGTADM_NOMEM;
+
+	s->slot_addr = address;
+	s->element_type = element_type;
+	s->sides = 1;
+	if (element_type == ELEMENT_DATA_TRANSFER)	/* Drive */
+		s->asc = ASC_INITIALIZING_REQUIRED;
+
+	list_add_tail(&s->slot_siblings, head);
+
+	return 0;
+}
+
+/*
+ * If both address & element type specified, check both values,
+ * else just check param that is defined.
+ *
+ * Return NULL if record not found.
+ */
+struct slot *slot_lookup(struct list_head *head, int element_type, int
address)
+{
+	struct slot *s;
+
+	list_for_each_entry(s, head, slot_siblings) {
+		if (element_type && address) {
+			if ((s->slot_addr == address) &&
+					(s->element_type ==
element_type))
+				return s;
+		} else if (element_type) {
+			if (s->element_type == element_type)
+				return s;
+		} else if (address) {
+			if (s->slot_addr == address)
+				return s;
+		}
+	}
+	return NULL;
+}
+
+static void slot_dump(struct list_head *head)
+{
+	struct slot *s;
+
+	list_for_each_entry(s, head, slot_siblings)
+		if (s) {
+			dprintf("Slot %d Information\n", s->slot_addr);
+			dprintf("  Last Addr: %d\n", s->last_addr);
+			dprintf("  Type: %d\n", s->element_type);
+			dprintf("  Barcode: %s\n", s->barcode);
+			dprintf("  TID : %d\n", s->drive_tid);
+			dprintf("  LUN : %d\n", s->drive_lun);
+			dprintf("  ASC/ASCQ : %d\n\n", s->asc);
+		}
+}
+
+/* **************************************
+ * Adding Slots within the SMC device
+ * **************************************/
+static int add_slt(struct scsi_lu *lu, int element_type, int
start_addr, int quantity)
+{
+	struct smc_info *smc = lu->smc_p;
+	int ret = TGTADM_INVALID_REQUEST;
+	struct mode *m;
+	struct slot *s;
+	uint16_t *element;
+	int sv_addr;
+	int qnty_save;
+	int i;
+
+	/* Update MODE PAGE 0x1d params */
+	if ((m = mode_page_lookup(&lu->mode_pages, 0x1d)) == NULL) {
+		dprintf("Failed to find Element Address Assignment mode
pg\n");
+		return TGTADM_UNKNOWN_ERR;
+	}
+	element = (uint16_t *)m->mode_data;
+
+	if (element_type && start_addr && quantity) {
+		/* Fiddle with element offset.*/
+		switch(element_type) {
+		case ELEMENT_MEDIUM_TRANSPORT:	/* Medium Transport */
+			break;
+		case ELEMENT_MAP:		/* Import/Export
Elements */
+			element += 4;
+			break;
+		case ELEMENT_STORAGE:		/* Storage Elements */
+			element += 2;
+			break;
+		case ELEMENT_DATA_TRANSFER:	/* Data Transfer
Elements */
+			element += 6;
+			break;
+		default:
+			goto dont_do_slots;
+			break;
+		}
+
+		/* Get existing values */
+		sv_addr = __be16_to_cpu(element[0]);
+		qnty_save  = __be16_to_cpu(element[1]);
+
+		/* Add existing values + passed params to config */
+		if (sv_addr)
+			element[0] =
+				__cpu_to_be16(min_t(int, start_addr,
sv_addr));
+		else
+			element[0] = __cpu_to_be16(start_addr);
+		element[1] = __cpu_to_be16(quantity + qnty_save);
+
+		s = slot_lookup(&smc->slots, element_type, start_addr);
+		if (s)	// Opps... Found a slot at this address..
+			goto dont_do_slots;
+
+		ret = TGTADM_SUCCESS;
+		for(i=start_addr; i < (start_addr + quantity); i++)
+			if (slot_insert(&smc->slots, element_type, i))
+				ret = TGTADM_INVALID_REQUEST;
+	}
+
+dont_do_slots:
+	return ret;
+}
+
+/* **************************************
+ * Configuring Slots within the SMC device
+ * **************************************/
+static int config_slot(struct scsi_lu *lu, int element_type,
+		int address, int tid, int lun, char *barcode, int sides)
+{
+	struct smc_info *smc = lu->smc_p;
+	struct mode *m = NULL;
+	struct slot *s = NULL;
+	int ret = TGTADM_INVALID_REQUEST;
+
+	switch(element_type) {
+	case ELEMENT_MEDIUM_TRANSPORT:
+		/* If medium has more than one side, set the 'rotate'
bit */
+		m = mode_page_lookup(&lu->mode_pages, 0x1e);
+		if (m) {
+			m->mode_data[0] = (sides > 1) ? 1 : 0;
+			ret = TGTADM_SUCCESS;
+		}
+		break;
+	case ELEMENT_STORAGE:
+	case ELEMENT_MAP:
+		if ((s = slot_lookup(&smc->slots, element_type,
address)) == NULL)
+			break;	// Slot not found..
+		strncpy(s->barcode, barcode, sizeof(s->barcode));
+		set_slot_full(s, 0);
+		ret = TGTADM_SUCCESS;
+		break;
+	case ELEMENT_DATA_TRANSFER:
+		if (!tid)
+			break;	/* Fail if no TID specified */
+		if ((s = slot_lookup(&smc->slots, element_type,
address)) == NULL)
+			break;	// Slot not found..
+		s->asc  = NO_ADDITIONAL_SENSE;
+		s->drive_tid = tid;
+		s->drive_lun = lun;
+		ret = TGTADM_SUCCESS;
+		break;
+	}
+	return ret;
+}
+
+/* ***********************************
+ * Command argument processing
+ * ***********************************/
+#define ADD	1
+#define CONFIGURE 2
+
+static int smc_lu_config(struct scsi_lu *lu, char *params)
+{
+	struct smc_info *smc = (struct smc_info *)lu->smc_p;
+	int err = 0;
+	char *p;
+	char barcode[20] = "";
+	char buf[20];
+	int operation = 0;
+	int element_type = 0;
+	int start_addr = 0;
+	int quantity = 0;
+	int sides = 1;
+	int address = 0;
+	int tid = 0;
+	int lun = 0;
+	char *smc_params;
+
+	smc_params = malloc(strlen(params) + 1);
+	if (!smc_params)
+		return TGTADM_NOMEM;
+	smc_params[0] = '\0';
+	err = spc_lu_config(lu, params, smc_params);
+
+	if (!strncmp("targetOps", smc_params, 9))
+		smc_params = smc_params + 10;
+
+	while ((p = strsep(&smc_params, ",")) != NULL) {
+		substring_t args[MAX_OPT_ARGS];
+		int token;
+		if (!*p)
+			continue;
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case Opt_element_type:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			element_type = atoi(buf);
+			break;
+		case Opt_start_address:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			start_addr = atoi(buf);
+			operation = ADD;
+			break;
+		case Opt_quantity:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			quantity = atoi(buf);
+			break;
+		case Opt_sides:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sides = atoi(buf);
+			break;
+		case Opt_address:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			address = atoi(buf);
+			operation = CONFIGURE;
+			break;
+		case Opt_barcode:
+			match_strncpy(barcode, &args[0],
sizeof(barcode));
+			break;
+		case Opt_tid:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			tid = atoi(buf);
+			break;
+		case Opt_lun:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			lun = atoi(buf);
+			break;
+		case Opt_dump:
+			slot_dump(&smc->slots);
+			break;
+		default:
+			err = TGTADM_UNKNOWN_PARAM;
+		}
+	}
+
+	free(smc_params);
+
+	switch(operation) {
+		case ADD:
+			err = add_slt(lu, element_type, start_addr,
quantity);
+			break;
+		case CONFIGURE:
+			err = config_slot(lu, element_type, address,
tid,
+							lun, barcode,
sides);
+			break;
+	}
+	return err;
+}
+
+/* ***********************************
+ * Device Template - entry routines
+ * ***********************************/
+struct device_type_template smc_template = {
+	.type		= TYPE_MEDIUM_CHANGER,
+	.lu_init	= smc_lu_init,
+	.lu_exit 	= smc_lu_exit,
+	.lu_config	= smc_lu_config,
+	.ops	= {
+		{spc_test_unit,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_request_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		/* 0x10 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_inquiry,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x20 ... 0x4f] = {spc_illegal_op,},
+
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x9f] = {spc_illegal_op,},
+
+		/* 0xA0 */
+		{spc_report_luns,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{smc_move_medium,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_test_unit,},
+
+		/* 0xB0 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{smc_read_element_status,},	// Mandatory
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0xc0 ... 0xff] = {spc_illegal_op},
+	}
+};
+
+__attribute__((constructor)) static void smc_init(void)
+{
+	device_type_register(&smc_template);
+}
diff --git a/usr/smc.h b/usr/smc.h
new file mode 100644
index 0000000..fc37f9d
--- /dev/null
+++ b/usr/smc.h
@@ -0,0 +1,77 @@
+/*
+ * SCSI Medium Changer Command
+ *
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _SMC_H_
+#define _SMC_H_
+
+/**************************************************
+ * Slot description
+ **************************************************/
+#define ELEMENT_ANY		0
+#define	ELEMENT_MEDIUM_TRANSPORT	1
+#define	ELEMENT_STORAGE		2
+#define	ELEMENT_MAP		3
+#define	ELEMENT_DATA_TRANSFER	4
+
+struct slot {
+	struct	list_head	slot_siblings;
+	uint8_t		element_type;	/* Element Type 1, 2, 3 or 4 */
+	uint8_t		cart_type;	/* 0 Unspecified, 1 Data, 2
Cleaning */
+	uint16_t	slot_addr;	/* 65535 slots should be
enough.. */
+	uint16_t	last_addr;	/* Where the media came from..
*/
+	uint16_t	asc;		/* Additional sense code */
+	uint8_t		status;		/* Used for MAP status bits */
+	uint8_t		sides;		/* Number of sides this media.
*/
+	char		barcode[11];	/* Up to 10 char barcode */
+	/* Only used if slot contains a drive. */
+	uint8_t		drive_tid;
+	uint8_t		drive_lun;
+};
+
+/**************************************************
+ * Data structure for SMC device
+ * Top of the 'tree'
+ **************************************************/
+struct smc_info {
+	struct	list_head	slots;
+};
+
+enum {
+	Opt_element_type, Opt_start_address,
+	Opt_quantity, Opt_sides,
+	Opt_address, Opt_barcode,
+	Opt_tid, Opt_lun,
+	Opt_type, Opt_dump,
+	Opt_err,
+};
+
+static match_table_t tokens = {
+	{Opt_element_type, "element_type=%s"},
+	{Opt_start_address, "start_address=%s"},
+	{Opt_quantity, "quantity=%s"},
+	{Opt_sides, "sides=%s"},
+	{Opt_address, "address=%s"},
+	{Opt_barcode, "barcode=%s"},
+	{Opt_tid, "tid=%s"},
+	{Opt_lun, "lun=%s"},
+	{Opt_type, "type=%s"},
+	{Opt_dump, "dump=%s"},
+	{Opt_err, NULL},
+};
+#endif // _SMC_H_
diff --git a/usr/spc.c b/usr/spc.c
index 3eb605c..19a0403 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -500,7 +500,19 @@ static match_table_t tokens = {
 	{Opt_err, NULL},
 };
 
-int spc_lu_config(struct scsi_lu *lu, char *params) {
+/*
+ * Parse options received from user.
+ *
+ * User options are in 'char * params', while any unprocessed options
+ * are copied into 'char * ret_param' for further processing by the
+ * 'target' from which it was called.
+ *
+ * Note: It is the callers responsibility to make sure *ret_param has
enough
+ * room to store up to "strlen(params) + 1" - In case we can not parse
any
+ * params locally.
+ */
+int spc_lu_config(struct scsi_lu *lu, char *params, char *ret_param)
+{
 	int err = 0;
 	char *p;
 	char buf[256];
@@ -551,7 +563,9 @@ int spc_lu_config(struct scsi_lu *lu, char *params)
{
 			match_strncpy(buf, &args[0], sizeof(buf));
 			err = add_mode_page(lu, buf);
 			break;
-		default:
+		default:	/* Append any unprocessed args to
ret_param */
+			strcat(ret_param, p);
+			strcat(ret_param, ",");
 			err = TGTADM_INVALID_REQUEST;
 		}
 	}
diff --git a/usr/spc.h b/usr/spc.h
index c7e38c0..559a14e 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -16,7 +16,7 @@ extern int spc_test_unit(int host_no, struct scsi_cmd
*cmd);
 extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
 extern int spc_lu_init(struct scsi_lu *lu);
-extern int spc_lu_config(struct scsi_lu *lu, char * params);
+extern int spc_lu_config(struct scsi_lu *lu, char *params, char
*ret_params);
 extern void dump_cdb(struct scsi_cmd *cmd);
 extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
 struct mode *mode_page_lookup(struct list_head *head, uint8_t page);
diff --git a/usr/tgtadm.c b/usr/tgtadm.c
index c2315b6..0631a7d 100644
--- a/usr/tgtadm.c
+++ b/usr/tgtadm.c
@@ -300,6 +300,8 @@ static int str_to_device_type(char *str)
 		exit(EINVAL);
 	} else if (!strcmp(str, "cd"))
 		return TYPE_ROM;
+	else if (!strcmp(str, "changer"))
+		return TYPE_MEDIUM_CHANGER;
 	else if (!strcmp(str, "osd"))
 		return TYPE_OSD;
 	else if (!strcmp(str, "pt"))
diff --git a/usr/tgtd.h b/usr/tgtd.h
index bbacae2..271b260 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -100,8 +100,11 @@ struct scsi_lu {
 	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
 	struct list_head mode_pages;
 
-	/* TODO: needs a structure for lots of device parameters */
 	struct lu_phy_attr attrs;
+
+	/* TODO: needs a structure for lots of device parameters */
+	/* Currently only used by smc module */
+	void *smc_p;
 };
 
 struct scsi_cmd {
-- 
1.5.2.1




_______________________________________________
Stgt-devel mailing list
Stgt-devel at lists.berlios.de
https://lists.berlios.de/mailman/listinfo/stgt-devel


From fujita.tomonori at lab.ntt.co.jp  Wed Jun 27 11:43:19 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 27 Jun 2007 18:43:19 +0900
Subject: [Stgt-devel] [Patch 3/3] Re-work of SMC support
In-Reply-To: <467CD64C.9060606@gmail.com>
References: <467CD64C.9060606@gmail.com>
Message-ID: <20070627184319P.fujita.tomonori@lab.ntt.co.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 3/3] Re-work of SMC support
Date: Sat, 23 Jun 2007 18:14:04 +1000

> diff --git a/usr/media.h b/usr/media.h
> new file mode 100644
> index 0000000..a04a27c
> --- /dev/null
> +++ b/usr/media.h
> @@ -0,0 +1,30 @@
> +/*
> + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; version 2 of the License.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, write to the Free Software
> + * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
> + */
> +#ifndef _MEDIA_H_
> +#define _MEDIA_H_
> +
> +enum c_type {	/* Cartridge Types - Ref: smc3r06 - Table 20, page 37 */
> +	CART_UNSPECIFIED,
> +	CART_DATA,
> +	CART_CLEAN,
> +	CART_DIAGNOSTICS,
> +	CART_WORM,
> +	CART_MICROCODE,
> +};
> +
> +#endif /* _MEDIA_H_ */

Why do you put this in smc.c?


> diff --git a/usr/mmc.c b/usr/mmc.c
> index 891cb60..0672877 100644
> --- a/usr/mmc.c
> +++ b/usr/mmc.c
> @@ -38,6 +38,7 @@
>  #include "util.h"
>  #include "tgtd.h"
>  #include "target.h"
> +#include "tgtadm_error.h"
>  #include "driver.h"
>  #include "scsi.h"
>  #include "spc.h"
> @@ -174,10 +175,26 @@ static int mmc_lu_init(struct scsi_lu *lu)
>  	return 0;
>  }
>  
> +static int mmc_lu_config(struct scsi_lu *lu, char * params)
> +{
> +	char	* mmc_params;
> +	int	ret;
> +
> +	mmc_params = malloc(strlen(params) + 1);
> +	if (!mmc_params)
> +		return -ENOMEM;
> +	mmc_params[0] = '\0';
> +	ret = spc_lu_config(lu, params, mmc_params);
> +	if (strlen(mmc_params))	/* We should not have any params left over */
> +		ret = TGTADM_INVALID_REQUEST;
> +	free(mmc_params);
> +	return ret;
> +}

strdup?


From fujita.tomonori at lab.ntt.co.jp  Wed Jun 27 13:23:17 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 27 Jun 2007 20:23:17 +0900
Subject: [Stgt-devel] [Patch 1/3] Rework of mnemonic ASC/ASCQ values
In-Reply-To: <467CD5C8.2090108@gmail.com>
References: <467CD5C8.2090108@gmail.com>
Message-ID: <20070627202317G.fujita.tomonori@lab.ntt.co.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: [Stgt-devel] [Patch 1/3] Rework of mnemonic ASC/ASCQ values
Date: Sat, 23 Jun 2007 18:11:52 +1000

> >From d163aa03f036609ac5343c2d8983aba38ecec679 Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Fri, 22 Jun 2007 18:20:54 +1000
> Subject: Use nmemonic codes for SENSE codes instead of numeric value.
> 
> Using nmemonic representation for ASC/ASCQ as a 16bit value.
>  - Values defined in sense_codes.h
>  - Updated sense_data_build() to accept a single 16bit
>    combined asc/ascq value.
> 
> Signed-off-by: Mark Harvey <markh794 at gmail.com>
> ---
>  usr/bs_sync.c       |    3 +-
>  usr/ibmvio/ibmvio.c |   15 ++++---
>  usr/mmc.c           |    7 ++-
>  usr/osd.c           |    5 +-
>  usr/sbc.c           |   33 +++++++++-------
>  usr/scsi.c          |   13 +++---
>  usr/sense_codes.h   |  103 +++++++++++++++++++++++++++++++++++++++++++++++++++
>  usr/spc.c           |   19 +++++----
>  usr/spt.c           |    5 +-
>  usr/tgtd.h          |    3 +-
>  10 files changed, 161 insertions(+), 45 deletions(-)
>  create mode 100644 usr/sense_codes.h
> 
> diff --git a/usr/bs_sync.c b/usr/bs_sync.c
> index 6789b5b..4986c59 100644
> --- a/usr/bs_sync.c
> +++ b/usr/bs_sync.c
> @@ -37,6 +37,7 @@
>  #include "util.h"
>  #include "tgtd.h"
>  #include "scsi.h"
> +#include "sense_codes.h"
>  
>  #define NR_WORKER_THREADS	4
>  
> @@ -161,7 +162,7 @@ static void *bs_sync_worker_fn(void *arg)
>  			eprintf("io error %p %x %d %d %" PRIu64 ", %m\n",
>  				cmd, cmd->scb[0], ret, cmd->len, cmd->offset);
>  			cmd->result = SAM_STAT_CHECK_CONDITION;
> -			sense_data_build(cmd, MEDIUM_ERROR, 0x11, 0x0);
> +			sense_data_build(cmd, MEDIUM_ERROR, ASC_READ_ERROR);
>  		}
>  
>  		pthread_mutex_lock(&info->finished_lock);
> diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
> index 5a2f8fe..8cfc8d6 100644
> --- a/usr/ibmvio/ibmvio.c
> +++ b/usr/ibmvio/ibmvio.c
> @@ -44,6 +44,7 @@
>  #include "target.h"
>  #include "driver.h"
>  #include "spc.h"
> +#include "sense_codes.h"
>  
>  #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
>  #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
> @@ -140,7 +141,8 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
>  {
>  	int ret = SAM_STAT_CHECK_CONDITION;
>  	uint8_t *data, *scb = cmd->scb;
> -	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
> +	unsigned char key = ILLEGAL_REQUEST;
> +	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
>  
>  	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
>  		goto sense;
> @@ -148,7 +150,7 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
>  	data = valloc(pagesize);
>  	if (!data) {
>  		key = HARDWARE_ERROR;
> -		asc = 0;
> +		asc = ASC_INTERNAL_TGT_FAILURE;

Just ASC_INTERNAL_FAILURE would look better?


> diff --git a/usr/scsi.c b/usr/scsi.c
> index 36722e1..5ddc94c 100644
> --- a/usr/scsi.c
> +++ b/usr/scsi.c
> @@ -38,27 +38,28 @@
>  #include "scsi.h"
>  #include "spc.h"
>  
> -void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
> +void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t asc)
>  {
> +	uint16_t *sense_code;
> +
>  	if (cmd->dev->attrs.sense_format) {
>  		/* descriptor format */
> +		sense_code = (uint16_t *)&cmd->sense_buffer[2];
>  
>  		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
>  		cmd->sense_buffer[1] = key;
> -		cmd->sense_buffer[2] = asc;
> -		cmd->sense_buffer[3] = asq;
>  		cmd->sense_len = 8;
>  	} else {
>  		/* fixed format */
> +		sense_code = (uint16_t *)&cmd->sense_buffer[12];
>  
>  		int len = 0xa;
> -		cmd->sense_buffer[0] = 0x70;
> +		cmd->sense_buffer[0] = 0x70;  /* current, not deferred */
>  		cmd->sense_buffer[2] = key;
>  		cmd->sense_buffer[7] = len;
> -		cmd->sense_buffer[12] = asc;
> -		cmd->sense_buffer[13] = asq;
>  		cmd->sense_len = len + 8;
>  	}
> +	*sense_code = __cpu_to_be16(asc);
>  }

This doesn't work on big-endian boxes?

I prefer more simple code like:

void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t code)
{
	uint8_t asc, asq;

	asc = code >> 8;
	asq = code & 0xff;

	if (cmd->dev->attrs.sense_format) {
		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
		cmd->sense_buffer[1] = key;
		cmd->sense_buffer[2] = asc;
		cmd->sense_buffer[3] = asq;
		cmd->sense_len = 8;


>  #define        TGT_INVALID_DEV_ID      ~0ULL
> diff --git a/usr/sense_codes.h b/usr/sense_codes.h
> new file mode 100644
> index 0000000..ea8eebc
> --- /dev/null
> +++ b/usr/sense_codes.h
> @@ -0,0 +1,103 @@
> +/*
> + * The SCSI sense key Additional Sense Code / Additional Sense Code Qualifier
> + *
> + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com

How about:

+ * Copyright (C) 2007      Mark Harvey <markh794 at gmail.com>

Looks better.

I don't think camouflaging your address is useful since spammers can
find your address in the git history.


From markh794 at gmail.com  Wed Jun 27 23:58:43 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 28 Jun 2007 07:58:43 +1000
Subject: [Stgt-devel] [Patch 1/3] Rework of mnemonic ASC/ASCQ values
In-Reply-To: <20070627202317G.fujita.tomonori@lab.ntt.co.jp>
References: <467CD5C8.2090108@gmail.com>
	<20070627202317G.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80706271458s78dd250fs926c48b60075c00f@mail.gmail.com>

On 6/27/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: Mark Harvey <markh794 at gmail.com>
> Subject: [Stgt-devel] [Patch 1/3] Rework of mnemonic ASC/ASCQ values
> Date: Sat, 23 Jun 2007 18:11:52 +1000
>
> > >From d163aa03f036609ac5343c2d8983aba38ecec679 Mon Sep 17 00:00:00 2001
> > From: Mark Harvey <markh794 at gmail.com>
> > Date: Fri, 22 Jun 2007 18:20:54 +1000
> > Subject: Use nmemonic codes for SENSE codes instead of numeric value.
> >
> > Using nmemonic representation for ASC/ASCQ as a 16bit value.
> >  - Values defined in sense_codes.h
> >  - Updated sense_data_build() to accept a single 16bit
> >    combined asc/ascq value.
> >
> > Signed-off-by: Mark Harvey <markh794 at gmail.com>
> > ---
> >  usr/bs_sync.c       |    3 +-
> >  usr/ibmvio/ibmvio.c |   15 ++++---
> >  usr/mmc.c           |    7 ++-
> >  usr/osd.c           |    5 +-
> >  usr/sbc.c           |   33 +++++++++-------
> >  usr/scsi.c          |   13 +++---
> >  usr/sense_codes.h   |  103 +++++++++++++++++++++++++++++++++++++++++++++++++++
> >  usr/spc.c           |   19 +++++----
> >  usr/spt.c           |    5 +-
> >  usr/tgtd.h          |    3 +-
> >  10 files changed, 161 insertions(+), 45 deletions(-)
> >  create mode 100644 usr/sense_codes.h
> >
> > diff --git a/usr/bs_sync.c b/usr/bs_sync.c
> > index 6789b5b..4986c59 100644
> > --- a/usr/bs_sync.c
> > +++ b/usr/bs_sync.c
> > @@ -37,6 +37,7 @@
> >  #include "util.h"
> >  #include "tgtd.h"
> >  #include "scsi.h"
> > +#include "sense_codes.h"
> >
> >  #define NR_WORKER_THREADS    4
> >
> > @@ -161,7 +162,7 @@ static void *bs_sync_worker_fn(void *arg)
> >                       eprintf("io error %p %x %d %d %" PRIu64 ", %m\n",
> >                               cmd, cmd->scb[0], ret, cmd->len, cmd->offset);
> >                       cmd->result = SAM_STAT_CHECK_CONDITION;
> > -                     sense_data_build(cmd, MEDIUM_ERROR, 0x11, 0x0);
> > +                     sense_data_build(cmd, MEDIUM_ERROR, ASC_READ_ERROR);
> >               }
> >
> >               pthread_mutex_lock(&info->finished_lock);
> > diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
> > index 5a2f8fe..8cfc8d6 100644
> > --- a/usr/ibmvio/ibmvio.c
> > +++ b/usr/ibmvio/ibmvio.c
> > @@ -44,6 +44,7 @@
> >  #include "target.h"
> >  #include "driver.h"
> >  #include "spc.h"
> > +#include "sense_codes.h"
> >
> >  #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
> >  #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
> > @@ -140,7 +141,8 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
> >  {
> >       int ret = SAM_STAT_CHECK_CONDITION;
> >       uint8_t *data, *scb = cmd->scb;
> > -     unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
> > +     unsigned char key = ILLEGAL_REQUEST;
> > +     uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
> >
> >       if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
> >               goto sense;
> > @@ -148,7 +150,7 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
> >       data = valloc(pagesize);
> >       if (!data) {
> >               key = HARDWARE_ERROR;
> > -             asc = 0;
> > +             asc = ASC_INTERNAL_TGT_FAILURE;
>
> Just ASC_INTERNAL_FAILURE would look better?

Took the Values & names from the t10 SPC doco
This was INTERNAL TARGET FAILURE, however I shortened it from TARGET to TGT
I can shorten this again to ASC_INTERNAL_FAILURE if you like..

>
>
> > diff --git a/usr/scsi.c b/usr/scsi.c
> > index 36722e1..5ddc94c 100644
> > --- a/usr/scsi.c
> > +++ b/usr/scsi.c
> > @@ -38,27 +38,28 @@
> >  #include "scsi.h"
> >  #include "spc.h"
> >
> > -void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
> > +void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t asc)
> >  {
> > +     uint16_t *sense_code;
> > +
> >       if (cmd->dev->attrs.sense_format) {
> >               /* descriptor format */
> > +             sense_code = (uint16_t *)&cmd->sense_buffer[2];
> >
> >               cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
> >               cmd->sense_buffer[1] = key;
> > -             cmd->sense_buffer[2] = asc;
> > -             cmd->sense_buffer[3] = asq;
> >               cmd->sense_len = 8;
> >       } else {
> >               /* fixed format */
> > +             sense_code = (uint16_t *)&cmd->sense_buffer[12];
> >
> >               int len = 0xa;
> > -             cmd->sense_buffer[0] = 0x70;
> > +             cmd->sense_buffer[0] = 0x70;  /* current, not deferred */
> >               cmd->sense_buffer[2] = key;
> >               cmd->sense_buffer[7] = len;
> > -             cmd->sense_buffer[12] = asc;
> > -             cmd->sense_buffer[13] = asq;
> >               cmd->sense_len = len + 8;
> >       }
> > +     *sense_code = __cpu_to_be16(asc);
> >  }
>
> This doesn't work on big-endian boxes?
>
> I prefer more simple code like:
>
> void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t code)
> {
>         uint8_t asc, asq;
>
>         asc = code >> 8;
>         asq = code & 0xff;
>
>         if (cmd->dev->attrs.sense_format) {
>                 cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
>                 cmd->sense_buffer[1] = key;
>                 cmd->sense_buffer[2] = asc;
>                 cmd->sense_buffer[3] = asq;
>                 cmd->sense_len = 8;
>

No problems at all.

I'll roll this back..

I did have:
 cmd->sense_buffer[2] = (code >> 8) & 0xff;
 cmd->sense_buffer[3] = code & 0xff;


> >  #define        TGT_INVALID_DEV_ID      ~0ULL
> > diff --git a/usr/sense_codes.h b/usr/sense_codes.h
> > new file mode 100644
> > index 0000000..ea8eebc
> > --- /dev/null
> > +++ b/usr/sense_codes.h
> > @@ -0,0 +1,103 @@
> > +/*
> > + * The SCSI sense key Additional Sense Code / Additional Sense Code Qualifier
> > + *
> > + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
>
> How about:
>
> + * Copyright (C) 2007      Mark Harvey <markh794 at gmail.com>
>
> Looks better.
>
> I don't think camouflaging your address is useful since spammers can
> find your address in the git history.

Actually, I'm not even sure I should have a "Copyright" here as the
details have been taken from information at www.t10.org

Should I remove my "Copyright" message altogether or leave it there
and update as per your suggestion ?


Cheers
Mark


From markh794 at gmail.com  Thu Jun 28 02:20:16 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 28 Jun 2007 10:20:16 +1000
Subject: [Stgt-devel] [Patch 3/3] Re-work of SMC support
In-Reply-To: <20070627184319P.fujita.tomonori@lab.ntt.co.jp>
References: <467CD64C.9060606@gmail.com>
	<20070627184319P.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80706271720j71f1aff4t2146cc64574c5280@mail.gmail.com>

On 6/27/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: Mark Harvey <markh794 at gmail.com>
> Subject: [Stgt-devel] [Patch 3/3] Re-work of SMC support
> Date: Sat, 23 Jun 2007 18:14:04 +1000
>
> > diff --git a/usr/media.h b/usr/media.h
> > new file mode 100644
> > index 0000000..a04a27c
> > --- /dev/null
> > +++ b/usr/media.h
> > @@ -0,0 +1,30 @@
> > +/*
> > + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
> > + *
> > + * This program is free software; you can redistribute it and/or modify
> > + * it under the terms of the GNU General Public License as published by
> > + * the Free Software Foundation; version 2 of the License.
> > + *
> > + * This program is distributed in the hope that it will be useful,
> > + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> > + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> > + * GNU General Public License for more details.
> > + *
> > + * You should have received a copy of the GNU General Public License
> > + * along with this program; if not, write to the Free Software
> > + * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
> > + */
> > +#ifndef _MEDIA_H_
> > +#define _MEDIA_H_
> > +
> > +enum c_type {        /* Cartridge Types - Ref: smc3r06 - Table 20, page 37 */
> > +     CART_UNSPECIFIED,
> > +     CART_DATA,
> > +     CART_CLEAN,
> > +     CART_DIAGNOSTICS,
> > +     CART_WORM,
> > +     CART_MICROCODE,
> > +};
> > +
> > +#endif /* _MEDIA_H_ */
>
> Why do you put this in smc.c?

Slots within the SMC device can contain different media type..

At the moment, this is not used by the SMC device but I included for
when this support is added.

Should I remove this until I get around to coding this portion of the code ?


> > diff --git a/usr/mmc.c b/usr/mmc.c
> > index 891cb60..0672877 100644
> > --- a/usr/mmc.c
> > +++ b/usr/mmc.c
> > @@ -38,6 +38,7 @@
> >  #include "util.h"
> >  #include "tgtd.h"
> >  #include "target.h"
> > +#include "tgtadm_error.h"
> >  #include "driver.h"
> >  #include "scsi.h"
> >  #include "spc.h"
> > @@ -174,10 +175,26 @@ static int mmc_lu_init(struct scsi_lu *lu)
> >       return 0;
> >  }
> >
> > +static int mmc_lu_config(struct scsi_lu *lu, char * params)
> > +{
> > +     char    * mmc_params;
> > +     int     ret;
> > +
> > +     mmc_params = malloc(strlen(params) + 1);
> > +     if (!mmc_params)
> > +             return -ENOMEM;
> > +     mmc_params[0] = '\0';
> > +     ret = spc_lu_config(lu, params, mmc_params);
> > +     if (strlen(mmc_params)) /* We should not have any params left over */
> > +             ret = TGTADM_INVALID_REQUEST;
> > +     free(mmc_params);
> > +     return ret;
> > +}
>
> strdup?

I'm still trying to come up with a 'better' way of doing this.

In an attempt to move all common parameter parsing within one common
function and still be able to process any module unique params
afterwards :

     ret = spc_lu_config(lu, params, mmc_params);

 - Original string of params passed in 'params', 'mmc_params' is a null string.
 - The spc_lu_config() copies any parameters it can not process in the
*mmc_params.
 - It is then up the the xxx_lu_config() calling function to process
any left over params (in mmc_params in this case) not handled by
spc_lu_config().
 - If all params are processed in spc_lu_config(), then the
*mmc_params will contain an empty string.

I thought it might be a little more obvious to have the malloc() /
free() within the same function rather then have spc_lu_config do the
malloc() and then the caller free the space afterwards.

The smc_lu_config() is the only module at the moment that needs the
extra options.

I expect the ssc_lu_config() to also require extra configuration
options. Although I have not started coding that yet and have not
fully thought thru what may be required.



The other option would be to move the spc_lu_config() into each module
and not share the common param handling.

Cheers
Mark


From fujita.tomonori at lab.ntt.co.jp  Thu Jun 28 07:49:31 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 28 Jun 2007 14:49:31 +0900 (JST)
Subject: [Stgt-devel] [Patch 3/3] Re-work of SMC support
In-Reply-To: <f29db9a80706271720j71f1aff4t2146cc64574c5280@mail.gmail.com>
References: <467CD64C.9060606@gmail.com>
	<20070627184319P.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80706271720j71f1aff4t2146cc64574c5280@mail.gmail.com>
Message-ID: <20070628034531Z.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] [Patch 3/3] Re-work of SMC support
Date: Thu, 28 Jun 2007 10:20:16 +1000

> On 6/27/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > From: Mark Harvey <markh794 at gmail.com>
> > Subject: [Stgt-devel] [Patch 3/3] Re-work of SMC support
> > Date: Sat, 23 Jun 2007 18:14:04 +1000
> >
> > > diff --git a/usr/media.h b/usr/media.h
> > > new file mode 100644
> > > index 0000000..a04a27c
> > > --- /dev/null
> > > +++ b/usr/media.h
> > > @@ -0,0 +1,30 @@
> > > +/*
> > > + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
> > > + *
> > > + * This program is free software; you can redistribute it and/or modify
> > > + * it under the terms of the GNU General Public License as published by
> > > + * the Free Software Foundation; version 2 of the License.
> > > + *
> > > + * This program is distributed in the hope that it will be useful,
> > > + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> > > + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> > > + * GNU General Public License for more details.
> > > + *
> > > + * You should have received a copy of the GNU General Public License
> > > + * along with this program; if not, write to the Free Software
> > > + * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
> > > + */
> > > +#ifndef _MEDIA_H_
> > > +#define _MEDIA_H_
> > > +
> > > +enum c_type {        /* Cartridge Types - Ref: smc3r06 - Table 20, page 37 */
> > > +     CART_UNSPECIFIED,
> > > +     CART_DATA,
> > > +     CART_CLEAN,
> > > +     CART_DIAGNOSTICS,
> > > +     CART_WORM,
> > > +     CART_MICROCODE,
> > > +};
> > > +
> > > +#endif /* _MEDIA_H_ */
> >
> > Why do you put this in smc.c?
> 
> Slots within the SMC device can contain different media type..
> 
> At the moment, this is not used by the SMC device but I included for
> when this support is added.
> 
> Should I remove this until I get around to coding this portion of the code ?

I'm not sure whether we are on the same page.

What I wanted to say is why you need to put enum c_type to media.h
instead of smc.c.


> > > diff --git a/usr/mmc.c b/usr/mmc.c
> > > index 891cb60..0672877 100644
> > > --- a/usr/mmc.c
> > > +++ b/usr/mmc.c
> > > @@ -38,6 +38,7 @@
> > >  #include "util.h"
> > >  #include "tgtd.h"
> > >  #include "target.h"
> > > +#include "tgtadm_error.h"
> > >  #include "driver.h"
> > >  #include "scsi.h"
> > >  #include "spc.h"
> > > @@ -174,10 +175,26 @@ static int mmc_lu_init(struct scsi_lu *lu)
> > >       return 0;
> > >  }
> > >
> > > +static int mmc_lu_config(struct scsi_lu *lu, char * params)
> > > +{
> > > +     char    * mmc_params;
> > > +     int     ret;
> > > +
> > > +     mmc_params = malloc(strlen(params) + 1);
> > > +     if (!mmc_params)
> > > +             return -ENOMEM;
> > > +     mmc_params[0] = '\0';
> > > +     ret = spc_lu_config(lu, params, mmc_params);
> > > +     if (strlen(mmc_params)) /* We should not have any params left over */
> > > +             ret = TGTADM_INVALID_REQUEST;
> > > +     free(mmc_params);
> > > +     return ret;
> > > +}
> >
> > strdup?
> 
> I'm still trying to come up with a 'better' way of doing this.
> 
> In an attempt to move all common parameter parsing within one common
> function and still be able to process any module unique params
> afterwards :
> 
>      ret = spc_lu_config(lu, params, mmc_params);
> 
>  - Original string of params passed in 'params', 'mmc_params' is a null string.
>  - The spc_lu_config() copies any parameters it can not process in the
> *mmc_params.
>  - It is then up the the xxx_lu_config() calling function to process
> any left over params (in mmc_params in this case) not handled by
> spc_lu_config().
>  - If all params are processed in spc_lu_config(), then the
> *mmc_params will contain an empty string.
> 
> I thought it might be a little more obvious to have the malloc() /
> free() within the same function rather then have spc_lu_config do the
> malloc() and then the caller free the space afterwards.
> 
> The smc_lu_config() is the only module at the moment that needs the
> extra options.
> 
> I expect the ssc_lu_config() to also require extra configuration
> options. Although I have not started coding that yet and have not
> fully thought thru what may be required.
> 
> 
> 
> The other option would be to move the spc_lu_config() into each module
> and not share the common param handling.

How about:

typedef int (match_fn_t) (struct scsi_lu *);

int spc_lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn,
match_table_t *t)
{
}

spc_lu_config calls fn with t (which device code like smc passes) for
non-standard params.


From fujita.tomonori at lab.ntt.co.jp  Thu Jun 28 07:49:31 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 28 Jun 2007 14:49:31 +0900 (JST)
Subject: [Stgt-devel] [Patch 1/3] Rework of mnemonic ASC/ASCQ values
In-Reply-To: <f29db9a80706271458s78dd250fs926c48b60075c00f@mail.gmail.com>
References: <467CD5C8.2090108@gmail.com>
	<20070627202317G.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80706271458s78dd250fs926c48b60075c00f@mail.gmail.com>
Message-ID: <20070628032122Y.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: Re: [Stgt-devel] [Patch 1/3] Rework of mnemonic ASC/ASCQ values
Date: Thu, 28 Jun 2007 07:58:43 +1000

> On 6/27/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > From: Mark Harvey <markh794 at gmail.com>
> > Subject: [Stgt-devel] [Patch 1/3] Rework of mnemonic ASC/ASCQ values
> > Date: Sat, 23 Jun 2007 18:11:52 +1000
> >
> > > >From d163aa03f036609ac5343c2d8983aba38ecec679 Mon Sep 17 00:00:00 2001
> > > From: Mark Harvey <markh794 at gmail.com>
> > > Date: Fri, 22 Jun 2007 18:20:54 +1000
> > > Subject: Use nmemonic codes for SENSE codes instead of numeric value.
> > >
> > > Using nmemonic representation for ASC/ASCQ as a 16bit value.
> > >  - Values defined in sense_codes.h
> > >  - Updated sense_data_build() to accept a single 16bit
> > >    combined asc/ascq value.
> > >
> > > Signed-off-by: Mark Harvey <markh794 at gmail.com>
> > > ---
> > >  usr/bs_sync.c       |    3 +-
> > >  usr/ibmvio/ibmvio.c |   15 ++++---
> > >  usr/mmc.c           |    7 ++-
> > >  usr/osd.c           |    5 +-
> > >  usr/sbc.c           |   33 +++++++++-------
> > >  usr/scsi.c          |   13 +++---
> > >  usr/sense_codes.h   |  103 +++++++++++++++++++++++++++++++++++++++++++++++++++
> > >  usr/spc.c           |   19 +++++----
> > >  usr/spt.c           |    5 +-
> > >  usr/tgtd.h          |    3 +-
> > >  10 files changed, 161 insertions(+), 45 deletions(-)
> > >  create mode 100644 usr/sense_codes.h
> > >
> > > diff --git a/usr/bs_sync.c b/usr/bs_sync.c
> > > index 6789b5b..4986c59 100644
> > > --- a/usr/bs_sync.c
> > > +++ b/usr/bs_sync.c
> > > @@ -37,6 +37,7 @@
> > >  #include "util.h"
> > >  #include "tgtd.h"
> > >  #include "scsi.h"
> > > +#include "sense_codes.h"
> > >
> > >  #define NR_WORKER_THREADS    4
> > >
> > > @@ -161,7 +162,7 @@ static void *bs_sync_worker_fn(void *arg)
> > >                       eprintf("io error %p %x %d %d %" PRIu64 ", %m\n",
> > >                               cmd, cmd->scb[0], ret, cmd->len, cmd->offset);
> > >                       cmd->result = SAM_STAT_CHECK_CONDITION;
> > > -                     sense_data_build(cmd, MEDIUM_ERROR, 0x11, 0x0);
> > > +                     sense_data_build(cmd, MEDIUM_ERROR, ASC_READ_ERROR);
> > >               }
> > >
> > >               pthread_mutex_lock(&info->finished_lock);
> > > diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
> > > index 5a2f8fe..8cfc8d6 100644
> > > --- a/usr/ibmvio/ibmvio.c
> > > +++ b/usr/ibmvio/ibmvio.c
> > > @@ -44,6 +44,7 @@
> > >  #include "target.h"
> > >  #include "driver.h"
> > >  #include "spc.h"
> > > +#include "sense_codes.h"
> > >
> > >  #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
> > >  #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
> > > @@ -140,7 +141,8 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
> > >  {
> > >       int ret = SAM_STAT_CHECK_CONDITION;
> > >       uint8_t *data, *scb = cmd->scb;
> > > -     unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
> > > +     unsigned char key = ILLEGAL_REQUEST;
> > > +     uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
> > >
> > >       if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
> > >               goto sense;
> > > @@ -148,7 +150,7 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
> > >       data = valloc(pagesize);
> > >       if (!data) {
> > >               key = HARDWARE_ERROR;
> > > -             asc = 0;
> > > +             asc = ASC_INTERNAL_TGT_FAILURE;
> >
> > Just ASC_INTERNAL_FAILURE would look better?
> 
> Took the Values & names from the t10 SPC doco
> This was INTERNAL TARGET FAILURE, however I shortened it from TARGET to TGT
> I can shorten this again to ASC_INTERNAL_FAILURE if you like..

ASC_INTERNAL_TGT_FAILURE or ASC_INTERNAL_TARGET_FAILURE is
fine. Sorry, I remember the wrong name.


> > >  #define        TGT_INVALID_DEV_ID      ~0ULL
> > > diff --git a/usr/sense_codes.h b/usr/sense_codes.h
> > > new file mode 100644
> > > index 0000000..ea8eebc
> > > --- /dev/null
> > > +++ b/usr/sense_codes.h
> > > @@ -0,0 +1,103 @@
> > > +/*
> > > + * The SCSI sense key Additional Sense Code / Additional Sense Code Qualifier
> > > + *
> > > + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
> >
> > How about:
> >
> > + * Copyright (C) 2007      Mark Harvey <markh794 at gmail.com>
> >
> > Looks better.
> >
> > I don't think camouflaging your address is useful since spammers can
> > find your address in the git history.
> 
> Actually, I'm not even sure I should have a "Copyright" here as the
> details have been taken from information at www.t10.org
> 
> Should I remove my "Copyright" message altogether or leave it there
> and update as per your suggestion ?

I'm not sure. Either is ok for me though as you said, putting the
copyright in this file might be meaningless.


From markh794 at gmail.com  Thu Jun 28 08:26:30 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 28 Jun 2007 16:26:30 +1000
Subject: [Stgt-devel] [Patch 3/3] Re-work of SMC support
In-Reply-To: <20070628034531Z.fujita.tomonori@lab.ntt.co.jp>
References: <467CD64C.9060606@gmail.com>
	<20070627184319P.fujita.tomonori@lab.ntt.co.jp>
	<f29db9a80706271720j71f1aff4t2146cc64574c5280@mail.gmail.com>
	<20070628034531Z.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80706272326w180fc5c7m448922bddb16d2ba@mail.gmail.com>

On 6/28/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: Re: [Stgt-devel] [Patch 3/3] Re-work of SMC support
> Date: Thu, 28 Jun 2007 10:20:16 +1000
>
> > On 6/27/07, FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp> wrote:
> > > From: Mark Harvey <markh794 at gmail.com>
> > > Subject: [Stgt-devel] [Patch 3/3] Re-work of SMC support
> > > Date: Sat, 23 Jun 2007 18:14:04 +1000
> > >
> > > > diff --git a/usr/media.h b/usr/media.h
> > > > new file mode 100644
> > > > index 0000000..a04a27c
> > > > --- /dev/null
> > > > +++ b/usr/media.h
> > > > @@ -0,0 +1,30 @@
> > > > +/*
> > > > + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
> > > > + *
> > > > + * This program is free software; you can redistribute it and/or modify
> > > > + * it under the terms of the GNU General Public License as published by
> > > > + * the Free Software Foundation; version 2 of the License.
> > > > + *
> > > > + * This program is distributed in the hope that it will be useful,
> > > > + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> > > > + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> > > > + * GNU General Public License for more details.
> > > > + *
> > > > + * You should have received a copy of the GNU General Public License
> > > > + * along with this program; if not, write to the Free Software
> > > > + * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
> > > > + */
> > > > +#ifndef _MEDIA_H_
> > > > +#define _MEDIA_H_
> > > > +
> > > > +enum c_type {        /* Cartridge Types - Ref: smc3r06 - Table 20, page 37 */
> > > > +     CART_UNSPECIFIED,
> > > > +     CART_DATA,
> > > > +     CART_CLEAN,
> > > > +     CART_DIAGNOSTICS,
> > > > +     CART_WORM,
> > > > +     CART_MICROCODE,
> > > > +};
> > > > +
> > > > +#endif /* _MEDIA_H_ */
> > >
> > > Why do you put this in smc.c?
> >
> > Slots within the SMC device can contain different media type..
> >
> > At the moment, this is not used by the SMC device but I included for
> > when this support is added.
> >
> > Should I remove this until I get around to coding this portion of the code ?
>
> I'm not sure whether we are on the same page.
>
> What I wanted to say is why you need to put enum c_type to media.h
> instead of smc.c.

OK - same page now...

The SSC module will be pulling this in as well as the current SMC module.

Hence I separated into its own header file.

>
>
> > > > diff --git a/usr/mmc.c b/usr/mmc.c
> > > > index 891cb60..0672877 100644
> > > > --- a/usr/mmc.c
> > > > +++ b/usr/mmc.c
> > > > @@ -38,6 +38,7 @@
> > > >  #include "util.h"
> > > >  #include "tgtd.h"
> > > >  #include "target.h"
> > > > +#include "tgtadm_error.h"
> > > >  #include "driver.h"
> > > >  #include "scsi.h"
> > > >  #include "spc.h"
> > > > @@ -174,10 +175,26 @@ static int mmc_lu_init(struct scsi_lu *lu)
> > > >       return 0;
> > > >  }
> > > >
> > > > +static int mmc_lu_config(struct scsi_lu *lu, char * params)
> > > > +{
> > > > +     char    * mmc_params;
> > > > +     int     ret;
> > > > +
> > > > +     mmc_params = malloc(strlen(params) + 1);
> > > > +     if (!mmc_params)
> > > > +             return -ENOMEM;
> > > > +     mmc_params[0] = '\0';
> > > > +     ret = spc_lu_config(lu, params, mmc_params);
> > > > +     if (strlen(mmc_params)) /* We should not have any params left over */
> > > > +             ret = TGTADM_INVALID_REQUEST;
> > > > +     free(mmc_params);
> > > > +     return ret;
> > > > +}
> > >
> > > strdup?
> >
> > I'm still trying to come up with a 'better' way of doing this.
> >
> > In an attempt to move all common parameter parsing within one common
> > function and still be able to process any module unique params
> > afterwards :
> >
> >      ret = spc_lu_config(lu, params, mmc_params);
> >
> >  - Original string of params passed in 'params', 'mmc_params' is a null string.
> >  - The spc_lu_config() copies any parameters it can not process in the
> > *mmc_params.
> >  - It is then up the the xxx_lu_config() calling function to process
> > any left over params (in mmc_params in this case) not handled by
> > spc_lu_config().
> >  - If all params are processed in spc_lu_config(), then the
> > *mmc_params will contain an empty string.
> >
> > I thought it might be a little more obvious to have the malloc() /
> > free() within the same function rather then have spc_lu_config do the
> > malloc() and then the caller free the space afterwards.
> >
> > The smc_lu_config() is the only module at the moment that needs the
> > extra options.
> >
> > I expect the ssc_lu_config() to also require extra configuration
> > options. Although I have not started coding that yet and have not
> > fully thought thru what may be required.
> >
> >
> >
> > The other option would be to move the spc_lu_config() into each module
> > and not share the common param handling.
>
> How about:
>
> typedef int (match_fn_t) (struct scsi_lu *);
>
> int spc_lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn,
> match_table_t *t)
> {
> }
>
> spc_lu_config calls fn with t (which device code like smc passes) for
> non-standard params.
>

Starting to push my boundary of C knowledge here. But I think I
understand what you are trying to tell me. Its the only way to
learn...

I need some time to look at this (to make sure I do understand it)..

I'll look at this (this evening) and see what I come up with..

Cheers
Mark


From markh794 at gmail.com  Thu Jun 28 10:24:45 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 28 Jun 2007 18:24:45 +1000
Subject: [Stgt-devel] rework of smc module
Message-ID: <4683704D.70509@gmail.com>

OK - Not a patch but a 'proof oc concept' type patch.

If this method of lu_config() is ok, then I'll put together a proper patch.

Regards
Mark

diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
index d63668a..47e4912 100644
--- a/doc/README.lu_configuration
+++ b/doc/README.lu_configuration
@@ -84,6 +84,49 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
          --params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 
 
+SMC unique options
+------------------
+
+--params have several unique key=value pairs ontop of all other modules.
+ - element_type=<1|2|3|4>
+ - start_address=Number between 1 & 65535
+ - quantity=Number between 1 & 65535
+ - sides=1|2
+ - address=Number between 1 & 65535
+ - barcode="Char string up to 10 chars"
+ - tid=<number>
+ - lun=<number>
+
+Several of these parameters 'work together'
+
+e.g. To add 'quantity' slots as 'element_type' starting at 'start_address'
+ - element_type=<1|2|3|4>
+ - start_address=Number between 1 & 65535
+ - quantity=Number between 1 & 65535
+
+Note: start_address + quantity should not overlap with any other slots..
+
+
+While 'configuring slot 'address' of 'element_type':
+ - Set barcode of meda (occupy slot)
+ - If element type is DATA TRANSFER DEVICE, then define TID & LUN of device.
+
+ - element_type=<1|2|3|4>
+ - address=Number between 1 & 65535
+ - barcode="String up to 10 chars"
+ - sides=<1|2>
+ - tid=<tid of device which belongs at this address>
+ - lun=<lun of device which belongs at this address>
+
+
+It is the responsibility of the user not to configure overlapping slots
+of differing types.
+
+Slot types:
+ 1 -> Medium Transport (picker arm)
+ 2 -> Storage Element
+ 3 -> Import/Export Element
+ 4 -> Data Transfer device (CD drive, tape drive, MO drive etc)
 
 Please refer to scripts/tgt-core-test for a working example.
 
diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
index a31be1b..b2ab6c0 100755
--- a/scripts/tgt-core-test
+++ b/scripts/tgt-core-test
@@ -17,15 +17,6 @@ fi
 if [ ! -f $HOME/hd_block ]; then
 	dd if=/dev/zero of=$HOME/hd_block bs=1M count=8
 fi
-if [ ! -f $HOME/cd_block0 ]; then
-	dd if=/dev/zero of=$HOME/cd_block0 bs=1M count=8
-fi
-if [ ! -f $HOME/cd_block1 ]; then
-	dd if=/dev/zero of=$HOME/cd_block1 bs=1M count=8
-fi
-if [ ! -f $HOME/cd_block2 ]; then
-	dd if=/dev/zero of=$HOME/cd_block2 bs=1M count=8
-fi
 
 set -x
 
@@ -85,10 +76,13 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 
 
-
 for LUN in 2 3 4; do
+	if [ ! -f $HOME/cdrom$LUN ]; then
+		dd if=/dev/zero of=$HOME/cdrom$LUN bs=1M count=8
+	fi
+
 	# Create LUN - CD/ROM
-	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
+	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cdrom$LUN --device-type=cd
 	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 		--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY1$LUN,removable=1
 	# Vendor Uniq - Mode page 0..
@@ -102,6 +96,86 @@ for LUN in 2 3 4; do
 		--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 done
 
+###############################################################################
+# Set up SMC Medium Changer
+###############################################################################
+LUN=5
+if [ ! -f $HOME/smc ]; then
+	dd if=/dev/zero of=$HOME/smc bs=1k count=1
+fi
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN \
+			-b $HOME/smc --device-type=changer
+
+#### Set up mode pages ####
+# From smc3-06.pdf
+# Page 0x02: Disconnect/Reconnect SPC-3
+# Page 0x0a: Control SPC-3
+# Page 0x18: Protocol Specific LUN SPC-3
+# Page 0x19: Protocol Specific Port SPC-3
+# Page 0x1a: Power Condition SPC-3
+# Page 0x1c: Informational Exceptions Control SPC-3
+# Page 0x1d: Element Address Assignment SMC-3 7.3.4
+# Page 0x1e: Transport Geometry Parameters SMC-3 7.3.5
+# Page 0x1f: Device Capabilities SMC-3 7.3.2
+# Page 0x1f/Subpage 0x41: Extended Device Capabilities SMC-3 7.3.3
+
+# Dummy 'page 0'
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0:0:0
+# Disconnect/Reconnect
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+# Power Condition
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1a:0:18:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
+# Informational Exceptions Control Mode Page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+# Element Address Assignment - Setup afterwards.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1d:0:0x12:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
+# Transport Geometry Parameters
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1e:0:2:0:0
+# Device Capabilities
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1f:0:0x12:0x0f:7:0x0f:0x0f:0x0f:0x0f:0:0:0:0:0x0f:0x0f:0x0f:0x0f:0:0:0:0
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params vendor_id=STK,product_id=L700,product_rev=0010,scsi_sn=XYZZY_0,removable=1
+
+
+## Add Data Transfer devices (3 drives)
+# Define slot address for devices.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,start_address=1,quantity=3
+# Now define which device at each address.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,address=1,tid=1,lun=2
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,address=2,tid=1,lun=3
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,address=3,tid=1,lun=4
+
+# Medium Transport Elements (robot arm / picker)
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=1,start_address=16,quantity=1
+
+## Storage Elements - 8 starting at addr 1024
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=2,start_address=1024,quantity=8
+# Add 'media' to slots
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=2,address=1024,barcode=ABC123,Sides=1
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=2,address=1026,barcode=ULT001L3,Sides=1
+
+# Import/Export Elements - 5 starting at addr 32
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=3,start_address=32,quantity=5
+
+
 # Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
 
diff --git a/usr/Makefile b/usr/Makefile
index 14be34b..c7fb2ca 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -43,8 +43,9 @@ INCLUDES += -I.
 CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
 
 PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o osd.o spt.o scc.o scsi.o log.o \
-	driver.o util.o work.o parser.o
+TGTD_OBJS += tgtd.o mgmt.o target.o \
+	spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o \
+	scsi.o log.o driver.o util.o work.o parser.o
 
 all: $(PROGRAMS)
 
diff --git a/usr/media.h b/usr/media.h
new file mode 100644
index 0000000..9b88765
--- /dev/null
+++ b/usr/media.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef _MEDIA_H_
+#define _MEDIA_H_
+
+enum c_type {	/* Cartridge Types - Ref: smc3r06 - Table 20, page 37 */
+	CART_UNSPECIFIED,
+	CART_DATA,
+	CART_CLEAN,
+	CART_DIAGNOSTICS,
+	CART_WORM,
+	CART_MICROCODE,
+};
+
+#endif /* _MEDIA_H_ */
+
diff --git a/usr/mmc.c b/usr/mmc.c
index 17cc741..a71568a 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -38,6 +38,7 @@
 #include "util.h"
 #include "tgtd.h"
 #include "target.h"
+#include "tgtadm_error.h"
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
@@ -174,10 +175,15 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+static int mmc_lu_config(struct scsi_lu *lu, char * params)
+{
+	return spc_lu_config(lu, params, NULL);
+}
+
 static struct device_type_template mmc_template = {
 	.type		= TYPE_ROM,
 	.lu_init	= mmc_lu_init,
-	.lu_config	= spc_lu_config,
+	.lu_config	= mmc_lu_config,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/osd.c b/usr/osd.c
index a48db32..0d8457a 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -29,6 +29,7 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "tgtadm_error.h"
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
@@ -68,9 +69,15 @@ static int osd_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+static int osd_lu_config(struct scsi_lu *lu, char * params)
+{
+	return spc_lu_config(lu, params, NULL);
+}
+
 static struct device_type_template osd_template = {
 	.type		= TYPE_OSD,
 	.lu_init	= osd_lu_init,
+	.lu_config	= osd_lu_config,
 	.ops		= {
 		[0x00 ... 0x0f] = {spc_illegal_op},
 
diff --git a/usr/sbc.c b/usr/sbc.c
index 5996081..70ea127 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -34,6 +34,7 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "tgtadm_error.h"
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
@@ -222,10 +223,15 @@ static int sbc_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+static int sbc_lu_config(struct scsi_lu *lu, char *params)
+{
+	return spc_lu_config(lu, params, NULL);
+}
+
 static struct device_type_template sbc_template = {
 	.type		= TYPE_DISK,
 	.lu_init	= sbc_lu_init,
-	.lu_config	= spc_lu_config,
+	.lu_config	= sbc_lu_config,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/scc.c b/usr/scc.c
index 0a154a5..2977dd6 100644
--- a/usr/scc.c
+++ b/usr/scc.c
@@ -50,10 +50,15 @@ static int scc_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+static int scc_lu_config(struct scsi_lu *lu, char *params)
+{
+	return spc_lu_config(lu, params, NULL);
+}
+
 static struct device_type_template scc_template = {
 	.type		= TYPE_RAID,
 	.lu_init	= scc_lu_init,
-	.lu_config	= spc_lu_config,
+	.lu_config	= scc_lu_config,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/sense_codes.h b/usr/sense_codes.h
index 210753a..5de28dc 100644
--- a/usr/sense_codes.h
+++ b/usr/sense_codes.h
@@ -1,7 +1,7 @@
 /*
  * The SCSI sense key Additional Sense Code / Additional Sense Code Qualifier
  *
- * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
+ * Reference : www.t10.org
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/usr/smc.c b/usr/smc.c
new file mode 100644
index 0000000..4dcfad3
--- /dev/null
+++ b/usr/smc.c
@@ -0,0 +1,824 @@
+/*
+ * SCSI Medium Changer command processing
+ * Based on smc3r06.pdf document from t10.org
+ *
+ * (C) 2004-2007 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
+ * (C) 2007      Mark Harvey <markh794 at gmail.com>
+ *
+ * SCSI target emulation code is based on Ardis's iSCSI implementation.
+ *   http://www.ardistech.com/iscsi/
+ *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
+ *   licensed under the terms of the GNU GPL v2.0,
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <errno.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <linux/fs.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "driver.h"
+#include "tgtadm_error.h"
+#include "scsi.h"
+#include "spc.h"
+#include "sense_codes.h"
+#include "parser.h"
+#include "smc.h"
+#include "media.h"
+
+struct slot *slot_lookup(struct list_head *head, int element_type, int address);
+static void set_slot_full(struct slot *s, uint16_t src);
+static void set_slot_empty(struct slot *s);
+static int test_slot_full(struct slot *s);
+struct lu_phy_attr *lu_attr_lookup(int tid, uint64_t lun);
+
+/* ********************************************************
+ * READ_ELEMENT_STATUS
+ *
+ * Ref: Working Draft SCSI Media Changer-3 (smc3r06.pdf), chapter 6.10
+ *
+ * The READ ELEMENT STATUS command request that the device server report the
+ * status of its internal elements to the application client.
+ * Support for READ ELEMENT STATUS command is mandatory.
+ * ******************************************************** */
+static int determine_element_sz(uint8_t dvcid, uint8_t voltag)
+{
+	if (voltag)
+		return (dvcid) ? 86 : 52;
+	else
+		return (dvcid) ? 50 : 16;
+}
+
+/* Fill in Element Status Header - Always 8 bytes long */
+static int element_status_data_hdr(uint8_t *data, uint8_t dvcid,
+					uint8_t voltag, int start, int count)
+{
+	int element_sz;
+	int size;
+
+	element_sz = determine_element_sz(dvcid, voltag);
+
+	/* First Element address reported */
+	*(uint16_t *)(data) = __cpu_to_be16(start);
+
+	/* Number of elements available */
+	*(uint16_t *)(data + 2) = __cpu_to_be16(count);
+
+	/* Byte count is the length required to return all valid data.
+	 * Allocated length is how much data the initiator will accept */
+	size = ((8 + (count * element_sz)) & 0xffffff);
+	*(uint32_t *)(data + 4) = __cpu_to_be32(size);
+
+return size;
+}
+
+static int add_element_descriptor(uint8_t *data, struct slot *s,
+			uint8_t element_type, uint8_t dvcid, uint8_t voltag)
+{
+	struct lu_phy_attr *attr = NULL;
+	int i;	/* data[] index */
+
+	*(uint16_t *)(data) = __cpu_to_be16(s->slot_addr);
+	data[2] = s->status;
+	data[3] = 0;	/* Reserved */
+	data[4] = (s->asc >> 8) & 0xff;	/* Additional Sense Code */
+	data[5] = s->asc & 0xff;	/* Additional Sense Code Qualifier */
+	/* [6], [7] & [8] reserved */
+	data[9] = (s->cart_type & 0xf);
+	if (s->last_addr) {	/* Source address is valid ? */
+		data[9] |= 0x80;
+		*(uint16_t *)(data + 10) = __cpu_to_be16(s->last_addr);
+	}
+	i = 12;
+	if (voltag) {
+		if (s->barcode[0] == ' ')
+			memset( &data[i], 0x20, 32); /* Pad with spaces */
+		else
+			snprintf((char *)&data[i], 32, "%-32s", s->barcode);
+
+		/* Reserve additional 4 bytes if dvcid is set */
+		i += (dvcid) ? 36 : 32;
+	}
+	if (element_type == ELEMENT_DATA_TRANSFER)
+		attr = lu_attr_lookup(s->drive_tid, s->drive_lun);
+	if (dvcid && attr) {
+		data[i] = 2;	/* ASCII code set */
+		data[i + 1] = attr->device_type;
+		data[i + 2] = 0;	/* reserved */
+		data[i + 3] = 34;	/* Length */
+		snprintf((char *)&data[i + 4], 9, "%-8s", attr->vendor_id);
+		snprintf((char *)&data[i + 12], 17, "%-16s", attr->product_id);
+		snprintf((char *)&data[i + 28], 11, "%-10s", attr->scsi_sn);
+	}
+
+return determine_element_sz(dvcid, voltag);
+}
+
+/* Fill in Element details
+ *
+ * Fill each Element Descriptor for slot *s
+ *
+ * data : pointer
+ * head : Slot struct head
+ * element_type : Slot type we are interested in.
+ * first : Return address of first slot found
+ * start : Start processing from this element #
+ * dvcid : Device ID
+ * voltag : Volume tag (barcode)
+ *
+ * Return number of elements
+ */
+static int build_element_descriptors(uint8_t *data, struct list_head *head,
+					uint8_t elem_type, int *first,
+					uint16_t start,
+					uint8_t dvcid, uint8_t voltag)
+{
+	struct slot *s;
+	int count = 0;
+	int len = 8;
+	int elem_sz = determine_element_sz(dvcid, voltag);
+
+	list_for_each_entry(s, head, slot_siblings) {
+		if (s->element_type == elem_type) {
+			if (s->slot_addr >= start) {
+				count++;
+				len += add_element_descriptor(&data[len],
+						s, elem_type, dvcid, voltag);
+			}
+		}
+		if (count == 1)	/* Record first found slot Address */
+			*first = s->slot_addr;
+	}
+
+	/* Fill in Element Status Page Header */
+	data[0] = elem_type;
+	data[1] = (voltag) ? 0x80 : 0;	/* Primary Vol Tag set */
+	*(uint16_t *)(data + 2) = __cpu_to_be16(elem_sz);
+
+	/* Total number of bytes in all element descriptors */
+	*(uint32_t *)(data + 4) = __cpu_to_be32((elem_sz * count) & 0xffffff);
+
+return count;
+}
+
+/* *********************************************
+ * READ ELEMENT STATUS op code
+ * ********************************************* */
+static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
+{
+	struct smc_info *smc = (struct smc_info *)cmd->dev->smc_p;
+	uint8_t *data;
+	uint8_t *scb;
+	uint8_t element_type;
+	uint8_t voltag;
+	uint16_t req_start_elem;
+//	FIXME: Take into account number of slots requested..
+//	uint16_t	number = __be16_to_cpu(*(uint16_t *)(scb[4]));
+	uint8_t dvcid;		/* Device ID */
+	uint32_t alloc_len;
+	uint16_t count = 0;
+	int first = 0;		/* First valid slot location */
+	int len = 8;
+	int elementSize;
+	int ret;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+
+	scb = cmd->scb;
+	element_type = scb[1] & 0x0f;
+	voltag	= (scb[1] & 0x10) >> 4;
+	dvcid = scb[6] & 0x01;
+	req_start_elem = __be16_to_cpu(*(uint16_t *)(scb + 2));
+	alloc_len = 0xffffff & __be32_to_cpu(*(uint32_t *)(scb + 6));
+
+	elementSize = determine_element_sz(dvcid, voltag);
+
+	cmd->len = 0;
+	if (cmd->dev) {
+		ret = device_reserved(cmd);
+		if (ret) {
+			dprintf("Reservation Conflict\n");
+			return SAM_STAT_RESERVATION_CONFLICT;
+		}
+	}
+
+	if (pagesize < alloc_len) {
+		dprintf("Can't allocate enough memory for cmd\n");
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	if ((data = valloc(pagesize)) == NULL) {
+		dprintf("valloc(%lu) failed\n", pagesize);
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	if (scb[11])	/* Reserved byte */
+		goto sense;
+
+	switch(element_type) {
+	case ELEMENT_ANY:
+		/* Return element in type order */
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MEDIUM_TRANSPORT, &first,
+					req_start_elem,
+					dvcid, voltag);
+		len = count * elementSize;
+		count += build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_STORAGE, &first,
+					req_start_elem,
+					dvcid, voltag);
+		len += count * elementSize;
+		count += build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MAP, &first,
+					req_start_elem,
+					dvcid, voltag);
+		len += count * elementSize;
+		count += build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_DATA_TRANSFER, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	case ELEMENT_MEDIUM_TRANSPORT:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MEDIUM_TRANSPORT, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	case ELEMENT_STORAGE:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_STORAGE, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	case ELEMENT_MAP:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MAP, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	case ELEMENT_DATA_TRANSFER:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_DATA_TRANSFER, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	default:
+		goto sense;
+		break;
+	}
+
+	/* Lastly, fill in data header */
+	len = element_status_data_hdr(data, dvcid, voltag, first, count);
+
+	cmd->len = min_t(int, len, alloc_len);
+	cmd->uaddr = (unsigned long) data;
+	cmd->rw = READ;
+
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+/* *********************************************
+ * MOVE MEDIUM op code
+ * ********************************************* */
+static int smc_move_medium(int host_no, struct scsi_cmd *cmd)
+{
+	struct smc_info *smc = (struct smc_info *)cmd->dev->smc_p;
+	uint8_t *scb;
+	uint16_t src;
+	uint16_t dest;
+	uint8_t invert;
+	struct slot *src_slot = NULL;
+	struct slot *dest_slot = NULL;
+	struct slot *s;
+	int key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+
+	scb = cmd->scb;
+	src = __be16_to_cpu(*(uint16_t *)(scb + 4));
+	dest = __be16_to_cpu(*(uint16_t *)(scb + 6));
+	invert = scb[10] & 1;
+
+	list_for_each_entry(s, &smc->slots, slot_siblings) {
+		if (s->slot_addr == src)
+			src_slot = s;
+		if (s->slot_addr == dest)
+			dest_slot = s;
+	}
+
+	if (src_slot) {
+		if (!test_slot_full(src_slot)) {
+			asc = ASC_MEDIUM_SRC_EMPTY;
+			goto sense;
+		}
+	} else	/* Could not find src slot - Error */
+		goto sense;
+
+	if (dest_slot) {
+		if (test_slot_full(dest_slot)) {
+			asc = ASC_MEDIUM_DEST_FULL;
+			goto sense;
+		}
+	} else	/* Could not find dest slot - Error */
+		goto sense;
+
+	if (invert)
+		if (s->sides == 1)	/* Use default INVALID FIELD IN CDB */
+			goto sense;
+
+	memcpy(&dest_slot->barcode, &src_slot->barcode, sizeof(s->barcode));
+	set_slot_empty(src_slot);
+	set_slot_full(dest_slot, src);
+	cmd->len = 0;
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+/* *********************************************
+ * ****       House keeping routines        ****
+ * ********************************************* */
+
+/* Any housekeeping required at logical unit setup */
+static int smc_lu_init(struct scsi_lu *lu)
+{
+	struct smc_info *smc;
+
+	smc = zalloc(sizeof(struct smc_info));
+	if (smc)
+		lu->smc_p = smc;
+	else
+		return -ENOMEM;
+
+	spc_lu_init(lu);
+
+	strncpy(lu->attrs.product_id, "VIRTUAL-CHANGER",
+						sizeof(lu->attrs.product_id));
+	lu->attrs.version_desc[0] = 0x0480; /* SMC-3 no version claimed */
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
+
+	INIT_LIST_HEAD(&lu->mode_pages);
+
+	/* Vendor uniq - However most apps seem to call for mode page 0*/
+	add_mode_page(lu, "0:0:0");
+	/* Control page */
+	add_mode_page(lu, "10:0:10:2:0:0:0:0:0:0:0:2:0");
+	/* Power Condition */
+	add_mode_page(lu, "0x1a:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Informational Exceptions Control page */
+	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Address Assignment */
+	add_mode_page(lu, "0x1d:0:0x12:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0");
+	/* Transport Geometry Params */
+	add_mode_page(lu, "0x1e:0:2:0:0");
+	/* Device Capabilities */
+	add_mode_page(lu, "0x1f:0:0x12:15:7:15:15:15:15:0:0:0:0:15:15:15:15:0:0:0:0");
+
+	INIT_LIST_HEAD(&smc->slots);
+
+	lu->attrs.online = 1;	/* Library will now report as Online */
+	lu->attrs.reset = 1;	/* Poweron/reset occurred */
+	lu->attrs.removable = 1; /* Default to removable media */
+
+	return 0;
+}
+
+/* Any housekeeping required at shutdown */
+static void smc_lu_exit(struct scsi_lu *lu)
+{
+	struct smc_info *smc = lu->smc_p;
+
+	dprintf("Medium Changer shutdown() called\n");
+
+	free(smc);
+}
+
+/* **************************************
+ * General utilities related to slot(s)
+ * **************************************/
+/* Set slot status to full */
+static void set_slot_full(struct slot *s, uint16_t src)
+{
+	s->status |= 1;
+	s->last_addr=src;
+}
+
+/* Set slot status to empty */
+static void set_slot_empty(struct slot *s)
+{
+	s-> status &= 0xfe;
+	s->last_addr=0;
+	memset(s->barcode, ' ', sizeof(s->barcode));
+}
+
+static int test_slot_full(struct slot *s)
+{
+	return s->status && 1;
+}
+
+static int slot_insert(struct list_head *head, int element_type, int address)
+{
+	struct slot *s;
+
+	if ((s = zalloc(sizeof(struct slot))) == NULL)
+		return TGTADM_NOMEM;
+
+	s->slot_addr = address;
+	s->element_type = element_type;
+	s->sides = 1;
+	if (element_type == ELEMENT_DATA_TRANSFER)	/* Drive */
+		s->asc = ASC_INITIALIZING_REQUIRED;
+
+	list_add_tail(&s->slot_siblings, head);
+
+	return 0;
+}
+
+/*
+ * If both address & element type specified, check both values,
+ * else just check param that is defined.
+ *
+ * Return NULL if record not found.
+ */
+struct slot *slot_lookup(struct list_head *head, int element_type, int address)
+{
+	struct slot *s;
+
+	list_for_each_entry(s, head, slot_siblings) {
+		if (element_type && address) {
+			if ((s->slot_addr == address) &&
+					(s->element_type == element_type))
+				return s;
+		} else if (element_type) {
+			if (s->element_type == element_type)
+				return s;
+		} else if (address) {
+			if (s->slot_addr == address)
+				return s;
+		}
+	}
+	return NULL;
+}
+
+static void slot_dump(struct list_head *head)
+{
+	struct slot *s;
+
+	list_for_each_entry(s, head, slot_siblings)
+		if (s) {
+			dprintf("Slot %d Information\n", s->slot_addr);
+			dprintf("  Last Addr: %d\n", s->last_addr);
+			dprintf("  Type: %d\n", s->element_type);
+			dprintf("  Barcode: %s\n", s->barcode);
+			dprintf("  TID : %d\n", s->drive_tid);
+			dprintf("  LUN : %" PRIu64 "\n", s->drive_lun);
+			dprintf("  ASC/ASCQ : %d\n\n", s->asc);
+		}
+}
+
+/* **************************************
+ * Adding Slots within the SMC device
+ * **************************************/
+static int add_slt(struct scsi_lu *lu, int element_type, int start_addr, int quantity)
+{
+	struct smc_info *smc = lu->smc_p;
+	int ret = TGTADM_INVALID_REQUEST;
+	struct mode *m;
+	struct slot *s;
+	uint16_t *element;
+	int sv_addr;
+	int qnty_save;
+	int i;
+
+	/* Update MODE PAGE 0x1d params */
+	if ((m = mode_page_lookup(&lu->mode_pages, 0x1d)) == NULL) {
+		dprintf("Failed to find Element Address Assignment mode pg\n");
+		return TGTADM_UNKNOWN_ERR;
+	}
+	element = (uint16_t *)m->mode_data;
+
+	if (element_type && start_addr && quantity) {
+		/* Fiddle with element offset.*/
+		switch(element_type) {
+		case ELEMENT_MEDIUM_TRANSPORT:	/* Medium Transport */
+			break;
+		case ELEMENT_MAP:		/* Import/Export Elements */
+			element += 4;
+			break;
+		case ELEMENT_STORAGE:		/* Storage Elements */
+			element += 2;
+			break;
+		case ELEMENT_DATA_TRANSFER:	/* Data Transfer Elements */
+			element += 6;
+			break;
+		default:
+			goto dont_do_slots;
+			break;
+		}
+
+		/* Get existing values */
+		sv_addr = __be16_to_cpu(element[0]);
+		qnty_save  = __be16_to_cpu(element[1]);
+
+		/* Add existing values + passed params to config */
+		if (sv_addr)
+			element[0] =
+				__cpu_to_be16(min_t(int, start_addr, sv_addr));
+		else
+			element[0] = __cpu_to_be16(start_addr);
+		element[1] = __cpu_to_be16(quantity + qnty_save);
+
+		s = slot_lookup(&smc->slots, element_type, start_addr);
+		if (s)	// Opps... Found a slot at this address..
+			goto dont_do_slots;
+
+		ret = TGTADM_SUCCESS;
+		for(i=start_addr; i < (start_addr + quantity); i++)
+			if (slot_insert(&smc->slots, element_type, i))
+				ret = TGTADM_INVALID_REQUEST;
+	}
+
+dont_do_slots:
+	return ret;
+}
+
+/* **************************************
+ * Configuring Slots within the SMC device
+ * **************************************/
+static int config_slot(struct scsi_lu *lu, int element_type,
+		int address, int tid, uint64_t lun, char *barcode, int sides)
+{
+	struct smc_info *smc = lu->smc_p;
+	struct mode *m = NULL;
+	struct slot *s = NULL;
+	int ret = TGTADM_INVALID_REQUEST;
+
+	switch(element_type) {
+	case ELEMENT_MEDIUM_TRANSPORT:
+		/* If medium has more than one side, set the 'rotate' bit */
+		m = mode_page_lookup(&lu->mode_pages, 0x1e);
+		if (m) {
+			m->mode_data[0] = (sides > 1) ? 1 : 0;
+			ret = TGTADM_SUCCESS;
+		}
+		break;
+	case ELEMENT_STORAGE:
+	case ELEMENT_MAP:
+		if ((s = slot_lookup(&smc->slots, element_type, address)) == NULL)
+			break;	// Slot not found..
+		strncpy(s->barcode, barcode, sizeof(s->barcode));
+		set_slot_full(s, 0);
+		ret = TGTADM_SUCCESS;
+		break;
+	case ELEMENT_DATA_TRANSFER:
+		if (!tid)
+			break;	/* Fail if no TID specified */
+		if ((s = slot_lookup(&smc->slots, element_type, address)) == NULL)
+			break;	// Slot not found..
+		s->asc  = NO_ADDITIONAL_SENSE;
+		s->drive_tid = tid;
+		s->drive_lun = lun;
+		ret = TGTADM_SUCCESS;
+		break;
+	}
+	return ret;
+}
+
+/* ***********************************
+ * Command argument processing
+ * ***********************************/
+#define ADD	1
+#define CONFIGURE 2
+
+static int __smc_lu_config(struct scsi_lu *lu, char *params)
+{
+	struct smc_info *smc = (struct smc_info *)lu->smc_p;
+	int err = 0;
+	char *p;
+	char barcode[20] = "";
+	char buf[20];
+	int operation = 0;
+	int element_type = 0;
+	int start_addr = 0;
+	int quantity = 0;
+	int sides = 1;
+	int address = 0;
+	int tid = 0;
+	uint64_t lun = 0;
+
+	while ((p = strsep(&params, ",")) != NULL) {
+		substring_t args[MAX_OPT_ARGS];
+		int token;
+		if (!*p)
+			continue;
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case Opt_element_type:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			element_type = atoi(buf);
+			break;
+		case Opt_start_address:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			start_addr = atoi(buf);
+			operation = ADD;
+			break;
+		case Opt_quantity:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			quantity = atoi(buf);
+			break;
+		case Opt_sides:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sides = atoi(buf);
+			break;
+		case Opt_address:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			address = atoi(buf);
+			operation = CONFIGURE;
+			break;
+		case Opt_barcode:
+			match_strncpy(barcode, &args[0], sizeof(barcode));
+			break;
+		case Opt_tid:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			tid = atoi(buf);
+			break;
+		case Opt_lun:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			lun = atoi(buf);
+			break;
+		case Opt_dump:
+			slot_dump(&smc->slots);
+			break;
+		default:
+			err = TGTADM_UNKNOWN_PARAM;
+		}
+	}
+
+	switch(operation) {
+		case ADD:
+			err = add_slt(lu, element_type, start_addr, quantity);
+			break;
+		case CONFIGURE:
+			err = config_slot(lu, element_type, address, tid,
+							lun, barcode, sides);
+			break;
+	}
+	return err;
+}
+
+static int smc_lu_config(struct scsi_lu *lu, char *params)
+{
+	int (*smc_p)(struct scsi_lu *lu, char *args) = __smc_lu_config;
+
+	return spc_lu_config(lu, params, smc_p);
+}
+
+/* ***********************************
+ * Device Template - entry routines
+ * ***********************************/
+struct device_type_template smc_template = {
+	.type		= TYPE_MEDIUM_CHANGER,
+	.lu_init	= smc_lu_init,
+	.lu_exit 	= smc_lu_exit,
+	.lu_config	= smc_lu_config,
+	.ops	= {
+		{spc_test_unit,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_request_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		/* 0x10 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_inquiry,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x20 ... 0x4f] = {spc_illegal_op,},
+
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x9f] = {spc_illegal_op,},
+
+		/* 0xA0 */
+		{spc_report_luns,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{smc_move_medium,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_test_unit,},
+
+		/* 0xB0 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{smc_read_element_status,},	// Mandatory
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0xc0 ... 0xff] = {spc_illegal_op},
+	}
+};
+
+__attribute__((constructor)) static void smc_init(void)
+{
+	device_type_register(&smc_template);
+}
diff --git a/usr/smc.h b/usr/smc.h
new file mode 100644
index 0000000..7c789e3
--- /dev/null
+++ b/usr/smc.h
@@ -0,0 +1,77 @@
+/*
+ * SCSI Medium Changer Command
+ *
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _SMC_H_
+#define _SMC_H_
+
+/**************************************************
+ * Slot description
+ **************************************************/
+#define ELEMENT_ANY		0
+#define	ELEMENT_MEDIUM_TRANSPORT	1
+#define	ELEMENT_STORAGE		2
+#define	ELEMENT_MAP		3
+#define	ELEMENT_DATA_TRANSFER	4
+
+struct slot {
+	struct	list_head	slot_siblings;
+	uint8_t		element_type;	/* Element Type 1, 2, 3 or 4 */
+	uint8_t		cart_type;	/* 0 Unspecified, 1 Data, 2 Cleaning */
+	uint16_t	slot_addr;	/* 65535 slots should be enough.. */
+	uint16_t	last_addr;	/* Where the media came from.. */
+	uint16_t	asc;		/* Additional sense code */
+	uint8_t		status;		/* Used for MAP status bits */
+	uint8_t		sides;		/* Number of sides this media. */
+	char		barcode[11];	/* Up to 10 char barcode */
+	/* Only used if slot contains a drive. */
+	uint8_t		drive_tid;
+	uint64_t	drive_lun;
+};
+
+/**************************************************
+ * Data structure for SMC device
+ * Top of the 'tree'
+ **************************************************/
+struct smc_info {
+	struct	list_head	slots;
+};
+
+enum {
+	Opt_element_type, Opt_start_address,
+	Opt_quantity, Opt_sides,
+	Opt_address, Opt_barcode,
+	Opt_tid, Opt_lun,
+	Opt_type, Opt_dump,
+	Opt_err,
+};
+
+static match_table_t tokens = {
+	{Opt_element_type, "element_type=%s"},
+	{Opt_start_address, "start_address=%s"},
+	{Opt_quantity, "quantity=%s"},
+	{Opt_sides, "sides=%s"},
+	{Opt_address, "address=%s"},
+	{Opt_barcode, "barcode=%s"},
+	{Opt_tid, "tid=%s"},
+	{Opt_lun, "lun=%s"},
+	{Opt_type, "type=%s"},
+	{Opt_dump, "dump=%s"},
+	{Opt_err, NULL},
+};
+#endif // _SMC_H_
diff --git a/usr/spc.c b/usr/spc.c
index 3eb605c..8df63d7 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -500,10 +500,24 @@ static match_table_t tokens = {
 	{Opt_err, NULL},
 };
 
-int spc_lu_config(struct scsi_lu *lu, char *params) {
+/*
+ * Parse options received from user.
+ *
+ * User options are in 'char * params', while any unprocessed options
+ * are copied into 'char * extra_args' for further processing by the
+ * 'target' from which it was called.
+ */
+int spc_lu_config(struct scsi_lu *lu, char *params,
+		int (*xxx_lu_config)(struct scsi_lu *lu, char *args))
+{
 	int err = 0;
 	char *p;
 	char buf[256];
+	char *extra_args;
+
+	extra_args = zalloc(strlen(params) + 1);
+	if (!extra_args)
+		return TGTADM_NOMEM;
 
 	if (!strncmp("targetOps", params, 9))
 		params = params + 10;
@@ -525,15 +539,15 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			break;
 		case Opt_vendor_id:
 			match_strncpy(lu->attrs.vendor_id, &args[0],
-					sizeof(lu->attrs.vendor_id));
+					sizeof(lu->attrs.vendor_id) - 1);
 			break;
 		case Opt_product_id:
 			match_strncpy(lu->attrs.product_id, &args[0],
-					sizeof(lu->attrs.product_id));
+					sizeof(lu->attrs.product_id) - 1);
 			break;
 		case Opt_product_rev:
 			match_strncpy(lu->attrs.product_rev, &args[0],
-					sizeof(lu->attrs.product_rev));
+					sizeof(lu->attrs.product_rev) - 1);
 			break;
 		case Opt_sense_format:
 			match_strncpy(buf, &args[0],  sizeof(buf));
@@ -551,10 +565,19 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			match_strncpy(buf, &args[0], sizeof(buf));
 			err = add_mode_page(lu, buf);
 			break;
-		default:
+		default:	/* Append any unprocessed args to ret_param */
+			strcat(extra_args, p);
+			strcat(extra_args, ",");
 			err = TGTADM_INVALID_REQUEST;
 		}
 	}
+
+	/* Call module uniq param handling routine */
+	if (strlen(extra_args) && xxx_lu_config)
+		err = xxx_lu_config(lu, extra_args);
+
+	free(extra_args);
+
 	return err;
 }
 
@@ -565,8 +588,9 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
  */
 int spc_lu_init(struct scsi_lu *lu)
 {
-	strncpy(lu->attrs.vendor_id, VENDOR_ID, sizeof(lu->attrs.vendor_id));
-	memcpy(lu->attrs.product_rev, "0001", 4);
+	snprintf(lu->attrs.vendor_id, sizeof(lu->attrs.vendor_id) - 1,
+							"%-16s", VENDOR_ID);
+	snprintf(lu->attrs.product_rev, 4, "%s", "0001");
 	lu->attrs.removable = 0;
 	lu->attrs.sense_format = 0;
 	lu->attrs.online = 0;
diff --git a/usr/spc.h b/usr/spc.h
index c7e38c0..47c1dc6 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -16,7 +16,8 @@ extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
 extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
 extern int spc_lu_init(struct scsi_lu *lu);
-extern int spc_lu_config(struct scsi_lu *lu, char * params);
+extern int spc_lu_config(struct scsi_lu *lu, char *params,
+		int (*func)(struct scsi_lu *lu, char *args));
 extern void dump_cdb(struct scsi_cmd *cmd);
 extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
 struct mode *mode_page_lookup(struct list_head *head, uint8_t page);
diff --git a/usr/target.c b/usr/target.c
index d3c9cb8..997f3f2 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -341,6 +341,17 @@ int tgt_device_destroy(int tid, uint64_t lun, int force)
 	return 0;
 }
 
+struct lu_phy_attr *lu_attr_lookup(int tid, uint64_t lun)
+{
+	struct target *target;
+	struct scsi_lu *lu;
+
+	lu = __device_lookup(tid, lun, &target);
+	if (!lu)
+		return NULL;
+	return &lu->attrs;
+}
+
 int device_reserve(struct scsi_cmd *cmd)
 {
 	struct scsi_lu *lu;
diff --git a/usr/tgtadm.c b/usr/tgtadm.c
index c2315b6..0631a7d 100644
--- a/usr/tgtadm.c
+++ b/usr/tgtadm.c
@@ -300,6 +300,8 @@ static int str_to_device_type(char *str)
 		exit(EINVAL);
 	} else if (!strcmp(str, "cd"))
 		return TYPE_ROM;
+	else if (!strcmp(str, "changer"))
+		return TYPE_MEDIUM_CHANGER;
 	else if (!strcmp(str, "osd"))
 		return TYPE_OSD;
 	else if (!strcmp(str, "pt"))
diff --git a/usr/tgtd.h b/usr/tgtd.h
index bbacae2..02a834b 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -73,7 +73,7 @@ struct backingstore_template {
 	int (*bs_open)(struct scsi_lu *dev, char *path, int *fd, uint64_t *size);
 	void (*bs_close)(struct scsi_lu *dev);
 	int (*bs_cmd_submit)(struct scsi_cmd *cmd);
-	int (*bs_cmd_done) (struct scsi_cmd *cmd);
+	int (*bs_cmd_done)(struct scsi_cmd *cmd);
 };
 
 struct scsi_lu {
@@ -100,8 +100,11 @@ struct scsi_lu {
 	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
 	struct list_head mode_pages;
 
-	/* TODO: needs a structure for lots of device parameters */
 	struct lu_phy_attr attrs;
+
+	/* TODO: needs a structure for lots of device parameters */
+	/* Currently only used by smc module */
+	void *smc_p;
 };
 
 struct scsi_cmd {





From fujita.tomonori at lab.ntt.co.jp  Thu Jun 28 12:41:14 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 28 Jun 2007 19:41:14 +0900 (JST)
Subject: [Stgt-devel] rework of smc module
In-Reply-To: <4683704D.70509@gmail.com>
References: <4683704D.70509@gmail.com>
Message-ID: <20070628193343E.fujita.tomonori@lab.ntt.co.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: Re: [Stgt-devel] rework of smc module
Date: Thu, 28 Jun 2007 18:24:45 +1000

> OK - Not a patch but a 'proof oc concept' type patch.
> 
> If this method of lu_config() is ok, then I'll put together a proper patch.

I'm thinking about something like this patch.

BTW, could you fix some of the comments in this patch? And please use
the kernel-doc format when commenting functions. Here's an example:

/**
 * sas_remove_children  --  tear down a devices SAS data structures
 * @dev:	device belonging to the sas object
 *
 * Removes all SAS PHYs and remote PHYs for a given object
 */
void sas_remove_children(struct device *dev)
{
	....
}

Note that I don't ask you to comment every functions. It's ok if you
comment only functions that you want to comment.


diff --git a/usr/sbc.c b/usr/sbc.c
index c0075e4..a0c2d34 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -39,6 +39,9 @@
 #include "scsi.h"
 #include "spc.h"
 
+#include "parser.h"
+#include "tgtadm_error.h"
+
 #define BLK_SHIFT	9
 
 static int sbc_rw(int host_no, struct scsi_cmd *cmd)
@@ -315,10 +318,48 @@ static int sbc_lu_init(struct scsi_lu *lu)
 	return 0;
 }
 
+enum {
+	Opt_hoge1, Opt_hoge2,
+	Opt_err,
+};
+
+static match_table_t tokens = {
+	{Opt_hoge1, "hoge1=%s"},
+	{Opt_hoge2, "hoge2=%s"},
+	{Opt_err, NULL},
+};
+
+static int __sbc_lu_config(struct scsi_lu *lu, char *p)
+{
+	substring_t args[MAX_OPT_ARGS];
+	int token, ret = 0;
+	char buf[64];
+
+	token = match_token(p, tokens, args);
+	switch (token) {
+	case Opt_hoge1:
+		match_strncpy(buf, &args[0], sizeof(buf));
+		eprintf("hoge1: %s\n", buf);
+		break;
+	case Opt_hoge2:
+		match_strncpy(buf, &args[0], sizeof(buf));
+		eprintf("hoge2: %s\n", buf);
+		break;
+	default:
+		ret = TGTADM_INVALID_REQUEST;
+	}
+	return ret;
+}
+
+static int sbc_lu_config(struct scsi_lu *lu, char *params)
+{
+	return lu_config(lu, params, __sbc_lu_config);
+}
+
 static struct device_type_template sbc_template = {
 	.type		= TYPE_DISK,
 	.lu_init	= sbc_lu_init,
-	.lu_config	= spc_lu_config,
+	.lu_config	= sbc_lu_config,
 	.ops		= {
 		{spc_test_unit,},
 		{spc_illegal_op,},
diff --git a/usr/spc.c b/usr/spc.c
index 1c363cd..8a8ee72 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -295,7 +295,8 @@ static match_table_t tokens = {
 	{Opt_err, NULL},
 };
 
-int spc_lu_config(struct scsi_lu *lu, char *params) {
+int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
+{
 	int err = 0;
 	char *p;
 	char buf[20];
@@ -343,12 +344,17 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			lu->attrs.online = atoi(buf);
 			break;
 		default:
-			err = TGTADM_INVALID_REQUEST;
+			err = fn ? fn(lu, p) : TGTADM_INVALID_REQUEST;
 		}
 	}
 	return err;
 }
 
+int spc_lu_config(struct scsi_lu *lu, char *params)
+{
+	return lu_config(lu, params, NULL);
+}
+
 int spc_lu_init(struct scsi_lu *lu)
 {
 	strncpy(lu->attrs.vendor_id, VENDOR_ID, sizeof(lu->attrs.vendor_id));
diff --git a/usr/spc.h b/usr/spc.h
index 1036b70..98e1448 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -8,7 +8,10 @@ extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
 extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
 extern int spc_lu_init(struct scsi_lu *lu);
-extern int spc_lu_config(struct scsi_lu *lu, char * params);
+
+typedef int (match_fn_t)(struct scsi_lu *, char *);
+extern int lu_config(struct scsi_lu *lu, char *params, match_fn_t *);
+extern int spc_lu_config(struct scsi_lu *lu, char *params);
 extern void dump_cdb(struct scsi_cmd *cmd);
 
 #endif


From markh794 at gmail.com  Thu Jun 28 13:04:13 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 28 Jun 2007 21:04:13 +1000
Subject: [Stgt-devel] [Patch 1/3] Rework of mnemonic ASC/ASCQ values
In-Reply-To: <467CD5C8.2090108@gmail.com>
References: <467CD5C8.2090108@gmail.com>
Message-ID: <468395AD.50805@gmail.com>

Another version of this patch (with simplification of sense_data_build()

Cheers
Mark


diff --git a/usr/bs_sync.c b/usr/bs_sync.c
index 6789b5b..4986c59 100644
--- a/usr/bs_sync.c
+++ b/usr/bs_sync.c
@@ -37,6 +37,7 @@
 #include "util.h"
 #include "tgtd.h"
 #include "scsi.h"
+#include "sense_codes.h"
 
 #define NR_WORKER_THREADS	4
 
@@ -161,7 +162,7 @@ static void *bs_sync_worker_fn(void *arg)
 			eprintf("io error %p %x %d %d %" PRIu64 ", %m\n",
 				cmd, cmd->scb[0], ret, cmd->len, cmd->offset);
 			cmd->result = SAM_STAT_CHECK_CONDITION;
-			sense_data_build(cmd, MEDIUM_ERROR, 0x11, 0x0);
+			sense_data_build(cmd, MEDIUM_ERROR, ASC_READ_ERROR);
 		}
 
 		pthread_mutex_lock(&info->finished_lock);
diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index 5a2f8fe..8cfc8d6 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -44,6 +44,7 @@
 #include "target.h"
 #include "driver.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
 #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
@@ -140,7 +141,8 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data, *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
@@ -148,7 +150,7 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -173,7 +175,7 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -194,7 +196,8 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 	int idx, alen, oalen, nr_luns, rbuflen = 4096;
 	int *len = &cmd->len;
 	uint8_t *lun_buf = cmd->lun;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 
 	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
 	if (alen < 16)
@@ -203,7 +206,7 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -241,7 +244,7 @@ done:
 	return SAM_STAT_GOOD;
 sense:
 	*len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
diff --git a/usr/mmc.c b/usr/mmc.c
index 10b0e3f..defe60b 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -41,6 +41,7 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define MMC_BLK_SHIFT 11
 
@@ -53,7 +54,7 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
 	if (ret) {
 		cmd->offset = 0;
 		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LUN_NOT_SUPPORTED);
 		return SAM_STAT_CHECK_CONDITION;
 	} else {
 		cmd->mmapped = 1;
@@ -69,7 +70,7 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		cmd->len = 0;
-		sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		sense_data_build(cmd, HARDWARE_ERROR, ASC_INTERNAL_TGT_FAILURE);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
@@ -105,7 +106,7 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		cmd->len = 0;
-		sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
+		sense_data_build(cmd, HARDWARE_ERROR, ASC_INTERNAL_TGT_FAILURE);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
diff --git a/usr/osd.c b/usr/osd.c
index a7b92ba..048d0c8 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -33,16 +33,15 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 {
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
-
 	dprintf("cdb[0] %x datalen %u\n", cmd->scb[0], cmd->len);
 	if (cmd->scb[7] != 200 - 8) {
 		eprintf("request size %d wrong, should be 200\n",
 			cmd->scb[7] + 8);
-		sense_data_build(cmd, key, asc, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LUN_NOT_SUPPORTED);
 		cmd->len = 0;
 		return SAM_STAT_CHECK_CONDITION;
 	}
diff --git a/usr/sbc.c b/usr/sbc.c
index c0075e4..a62e6d8 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -38,13 +38,15 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define BLK_SHIFT	9
 
 static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 {
 	int ret;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_LUN_NOT_SUPPORTED;
 
 	ret = device_reserved(cmd);
 	if (ret)
@@ -65,7 +67,7 @@ static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 	} else {
 		cmd->mmapped = 1;
 		return SAM_STAT_GOOD;
@@ -74,7 +76,7 @@ static int sbc_rw(int host_no, struct scsi_cmd *cmd)
 	cmd->rw = READ;
 	cmd->offset = 0;
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -101,20 +103,21 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	uint32_t *data;
 	uint64_t size;
 	uint8_t *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_LUN_NOT_SUPPORTED;
 
 	if (device_reserved(cmd))
 		return SAM_STAT_RESERVATION_CONFLICT;
 
 	if (!(scb[8] & 0x1) & (scb[2] | scb[3] | scb[4] | scb[5])) {
-		asc = 0x24;
+		asc = ASC_INVALID_FIELD_IN_CDB;
 		goto sense;
 	}
 
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	cmd->uaddr = (unsigned long) data;
@@ -129,14 +132,15 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
 static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 {
 	int ret, len;
-	uint8_t key = ILLEGAL_REQUEST, asc;
+	uint8_t key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_LUN_NOT_SUPPORTED;
 
 	if (device_reserved(cmd))
 		return SAM_STAT_RESERVATION_CONFLICT;
@@ -152,7 +156,7 @@ static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 		 * what should I put for the asc/ascq?
 		 */
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	default:
 		len = 0;
@@ -161,7 +165,7 @@ static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
 
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -232,7 +236,8 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	uint8_t pcode = cmd->scb[2] & 0x3f;
 	uint64_t size;
 	uint8_t *data = NULL;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_LUN_NOT_SUPPORTED;
 
 	if (device_reserved(cmd))
 		return SAM_STAT_RESERVATION_CONFLICT;
@@ -240,7 +245,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -288,7 +293,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 		len += insert_iec_m_pg(data + len);
 		break;
 	default:
-		asc = 0x24;
+		asc = ASC_INVALID_FIELD_IN_CDB;
 		goto sense;
 	}
 
@@ -298,7 +303,7 @@ static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	return ret;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
diff --git a/usr/scsi.c b/usr/scsi.c
index 36722e1..beaa857 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -38,25 +38,24 @@
 #include "scsi.h"
 #include "spc.h"
 
-void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, uint8_t asq)
+void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t asc)
 {
+
 	if (cmd->dev->attrs.sense_format) {
 		/* descriptor format */
-
 		cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
 		cmd->sense_buffer[1] = key;
-		cmd->sense_buffer[2] = asc;
-		cmd->sense_buffer[3] = asq;
+		cmd->sense_buffer[2] = (asc >> 8) & 0xff;
+		cmd->sense_buffer[3] = asc & 0xff;
 		cmd->sense_len = 8;
 	} else {
 		/* fixed format */
-
 		int len = 0xa;
-		cmd->sense_buffer[0] = 0x70;
+		cmd->sense_buffer[0] = 0x70;  /* current, not deferred */
 		cmd->sense_buffer[2] = key;
 		cmd->sense_buffer[7] = len;
-		cmd->sense_buffer[12] = asc;
-		cmd->sense_buffer[13] = asq;
+		cmd->sense_buffer[12] = (asc >> 8) & 0xff;
+		cmd->sense_buffer[13] = asc & 0xff;
 		cmd->sense_len = len + 8;
 	}
 }
diff --git a/usr/sense_codes.h b/usr/sense_codes.h
new file mode 100644
index 0000000..210753a
--- /dev/null
+++ b/usr/sense_codes.h
@@ -0,0 +1,103 @@
+/*
+ * The SCSI sense key Additional Sense Code / Additional Sense Code Qualifier
+ *
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * SENSE keys
+ */
+#define NO_SENSE			0x00
+#define	RECOVERED_ERROR			0x01
+#define NOT_READY			0x02
+#define MEDIUM_ERROR			0x03
+#define	HARDWARE_ERROR			0x04
+#define ILLEGAL_REQUEST			0x05
+#define UNIT_ATTENTION			0x06
+#define DATA_PROTECT			0x07
+#define	BLANK_CHECK			0x08
+
+/* Key 0: No Sense Errors */
+#define NO_ADDITIONAL_SENSE			0x0000
+#define ASC_MARK				0x0001
+#define ASC_EOM					0x0002
+#define ASC_BOM					0x0004
+#define ASC_END_OF_DATA				0x0005
+#define ASC_OP_IN_PROGRESS			0x0016
+#define ASC_DRIVASC_REQUIRES_CLEANING		0x8282
+
+/* Key 1: Recovered Errors */
+#define ASC_WRITASC_ERROR			0x0c00
+#define ASC_READ_ERROR				0x1100
+#define ASC_RECOVERED_WITH_RETRYS		0x1701
+#define ASC_MEDIA_LOAD_EJECT_ERROR		0x5300
+#define ASC_FAILURASC_PREDICTION		0x5d00
+
+/* Key 2: Not ready */
+#define ASC_CAUSASC_NOT_REPORTABLE		0x0400
+#define ASC_BECOMING_READY			0x0401
+#define ASC_INITIALIZING_REQUIRED		0x0402
+#define ASC_CLEANING_CART_INSTALLED		0x3003
+#define ASC_CLEANING_FAILURE			0x3007
+#define ASC_MEDIUM_NOT_PRESENT			0x3a00
+#define ASC_LOGICAL_UNIT_NOT_CONFIG		0x3e00
+
+/* Key 3: Medium Errors */
+#define ASC_WRITE_ERROR			0x0c00
+#define ASC_UNRECOVERED_READ			0x1100
+#define ASC_RECORDED_ENTITY_NOT_FOUND		0x1400
+#define ASC_UNKNOWN_FORMAT			0x3001
+#define ASC_IMCOMPATIBLE_FORMAT		0x3002
+#define ASC_MEDIUM_FORMAT_CORRUPT		0x3100
+#define ASC_SEQUENTIAL_POSITION_ERR		0x3b00
+#define ASC_WRITE_APPEND_ERR			0x5000
+#define ASC_CARTRIDGE_FAULT			0x5200
+#define ASC_MEDIA_LOAD_OR_EJECT_FAILED		0x5300
+
+/* Key 4: Hardware Failure */
+#define ASC_COMPRESSION_CHECK			0x0c04
+#define ASC_DECOMPRESSION_CRC			0x110d
+#define ASC_MECHANICAL_POSITIONING_ERROR	0x1501
+#define ASC_MANUAL_INTERVENTION_REQ		0x0403
+#define ASC_HARDWARE_FAILURE			0x4000
+#define ASC_INTERNAL_TGT_FAILURE		0x4400
+#define ASC_ERASE_FAILURE			0x5100
+
+/* Key 5: Illegal Request */
+#define ASC_PARAMETER_LIST_LENGTH_ERR		0x1a00
+#define ASC_INVALID_OP_CODE			0x2000
+#define ASC_INVALID_FIELD_IN_CDB		0x2400
+#define ASC_LUN_NOT_SUPPORTED			0x2500
+#define ASC_INVALID_FIELD_IN_PARMS		0x2600
+#define ASC_SAVING_PARMS_UNSUP			0x3900
+#define ASC_MEDIUM_DEST_FULL			0x3b0d
+#define ASC_MEDIUM_SRC_EMPTY			0x3b0e
+#define ASC_POSITION_PAST_BOM			0x3b0c
+#define ASC_MEDIUM_REMOVAL_PREVENTED		0x5302
+#define ASC_BAD_MICROCODE_DETECTED		0x8283
+
+/* Key 6: Unit Attention */
+#define ASC_NOT_READY_TO_TRANSITION		0x2800
+#define ASC_POWERON_RESET			0x2900
+#define ASC_MODE_PARAMETERS_CHANGED		0x2a01
+#define ASC_INSUFFICIENT_TIME_FOR_OPERATION	0x2e00
+#define ASC_MICROCODE_DOWNLOADED		0x3f01
+#define ASC_FAILURE_PREDICTION_FALSE		0x5dff
+#define ASC_INQUIRY_DATA_HAS_CHANGED		0x3f03
+
+/* Data Protect */
+#define ASC_WRITE_PROTECT			0x2700
+#define ASC_MEDIUM_OVERWRITE_ATTEMPTED		0x300c
diff --git a/usr/spc.c b/usr/spc.c
index 1c363cd..6560e98 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -34,6 +34,7 @@
 #include "tgtadm_error.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 #define PRODUCT_REV	"0"
 #define BLK_SHIFT	9
@@ -43,7 +44,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	int len, ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data;
 	uint8_t *scb = cmd->scb;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 	uint8_t devtype = 0;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
@@ -52,7 +54,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -148,7 +150,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -158,7 +160,8 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	struct list_head *dev_list = &cmd->c_target->device_list;
 	uint64_t lun, *data;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096, overflow;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
 
 	alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
 	if (alen < 16)
@@ -167,7 +170,7 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
-		asc = 0;
+		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
 	memset(data, 0, pagesize);
@@ -204,7 +207,7 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
-	sense_data_build(cmd, key, asc, 0);
+	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
@@ -231,7 +234,7 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
 int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
 	cmd->len = 0;
-	sense_data_build(cmd, NO_SENSE, 0, 0);
+	sense_data_build(cmd, NO_SENSE, NO_ADDITIONAL_SENSE);
 	return SAM_STAT_GOOD;
 }
 
@@ -271,7 +274,7 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
 {
 	dump_cdb(cmd);
 	cmd->len = 0;
-	sense_data_build(cmd, ILLEGAL_REQUEST, 0x20, 0);
+	sense_data_build(cmd, ILLEGAL_REQUEST, ASC_INVALID_OP_CODE);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
diff --git a/usr/spt.c b/usr/spt.c
index c882fd0..9115d7f 100644
--- a/usr/spt.c
+++ b/usr/spt.c
@@ -40,6 +40,7 @@
 #include "target.h"
 #include "scsi.h"
 #include "spc.h"
+#include "sense_codes.h"
 
 extern int spt_sg_open(struct scsi_lu *lu, char *path, int *fd, uint64_t *size);
 extern int spt_sg_perform(struct scsi_cmd *cmd);
@@ -68,14 +69,14 @@ static int spt_cmd_perform(int host_no, struct scsi_cmd *cmd)
 
 	if (!cmd->dev) {
 		cmd->len = 0;
-		sense_data_build(cmd, NOT_READY, 0x44, 0); /* Internal target failure */
+		sense_data_build(cmd, NOT_READY, ASC_INTERNAL_TGT_FAILURE);
 		return SAM_STAT_CHECK_CONDITION;
 	}
 
 	ret = spt_sg_perform(cmd);
 	if (ret) {
 		cmd->len = 0;
-		sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
+		sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LUN_NOT_SUPPORTED);
 		return SAM_STAT_CHECK_CONDITION;
 	} else
 		return SAM_STAT_GOOD;
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 15ae2e1..8e66d60 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -190,8 +190,7 @@ extern void target_cmd_io_done(struct scsi_cmd *cmd, int result);
 
 extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
 extern int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd);
-extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc,
-			     uint8_t asq);
+extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t asc);
 extern uint64_t scsi_rw_offset(uint8_t *scb);
 
 extern enum scsi_target_state tgt_get_target_state(int tid);





Mark Harvey wrote:
>> From d163aa03f036609ac5343c2d8983aba38ecec679 Mon Sep 17 00:00:00 2001
> From: Mark Harvey <markh794 at gmail.com>
> Date: Fri, 22 Jun 2007 18:20:54 +1000
> Subject: Use nmemonic codes for SENSE codes instead of numeric value.
>
> Using nmemonic representation for ASC/ASCQ as a 16bit value.
> - Values defined in sense_codes.h
> - Updated sense_data_build() to accept a single 16bit
>   combined asc/ascq value.
>
> Signed-off-by: Mark Harvey <markh794 at gmail.com>
> ---
> usr/bs_sync.c       |    3 +-
> usr/ibmvio/ibmvio.c |   15 ++++---
> usr/mmc.c           |    7 ++-
> usr/osd.c           |    5 +-
> usr/sbc.c           |   33 +++++++++-------
> usr/scsi.c          |   13 +++---
> usr/sense_codes.h   |  103 
> +++++++++++++++++++++++++++++++++++++++++++++++++++
> usr/spc.c           |   19 +++++----
> usr/spt.c           |    5 +-
> usr/tgtd.h          |    3 +-
> 10 files changed, 161 insertions(+), 45 deletions(-)
> create mode 100644 usr/sense_codes.h
>
> diff --git a/usr/bs_sync.c b/usr/bs_sync.c
> index 6789b5b..4986c59 100644
> --- a/usr/bs_sync.c
> +++ b/usr/bs_sync.c
> @@ -37,6 +37,7 @@
> #include "util.h"
> #include "tgtd.h"
> #include "scsi.h"
> +#include "sense_codes.h"
>
> #define NR_WORKER_THREADS    4
>
> @@ -161,7 +162,7 @@ static void *bs_sync_worker_fn(void *arg)
>             eprintf("io error %p %x %d %d %" PRIu64 ", %m\n",
>                 cmd, cmd->scb[0], ret, cmd->len, cmd->offset);
>             cmd->result = SAM_STAT_CHECK_CONDITION;
> -            sense_data_build(cmd, MEDIUM_ERROR, 0x11, 0x0);
> +            sense_data_build(cmd, MEDIUM_ERROR, ASC_READ_ERROR);
>         }
>
>         pthread_mutex_lock(&info->finished_lock);
> diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
> index 5a2f8fe..8cfc8d6 100644
> --- a/usr/ibmvio/ibmvio.c
> +++ b/usr/ibmvio/ibmvio.c
> @@ -44,6 +44,7 @@
> #include "target.h"
> #include "driver.h"
> #include "spc.h"
> +#include "sense_codes.h"
>
> #define GETTARGET(x) ((int)((((uint64_t)(x)) >> 56) & 0x003f))
> #define GETBUS(x) ((int)((((uint64_t)(x)) >> 53) & 0x0007))
> @@ -140,7 +141,8 @@ static int ibmvio_inquiry(int host_no, struct 
> scsi_cmd *cmd)
> {
>     int ret = SAM_STAT_CHECK_CONDITION;
>     uint8_t *data, *scb = cmd->scb;
> -    unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
> +    unsigned char key = ILLEGAL_REQUEST;
> +    uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
>
>     if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
>         goto sense;
> @@ -148,7 +150,7 @@ static int ibmvio_inquiry(int host_no, struct 
> scsi_cmd *cmd)
>     data = valloc(pagesize);
>     if (!data) {
>         key = HARDWARE_ERROR;
> -        asc = 0;
> +        asc = ASC_INTERNAL_TGT_FAILURE;
>         goto sense;
>     }
>     memset(data, 0, pagesize);
> @@ -173,7 +175,7 @@ static int ibmvio_inquiry(int host_no, struct 
> scsi_cmd *cmd)
>     return SAM_STAT_GOOD;
> sense:
>     cmd->len = 0;
> -    sense_data_build(cmd, key, asc, 0);
> +    sense_data_build(cmd, key, asc);
>     return SAM_STAT_CHECK_CONDITION;
> }
>
> @@ -194,7 +196,8 @@ static int ibmvio_report_luns(int host_no, struct 
> scsi_cmd *cmd)
>     int idx, alen, oalen, nr_luns, rbuflen = 4096;
>     int *len = &cmd->len;
>     uint8_t *lun_buf = cmd->lun;
> -    unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
> +    unsigned char key = ILLEGAL_REQUEST;
> +    uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
>
>     alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
>     if (alen < 16)
> @@ -203,7 +206,7 @@ static int ibmvio_report_luns(int host_no, struct 
> scsi_cmd *cmd)
>     data = valloc(pagesize);
>     if (!data) {
>         key = HARDWARE_ERROR;
> -        asc = 0;
> +        asc = ASC_INTERNAL_TGT_FAILURE;
>         goto sense;
>     }
>     memset(data, 0, pagesize);
> @@ -241,7 +244,7 @@ done:
>     return SAM_STAT_GOOD;
> sense:
>     *len = 0;
> -    sense_data_build(cmd, key, asc, 0);
> +    sense_data_build(cmd, key, asc);
>     return SAM_STAT_CHECK_CONDITION;
> }
>
> diff --git a/usr/mmc.c b/usr/mmc.c
> index 10b0e3f..defe60b 100644
> --- a/usr/mmc.c
> +++ b/usr/mmc.c
> @@ -41,6 +41,7 @@
> #include "driver.h"
> #include "scsi.h"
> #include "spc.h"
> +#include "sense_codes.h"
>
> #define MMC_BLK_SHIFT 11
>
> @@ -53,7 +54,7 @@ static int mmc_rw(int host_no, struct scsi_cmd *cmd)
>     if (ret) {
>         cmd->offset = 0;
>         cmd->len = 0;
> -        sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
> +        sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LUN_NOT_SUPPORTED);
>         return SAM_STAT_CHECK_CONDITION;
>     } else {
>         cmd->mmapped = 1;
> @@ -69,7 +70,7 @@ static int mmc_read_toc(int host_no, struct scsi_cmd 
> *cmd)
>     data = valloc(pagesize);
>     if (!data) {
>         cmd->len = 0;
> -        sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
> +        sense_data_build(cmd, HARDWARE_ERROR, ASC_INTERNAL_TGT_FAILURE);
>         return SAM_STAT_CHECK_CONDITION;
>     }
>     memset(data, 0, pagesize);
> @@ -105,7 +106,7 @@ static int mmc_read_capacity(int host_no, struct 
> scsi_cmd *cmd)
>     data = valloc(pagesize);
>     if (!data) {
>         cmd->len = 0;
> -        sense_data_build(cmd, HARDWARE_ERROR, 0, 0);
> +        sense_data_build(cmd, HARDWARE_ERROR, ASC_INTERNAL_TGT_FAILURE);
>         return SAM_STAT_CHECK_CONDITION;
>     }
>     memset(data, 0, pagesize);
> diff --git a/usr/osd.c b/usr/osd.c
> index a7b92ba..048d0c8 100644
> --- a/usr/osd.c
> +++ b/usr/osd.c
> @@ -33,16 +33,15 @@
> #include "driver.h"
> #include "scsi.h"
> #include "spc.h"
> +#include "sense_codes.h"
>
> static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
> {
> -    unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
> -
>     dprintf("cdb[0] %x datalen %u\n", cmd->scb[0], cmd->len);
>     if (cmd->scb[7] != 200 - 8) {
>         eprintf("request size %d wrong, should be 200\n",
>             cmd->scb[7] + 8);
> -        sense_data_build(cmd, key, asc, 0);
> +        sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LUN_NOT_SUPPORTED);
>         cmd->len = 0;
>         return SAM_STAT_CHECK_CONDITION;
>     }
> diff --git a/usr/sbc.c b/usr/sbc.c
> index c0075e4..a62e6d8 100644
> --- a/usr/sbc.c
> +++ b/usr/sbc.c
> @@ -38,13 +38,15 @@
> #include "driver.h"
> #include "scsi.h"
> #include "spc.h"
> +#include "sense_codes.h"
>
> #define BLK_SHIFT    9
>
> static int sbc_rw(int host_no, struct scsi_cmd *cmd)
> {
>     int ret;
> -    unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
> +    unsigned char key = ILLEGAL_REQUEST;
> +    uint16_t asc = ASC_LUN_NOT_SUPPORTED;
>
>     ret = device_reserved(cmd);
>     if (ret)
> @@ -65,7 +67,7 @@ static int sbc_rw(int host_no, struct scsi_cmd *cmd)
>     ret = cmd->dev->bst->bs_cmd_submit(cmd);
>     if (ret) {
>         key = HARDWARE_ERROR;
> -        asc = 0;
> +        asc = ASC_INTERNAL_TGT_FAILURE;
>     } else {
>         cmd->mmapped = 1;
>         return SAM_STAT_GOOD;
> @@ -74,7 +76,7 @@ static int sbc_rw(int host_no, struct scsi_cmd *cmd)
>     cmd->rw = READ;
>     cmd->offset = 0;
>     cmd->len = 0;
> -    sense_data_build(cmd, key, asc, 0);
> +    sense_data_build(cmd, key, asc);
>     return SAM_STAT_CHECK_CONDITION;
> }
>
> @@ -101,20 +103,21 @@ static int sbc_read_capacity(int host_no, struct 
> scsi_cmd *cmd)
>     uint32_t *data;
>     uint64_t size;
>     uint8_t *scb = cmd->scb;
> -    unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
> +    unsigned char key = ILLEGAL_REQUEST;
> +    uint16_t asc = ASC_LUN_NOT_SUPPORTED;
>
>     if (device_reserved(cmd))
>         return SAM_STAT_RESERVATION_CONFLICT;
>
>     if (!(scb[8] & 0x1) & (scb[2] | scb[3] | scb[4] | scb[5])) {
> -        asc = 0x24;
> +        asc = ASC_INVALID_FIELD_IN_CDB;
>         goto sense;
>     }
>
>     data = valloc(pagesize);
>     if (!data) {
>         key = HARDWARE_ERROR;
> -        asc = 0;
> +        asc = ASC_INTERNAL_TGT_FAILURE;
>         goto sense;
>     }
>     cmd->uaddr = (unsigned long) data;
> @@ -129,14 +132,15 @@ static int sbc_read_capacity(int host_no, struct 
> scsi_cmd *cmd)
>     return SAM_STAT_GOOD;
> sense:
>     cmd->len = 0;
> -    sense_data_build(cmd, key, asc, 0);
> +    sense_data_build(cmd, key, asc);
>     return SAM_STAT_CHECK_CONDITION;
> }
>
> static int sbc_sync_cache(int host_no, struct scsi_cmd *cmd)
> {
>     int ret, len;
> -    uint8_t key = ILLEGAL_REQUEST, asc;
> +    uint8_t key = ILLEGAL_REQUEST;
> +    uint16_t asc = ASC_LUN_NOT_SUPPORTED;
>
>     if (device_reserved(cmd))
>         return SAM_STAT_RESERVATION_CONFLICT;
> @@ -152,7 +156,7 @@ static int sbc_sync_cache(int host_no, struct 
> scsi_cmd *cmd)
>          * what should I put for the asc/ascq?
>          */
>         key = HARDWARE_ERROR;
> -        asc = 0;
> +        asc = ASC_INTERNAL_TGT_FAILURE;
>         goto sense;
>     default:
>         len = 0;
> @@ -161,7 +165,7 @@ static int sbc_sync_cache(int host_no, struct 
> scsi_cmd *cmd)
>
> sense:
>     cmd->len = 0;
> -    sense_data_build(cmd, key, asc, 0);
> +    sense_data_build(cmd, key, asc);
>     return SAM_STAT_CHECK_CONDITION;
> }
>
> @@ -232,7 +236,8 @@ static int sbc_mode_sense(int host_no, struct 
> scsi_cmd *cmd)
>     uint8_t pcode = cmd->scb[2] & 0x3f;
>     uint64_t size;
>     uint8_t *data = NULL;
> -    unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
> +    unsigned char key = ILLEGAL_REQUEST;
> +    uint16_t asc = ASC_LUN_NOT_SUPPORTED;
>
>     if (device_reserved(cmd))
>         return SAM_STAT_RESERVATION_CONFLICT;
> @@ -240,7 +245,7 @@ static int sbc_mode_sense(int host_no, struct 
> scsi_cmd *cmd)
>     data = valloc(pagesize);
>     if (!data) {
>         key = HARDWARE_ERROR;
> -        asc = 0;
> +        asc = ASC_INTERNAL_TGT_FAILURE;
>         goto sense;
>     }
>     memset(data, 0, pagesize);
> @@ -288,7 +293,7 @@ static int sbc_mode_sense(int host_no, struct 
> scsi_cmd *cmd)
>         len += insert_iec_m_pg(data + len);
>         break;
>     default:
> -        asc = 0x24;
> +        asc = ASC_INVALID_FIELD_IN_CDB;
>         goto sense;
>     }
>
> @@ -298,7 +303,7 @@ static int sbc_mode_sense(int host_no, struct 
> scsi_cmd *cmd)
>     return ret;
> sense:
>     cmd->len = 0;
> -    sense_data_build(cmd, key, asc, 0);
> +    sense_data_build(cmd, key, asc);
>     return SAM_STAT_CHECK_CONDITION;
> }
>
> diff --git a/usr/scsi.c b/usr/scsi.c
> index 36722e1..5ddc94c 100644
> --- a/usr/scsi.c
> +++ b/usr/scsi.c
> @@ -38,27 +38,28 @@
> #include "scsi.h"
> #include "spc.h"
>
> -void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint8_t asc, 
> uint8_t asq)
> +void sense_data_build(struct scsi_cmd *cmd, uint8_t key, uint16_t asc)
> {
> +    uint16_t *sense_code;
> +
>     if (cmd->dev->attrs.sense_format) {
>         /* descriptor format */
> +        sense_code = (uint16_t *)&cmd->sense_buffer[2];
>
>         cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
>         cmd->sense_buffer[1] = key;
> -        cmd->sense_buffer[2] = asc;
> -        cmd->sense_buffer[3] = asq;
>         cmd->sense_len = 8;
>     } else {
>         /* fixed format */
> +        sense_code = (uint16_t *)&cmd->sense_buffer[12];
>
>         int len = 0xa;
> -        cmd->sense_buffer[0] = 0x70;
> +        cmd->sense_buffer[0] = 0x70;  /* current, not deferred */
>         cmd->sense_buffer[2] = key;
>         cmd->sense_buffer[7] = len;
> -        cmd->sense_buffer[12] = asc;
> -        cmd->sense_buffer[13] = asq;
>         cmd->sense_len = len + 8;
>     }
> +    *sense_code = __cpu_to_be16(asc);
> }
>
> #define        TGT_INVALID_DEV_ID      ~0ULL
> diff --git a/usr/sense_codes.h b/usr/sense_codes.h
> new file mode 100644
> index 0000000..ea8eebc
> --- /dev/null
> +++ b/usr/sense_codes.h
> @@ -0,0 +1,103 @@
> +/*
> + * The SCSI sense key Additional Sense Code / Additional Sense Code 
> Qualifier
> + *
> + * Copyright (C) 2007 Mark Harvey markh794 at gmail dot com
> + *
> + * This program is free software; you can redistribute it and/or modify
> + * it under the terms of the GNU General Public License as published by
> + * the Free Software Foundation; version 2 of the License.
> + *
> + * This program is distributed in the hope that it will be useful,
> + * but WITHOUT ANY WARRANTY; without even the implied warranty of
> + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
> + * GNU General Public License for more details.
> + *
> + * You should have received a copy of the GNU General Public License
> + * along with this program; if not, write to the Free Software
> + * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
> + */
> +
> +/*
> + * SENSE keys
> + */
> +#define NO_SENSE            0x00
> +#define    RECOVERED_ERROR            0x01
> +#define NOT_READY            0x02
> +#define MEDIUM_ERROR            0x03
> +#define    HARDWARE_ERROR            0x04
> +#define ILLEGAL_REQUEST            0x05
> +#define UNIT_ATTENTION            0x06
> +#define DATA_PROTECT            0x07
> +#define    BLANK_CHECK            0x08
> +
> +/* Key 0: No Sense Errors */
> +#define NO_ADDITIONAL_SENSE            0x0000
> +#define ASC_MARK                0x0001
> +#define ASC_EOM                    0x0002
> +#define ASC_BOM                    0x0004
> +#define ASC_END_OF_DATA                0x0005
> +#define ASC_OP_IN_PROGRESS            0x0016
> +#define ASC_DRIVASC_REQUIRES_CLEANING        0x8282
> +
> +/* Key 1: Recovered Errors */
> +#define ASC_WRITASC_ERROR            0x0c00
> +#define ASC_READ_ERROR                0x1100
> +#define ASC_RECOVERED_WITH_RETRYS        0x1701
> +#define ASC_MEDIA_LOAD_EJECT_ERROR        0x5300
> +#define ASC_FAILURASC_PREDICTION        0x5d00
> +
> +/* Key 2: Not ready */
> +#define ASC_CAUSASC_NOT_REPORTABLE        0x0400
> +#define ASC_BECOMING_READY            0x0401
> +#define ASC_INITIALIZING_REQUIRED        0x0402
> +#define ASC_CLEANING_CART_INSTALLED        0x3003
> +#define ASC_CLEANING_FAILURE            0x3007
> +#define ASC_MEDIUM_NOT_PRESENT            0x3a00
> +#define ASC_LOGICAL_UNIT_NOT_CONFIG        0x3e00
> +
> +/* Key 3: Medium Errors */
> +#define ASC_WRITE_ERROR            0x0c00
> +#define ASC_UNRECOVERED_READ            0x1100
> +#define ASC_RECORDED_ENTITY_NOT_FOUND        0x1400
> +#define ASC_UNKNOWN_FORMAT            0x3001
> +#define ASC_IMCOMPATIBLE_FORMAT        0x3002
> +#define ASC_MEDIUM_FORMAT_CORRUPT        0x3100
> +#define ASC_SEQUENTIAL_POSITION_ERR        0x3b00
> +#define ASC_WRITE_APPEND_ERR            0x5000
> +#define ASC_CARTRIDGE_FAULT            0x5200
> +#define ASC_MEDIA_LOAD_OR_EJECT_FAILED        0x5300
> +
> +/* Key 4: Hardware Failure */
> +#define ASC_COMPRESSION_CHECK            0x0c04
> +#define ASC_DECOMPRESSION_CRC            0x110d
> +#define ASC_MECHANICAL_POSITIONING_ERROR    0x1501
> +#define ASC_MANUAL_INTERVENTION_REQ        0x0403
> +#define ASC_HARDWARE_FAILURE            0x4000
> +#define ASC_INTERNAL_TGT_FAILURE        0x4400
> +#define ASC_ERASE_FAILURE            0x5100
> +
> +/* Key 5: Illegal Request */
> +#define ASC_PARAMETER_LIST_LENGTH_ERR        0x1a00
> +#define ASC_INVALID_OP_CODE            0x2000
> +#define ASC_INVALID_FIELD_IN_CDB        0x2400
> +#define ASC_LUN_NOT_SUPPORTED            0x2500
> +#define ASC_INVALID_FIELD_IN_PARMS        0x2600
> +#define ASC_SAVING_PARMS_UNSUP            0x3900
> +#define ASC_MEDIUM_DEST_FULL            0x3b0d
> +#define ASC_MEDIUM_SRC_EMPTY            0x3b0e
> +#define ASC_POSITION_PAST_BOM            0x3b0c
> +#define ASC_MEDIUM_REMOVAL_PREVENTED        0x5302
> +#define ASC_BAD_MICROCODE_DETECTED        0x8283
> +
> +/* Key 6: Unit Attention */
> +#define ASC_NOT_READY_TO_TRANSITION        0x2800
> +#define ASC_POWERON_RESET            0x2900
> +#define ASC_MODE_PARAMETERS_CHANGED        0x2a01
> +#define ASC_INSUFFICIENT_TIME_FOR_OPERATION    0x2e00
> +#define ASC_MICROCODE_DOWNLOADED        0x3f01
> +#define ASC_FAILURE_PREDICTION_FALSE        0x5dff
> +#define ASC_INQUIRY_DATA_HAS_CHANGED        0x3f03
> +
> +/* Data Protect */
> +#define ASC_WRITE_PROTECT            0x2700
> +#define ASC_MEDIUM_OVERWRITE_ATTEMPTED        0x300c
> diff --git a/usr/spc.c b/usr/spc.c
> index 1c363cd..6560e98 100644
> --- a/usr/spc.c
> +++ b/usr/spc.c
> @@ -34,6 +34,7 @@
> #include "tgtadm_error.h"
> #include "scsi.h"
> #include "spc.h"
> +#include "sense_codes.h"
>
> #define PRODUCT_REV    "0"
> #define BLK_SHIFT    9
> @@ -43,7 +44,8 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>     int len, ret = SAM_STAT_CHECK_CONDITION;
>     uint8_t *data;
>     uint8_t *scb = cmd->scb;
> -    unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
> +    unsigned char key = ILLEGAL_REQUEST;
> +    uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
>     uint8_t devtype = 0;
>
>     if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
> @@ -52,7 +54,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>     data = valloc(pagesize);
>     if (!data) {
>         key = HARDWARE_ERROR;
> -        asc = 0;
> +        asc = ASC_INTERNAL_TGT_FAILURE;
>         goto sense;
>     }
>     memset(data, 0, pagesize);
> @@ -148,7 +150,7 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
>     return SAM_STAT_GOOD;
> sense:
>     cmd->len = 0;
> -    sense_data_build(cmd, key, asc, 0);
> +    sense_data_build(cmd, key, asc);
>     return SAM_STAT_CHECK_CONDITION;
> }
>
> @@ -158,7 +160,8 @@ int spc_report_luns(int host_no, struct scsi_cmd 
> *cmd)
>     struct list_head *dev_list = &cmd->c_target->device_list;
>     uint64_t lun, *data;
>     int idx, alen, oalen, nr_luns, rbuflen = 4096, overflow;
> -    unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
> +    unsigned char key = ILLEGAL_REQUEST;
> +    uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
>
>     alen = __be32_to_cpu(*(uint32_t *)&cmd->scb[6]);
>     if (alen < 16)
> @@ -167,7 +170,7 @@ int spc_report_luns(int host_no, struct scsi_cmd 
> *cmd)
>     data = valloc(pagesize);
>     if (!data) {
>         key = HARDWARE_ERROR;
> -        asc = 0;
> +        asc = ASC_INTERNAL_TGT_FAILURE;
>         goto sense;
>     }
>     memset(data, 0, pagesize);
> @@ -204,7 +207,7 @@ int spc_report_luns(int host_no, struct scsi_cmd 
> *cmd)
>     return SAM_STAT_GOOD;
> sense:
>     cmd->len = 0;
> -    sense_data_build(cmd, key, asc, 0);
> +    sense_data_build(cmd, key, asc);
>     return SAM_STAT_CHECK_CONDITION;
> }
>
> @@ -231,7 +234,7 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
> int spc_request_sense(int host_no, struct scsi_cmd *cmd)
> {
>     cmd->len = 0;
> -    sense_data_build(cmd, NO_SENSE, 0, 0);
> +    sense_data_build(cmd, NO_SENSE, NO_ADDITIONAL_SENSE);
>     return SAM_STAT_GOOD;
> }
>
> @@ -271,7 +274,7 @@ int spc_illegal_op(int host_no, struct scsi_cmd *cmd)
> {
>     dump_cdb(cmd);
>     cmd->len = 0;
> -    sense_data_build(cmd, ILLEGAL_REQUEST, 0x20, 0);
> +    sense_data_build(cmd, ILLEGAL_REQUEST, ASC_INVALID_OP_CODE);
>     return SAM_STAT_CHECK_CONDITION;
> }
>
> diff --git a/usr/spt.c b/usr/spt.c
> index c882fd0..9115d7f 100644
> --- a/usr/spt.c
> +++ b/usr/spt.c
> @@ -40,6 +40,7 @@
> #include "target.h"
> #include "scsi.h"
> #include "spc.h"
> +#include "sense_codes.h"
>
> extern int spt_sg_open(struct scsi_lu *lu, char *path, int *fd, 
> uint64_t *size);
> extern int spt_sg_perform(struct scsi_cmd *cmd);
> @@ -68,14 +69,14 @@ static int spt_cmd_perform(int host_no, struct 
> scsi_cmd *cmd)
>
>     if (!cmd->dev) {
>         cmd->len = 0;
> -        sense_data_build(cmd, NOT_READY, 0x44, 0); /* Internal target 
> failure */
> +        sense_data_build(cmd, NOT_READY, ASC_INTERNAL_TGT_FAILURE);
>         return SAM_STAT_CHECK_CONDITION;
>     }
>
>     ret = spt_sg_perform(cmd);
>     if (ret) {
>         cmd->len = 0;
> -        sense_data_build(cmd, ILLEGAL_REQUEST, 0x25, 0);
> +        sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LUN_NOT_SUPPORTED);
>         return SAM_STAT_CHECK_CONDITION;
>     } else
>         return SAM_STAT_GOOD;
> diff --git a/usr/tgtd.h b/usr/tgtd.h
> index 15ae2e1..8e66d60 100644
> --- a/usr/tgtd.h
> +++ b/usr/tgtd.h
> @@ -190,8 +190,7 @@ extern void target_cmd_io_done(struct scsi_cmd 
> *cmd, int result);
>
> extern uint64_t scsi_get_devid(int lid, uint8_t *pdu);
> extern int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd);
> -extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, 
> uint8_t asc,
> -                 uint8_t asq);
> +extern void sense_data_build(struct scsi_cmd *cmd, uint8_t key, 
> uint16_t asc);
> extern uint64_t scsi_rw_offset(uint8_t *scb);
>
> extern enum scsi_target_state tgt_get_target_state(int tid);



From fujita.tomonori at lab.ntt.co.jp  Fri Jun 29 03:02:49 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 29 Jun 2007 10:02:49 +0900
Subject: [Stgt-devel] [Patch 1/3] Rework of mnemonic ASC/ASCQ values
In-Reply-To: <468395AD.50805@gmail.com>
References: <467CD5C8.2090108@gmail.com>
	<468395AD.50805@gmail.com>
Message-ID: <20070629100249E.fujita.tomonori@lab.ntt.co.jp>

From: Mark Harvey <markh794 at gmail.com>
Subject: Re: [Stgt-devel] [Patch 1/3] Rework of mnemonic ASC/ASCQ values
Date: Thu, 28 Jun 2007 21:04:13 +1000

> Another version of this patch (with simplification of sense_data_build()

Applied, thanks a lot.


From glaw at solarflare.com  Fri Jun 29 15:29:32 2007
From: glaw at solarflare.com (Greg Law)
Date: Fri, 29 Jun 2007 14:29:32 +0100
Subject: [Stgt-devel] iSCSI digest offload
Message-ID: <4685093C.1040008@solarflare.com>

Hi list,

I posted the following yesterday to iet-devel, and they suggested I'd be 
better off talking to you guys, as this is the place for "hot iSCSI 
target" developments.

My company, Solarflare, makes 10gig NICs.  We don't do full TCP offload, 
but we do have support on the card for iSCSI digest offload. Essentially 
this means that if your packets are conveniently formatted, you can have 
iSCSI digests with a very small performance penalty (in terms of both 
throughput and CPU hit).  I say "if your packets are conveniently 
formatted" because the NIC can only offload the digest if an Ethernet 
frame contains exactly one iSCSI PDU in exactly one TCP segment. 
However, providing you use a MaxRecvDataSegmentLength of <= MSS (less 
headers) our experiments show this is almost always the case.

We've implemented our own iSCSI initiator stack on Linux as a 
proof-of-concept, and it gives the performance wins we'd hoped for.  Now 
we want to patch the open-source stacks (target and initiator) to take 
advantage of this feature.  We will also need to patch the Linux TCP 
stack so that (a) we can pass meta data down (to tell the NIC to compute 
and insert digests on tx) and pass meta data back up (to tell the iSCSI 
stack whether the digests computed ok on rx); and (b) to make sure we 
can handle edge-cases such as routing changes etc.

We expect the patch to be quite small - both the TCP and iSCSI parts. We 
plan to do the target first, and follow up with the initiator.

I'd be really interested to hear the list's views on this.  Have you 
heard of anything similar before?  Does it sound like a patch that you 
might be interested in merging (of course, I'm not looking for a 
definitive answer here, just a "could be interesting, providing ....".)

Also, do the tgt and open-iscsi share any code for the iSCSI protocol 
processing?  If not, are there any plans to do so?


Cheers,

Greg
-- 
Greg Law               glaw at solarflare.com              +44 1223 518 040


From markh794 at gmail.com  Sat Jun 30 09:45:23 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 30 Jun 2007 17:45:23 +1000
Subject: [Stgt-devel] [Patch 0/2] Re-submit MODE SENSE & SMC patches based
	on latest head.
Message-ID: <46860A13.6020203@gmail.com>

Set of patches based against commit of :

  ==================================
commit 035bbdf457a4201355466a90d00968113ad961a5
Author: Mark Harvey <markh794 at gmail.com>
Date:   Fri Jun 29 09:32:51 2007 +0900

    use nmemonic representation for ASC/ASCQ as a 16bit value
   
    - Values defined in sense_codes.h
    - Updated sense_data_build() to accept a single 16bit combined
    asc/ascq value.
   
    Signed-off-by: Mark Harvey <markh794 at gmail.com>
    Signed-off-by: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
  ==================================

Patch 1 - Dynamic MODE SENSE (6) & MODE SENSE (10) support.
 - Adds ability to define mode pages at runtime.

Patch 2 - SMC (medium changer) support.
 - Supports all SCSI op codes defined as Mandatory
 - Includes param parsing as recommended..

Cheers
Mark





From markh794 at gmail.com  Sat Jun 30 09:47:10 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 30 Jun 2007 17:47:10 +1000
Subject: [Stgt-devel] [Patch 1/2] Add MODE SENSE (6) & MODE SENSE (10)
	support
Message-ID: <46860A7E.8040800@gmail.com>

>From 4afa975c190c87fab099f52bcd95cafa608fcf96 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Sat, 30 Jun 2007 16:56:19 +1000
Subject: Initial commit of Dynamic MODE SENSE support

Add support for:
 - MODE SENSE (6)
 - MODE SENSE (10)

Add ability to add mode pages 'on the fly'. i.e. At setup time.

Configuration/creation of mode pages via the 'tgtadm --params mode_page'

Page data information is seperated by ':'
e.g.
 --params mode_page=10:1:11:2:0:0:0:0:0:0:0:2:0:0
Where '10' is mode page 10
      '1'  is the subpage
      '11' is the length of the page data (11 bytes of information follow)

SBC & MMC devices set up some default pages at lu creation time.

The example script 'scripts/tgt-core-test' contains an executable example.

The 'doc/README.lu_configuration' updated for mode page informaiton.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 doc/README.lu_configuration |   20 ++++
 scripts/tgt-core-test       |   64 ++++++++++---
 usr/mmc.c                   |   61 ++++++++++++-
 usr/osd.c                   |    6 +-
 usr/sbc.c                   |  199 ++++++++++++----------------------------
 usr/scc.c                   |    3 +-
 usr/spc.c                   |  213 ++++++++++++++++++++++++++++++++++++++++++-
 usr/spc.h                   |   11 ++
 usr/tgtd.h                  |    4 +
 9 files changed, 424 insertions(+), 157 deletions(-)

diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
index 1244bc0..d63668a 100644
--- a/doc/README.lu_configuration
+++ b/doc/README.lu_configuration
@@ -65,5 +65,25 @@ standard INQUIRY:
 As can be seen from above 'sg_inq' output, the RMB (removable) bit is set to 1.
 The Unit serial number page updated with 'FRED00'
 
+Mode Page Creation
+------------------
+Create mode page '2', subpage 0 and 14 bytes of data.
+tgtadm --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+
+Create mode page '3', subpage 0 and 22 bytes of data.
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
+
+Create mode page '10', subpage 0 and 10 bytes of data.
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
+
+Create mode page '0x1c', subpage 0 and 10 bytes of data.
+tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
+         --params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+
+
+
 Please refer to scripts/tgt-core-test for a working example.
 
diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
index a90fc9d..a31be1b 100755
--- a/scripts/tgt-core-test
+++ b/scripts/tgt-core-test
@@ -3,6 +3,7 @@
 # Parent directory for data files..
 HOME=/d/01
 
+# Start tgtd if not running..
 P=`ps -ef|grep -v grep|grep tgtd|wc -l`
 if [ "X"$P == "X0" ]; then
 	tgtd -d 1
@@ -35,7 +36,7 @@ TID=1
 
 # Create Target ID 1..
 tgtadm --lld iscsi --mode target --op new --tid $TID \
-		-T iqn.2007-03:marks-vtl_sbc:`hostname`
+		-T iqn.2007-03:marks-vtl_tgt:`hostname`
 sleep 1
 
 # Create first LUN - Disk
@@ -48,23 +49,58 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 	--params vendor_id=QUANTUM,product_id=HD100,product_rev=0010,removable=1,sense_format=0
 
-# Create 2nd LUN - CD/ROM
-LUN=2
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
+#### Set up mode pages ####
+# First try a couple of attempts with incorrect data..
+# i.e. Expect the first two to fail!
+# - Length too long & Incorrect value (300) as one if the params...
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY11,removable=1
-
-# Create 3rd LUN - CD/ROM
-LUN=3
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:300:0:0:0:0:0:0:0:0:3
+# - Length too short...
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY12,removable=1
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0
+#
+# From here on - should work OK..
+#
 
-# Create 4th LUN - CD/ROM
-LUN=4
-tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block1 --device-type=cd
+# Vendor Uniq - Mode page 0..
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0:0:0
+# Disconnect page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+# Format mode page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0
+# Geo mode page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=4:0:22:0:0:0:0x40:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0x3a:0x98:0:0
+# Caching Page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=8:0:18:0x14:0:0xff:0xff:0:0:0xff:0xff:0xff:0xff:0x80:0x14:0:0:0:0:0:0
+# ctrl mode page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
+# Informational Exceptions Control Mode Page
 tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
-	--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY13,removable=1
+	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+
+
+
+for LUN in 2 3 4; do
+	# Create LUN - CD/ROM
+	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY1$LUN,removable=1
+	# Vendor Uniq - Mode page 0..
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params mode_page=0:0:0
+	# ctrl mode page
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params mode_page=10:0:10:2:0:0:0:0:0:0:0:2:0
+	# Informational Exceptions Control Mode Page
+	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+		--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+done
 
 # Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
diff --git a/usr/mmc.c b/usr/mmc.c
index defe60b..17cc741 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -41,6 +41,7 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "tgtadm_error.h"
 #include "sense_codes.h"
 
 #define MMC_BLK_SHIFT 11
@@ -122,10 +123,19 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 }
 
+static int mmc_mode_sense(int host_no, struct scsi_cmd *cmd)
+{
+	uint8_t *scb = cmd->scb;
+
+	/* MMC devices always return descriptor block */
+	scb[1] |= 8;
+	return spc_mode_sense(host_no, cmd);
+}
+
 static int mmc_lu_init(struct scsi_lu *lu)
 {
 	if (spc_lu_init(lu))
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "VIRTUAL-CDROM", sizeof(lu->attrs.product_id));
 	lu->attrs.sense_format = 0;
@@ -133,6 +143,34 @@ static int mmc_lu_init(struct scsi_lu *lu)
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
 	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
+/*
+ * Set up default mode pages
+ * Ref: mmc6r00.pdf 7.2.2 (Table 649)
+ */
+	INIT_LIST_HEAD(&lu->mode_pages);
+
+	/* Vendor uniq - However most apps seem to call for mode page 0*/
+	add_mode_page(lu, "0:0:0");
+	/* Read/Write Error Recovery */
+	add_mode_page(lu, "1:0:10:0:8:0:0:0:0:8:0:0:0");
+	/* MRW */
+	add_mode_page(lu, "3:0:6:0:0:0:0:0:0");
+	/* Write Parameter
+	 * Somebody who knows more about this mode page should be setting
+	 * defaults.
+	add_mode_page(lu, "5:0:0");
+	 */
+	/* Caching Page */
+	add_mode_page(lu, "8:0:10:0:0:0:0:0:0:0:0:0:0");
+	/* Control page */
+	add_mode_page(lu, "10:0:10:2:0:0:0:0:0:0:0:2:0");
+	/* Power Condition */
+	add_mode_page(lu, "0x1a:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Informational Exceptions Control page */
+	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Timeout & Protect */
+	add_mode_page(lu, "0x1d:0:10:0:0:7:0:0:2:0:2:0:20");
+
 	return 0;
 }
 
@@ -218,7 +256,26 @@ static struct device_type_template mmc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 
-		[0x50 ... 0x9f] = {spc_illegal_op,},
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{mmc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x9f] = {spc_illegal_op,},
 
 		/* 0xA0 */
 		{spc_report_luns,},
diff --git a/usr/osd.c b/usr/osd.c
index 048d0c8..a48db32 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -33,6 +33,7 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "tgtadm_error.h"
 #include "sense_codes.h"
 
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
@@ -53,7 +54,7 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 static int osd_lu_init(struct scsi_lu *lu)
 {
 	if (spc_lu_init(lu))
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "OSD", sizeof(lu->attrs.product_id));
 	lu->attrs.sense_format = 1;
@@ -61,6 +62,9 @@ static int osd_lu_init(struct scsi_lu *lu)
 	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
 	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
+	/* not used - but initialise anyway... */
+	INIT_LIST_HEAD(&lu->mode_pages);
+
 	return 0;
 }
 
diff --git a/usr/sbc.c b/usr/sbc.c
index a62e6d8..5996081 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -38,6 +38,7 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
+#include "tgtadm_error.h"
 #include "sense_codes.h"
 
 #define BLK_SHIFT	9
@@ -169,153 +170,54 @@ sense:
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int insert_disconnect_pg(uint8_t *ptr)
-{
-	unsigned char disconnect_pg[] = {0x02, 0x0e, 0x80, 0x80, 0x00, 0x0a, 0x00, 0x00,
-                                         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, disconnect_pg, sizeof(disconnect_pg));
-	return sizeof(disconnect_pg);
-}
-
-static int insert_caching_pg(uint8_t *ptr)
-{
-	unsigned char caching_pg[] = {0x08, 0x12, 0x14, 0x00, 0xff, 0xff, 0x00, 0x00,
-				      0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0x00, 0x00,
-				      0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, caching_pg, sizeof(caching_pg));
-	return sizeof(caching_pg);
-}
-
-static int insert_ctrl_m_pg(uint8_t *ptr)
-{
-	unsigned char ctrl_m_pg[] = {0x0a, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
-				     0x00, 0x00, 0x02, 0x4b};
-
-	memcpy(ptr, ctrl_m_pg, sizeof(ctrl_m_pg));
-	return sizeof(ctrl_m_pg);
-}
-
-static int insert_iec_m_pg(uint8_t *ptr)
-{
-	unsigned char iec_m_pg[] = {0x1c, 0xa, 0x08, 0x00, 0x00, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x00};
-
-	memcpy(ptr, iec_m_pg, sizeof(iec_m_pg));
-	return sizeof(iec_m_pg);
-}
-
-static int insert_format_m_pg(uint8_t *ptr)
-{
-	unsigned char format_m_pg[] = {0x03, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-				       0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
-				       0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00};
-	memcpy(ptr, format_m_pg, sizeof(format_m_pg));
-	return sizeof(format_m_pg);
-}
-
-static int insert_geo_m_pg(uint8_t *ptr, uint64_t sec)
-{
-	unsigned char geo_m_pg[] = {0x04, 0x16, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-				    0x00, 0x00, 0x00, 0x00, 0x3a, 0x98, 0x00, 0x00};
-	uint32_t ncyl, *p;
-
-	/* assume 0xff heads, 15krpm. */
-	memcpy(ptr, geo_m_pg, sizeof(geo_m_pg));
-	ncyl = sec >> 14; /* 256 * 64 */
-	p = (uint32_t *)(ptr + 1);
-	*p = *p | __cpu_to_be32(ncyl);
-	return sizeof(geo_m_pg);
-}
-
-static int sbc_mode_sense(int host_no, struct scsi_cmd *cmd)
+static int sbc_lu_init(struct scsi_lu *lu)
 {
-	int ret = SAM_STAT_GOOD, len;
-	uint8_t pcode = cmd->scb[2] & 0x3f;
 	uint64_t size;
-	uint8_t *data = NULL;
-	unsigned char key = ILLEGAL_REQUEST;
-	uint16_t asc = ASC_LUN_NOT_SUPPORTED;
+	uint8_t *data;
 
-	if (device_reserved(cmd))
-		return SAM_STAT_RESERVATION_CONFLICT;
+	if (spc_lu_init(lu))
+		return TGTADM_NOMEM;
 
-	data = valloc(pagesize);
-	if (!data) {
-		key = HARDWARE_ERROR;
-		asc = ASC_INTERNAL_TGT_FAILURE;
-		goto sense;
-	}
-	memset(data, 0, pagesize);
+	strncpy(lu->attrs.product_id, "VIRTUAL-DISK", sizeof(lu->attrs.product_id));
+	lu->attrs.version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
 
-	len = 4;
-	size = cmd->dev->size >> BLK_SHIFT;
+	data = lu->mode_block_descriptor;
+	size = lu->size >> BLK_SHIFT;
 
-	if ((cmd->scb[1] & 0x8))
-		data[3] = 0;
-	else {
-		data[3] = 8;
-		len += 8;
-		*(uint32_t *)(data + 4) = (size >> 32) ?
+	*(uint32_t *)(data) = (size >> 32) ?
 			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
-		*(uint32_t *)(data + 8) = __cpu_to_be32(1 << BLK_SHIFT);
-	}
+	*(uint32_t *)(data + 4) = __cpu_to_be32(1 << BLK_SHIFT);
 
-	switch (pcode) {
-	case 0x0:
-		break;
-	case 0x2:
-		len += insert_disconnect_pg(data + len);
-		break;
-	case 0x3:
-		len += insert_format_m_pg(data + len);
-		break;
-	case 0x4:
-		len += insert_geo_m_pg(data + len, size);
-		break;
-	case 0x8:
-		len += insert_caching_pg(data + len);
-		break;
-	case 0xa:
-		len += insert_ctrl_m_pg(data + len);
-		break;
-	case 0x1c:
-		len += insert_iec_m_pg(data + len);
-		break;
-	case 0x3f:
-		len += insert_disconnect_pg(data + len);
-		len += insert_format_m_pg(data + len);
-		len += insert_geo_m_pg(data + len, size);
-		len += insert_caching_pg(data + len);
-		len += insert_ctrl_m_pg(data + len);
-		len += insert_iec_m_pg(data + len);
-		break;
-	default:
-		asc = ASC_INVALID_FIELD_IN_CDB;
-		goto sense;
-	}
+	INIT_LIST_HEAD(&lu->mode_pages);
 
-	data[0] = len - 1;
-	cmd->len = len;
-	cmd->uaddr = (unsigned long) data;
-	return ret;
-sense:
-	cmd->len = 0;
-	sense_data_build(cmd, key, asc);
-	return SAM_STAT_CHECK_CONDITION;
-}
+	data = lu->mode_block_descriptor;
+	size = lu->size >> BLK_SHIFT;
 
-static int sbc_lu_init(struct scsi_lu *lu)
-{
-	if (spc_lu_init(lu))
-		return -ENOMEM;
+	*(uint32_t *)(data) = (size >> 32) ?
+			__cpu_to_be32(0xffffffff) : __cpu_to_be32(size);
+	*(uint32_t *)(data + 4) = __cpu_to_be32(1 << BLK_SHIFT);
 
-	strncpy(lu->attrs.product_id, "VIRTUAL-DISK", sizeof(lu->attrs.product_id));
-	lu->attrs.version_desc[0] = 0x04C0; /* SBC-3 no version claimed */
-	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
-	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
+/*
+ * Set up default mode pages
+ */
+	INIT_LIST_HEAD(&lu->mode_pages);
+
+	/* Vendor uniq - However most apps seem to call for mode page 0*/
+	add_mode_page(lu, "0:0:0");
+	/* Disconnect page */
+	add_mode_page(lu, "2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0");
+	/* Format page */
+	add_mode_page(lu, "3:0:22:0:0:0:0:0:0:0:0:1:0:2:0:0:0:0:0:0:0:0:13:0:0");
+	/* GEO page */
+	add_mode_page(lu, "4:0:22:0:0:0:0x40:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0x3a:0x98:0:0");
+	/* Caching Page */
+	add_mode_page(lu, "8:0:18:0x14:0:0xff:0xff:0:0:0xff:0xff:0xff:0xff:0x80:0x14:0:0:0:0:0:0");
+	/* Control page */
+	add_mode_page(lu, "10:0:10:2:0:0:0:0:0:0:0:2:0");
+	/* Informational Exceptions Control page */
+	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
 
 	return 0;
 }
@@ -355,7 +257,7 @@ static struct device_type_template sbc_template = {
 
 		{spc_illegal_op,},
 		{spc_illegal_op,},
-		{sbc_mode_sense,},
+		{spc_mode_sense,},
 		{spc_start_stop,},
 		{spc_illegal_op,},
 		{spc_illegal_op,},
@@ -400,7 +302,28 @@ static struct device_type_template sbc_template = {
 		{spc_illegal_op,},
 		{spc_illegal_op,},
 
-		[0x40 ... 0x7f] = {spc_illegal_op,},
+		[0x40 ... 0x4f] = {spc_illegal_op,},
+
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x7f] = {spc_illegal_op,},
 
 		/* 0x80 */
 		{spc_illegal_op,},
diff --git a/usr/scc.c b/usr/scc.c
index 3b26a57..0a154a5 100644
--- a/usr/scc.c
+++ b/usr/scc.c
@@ -33,12 +33,13 @@
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
+#include "tgtadm_error.h"
 #include "spc.h"
 
 static int scc_lu_init(struct scsi_lu *lu)
 {
 	if (spc_lu_init(lu))
-		return -ENOMEM;
+		return TGTADM_NOMEM;
 
 	strncpy(lu->attrs.product_id, "Controller",
 		sizeof(lu->attrs.product_id));
diff --git a/usr/spc.c b/usr/spc.c
index 6560e98..3eb605c 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -231,6 +231,106 @@ int spc_test_unit(int host_no, struct scsi_cmd *cmd)
 		return SAM_STAT_GOOD;
 }
 
+/*
+ * Copy mode page data from list into SCSI data so it can be returned
+ * to the initiator
+ *
+ * *data -> target address (destination)
+ * mode -> Pointer to mode page information (source)
+ *
+ * Returns number of bytes copied.
+ */
+static int build_mode_page(uint8_t *data, struct mode *m)
+{
+	uint8_t *p;
+	int len;
+
+	data[0] = m->pcode;
+	len = m->pcode_sz;
+	data[1] = len;
+	p = &data[2];
+	len += 2;
+	memcpy(p, m->mode_data, m->pcode_sz);
+
+return len;
+}
+
+/*
+ * Reference : SPC4r11
+ * 6.11 - MODE SENSE(6)
+ * 6.12 - MODE SENSE(10)
+ */
+int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
+{
+	int	len = 0;
+	uint8_t *data;
+	uint8_t *scb = cmd->scb;
+	uint8_t	mode6 = (scb[0] == 0x1a) ? 1 : 0;
+	uint8_t dbd = (scb[1] & 8) ? 1 : 0;	/* Disable Block Descriptors */
+	uint8_t page_code = scb[2] & 0x3f;
+	uint8_t subpage = scb[3];
+	uint16_t alloc_len;
+	struct	mode	* m;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+
+	if (subpage)
+		goto sense;	/* Currently not implemented */
+
+	data = valloc(pagesize);
+	if (!data) {
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+	if (mode6) {
+		alloc_len = scb[4];
+		len = 4;
+	} else {
+		alloc_len = (scb[7] << 8) + scb[8];
+		len = 8;
+	}
+	if (alloc_len > pagesize)
+		goto sense;
+
+	if (!dbd) {
+		memcpy(data + len, cmd->dev->mode_block_descriptor,
+				BLOCK_DESCRIPTOR_LEN);
+		len += 8;
+	}
+
+	if (page_code == 0x3f) {	/* All pages */
+		int	i;
+		for (i=0; i < 0x3f; i++) {
+			m = mode_page_lookup(&cmd->dev->mode_pages, i);
+			if (m)
+				len += build_mode_page(data + len, m);
+		}
+	} else {
+		m = mode_page_lookup(&cmd->dev->mode_pages, page_code);
+		if (!m)
+			goto sense;
+		len += build_mode_page(data + len, m);
+	}
+	if (mode6) {
+		data[0] = len - 1;
+		data[3] = (dbd) ? 0 : BLOCK_DESCRIPTOR_LEN;
+	} else {
+		*(uint16_t *)(data) = __cpu_to_be16(len - 3);
+		data[7] = (dbd) ? 0 : BLOCK_DESCRIPTOR_LEN;
+	}
+
+	cmd->len = len;
+	cmd->uaddr = (unsigned long)data;
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
 int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 {
 	cmd->len = 0;
@@ -238,6 +338,106 @@ int spc_request_sense(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 }
 
+/*
+ * Init and alloc space for the supported mode page structures
+ */
+static struct mode *insert_mode_page(struct list_head *head, int page, int subpage, int sz)
+{
+	struct mode *m;
+
+	if ((m = zalloc(sizeof(struct mode))) == NULL)
+		return NULL;
+	if ((m->mode_data = zalloc(sz)) == NULL) {
+		free(m);
+		return NULL;
+	}
+	m->pcode = page;
+	m->subpcode = subpage;
+	m->pcode_sz = (uint16_t)sz;
+	list_add_tail(&m->mode_siblings, head);
+	return m;
+}
+
+struct mode *mode_page_lookup(struct list_head *head, uint8_t page)
+{
+	struct mode *m;
+
+	list_for_each_entry(m, head, mode_siblings)
+		if (m->pcode == page)
+			return m;
+
+	return NULL;
+}
+
+/*
+ * Return:
+ * 	0 on success
+ *	TGTADM_INVALID_REQUEST on error
+ */
+int add_mode_page(struct scsi_lu *lu, char *params)
+{
+	int i = 0;
+	int tmp;
+	uint8_t page = 0;
+	uint8_t subpage = 0;
+	uint8_t *data = NULL;
+	uint16_t sz = 0;
+	struct mode *m = NULL;
+	char *buf;
+	char *p = NULL;
+	int err = TGTADM_NOMEM;
+
+	buf = malloc(strlen(params) + 1);
+	strcpy(buf, params);
+
+	while ((p = strsep(&buf, ":")) != NULL) {
+		switch (i) {
+		case 0:
+			page = strtol(p, NULL, 0);
+			break;
+		case 1:
+			subpage = strtol(p, NULL, 0);
+			break;
+		case 2:
+			sz = strtol(p, NULL, 0);
+			/* Try find existing mode page */
+			m = mode_page_lookup(&lu->mode_pages, page);
+			/* If not found, create the mode page */
+			if (!m)
+				m = insert_mode_page(&lu->mode_pages, page,
+								subpage, sz);
+			/* Still no mode page, fail */
+			if (!m)
+				goto exit;
+
+			data = m->mode_data;
+			break;
+		default:
+			if (i < (sz + 3)) {
+				tmp = strtol(p, NULL, 0);
+				if (tmp > 255)
+					dprintf("Error : Incorrect value %d "
+					"Mode page %d (0x%02x), index: %d\n",
+						tmp, page, page, i - 3);
+				data[i - 3] = (uint8_t)tmp;
+			}
+			break;
+		}
+		i++;
+	}
+
+	err = (i != (sz + 3)) ? TGTADM_INVALID_REQUEST : TGTADM_SUCCESS;
+
+	if (i != (sz + 3))
+		dprintf("Mode Page %d (0x%02x): param_count %d != "
+					" MODE PAGE size : %d\n",
+				page, page, i, sz + 3);
+
+exit:
+	free(buf);
+	return err;
+}
+
 void dump_cdb(struct scsi_cmd *cmd)
 {
 	uint8_t *cdb = cmd->scb;
@@ -283,6 +483,7 @@ enum {
 	Opt_vendor_id, Opt_product_id,
 	Opt_product_rev, Opt_sense_format,
 	Opt_removable, Opt_online,
+	Opt_mode_page,
 	Opt_err,
 };
 
@@ -295,13 +496,14 @@ static match_table_t tokens = {
 	{Opt_sense_format, "sense_format=%s"},
 	{Opt_removable, "removable=%s"},
 	{Opt_online, "online=%s"},
+	{Opt_mode_page, "mode_page=%s"},
 	{Opt_err, NULL},
 };
 
 int spc_lu_config(struct scsi_lu *lu, char *params) {
 	int err = 0;
 	char *p;
-	char buf[20];
+	char buf[256];
 
 	if (!strncmp("targetOps", params, 9))
 		params = params + 10;
@@ -345,6 +547,10 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			match_strncpy(buf, &args[0],  sizeof(buf));
 			lu->attrs.online = atoi(buf);
 			break;
+		case Opt_mode_page:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			err = add_mode_page(lu, buf);
+			break;
 		default:
 			err = TGTADM_INVALID_REQUEST;
 		}
@@ -352,6 +558,11 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 	return err;
 }
 
+/*
+ * Set initial power-on defaults for lu
+ *
+ * Currently always return '0'
+ */
 int spc_lu_init(struct scsi_lu *lu)
 {
 	strncpy(lu->attrs.vendor_id, VENDOR_ID, sizeof(lu->attrs.vendor_id));
diff --git a/usr/spc.h b/usr/spc.h
index 1036b70..c7e38c0 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -1,6 +1,14 @@
 #ifndef __SPC_H
 #define __SPC_H
 
+struct mode {
+	struct list_head mode_siblings;
+	uint8_t pcode;		/* Page code */
+	uint8_t subpcode;	/* Sub page code */
+	int16_t pcode_sz;	/* Size of page code data. */
+	uint8_t *mode_data;	/* Rest of mode page info */
+};
+
 extern int spc_inquiry(int host_no, struct scsi_cmd *cmd);
 extern int spc_report_luns(int host_no, struct scsi_cmd *cmd);
 extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
@@ -10,5 +18,8 @@ extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
 extern int spc_lu_init(struct scsi_lu *lu);
 extern int spc_lu_config(struct scsi_lu *lu, char * params);
 extern void dump_cdb(struct scsi_cmd *cmd);
+extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
+struct mode *mode_page_lookup(struct list_head *head, uint8_t page);
+int add_mode_page(struct scsi_lu *lu, char *params);
 
 #endif
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 8e66d60..bbacae2 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -5,6 +5,7 @@
 
 #define SCSI_ID_LEN	24
 #define SCSI_SN_LEN	8
+#define BLOCK_DESCRIPTOR_LEN 8
 #define VERSION_DESCRIPTOR_LEN 8
 
 #define VENDOR_ID	"IET"
@@ -96,6 +97,9 @@ struct scsi_lu {
 
 	struct backingstore_template *bst;
 
+	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
+	struct list_head mode_pages;
+
 	/* TODO: needs a structure for lots of device parameters */
 	struct lu_phy_attr attrs;
 };
-- 
1.5.2.1







From markh794 at gmail.com  Sat Jun 30 09:49:11 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 30 Jun 2007 17:49:11 +1000
Subject: [Stgt-devel] [Patch 2/2] Re-submit of patch to add SMC module
Message-ID: <46860AF7.6030905@gmail.com>

>From 90317ecae91eb23fc5a467981ae4950f996dd8b6 Mon Sep 17 00:00:00 2001
From: Mark Harvey <markh794 at gmail.com>
Date: Sat, 30 Jun 2007 16:58:48 +1000
Subject: Initial commit of SMC module.

Includes all SCSI op codes defined in SMC as MANDATORY.

As yet, does not contain any way of signaling the DATA TRANSFER DEVICE
a piece of medium has been moved / loaded.

doc/README.lu_configuration updated with SMC specific options.

scripts/tgt-core-test updated to create an SMC device as well.

Signed-off-by: Mark Harvey <markh794 at gmail.com>
---
 doc/README.lu_configuration |   43 +++
 scripts/tgt-core-test       |  101 +++++-
 usr/Makefile                |    5 +-
 usr/media.h                 |   28 ++
 usr/mmc.c                   |    1 +
 usr/osd.c                   |    2 +
 usr/sbc.c                   |    1 +
 usr/sense_codes.h           |    2 +-
 usr/smc.c                   |  791 +++++++++++++++++++++++++++++++++++++++++++
 usr/smc.h                   |   98 ++++++
 usr/spc.c                   |   28 +-
 usr/spc.h                   |    5 +-
 usr/target.c                |   11 +
 usr/tgtadm.c                |    2 +
 usr/tgtd.h                  |    7 +-
 15 files changed, 1095 insertions(+), 30 deletions(-)

diff --git a/doc/README.lu_configuration b/doc/README.lu_configuration
index d63668a..47e4912 100644
--- a/doc/README.lu_configuration
+++ b/doc/README.lu_configuration
@@ -84,6 +84,49 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 2 \
          --params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 
 
+SMC unique options
+------------------
+
+--params have several unique key=value pairs ontop of all other modules.
+ - element_type=<1|2|3|4>
+ - start_address=Number between 1 & 65535
+ - quantity=Number between 1 & 65535
+ - sides=1|2
+ - address=Number between 1 & 65535
+ - barcode="Char string up to 10 chars"
+ - tid=<number>
+ - lun=<number>
+
+Several of these parameters 'work together'
+
+e.g. To add 'quantity' slots as 'element_type' starting at 'start_address'
+ - element_type=<1|2|3|4>
+ - start_address=Number between 1 & 65535
+ - quantity=Number between 1 & 65535
+
+Note: start_address + quantity should not overlap with any other slots..
+
+
+While 'configuring slot 'address' of 'element_type':
+ - Set barcode of meda (occupy slot)
+ - If element type is DATA TRANSFER DEVICE, then define TID & LUN of device.
+
+ - element_type=<1|2|3|4>
+ - address=Number between 1 & 65535
+ - barcode="String up to 10 chars"
+ - sides=<1|2>
+ - tid=<tid of device which belongs at this address>
+ - lun=<lun of device which belongs at this address>
+
+
+It is the responsibility of the user not to configure overlapping slots
+of differing types.
+
+Slot types:
+ 1 -> Medium Transport (picker arm)
+ 2 -> Storage Element
+ 3 -> Import/Export Element
+ 4 -> Data Transfer device (CD drive, tape drive, MO drive etc)
 
 Please refer to scripts/tgt-core-test for a working example.
 
diff --git a/scripts/tgt-core-test b/scripts/tgt-core-test
index a31be1b..db7509c 100755
--- a/scripts/tgt-core-test
+++ b/scripts/tgt-core-test
@@ -17,15 +17,6 @@ fi
 if [ ! -f $HOME/hd_block ]; then
 	dd if=/dev/zero of=$HOME/hd_block bs=1M count=8
 fi
-if [ ! -f $HOME/cd_block0 ]; then
-	dd if=/dev/zero of=$HOME/cd_block0 bs=1M count=8
-fi
-if [ ! -f $HOME/cd_block1 ]; then
-	dd if=/dev/zero of=$HOME/cd_block1 bs=1M count=8
-fi
-if [ ! -f $HOME/cd_block2 ]; then
-	dd if=/dev/zero of=$HOME/cd_block2 bs=1M count=8
-fi
 
 set -x
 
@@ -85,10 +76,13 @@ tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 
 
-
 for LUN in 2 3 4; do
+	if [ ! -f $HOME/cdrom$LUN ]; then
+		dd if=/dev/zero of=$HOME/cdrom$LUN bs=1M count=8
+	fi
+
 	# Create LUN - CD/ROM
-	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cd_block0 --device-type=cd
+	tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN -b $HOME/cdrom$LUN --device-type=cd
 	tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
 		--params vendor_id=VirtualCD,product_id=CD101,product_rev=0010,scsi_sn=XYZZY1$LUN,removable=1
 	# Vendor Uniq - Mode page 0..
@@ -102,6 +96,91 @@ for LUN in 2 3 4; do
 		--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
 done
 
+###############################################################################
+# Set up SMC Medium Changer
+###############################################################################
+LUN=5
+if [ ! -f $HOME/smc ]; then
+	dd if=/dev/zero of=$HOME/smc bs=1k count=1
+fi
+
+tgtadm --lld iscsi --mode logicalunit --op new --tid $TID --lun $LUN \
+			-b $HOME/smc --device-type=changer
+
+#### Set up mode pages ####
+# From smc3-06.pdf
+# Page 0x02: Disconnect/Reconnect SPC-3
+# Page 0x0a: Control SPC-3
+# Page 0x18: Protocol Specific LUN SPC-3
+# Page 0x19: Protocol Specific Port SPC-3
+# Page 0x1a: Power Condition SPC-3
+# Page 0x1c: Informational Exceptions Control SPC-3
+# Page 0x1d: Element Address Assignment SMC-3 7.3.4
+# Page 0x1e: Transport Geometry Parameters SMC-3 7.3.5
+# Page 0x1f: Device Capabilities SMC-3 7.3.2
+# Page 0x1f/Subpage 0x41: Extended Device Capabilities SMC-3 7.3.3
+
+# Dummy 'page 0'
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0:0:0
+# Disconnect/Reconnect
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=2:0:14:0x80:0x80:0:0xa:0:0:0:0:0:0:0:0:0:0
+# Power Condition
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1a:0:18:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
+# Informational Exceptions Control Mode Page
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1c:0:10:8:0:0:0:0:0:0:0:0:0
+# Element Address Assignment - Setup afterwards.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1d:0:0x12:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0
+# Transport Geometry Parameters
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1e:0:2:0:0
+# Device Capabilities
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params mode_page=0x1f:0:0x12:0x0f:7:0x0f:0x0f:0x0f:0x0f:0:0:0:0:0x0f:0x0f:0x0f:0x0f:0:0:0:0
+
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params vendor_id=STK,product_id=L700,product_rev=0010,scsi_sn=XYZZY_0,removable=1
+
+
+## Add Data Transfer devices (3 drives)
+# Define slot address for devices.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,start_address=1,quantity=3
+# Now define which device at each address.
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,address=1,tid=1,lun=2
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,address=2,tid=1,lun=3
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=4,address=3,tid=1,lun=4
+
+# Medium Transport Elements (robot arm / picker)
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=1,start_address=16,quantity=1
+
+## Storage Elements - 8 starting at addr 1024
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=2,start_address=1024,quantity=8
+# Add 'media' to slots
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=2,address=1024,barcode=ABC123,sides=1
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=2,address=1026,barcode=ULT001L3,sides=1
+
+# Import/Export Elements - 5 starting at addr 32
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params element_type=3,start_address=32,quantity=5
+
+
+# Dump the list of configured slots to syslog...
+tgtadm --lld iscsi --mode logicalunit --op update --tid $TID --lun $LUN \
+	--params dump=1
+
+
 # Allow ALL initiators to connect to this target
 tgtadm --lld iscsi --mode target --op bind --tid $TID -I ALL
 
diff --git a/usr/Makefile b/usr/Makefile
index 14be34b..c7fb2ca 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -43,8 +43,9 @@ INCLUDES += -I.
 CFLAGS += -Wall -g -O2 -Wstrict-prototypes -fPIC -D_LARGEFILE64_SOURCE $(INCLUDES)
 
 PROGRAMS += tgtd tgtadm
-TGTD_OBJS += tgtd.o mgmt.o target.o spc.o sbc.o mmc.o osd.o spt.o scc.o scsi.o log.o \
-	driver.o util.o work.o parser.o
+TGTD_OBJS += tgtd.o mgmt.o target.o \
+	spc.o sbc.o mmc.o osd.o spt.o scc.o smc.o \
+	scsi.o log.o driver.o util.o work.o parser.o
 
 all: $(PROGRAMS)
 
diff --git a/usr/media.h b/usr/media.h
new file mode 100644
index 0000000..e54787e
--- /dev/null
+++ b/usr/media.h
@@ -0,0 +1,28 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef _MEDIA_H_
+#define _MEDIA_H_
+
+enum c_type {	/* Cartridge Types - Ref: smc3r06 - Table 20, page 37 */
+	CART_UNSPECIFIED,
+	CART_DATA,
+	CART_CLEAN,
+	CART_DIAGNOSTICS,
+	CART_WORM,
+	CART_MICROCODE,
+};
+
+#endif /* _MEDIA_H_ */
+
diff --git a/usr/mmc.c b/usr/mmc.c
index 17cc741..a08004f 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -38,6 +38,7 @@
 #include "util.h"
 #include "tgtd.h"
 #include "target.h"
+#include "tgtadm_error.h"
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
diff --git a/usr/osd.c b/usr/osd.c
index a48db32..caba4d2 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -29,6 +29,7 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "tgtadm_error.h"
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
@@ -71,6 +72,7 @@ static int osd_lu_init(struct scsi_lu *lu)
 static struct device_type_template osd_template = {
 	.type		= TYPE_OSD,
 	.lu_init	= osd_lu_init,
+	.lu_config	= spc_lu_config,
 	.ops		= {
 		[0x00 ... 0x0f] = {spc_illegal_op},
 
diff --git a/usr/sbc.c b/usr/sbc.c
index 5996081..95ad7f7 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -34,6 +34,7 @@
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
+#include "tgtadm_error.h"
 #include "target.h"
 #include "driver.h"
 #include "scsi.h"
diff --git a/usr/sense_codes.h b/usr/sense_codes.h
index 60a877c..04d3cb5 100644
--- a/usr/sense_codes.h
+++ b/usr/sense_codes.h
@@ -1,7 +1,7 @@
 /*
  * The SCSI sense key Additional Sense Code / Additional Sense Code Qualifier
  *
- * Copyright (C) 2007 Mark Harvey <markh794 at gmail.com>
+ * Reference: http://www.t10.org - spc4r11.pdf
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/usr/smc.c b/usr/smc.c
new file mode 100644
index 0000000..f03ba2d
--- /dev/null
+++ b/usr/smc.c
@@ -0,0 +1,791 @@
+/*
+ * SCSI Medium Changer command processing
+ * Based on smc3r06.pdf document from t10.org
+ *
+ * (C) 2004-2007 FUJITA Tomonori <tomof at acm.org>
+ * (C) 2005-2007 Mike Christie <michaelc at cs.wisc.edu>
+ * (C) 2007      Mark Harvey <markh794 at gmail.com>
+ *
+ * SCSI target emulation code is based on Ardis's iSCSI implementation.
+ *   http://www.ardistech.com/iscsi/
+ *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
+ *   licensed under the terms of the GNU GPL v2.0,
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <errno.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <linux/fs.h>
+
+#include "list.h"
+#include "util.h"
+#include "tgtd.h"
+#include "target.h"
+#include "driver.h"
+#include "tgtadm_error.h"
+#include "scsi.h"
+#include "spc.h"
+#include "sense_codes.h"
+#include "parser.h"
+#include "smc.h"
+#include "media.h"
+
+struct slot *slot_lookup(struct list_head *head, int element_type, int address);
+static void set_slot_full(struct slot *s, uint16_t src);
+static void set_slot_empty(struct slot *s);
+static int test_slot_full(struct slot *s);
+struct lu_phy_attr *lu_attr_lookup(int tid, uint64_t lun);
+
+/* ********************************************************
+ * READ_ELEMENT_STATUS
+ *
+ * Ref: Working Draft SCSI Media Changer-3 (smc3r06.pdf), chapter 6.10
+ *
+ * The READ ELEMENT STATUS command request that the device server report the
+ * status of its internal elements to the application client.
+ * Support for READ ELEMENT STATUS command is mandatory.
+ * ******************************************************** */
+static int determine_element_sz(uint8_t dvcid, uint8_t voltag)
+{
+	if (voltag)
+		return (dvcid) ? 86 : 52;
+	else
+		return (dvcid) ? 50 : 16;
+}
+
+/**
+ * element_status_data_hdr  --  Fill in Element Status Header
+ *  - Always 8 bytes long
+ */
+static int element_status_data_hdr(uint8_t *data, uint8_t dvcid,
+					uint8_t voltag, int start, int count)
+{
+	int element_sz;
+	int size;
+
+	element_sz = determine_element_sz(dvcid, voltag);
+
+	/* First Element address reported */
+	*(uint16_t *)(data) = __cpu_to_be16(start);
+
+	/* Number of elements available */
+	*(uint16_t *)(data + 2) = __cpu_to_be16(count);
+
+	/* Byte count is the length required to return all valid data.
+	 * Allocated length is how much data the initiator will accept */
+	size = ((8 + (count * element_sz)) & 0xffffff);
+	*(uint32_t *)(data + 4) = __cpu_to_be32(size);
+
+return size;
+}
+
+static int add_element_descriptor(uint8_t *data, struct slot *s,
+			uint8_t element_type, uint8_t dvcid, uint8_t voltag)
+{
+	struct lu_phy_attr *attr = NULL;
+	int i;	/* data[] index */
+
+	*(uint16_t *)(data) = __cpu_to_be16(s->slot_addr);
+	data[2] = s->status;
+	data[3] = 0;	/* Reserved */
+	data[4] = (s->asc >> 8) & 0xff;	/* Additional Sense Code */
+	data[5] = s->asc & 0xff;	/* Additional Sense Code Qualifier */
+	/* [6], [7] & [8] reserved */
+	data[9] = (s->cart_type & 0xf);
+	if (s->last_addr) {	/* Source address is valid ? */
+		data[9] |= 0x80;
+		*(uint16_t *)(data + 10) = __cpu_to_be16(s->last_addr);
+	}
+	i = 12;
+	if (voltag) {
+		if (s->barcode[0] == ' ')
+			memset( &data[i], 0x20, 32);
+		else
+			snprintf((char *)&data[i], 32, "%-32s", s->barcode);
+
+		/* Reserve additional 4 bytes if dvcid is set */
+		i += (dvcid) ? 36 : 32;
+	}
+	if (element_type == ELEMENT_DATA_TRANSFER)
+		attr = lu_attr_lookup(s->drive_tid, s->drive_lun);
+	if (dvcid && attr) {
+		data[i] = 2;	/* ASCII code set */
+		data[i + 1] = attr->device_type;
+		data[i + 2] = 0;	/* reserved */
+		data[i + 3] = 34;	/* Length */
+		snprintf((char *)&data[i + 4], 9, "%-8s", attr->vendor_id);
+		snprintf((char *)&data[i + 12], 17, "%-16s", attr->product_id);
+		snprintf((char *)&data[i + 28], 11, "%-10s", attr->scsi_sn);
+	}
+
+return determine_element_sz(dvcid, voltag);
+}
+
+/**
+ * build_element_descriptor  --  Fill in Element details
+ * @data;	pointer
+ * @head;	Slot struct head
+ * @element_type; Slot type we are interested in.
+ * @first:	Return address of first slot found
+ * @start;	Start processing from this element #
+ * @dvcid;	Device ID
+ * @voltag;	Volume tag (barcode)
+ *
+ * Fill each Element Descriptor for slot *s
+ * Return number of elements
+ */
+static int build_element_descriptors(uint8_t *data, struct list_head *head,
+					uint8_t elem_type, int *first,
+					uint16_t start,
+					uint8_t dvcid, uint8_t voltag)
+{
+	struct slot *s;
+	int count = 0;
+	int len = 8;
+	int elem_sz = determine_element_sz(dvcid, voltag);
+
+	list_for_each_entry(s, head, slot_siblings) {
+		if (s->element_type == elem_type) {
+			if (s->slot_addr >= start) {
+				count++;
+				len += add_element_descriptor(&data[len],
+						s, elem_type, dvcid, voltag);
+			}
+		}
+		if (count == 1)	/* Record first found slot Address */
+			*first = s->slot_addr;
+	}
+
+	/* Fill in Element Status Page Header */
+	data[0] = elem_type;
+	data[1] = (voltag) ? 0x80 : 0;
+	*(uint16_t *)(data + 2) = __cpu_to_be16(elem_sz);
+
+	/* Total number of bytes in all element descriptors */
+	*(uint32_t *)(data + 4) = __cpu_to_be32((elem_sz * count) & 0xffffff);
+
+return count;
+}
+
+/* *********************************************
+ * READ ELEMENT STATUS op code
+ * ********************************************* */
+static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
+{
+	struct smc_info *smc = (struct smc_info *)cmd->dev->smc_p;
+	uint8_t *data;
+	uint8_t *scb;
+	uint8_t element_type;
+	uint8_t voltag;
+	uint16_t req_start_elem;
+	uint8_t dvcid;
+	uint32_t alloc_len;
+	uint16_t count = 0;
+	int first = 0;		/* First valid slot location */
+	int len = 8;
+	int elementSize;
+	int ret;
+	unsigned char key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+
+	scb = cmd->scb;
+	element_type = scb[1] & 0x0f;
+	voltag	= (scb[1] & 0x10) >> 4;
+	dvcid = scb[6] & 0x01;
+	req_start_elem = __be16_to_cpu(*(uint16_t *)(scb + 2));
+	alloc_len = 0xffffff & __be32_to_cpu(*(uint32_t *)(scb + 6));
+
+	elementSize = determine_element_sz(dvcid, voltag);
+
+	cmd->len = 0;
+	if (cmd->dev) {
+		ret = device_reserved(cmd);
+		if (ret) {
+			dprintf("Reservation Conflict\n");
+			return SAM_STAT_RESERVATION_CONFLICT;
+		}
+	}
+
+	if (pagesize < alloc_len) {
+		dprintf("Can't allocate enough memory for cmd\n");
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	if ((data = valloc(pagesize)) == NULL) {
+		dprintf("valloc(%lu) failed\n", pagesize);
+		key = HARDWARE_ERROR;
+		asc = ASC_INTERNAL_TGT_FAILURE;
+		goto sense;
+	}
+	memset(data, 0, pagesize);
+
+	if (scb[11])	/* Reserved byte */
+		goto sense;
+
+	switch(element_type) {
+	case ELEMENT_ANY:
+		/* Return element in type order */
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MEDIUM_TRANSPORT, &first,
+					req_start_elem,
+					dvcid, voltag);
+		len = count * elementSize;
+		count += build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_STORAGE, &first,
+					req_start_elem,
+					dvcid, voltag);
+		len += count * elementSize;
+		count += build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MAP, &first,
+					req_start_elem,
+					dvcid, voltag);
+		len += count * elementSize;
+		count += build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_DATA_TRANSFER, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	case ELEMENT_MEDIUM_TRANSPORT:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MEDIUM_TRANSPORT, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	case ELEMENT_STORAGE:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_STORAGE, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	case ELEMENT_MAP:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_MAP, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	case ELEMENT_DATA_TRANSFER:
+		count = build_element_descriptors(&data[len], &smc->slots,
+					ELEMENT_DATA_TRANSFER, &first,
+					req_start_elem,
+					dvcid, voltag);
+		break;
+	default:
+		goto sense;
+		break;
+	}
+
+	/* Lastly, fill in data header */
+	len = element_status_data_hdr(data, dvcid, voltag, first, count);
+
+	cmd->len = min_t(int, len, alloc_len);
+	cmd->uaddr = (unsigned long) data;
+	cmd->rw = READ;
+
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+static int smc_move_medium(int host_no, struct scsi_cmd *cmd)
+{
+	struct smc_info *smc = (struct smc_info *)cmd->dev->smc_p;
+	uint8_t *scb;
+	uint16_t src;
+	uint16_t dest;
+	uint8_t invert;
+	struct slot *src_slot = NULL;
+	struct slot *dest_slot = NULL;
+	struct slot *s;
+	int key = ILLEGAL_REQUEST;
+	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+
+	scb = cmd->scb;
+	src = __be16_to_cpu(*(uint16_t *)(scb + 4));
+	dest = __be16_to_cpu(*(uint16_t *)(scb + 6));
+	invert = scb[10] & 1;
+
+	list_for_each_entry(s, &smc->slots, slot_siblings) {
+		if (s->slot_addr == src)
+			src_slot = s;
+		if (s->slot_addr == dest)
+			dest_slot = s;
+	}
+
+	if (src_slot) {
+		if (!test_slot_full(src_slot)) {
+			asc = ASC_MEDIUM_SRC_EMPTY;
+			goto sense;
+		}
+	} else	/* Could not find src slot - Error */
+		goto sense;
+
+	if (dest_slot) {
+		if (test_slot_full(dest_slot)) {
+			asc = ASC_MEDIUM_DEST_FULL;
+			goto sense;
+		}
+	} else	/* Could not find dest slot - Error */
+		goto sense;
+
+	if (invert)
+		if (s->sides == 1)	/* Use default INVALID FIELD IN CDB */
+			goto sense;
+
+	memcpy(&dest_slot->barcode, &src_slot->barcode, sizeof(s->barcode));
+	set_slot_empty(src_slot);
+	set_slot_full(dest_slot, src);
+	cmd->len = 0;
+	return SAM_STAT_GOOD;
+
+sense:
+	cmd->len = 0;
+	sense_data_build(cmd, key, asc);
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+static int smc_lu_init(struct scsi_lu *lu)
+{
+	struct smc_info *smc;
+
+	smc = zalloc(sizeof(struct smc_info));
+	if (smc)
+		lu->smc_p = smc;
+	else
+		return -ENOMEM;
+
+	spc_lu_init(lu);
+
+	strncpy(lu->attrs.product_id, "VIRTUAL-CHANGER",
+						sizeof(lu->attrs.product_id));
+	lu->attrs.version_desc[0] = 0x0480; /* SMC-3 no version claimed */
+	lu->attrs.version_desc[1] = 0x0960; /* iSCSI */
+	lu->attrs.version_desc[2] = 0x0300; /* SPC-3 */
+
+	INIT_LIST_HEAD(&lu->mode_pages);
+
+	/* Vendor uniq - However most apps seem to call for mode page 0*/
+	add_mode_page(lu, "0:0:0");
+	/* Control page */
+	add_mode_page(lu, "10:0:10:2:0:0:0:0:0:0:0:2:0");
+	/* Power Condition */
+	add_mode_page(lu, "0x1a:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Informational Exceptions Control page */
+	add_mode_page(lu, "0x1c:0:10:8:0:0:0:0:0:0:0:0:0");
+	/* Address Assignment */
+	add_mode_page(lu, "0x1d:0:0x12:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0");
+	/* Transport Geometry Params */
+	add_mode_page(lu, "0x1e:0:2:0:0");
+	/* Device Capabilities */
+	add_mode_page(lu, "0x1f:0:0x12:15:7:15:15:15:15:0:0:0:0:15:15:15:15:0:0:0:0");
+
+	INIT_LIST_HEAD(&smc->slots);
+
+	lu->attrs.online = 1;	/* Library will now report as Online */
+	lu->attrs.reset = 1;	/* Poweron/reset occurred */
+	lu->attrs.removable = 1; /* Default to removable media */
+
+	return 0;
+}
+
+static void smc_lu_exit(struct scsi_lu *lu)
+{
+	struct smc_info *smc = lu->smc_p;
+
+	dprintf("Medium Changer shutdown() called\n");
+
+	free(smc);
+}
+
+static void set_slot_full(struct slot *s, uint16_t src)
+{
+	s->status |= 1;
+	s->last_addr=src;
+}
+
+static void set_slot_empty(struct slot *s)
+{
+	s-> status &= 0xfe;
+	s->last_addr=0;
+	memset(s->barcode, ' ', sizeof(s->barcode));
+}
+
+static int test_slot_full(struct slot *s)
+{
+	return s->status && 1;
+}
+
+static int slot_insert(struct list_head *head, int element_type, int address)
+{
+	struct slot *s;
+
+	if ((s = zalloc(sizeof(struct slot))) == NULL)
+		return TGTADM_NOMEM;
+
+	s->slot_addr = address;
+	s->element_type = element_type;
+	s->sides = 1;
+	if (element_type == ELEMENT_DATA_TRANSFER)	/* Drive */
+		s->asc = ASC_INITIALIZING_REQUIRED;
+
+	list_add_tail(&s->slot_siblings, head);
+
+	return 0;
+}
+
+/**
+ * slot_lookup  -- Find slot of type 'element_type' & address 'address'
+ * @element_type;	Type of slot, 0 == Any type
+ * @address;		Slot address, 0 == First found slot
+ *
+ * Return NULL if no match
+ */
+struct slot *slot_lookup(struct list_head *head, int element_type, int address)
+{
+	struct slot *s;
+
+	list_for_each_entry(s, head, slot_siblings) {
+		if (element_type && address) {
+			if ((s->slot_addr == address) &&
+					(s->element_type == element_type))
+				return s;
+		} else if (element_type) {
+			if (s->element_type == element_type)
+				return s;
+		} else if (address) {
+			if (s->slot_addr == address)
+				return s;
+		}
+	}
+	return NULL;
+}
+
+static void slot_dump(struct list_head *head)
+{
+	struct slot *s;
+
+	list_for_each_entry(s, head, slot_siblings)
+		if (s) {
+			dprintf("Slot %d Information\n", s->slot_addr);
+			dprintf("  Last Addr: %d\n", s->last_addr);
+			dprintf("  Type: %d\n", s->element_type);
+			dprintf("  Barcode: %s\n", s->barcode);
+			if (s->drive_tid) {
+				dprintf("  TID : %d\n", s->drive_tid);
+				dprintf("  LUN : %" PRIu64 "\n", s->drive_lun);
+			}
+			dprintf("  ASC/ASCQ : %d\n\n", s->asc);
+		}
+}
+
+static int add_slt(struct scsi_lu *lu, struct tmp_param *tmp)
+{
+	struct smc_info *smc = lu->smc_p;
+	int ret = TGTADM_INVALID_REQUEST;
+	struct mode *m;
+	struct slot *s;
+	uint16_t *element;
+	int sv_addr;
+	int qnty_save;
+	int i;
+
+	if ((m = mode_page_lookup(&lu->mode_pages, 0x1d)) == NULL) {
+		dprintf("Failed to find Element Address Assignment mode pg\n");
+		return TGTADM_UNKNOWN_ERR;
+	}
+	element = (uint16_t *)m->mode_data;
+
+	if (tmp->element_type && tmp->start_addr && tmp->quantity) {
+		switch(tmp->element_type) {
+		case ELEMENT_MEDIUM_TRANSPORT:
+			break;
+		case ELEMENT_MAP:
+			element += 4;
+			break;
+		case ELEMENT_STORAGE:
+			element += 2;
+			break;
+		case ELEMENT_DATA_TRANSFER:
+			element += 6;
+			break;
+		default:
+			goto dont_do_slots;
+			break;
+		}
+
+		sv_addr = __be16_to_cpu(element[0]);
+		qnty_save  = __be16_to_cpu(element[1]);
+
+		if (sv_addr)
+			element[0] =
+				__cpu_to_be16(min_t(int, tmp->start_addr, sv_addr));
+		else
+			element[0] = __cpu_to_be16(tmp->start_addr);
+		element[1] = __cpu_to_be16(tmp->quantity + qnty_save);
+
+		s = slot_lookup(&smc->slots, tmp->element_type, tmp->start_addr);
+		if (s)	// Opps... Found a slot at this address..
+			goto dont_do_slots;
+
+		ret = TGTADM_SUCCESS;
+		for(i=tmp->start_addr; i < (tmp->start_addr + tmp->quantity); i++)
+			if (slot_insert(&smc->slots, tmp->element_type, i))
+				ret = TGTADM_INVALID_REQUEST;
+	}
+
+dont_do_slots:
+	return ret;
+}
+
+static int config_slot(struct scsi_lu *lu, struct tmp_param *tmp)
+{
+	struct smc_info *smc = lu->smc_p;
+	struct mode *m = NULL;
+	struct slot *s = NULL;
+	int ret = TGTADM_INVALID_REQUEST;
+
+	switch(tmp->element_type) {
+	case ELEMENT_MEDIUM_TRANSPORT:
+		/* If medium has more than one side, set the 'rotate' bit */
+		m = mode_page_lookup(&lu->mode_pages, 0x1e);
+		if (m) {
+			m->mode_data[0] = (tmp->sides > 1) ? 1 : 0;
+			ret = TGTADM_SUCCESS;
+		}
+		break;
+	case ELEMENT_STORAGE:
+	case ELEMENT_MAP:
+		if ((s = slot_lookup(&smc->slots, tmp->element_type, tmp->address)) == NULL)
+			break;	// Slot not found..
+		strncpy(s->barcode, tmp->barcode, sizeof(s->barcode));
+		set_slot_full(s, 0);
+		ret = TGTADM_SUCCESS;
+		break;
+	case ELEMENT_DATA_TRANSFER:
+		if (!tmp->tid)
+			break;	/* Fail if no TID specified */
+		if ((s = slot_lookup(&smc->slots, tmp->element_type, tmp->address)) == NULL)
+			break;	// Slot not found..
+		s->asc  = NO_ADDITIONAL_SENSE;
+		s->drive_tid = tmp->tid;
+		s->drive_lun = tmp->lun;
+		ret = TGTADM_SUCCESS;
+		break;
+	}
+	return ret;
+}
+
+#define ADD	1
+#define CONFIGURE 2
+
+static int __smc_lu_config(struct scsi_lu *lu, char *params)
+{
+	struct smc_info *smc = (struct smc_info *)lu->smc_p;
+	int err = TGTADM_SUCCESS;
+	char *p;
+	char buf[20];
+
+	while ((p = strsep(&params, ",")) != NULL) {
+		substring_t args[MAX_OPT_ARGS];
+		int token;
+		if (!*p)
+			continue;
+		token = match_token(p, tokens, args);
+		switch (token) {
+		case Opt_element_type:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.element_type = atoi(buf);
+			break;
+		case Opt_start_address:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.start_addr = atoi(buf);
+			sv_param.operation = ADD;
+			break;
+		case Opt_quantity:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.quantity = atoi(buf);
+			break;
+		case Opt_sides:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.sides = atoi(buf);
+			break;
+		case Opt_address:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.address = atoi(buf);
+			sv_param.operation = CONFIGURE;
+			break;
+		case Opt_barcode:
+			match_strncpy(sv_param.barcode, &args[0],
+						sizeof(sv_param.barcode));
+			break;
+		case Opt_tid:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.tid = atoi(buf);
+			break;
+		case Opt_lun:
+			match_strncpy(buf, &args[0], sizeof(buf));
+			sv_param.lun = atoi(buf);
+			break;
+		case Opt_dump:
+			slot_dump(&smc->slots);
+			break;
+		default:
+			err = TGTADM_UNKNOWN_PARAM;
+		}
+	}
+	return err;
+}
+
+static int smc_lu_config(struct scsi_lu *lu, char *params)
+{
+	int ret = TGTADM_SUCCESS;
+
+	memset(&sv_param, 0, sizeof(struct tmp_param));
+
+	if ((ret = lu_config(lu, params, __smc_lu_config)))
+		return TGTADM_UNKNOWN_PARAM;
+
+	switch(sv_param.operation) {
+		case ADD:
+			ret = add_slt(lu, &sv_param);
+			break;
+		case CONFIGURE:
+			ret = config_slot(lu, &sv_param);
+			break;
+	}
+	return ret;
+}
+
+struct device_type_template smc_template = {
+	.type		= TYPE_MEDIUM_CHANGER,
+	.lu_init	= smc_lu_init,
+	.lu_exit 	= smc_lu_exit,
+	.lu_config	= smc_lu_config,
+	.ops	= {
+		{spc_test_unit,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_request_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		/* 0x10 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_inquiry,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x20 ... 0x4f] = {spc_illegal_op,},
+
+		/* 0x50 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_mode_sense,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0x60 ... 0x9f] = {spc_illegal_op,},
+
+		/* 0xA0 */
+		{spc_report_luns,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{smc_move_medium,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_test_unit,},
+
+		/* 0xB0 */
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		{smc_read_element_status,},	// Mandatory
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+		{spc_illegal_op,},
+
+		[0xc0 ... 0xff] = {spc_illegal_op},
+	}
+};
+
+__attribute__((constructor)) static void smc_init(void)
+{
+	device_type_register(&smc_template);
+}
diff --git a/usr/smc.h b/usr/smc.h
new file mode 100644
index 0000000..3c83ce8
--- /dev/null
+++ b/usr/smc.h
@@ -0,0 +1,98 @@
+/*
+ * SCSI Medium Changer Command
+ *
+ * Copyright (C) 2007 Mark Harvey markh794 at gmail.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _SMC_H_
+#define _SMC_H_
+
+/**************************************************
+ * Slot description
+ **************************************************/
+#define ELEMENT_ANY		0
+#define	ELEMENT_MEDIUM_TRANSPORT	1
+#define	ELEMENT_STORAGE		2
+#define	ELEMENT_MAP		3
+#define	ELEMENT_DATA_TRANSFER	4
+
+struct slot {
+	struct	list_head	slot_siblings;
+	uint8_t		element_type;	/* Element Type 1, 2, 3 or 4 */
+	uint8_t		cart_type;	/* 0 Unspecified, 1 Data, 2 Cleaning */
+	uint16_t	slot_addr;	/* 65535 slots should be enough.. */
+	uint16_t	last_addr;	/* Where the media came from.. */
+	uint16_t	asc;		/* Additional sense code */
+	uint8_t		status;		/* Used for MAP status bits */
+	uint8_t		sides;		/* Number of sides this media. */
+	char		barcode[11];	/* Up to 10 char barcode */
+	/* Only used if slot contains a drive. */
+	uint8_t		drive_tid;
+	uint64_t	drive_lun;
+};
+
+/**************************************************
+ * Data structure for SMC device
+ * Top of the 'tree'
+ **************************************************/
+struct smc_info {
+	struct	list_head	slots;
+};
+
+enum {
+	Opt_element_type, Opt_start_address,
+	Opt_quantity, Opt_sides,
+	Opt_address, Opt_barcode,
+	Opt_tid, Opt_lun,
+	Opt_type, Opt_dump,
+	Opt_err,
+};
+
+static match_table_t tokens = {
+	{Opt_element_type, "element_type=%s"},
+	{Opt_start_address, "start_address=%s"},
+	{Opt_quantity, "quantity=%s"},
+	{Opt_sides, "sides=%s"},
+	{Opt_address, "address=%s"},
+	{Opt_barcode, "barcode=%s"},
+	{Opt_tid, "tid=%s"},
+	{Opt_lun, "lun=%s"},
+	{Opt_type, "type=%s"},
+	{Opt_dump, "dump=%s"},
+	{Opt_err, NULL},
+};
+
+/**
+ * struct tmp_param{} -- temporary storage of param values from user
+ *
+ * As param parsing is stateless, several params need to be collected
+ * before we know if we are attempting to configure a slot or adding
+ * a number of new slots. This is just a temporary holder for all
+ * possible valid params before processing.
+ */
+struct tmp_param {
+	int operation;
+	int element_type;
+	int start_addr;
+	int quantity;
+	int address;
+	int tid;
+	uint64_t lun;
+	char barcode[20];
+	int sides;
+} sv_param;
+
+#endif // _SMC_H_
diff --git a/usr/spc.c b/usr/spc.c
index 3eb605c..e17e25c 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -500,8 +500,9 @@ static match_table_t tokens = {
 	{Opt_err, NULL},
 };
 
-int spc_lu_config(struct scsi_lu *lu, char *params) {
-	int err = 0;
+int lu_config(struct scsi_lu *lu, char *params, match_fn_t *fn)
+{
+	int err = TGTADM_SUCCESS;
 	char *p;
 	char buf[256];
 
@@ -525,15 +526,15 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			break;
 		case Opt_vendor_id:
 			match_strncpy(lu->attrs.vendor_id, &args[0],
-					sizeof(lu->attrs.vendor_id));
+					sizeof(lu->attrs.vendor_id) - 1);
 			break;
 		case Opt_product_id:
 			match_strncpy(lu->attrs.product_id, &args[0],
-					sizeof(lu->attrs.product_id));
+					sizeof(lu->attrs.product_id) - 1);
 			break;
 		case Opt_product_rev:
 			match_strncpy(lu->attrs.product_rev, &args[0],
-					sizeof(lu->attrs.product_rev));
+					sizeof(lu->attrs.product_rev) - 1);
 			break;
 		case Opt_sense_format:
 			match_strncpy(buf, &args[0],  sizeof(buf));
@@ -552,21 +553,22 @@ int spc_lu_config(struct scsi_lu *lu, char *params) {
 			err = add_mode_page(lu, buf);
 			break;
 		default:
-			err = TGTADM_INVALID_REQUEST;
+			err |= fn ? fn(lu, p) : TGTADM_INVALID_REQUEST;
 		}
 	}
 	return err;
 }
 
-/*
- * Set initial power-on defaults for lu
- *
- * Currently always return '0'
- */
+int spc_lu_config(struct scsi_lu *lu, char *params)
+{
+	return lu_config(lu, params, NULL);
+}
+
 int spc_lu_init(struct scsi_lu *lu)
 {
-	strncpy(lu->attrs.vendor_id, VENDOR_ID, sizeof(lu->attrs.vendor_id));
-	memcpy(lu->attrs.product_rev, "0001", 4);
+	snprintf(lu->attrs.vendor_id, sizeof(lu->attrs.vendor_id) - 1,
+							"%-16s", VENDOR_ID);
+	snprintf(lu->attrs.product_rev, 4, "%s", "0001");
 	lu->attrs.removable = 0;
 	lu->attrs.sense_format = 0;
 	lu->attrs.online = 0;
diff --git a/usr/spc.h b/usr/spc.h
index c7e38c0..b2b0cf0 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -16,7 +16,10 @@ extern int spc_test_unit(int host_no, struct scsi_cmd *cmd);
 extern int spc_request_sense(int host_no, struct scsi_cmd *cmd);
 extern int spc_illegal_op(int host_no, struct scsi_cmd *cmd);
 extern int spc_lu_init(struct scsi_lu *lu);
-extern int spc_lu_config(struct scsi_lu *lu, char * params);
+
+typedef int (match_fn_t)(struct scsi_lu *lu, char *params);
+extern int lu_config(struct scsi_lu *lu, char *params, match_fn_t *);
+extern int spc_lu_config(struct scsi_lu *lu, char *params);
 extern void dump_cdb(struct scsi_cmd *cmd);
 extern int spc_mode_sense(int host_no, struct scsi_cmd *cmd);
 struct mode *mode_page_lookup(struct list_head *head, uint8_t page);
diff --git a/usr/target.c b/usr/target.c
index d3c9cb8..997f3f2 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -341,6 +341,17 @@ int tgt_device_destroy(int tid, uint64_t lun, int force)
 	return 0;
 }
 
+struct lu_phy_attr *lu_attr_lookup(int tid, uint64_t lun)
+{
+	struct target *target;
+	struct scsi_lu *lu;
+
+	lu = __device_lookup(tid, lun, &target);
+	if (!lu)
+		return NULL;
+	return &lu->attrs;
+}
+
 int device_reserve(struct scsi_cmd *cmd)
 {
 	struct scsi_lu *lu;
diff --git a/usr/tgtadm.c b/usr/tgtadm.c
index c2315b6..0631a7d 100644
--- a/usr/tgtadm.c
+++ b/usr/tgtadm.c
@@ -300,6 +300,8 @@ static int str_to_device_type(char *str)
 		exit(EINVAL);
 	} else if (!strcmp(str, "cd"))
 		return TYPE_ROM;
+	else if (!strcmp(str, "changer"))
+		return TYPE_MEDIUM_CHANGER;
 	else if (!strcmp(str, "osd"))
 		return TYPE_OSD;
 	else if (!strcmp(str, "pt"))
diff --git a/usr/tgtd.h b/usr/tgtd.h
index bbacae2..02a834b 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -73,7 +73,7 @@ struct backingstore_template {
 	int (*bs_open)(struct scsi_lu *dev, char *path, int *fd, uint64_t *size);
 	void (*bs_close)(struct scsi_lu *dev);
 	int (*bs_cmd_submit)(struct scsi_cmd *cmd);
-	int (*bs_cmd_done) (struct scsi_cmd *cmd);
+	int (*bs_cmd_done)(struct scsi_cmd *cmd);
 };
 
 struct scsi_lu {
@@ -100,8 +100,11 @@ struct scsi_lu {
 	uint8_t	mode_block_descriptor[BLOCK_DESCRIPTOR_LEN];
 	struct list_head mode_pages;
 
-	/* TODO: needs a structure for lots of device parameters */
 	struct lu_phy_attr attrs;
+
+	/* TODO: needs a structure for lots of device parameters */
+	/* Currently only used by smc module */
+	void *smc_p;
 };
 
 struct scsi_cmd {
-- 
1.5.2.1








From albert.pauw at gmail.com  Sat Jun 30 22:56:13 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Sat, 30 Jun 2007 22:56:13 +0200
Subject: [Stgt-devel] iscsi: cmd 0x35 is not queued (6)
Message-ID: <4686C36D.6090004@gmail.com>

When running open-iscsi (latest git version) I seem to be hitting the 
following regularly when logging out the stgt target:

Jun 28 22:04:03 orange kernel: Synchronizing SCSI cache for disk sdb:
Jun 28 22:04:03 orange kernel: iscsi: cmd 0x35 is not queued (6)
Jun 28 22:04:03 orange last message repeated 2 times
Jun 28 22:04:03 orange kernel: FAILED
Jun 28 22:04:03 orange kernel:   status = 0, message = 00, host = 1, 
driver = 00

However, when doing the same with iscsi-target it works fine (I actually
ran the regression.sh script of open-iscsi).

So something is different here between iscsi-target and stgt with 
handling the
SCSI synchronize cache command (0x35).

I use a 4 GB file as a backing store.

Albert


