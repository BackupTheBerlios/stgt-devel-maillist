From fujita.tomonori at lab.ntt.co.jp  Fri Mar  2 00:18:40 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 02 Mar 2007 08:18:40 +0900
Subject: [Stgt-devel] your recent sense checkin
In-Reply-To: <20070228201323.GA18276@osc.edu>
References: <20070228201323.GA18276@osc.edu>
Message-ID: <20070302081840U.fujita.tomonori@lab.ntt.co.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] your recent sense checkin
Date: Wed, 28 Feb 2007 15:13:23 -0500

> I took a look at your SVN and rebased my patches on top of it.

Oh, thanks a lot. I can take care of you patches. I need to clean up
something before merging them.


>  One thing to point out: it should be possible for a target to send
> back both data-in bytes as the result of a command, and status bytes
> in the response.  Your use of task->addr to get the status bytes
> appears to make that impossible.  I had added extra task->sense and
> task->senselen to accommodate this usage.

Yeah. We've been fixing sense issues in tgt in-kernel component.

You add:

@@ -94,6 +94,8 @@ struct scsi_cmd {

 	unsigned char sense_buffer[SCSI_SENSE_BUFFERSIZE];
+	uint8_t *sense;    /* output values from target */

scsi_cmd structure has two sense_buffer. one is for some lld and one
is a pointer for odd llds.

Then, you add super long sense buffer to struct iscsi_connection:

@@ -146,6 +148,7 @@ struct iscsi_connection {
 	struct iscsi_pdu req;
 	void *req_buffer;
 	struct iscsi_pdu rsp;
+	uint8_t sense_buffer[252];  /* architectural limit */


I just want to have one sense_buffer in scsi_cmd even even if it's
large.

The problem is that tgt in-kernel component can't accept unaligned
buffer for sense (and as you pointed out, we wrongly use uaddr and len
fields in cmd_rsp struct for sense). I've been testing the patches.
When I finish it, I can fix tgtd.


> Regarding the "Need to clean up this mess" comment in
> iscsi_scsi_cmd_tx_start:  it gets worse once we mix in the
> bidirectional.  There you cannot do a phase collapse on the final
> data packet, so it becomes even more of a mess.

Nice.


> I have cleaned most of that mess up, perhaps, as part of getting
> bidirectional transfers to work, but the patches are not ready for
> submission to stgt because they depend on AHS structures defined
> only in non-mainline kernel patches.  If you are willing to remove
> the dependency on kernel headers by copying the relevant bits into
> stgt, we can avoid that problem.

I'm ok with using the nice header instead of upstream header files.


> Note the duplication in iscsi_cmd_rsp_build and
> iscsi_sense_rsp_build; wouldn't it be better to have a single
> function with "if (task->result != 0) {...}" to return status?

Probabaly.


> Here they are, fyi.  Let me know if you have suggestions on how I
> can help you get more of this merged.

Sorry for taking so long to merge your patches. Surely, I'll merge
your patches.

I'll try to finish multiple device support sutff this weekend. Yeah, I
did last week and fixed AIO stuff instead. tgtd works with any
upstream kernels. It's as neat as multiple device support, isn't it ;)


From fujita.tomonori at lab.ntt.co.jp  Sun Mar  4 16:12:57 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 05 Mar 2007 00:12:57 +0900
Subject: [Stgt-devel] [PATCH 4/4] OSD command parser
In-Reply-To: <200702191433.l1JEX6Dn025494@r-dd.iij4u.or.jp>
References: <1169494510.2784.58.camel@localhost.localdomain>
	<20070123161917.GB2885@osc.edu>
	<200702191433.l1JEX6Dn025494@r-dd.iij4u.or.jp>
Message-ID: <200703041513.l24FD0SC002879@r-dd.iij4u.or.jp>

From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
Subject: Re: [Stgt-devel] [PATCH 4/4] OSD command parser
Date: Mon, 19 Feb 2007 23:32:59 +0900

> From: Pete Wyckoff <pw at osc.edu>
> Subject: Re: [Stgt-devel] [PATCH 4/4] OSD command parser
> Date: Tue, 23 Jan 2007 11:19:17 -0500
> 
> > blackmagic02881 at gmail.com wrote on Mon, 22 Jan 2007 14:35 -0500:
> > > not a good idea. suggest to keep in a way like IET code, for each target
> > > type, call its foo_cmd_perform(), and make some common spc function as
> > > helper functions.
> > 
> > I think you're saying that I should duplicate the switch() logic for
> > the SPC commands in all the (osd|sbc|mmc|...)_cmd_perfom()
> > type-specific functions.  This would reduce scsi_cmd_perform() into
> > just a check on the target type, with no handling of SPC commands,
> > e.g. INQUIRY.
> > 
> > I'm not opposed to doing that, just don't have a good reason to do
> > so.  As the OSD work progresses this may become clear to me (PERFORM
> > SCSI COMMAND and PERFORM TASK MANAGEMENT FUNCTION).
> 
> Very sorry for taking so long.
> 
> I put a patch to support various device types:
> 
> http://zaal.org/tgt/device-types.diff
> 
> 
> I don't merge it because:
> 
> - only iscsi + AIO works (sg and ibmvio are broken).
> 
> - there are still lots of things to implement
> 
> - huge cleanup is necessary

I've merged it though there are still many things to clean up.

I added the virtual cd patch that Ming wrote for IET as an
example. You can export iso files as a cd drive. An initiator can see
a cd drive, but it can't read the iso file. So there must be bugs,
however I've not dig into it. Patches are welcome :)

You can export iso files in the following way:

tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz --target-type cd
tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 -b /home/fujita/debian-31r5-i386-businesscard.iso
tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL


Pete, I found that you don't put a license in osd.c. GPL2 or GPL2 or
any later version? Let me know. I'll update and merge it.


I added sgv3 pass through support. By default, tgt is compiled with
sgv3 support instead of sgv4.

tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz --target-type pt
tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 -b /dev/sg0
tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL

Note that I'll change the interface not to use /dev/sgX directly.

I can export a disk drive with sgv3 support. But it doesn't work
fully. I'll fix it someday, but the next thing I'll do is adding
bi-directional support.


From pw at osc.edu  Sun Mar  4 22:58:00 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sun, 4 Mar 2007 16:58:00 -0500
Subject: [Stgt-devel] [PATCH 4/4] OSD command parser
In-Reply-To: <200703041513.l24FD0SC002879@r-dd.iij4u.or.jp>
References: <1169494510.2784.58.camel@localhost.localdomain>
	<20070123161917.GB2885@osc.edu>
	<200702191433.l1JEX6Dn025494@r-dd.iij4u.or.jp>
	<200703041513.l24FD0SC002879@r-dd.iij4u.or.jp>
Message-ID: <20070304215800.GA22985@osc.edu>

fujita.tomonori at lab.ntt.co.jp wrote on Mon, 05 Mar 2007 00:12 +0900:
> I've merged it though there are still many things to clean up.
> 
> I added the virtual cd patch that Ming wrote for IET as an
> example. You can export iso files as a cd drive. An initiator can see
> a cd drive, but it can't read the iso file. So there must be bugs,
> however I've not dig into it. Patches are welcome :)
> 
> You can export iso files in the following way:
> 
> tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz --target-type cd
> tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 -b /home/fujita/debian-31r5-i386-businesscard.iso
> tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL
> 
> 
> Pete, I found that you don't put a license in osd.c. GPL2 or GPL2 or
> any later version? Let me know. I'll update and merge it.

Great!  Thanks for doing all this.  It will take me some time for me
to catch up and see how things are integrated now.

Please add license GPL2 exact.  I forgot.

If you generate SVN checkin emails, I would be happy to be added to
that list.

> I added sgv3 pass through support. By default, tgt is compiled with
> sgv3 support instead of sgv4.
> 
> tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz --target-type pt
> tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 -b /dev/sg0
> tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL
> 
> Note that I'll change the interface not to use /dev/sgX directly.
> 
> I can export a disk drive with sgv3 support. But it doesn't work
> fully. I'll fix it someday, but the next thing I'll do is adding
> bi-directional support.

This is a nice addition.  But I'll probably not try it in the near
term.

		-- Pete


From blackmagic02881 at gmail.com  Sun Mar  4 23:09:29 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Sun, 04 Mar 2007 17:09:29 -0500
Subject: [Stgt-devel] [PATCH 4/4] OSD command parser
In-Reply-To: <20070304215800.GA22985@osc.edu>
References: <1169494510.2784.58.camel@localhost.localdomain>
	<20070123161917.GB2885@osc.edu>
	<200702191433.l1JEX6Dn025494@r-dd.iij4u.or.jp>
	<200703041513.l24FD0SC002879@r-dd.iij4u.or.jp>
	<20070304215800.GA22985@osc.edu>
Message-ID: <1173046169.4177.26.camel@localhost.localdomain>

On Sun, 2007-03-04 at 16:58 -0500, Pete Wyckoff wrote:
> If you generate SVN checkin emails, I would be happy to be added to
> that list.
> 

check berlios, it is there already.




From pw at osc.edu  Sun Mar  4 23:34:22 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sun, 4 Mar 2007 17:34:22 -0500
Subject: [Stgt-devel] [PATCH 4/4] OSD command parser
In-Reply-To: <1173046169.4177.26.camel@localhost.localdomain>
References: <1169494510.2784.58.camel@localhost.localdomain>
	<20070123161917.GB2885@osc.edu>
	<200702191433.l1JEX6Dn025494@r-dd.iij4u.or.jp>
	<200703041513.l24FD0SC002879@r-dd.iij4u.or.jp>
	<20070304215800.GA22985@osc.edu>
	<1173046169.4177.26.camel@localhost.localdomain>
Message-ID: <20070304223422.GA23000@osc.edu>

blackmagic02881 at gmail.com wrote on Sun, 04 Mar 2007 17:09 -0500:
> On Sun, 2007-03-04 at 16:58 -0500, Pete Wyckoff wrote:
> > If you generate SVN checkin emails, I would be happy to be added to
> > that list.
> > 
> check berlios, it is there already.

Thanks.  Easy enough to guess the name.

		-- Pete


From fujita.tomonori at lab.ntt.co.jp  Mon Mar  5 01:50:02 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 05 Mar 2007 09:50:02 +0900
Subject: [Stgt-devel] [PATCH 4/4] OSD command parser
In-Reply-To: <20070304215800.GA22985@osc.edu>
References: <200702191433.l1JEX6Dn025494@r-dd.iij4u.or.jp>
	<200703041513.l24FD0SC002879@r-dd.iij4u.or.jp>
	<20070304215800.GA22985@osc.edu>
Message-ID: <20070305095002I.fujita.tomonori@lab.ntt.co.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: Re: [Stgt-devel] [PATCH 4/4] OSD command parser
Date: Sun, 4 Mar 2007 16:58:00 -0500

> > Pete, I found that you don't put a license in osd.c. GPL2 or GPL2 or
> > any later version? Let me know. I'll update and merge it.
> 
> Great!  Thanks for doing all this.  It will take me some time for me
> to catch up and see how things are integrated now.
> 
> Please add license GPL2 exact.  I forgot.

Done.

You can do something like that:

tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz  --target-type osd
tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 -b /dev/sdb
tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL

tulip:/home/fujita# ./tgt/usr/tgtadm --op show --mode target
Target 1: iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz
    System information:
        Type: osd
        Driver: iscsi
        Status: running
    I_T nexus information:
    LUN information:
        LUN: 0
            SCSI ID: deadbeaf1:0
            SCSI SN:
            Size: 279G
            Backing store: /dev/sdb
    Account information:
    ACL information:
        ALL


It doesn't work at all. Currently, it only shows that we will support
osd someday. ;)


From pw at osc.edu  Mon Mar  5 21:34:34 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 5 Mar 2007 15:34:34 -0500
Subject: [Stgt-devel] [PATCH 4/4] OSD command parser
In-Reply-To: <20070305095002I.fujita.tomonori@lab.ntt.co.jp>
References: <200702191433.l1JEX6Dn025494@r-dd.iij4u.or.jp>
	<200703041513.l24FD0SC002879@r-dd.iij4u.or.jp>
	<20070304215800.GA22985@osc.edu>
	<20070305095002I.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20070305203434.GA17606@osc.edu>

fujita.tomonori at lab.ntt.co.jp wrote on Mon, 05 Mar 2007 09:50 +0900:
> It doesn't work at all. Currently, it only shows that we will support
> osd someday. ;)

It works!  Well, I have a local patch to add a backedio_template to
talk to our emulator, and then it works.

Here is the much reduced set of generic patches I use.  You are
probably working on all this already, though (scb length, AHS,
bidirectional).  The only one you may want to apply directly is the
osd one.

Regarding sense format.  OSD must use descriptor format.  The rest
of stgt uses fixed format.  You will see how I have to redefine
things like osd_test_unit just to be able to send the right sense
format.  Perhaps we should have a field in device_type_template that
specifies a function to build the basic sense header?  Let me know
and I will clean it up.

I'd also like to add a "illegal_op" function pointer in the
device_type_template to simplify the long listing at the end of
osd.c and others.  Semantics would be:  ops[cdb[0]] != NULL ? call
the function, else call ->illegal_op().

		-- Pete


From pw at osc.edu  Mon Mar  5 21:36:25 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 5 Mar 2007 15:36:25 -0500
Subject: [Stgt-devel] [PATCH] pass scb length
Message-ID: <20070305203625.GB17606@osc.edu>

Large CDBs are needed for OSD commands.  Pass the length of the command
as well as the CDB itself.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    4 ++--
 usr/target.c       |    8 +++++---
 usr/tgtd.h         |    5 +++--
 usr/tgtif.c        |    2 +-
 4 files changed, 11 insertions(+), 8 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 68c3c77..3178df6 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -987,14 +987,14 @@ static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 				list_add_tail(&task->c_list, &task->conn->tx_clist);
 		} else
 			err = target_cmd_queue(conn->session->iscsi_nexus_id,
-					       req->cdb,
+					       req->cdb, 16,
 					       req->flags & ISCSI_FLAG_CMD_WRITE,
 					       uaddr, req->lun,
 					       ntohl(req->data_length),
 					       cmd_attr(task), req->itt);
 	} else
 		err = target_cmd_queue(conn->session->iscsi_nexus_id,
-				       req->cdb,
+				       req->cdb, 16,
 				       req->flags & ISCSI_FLAG_CMD_WRITE,
 				       uaddr, req->lun, ntohl(req->data_length),
 				       cmd_attr(task), req->itt);
diff --git a/usr/target.c b/usr/target.c
index 4be4aa2..8fa12cc 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -391,7 +391,7 @@ static void cmd_post_perform(struct tgt_cmd_queue *q, struct scsi_cmd *cmd)
 	}
 }
 
-int target_cmd_queue(uint64_t nid, uint8_t *scb, uint8_t rw,
+int target_cmd_queue(uint64_t nid, uint8_t *scb, int scblen, uint8_t rw,
 		     unsigned long uaddr,
 		     uint8_t *lun, uint32_t data_len,
 		     int attribute, uint64_t tag)
@@ -412,7 +412,7 @@ int target_cmd_queue(uint64_t nid, uint8_t *scb, uint8_t rw,
 
 	target = nexus->nexus_target;
 	/* TODO: preallocate cmd */
-	cmd = zalloc(sizeof(*cmd));
+	cmd = zalloc(sizeof(*cmd) + scblen);
 	if (!cmd)
 		return -ENOMEM;
 
@@ -423,7 +423,9 @@ int target_cmd_queue(uint64_t nid, uint8_t *scb, uint8_t rw,
 	cmd->uaddr = uaddr;
 	cmd->len = data_len;
 	cmd->rw = rw;
-	memcpy(cmd->scb, scb, sizeof(cmd->scb));
+ 	cmd->scb = (void *) (cmd + 1);
+ 	cmd->scblen = scblen;
+ 	memcpy(cmd->scb, scb, scblen);
 	memcpy(cmd->lun, lun, sizeof(cmd->lun));
 
 	cmd_hlist_insert(target, cmd);
diff --git a/usr/tgtd.h b/usr/tgtd.h
index d2a79c1..a6cc287 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -73,7 +73,8 @@ struct scsi_cmd {
 	uint64_t cmd_nexus_id;
 	uint32_t data_len;
 	uint64_t offset;
-	uint8_t scb[16];
+	uint8_t *scb;
+	int scblen;
 	uint8_t lun[8];
 	int attribute;
 	uint64_t tag;
@@ -126,7 +127,7 @@ extern int tgt_event_add(int fd, int events, event_handler_t handler, void *data
 extern void tgt_event_del(int fd);
 extern int tgt_event_modify(int fd, int events);
 
-extern int target_cmd_queue(uint64_t nid, uint8_t *scb, uint8_t rw,
+extern int target_cmd_queue(uint64_t nid, uint8_t *scb, int scblen, uint8_t rw,
 			    unsigned long uaddr,
 			    uint8_t *lun, uint32_t data_len,
 			    int attribute, uint64_t tag);
diff --git a/usr/tgtif.c b/usr/tgtif.c
index 3d54aa1..0328c1d 100644
--- a/usr/tgtif.c
+++ b/usr/tgtif.c
@@ -136,7 +136,7 @@ retry:
 	switch (ev->hdr.type) {
 	case TGT_KEVENT_CMD_REQ:
 		target_cmd_queue(host_no_to_it_nexus(ev->p.cmd_req.host_no),
-				 ev->p.cmd_req.scb,
+				 ev->p.cmd_req.scb, 16,
 				 0, 0,
 /* 				 ev->k.cmd_req.uaddr, */
 				 ev->p.cmd_req.lun, ev->p.cmd_req.data_len,
-- 
1.5.0.2



From pw at osc.edu  Mon Mar  5 21:36:59 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 5 Mar 2007 15:36:59 -0500
Subject: [Stgt-devel] [PATCH] osd sense fixup
Message-ID: <20070305203659.GC17606@osc.edu>

OSD must use descriptor format sense data.  Support request sense and
report luns.  Add support for a couple more inquiry page codes.  Remove
list of actions; submit can deal with it.  They are obsolete anyway.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/osd.c |  289 +++++++++++++++++++++++++++++++++++++++----------------------
 usr/osd.h |   33 -------
 2 files changed, 186 insertions(+), 136 deletions(-)
 delete mode 100644 usr/osd.h

diff --git a/usr/osd.c b/usr/osd.c
index 4cdfa1a..1d65e42 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -1,7 +1,7 @@
 /*
  * SCSI object storage device command processing
  *
- * Copyright (C) 2006 Pete Wyckoff <pw at osc.edu>
+ * Copyright (C) 2006-2007 Pete Wyckoff <pw at osc.edu>
  *
  * Copyright (C) 2007 FUJITA Tomonori <tomof at acm.org>
  * Copyright (C) 2007 Mike Christie <michaelc at cs.wisc.edu>
@@ -13,6 +13,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
 
 #include "list.h"
 #include "util.h"
@@ -21,19 +22,36 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
-#include "osd.h"
 
 #define PRODUCT_ID	"OSD"
 #define PRODUCT_REV	"0"
 
+/*
+ * Build a descriptor format sense header.  OSDs must return this,
+ * not fixed format.
+ */
+static void sense_descriptor_build(struct scsi_cmd *cmd, uint8_t key,
+				   uint8_t asc, uint8_t ascq)
+{
+	cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
+	cmd->sense_buffer[1] = key;
+	cmd->sense_buffer[2] = asc;
+	cmd->sense_buffer[3] = ascq;
+	cmd->sense_len = 8;
+}
+
 static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	uint8_t *data, *scb = cmd->scb;
-	int len, ret = SAM_STAT_CHECK_CONDITION;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	int evpd = scb[1] & 1;
+	uint8_t page_code = scb[2];
+	uint16_t alloc_len = (scb[3] << 8) | scb[4];
+	int len;
+	/* illegal field in CDB */
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
 	/* EVPD means need a page code */
-	if ((scb[1] & 0x3) == 0 && scb[2] != 0)
+	if ((scb[1] & 0x3) == 0 && page_code != 0)
 		goto sense;
 
 	data = valloc(pagesize);
@@ -44,13 +62,17 @@ static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
 	}
 	memset(data, 0, pagesize);
 
-	dprintf("%x %x\n", scb[1], scb[2]);
+	dprintf("%x %x\n", scb[1], page_code);
 
 	data[0] = TYPE_OSD;
 	if (!cmd->dev)
 		data[0] = TYPE_NO_LUN;
 
-	if ((scb[1] & 0x1) == 0) {
+	if (evpd == 0) {
+		if (alloc_len < 5)
+			goto sense;
+		if (page_code != 0)
+			goto sense;
 		data[2] = 5;  /* modern version */
 		data[3] = 0x02;  /* modern response format */
 		data[7] = 0x02;  /* support command queueing */
@@ -72,47 +94,56 @@ static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
 			len = 64;
 		}
 		data[4] = len - 5;  /* additional length */
-		ret = SAM_STAT_GOOD;
 	} else {
+		if (alloc_len < 4)
+			goto sense;
 		if (!cmd->dev)
 			goto sense;
-
-		data[1] = scb[2];
-		if (scb[2] == 0x0) {
+		data[1] = page_code;
+		if (page_code == 0x0) {
 			/* supported VPD pages */
 			data[3] = 3;
 			data[4] = 0x0;
 			data[5] = 0x80;
 			data[6] = 0x83;
 			len = 7;
-			ret = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x80) {
-			/* unit serial number "    " */
-			data[3] = 4;
-			memset(data + 4, 0x20, 4);
-			len = 8;
-			ret = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x83) {
+		} else if (page_code == 0x80) {
+			/* unit serial number */
+			char hostname[256];
+			gethostname(hostname, sizeof(hostname));
+			data[3] = strlen(hostname);
+			memcpy(data + 4, hostname, strlen(hostname)+1);
+			len = 4 + data[3];
+		} else if (page_code == 0x83) {
 			/* device identification */
 			data[3] = SCSI_ID_LEN + 4;
 			data[4] = 0x1;
 			data[5] = 0x1;
 			data[7] = SCSI_ID_LEN;
 			if (cmd->dev)
-				memcpy(data + 8, cmd->dev->scsi_id, SCSI_ID_LEN);
+				memcpy(data + 8, cmd->dev->scsi_id,
+				       SCSI_ID_LEN);
 			len = SCSI_ID_LEN + 8;
-			ret = SAM_STAT_GOOD;
+		} else if (page_code == 0xb0) {
+			/* osd information */
+			data[3] = 10-4; /* addl length */
+			data[4+3] = 2;
+			data[4+4] = 0;  /* nosec */
+			data[4+5] = 0;
+			len = 10;
+		} else if (page_code == 0xb1) {
+			data[3] = 20-4;  /* addl length */
+			memset(&data[4], 0xaa, 16);  /* random secy token */
+			len = 20;
 		}
 	}
 
-	if (ret != SAM_STAT_GOOD)
-		goto sense;
-
-	cmd->len = min_t(int, len, scb[4]);
-
+	cmd->uaddr = (uintptr_t) data;
+	cmd->len = min_t(int, len, alloc_len);
 	return SAM_STAT_GOOD;
+
 sense:
-	sense_data_build(cmd, key, asc, 0);
+	sense_descriptor_build(cmd, key, asc, 0);
 	cmd->len = 0;
 	return SAM_STAT_CHECK_CONDITION;
 }
@@ -120,7 +151,6 @@ sense:
 static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 {
 	int ret = SAM_STAT_GOOD;
-	uint16_t action;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
 	unsigned long uaddr;
 	bkio_submit_t *submit = cmd->c_target->bdt->bd_cmd_submit;
@@ -132,98 +162,151 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 		goto sense;
 	}
 
-	action = (cmd->scb[8] << 8) | cmd->scb[9];
-
-	switch (action) {
-	case OSD_APPEND:
-	case OSD_CREATE:
-	case OSD_CREATE_AND_WRITE:
-	case OSD_CREATE_COLLECTION:
-	case OSD_CREATE_PARTITION:
-	case OSD_FLUSH:
-	case OSD_FLUSH_COLLECTION:
-	case OSD_FLUSH_OSD:
-	case OSD_FLUSH_PARTITION:
-	case OSD_FORMAT_OSD:
-	case OSD_GET_ATTRIBUTES:
-	case OSD_GET_MEMBER_ATTRIBUTES:
-	case OSD_LIST:
-	case OSD_LIST_COLLECTION:
-	case OSD_PERFORM_SCSI_COMMAND:
-	case OSD_PERFORM_TASK_MGMT_FUNC:
-	case OSD_QUERY:
-	case OSD_READ:
-	case OSD_REMOVE:
-	case OSD_REMOVE_COLLECTION:
-	case OSD_REMOVE_MEMBER_OBJECTS:
-	case OSD_REMOVE_PARTITION:
-	case OSD_SET_ATTRIBUTES:
-	case OSD_SET_KEY:
-	case OSD_SET_MASTER_KEY:
-	case OSD_SET_MEMBER_ATTRIBUTES:
-	case OSD_WRITE:
-		ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
-			     cmd->offset, &cmd->async, (void *)cmd);
-		if (ret)
-			goto sense;
-		break;
-	default:
-		eprintf("unknown service action 0x%04x\n", action);
+	ret = submit(cmd->dev, cmd->scb, cmd->rw, cmd->len, &uaddr,
+		     cmd->offset, &cmd->async, (void *)cmd);
+	if (ret)
 		goto sense;
-	}
 
 	return SAM_STAT_GOOD;
 sense:
-	sense_data_build(cmd, key, asc, 0);
+	sense_descriptor_build(cmd, key, asc, 0);
+	cmd->len = 0;
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+/*
+ * Return descriptor format, with asc/ascq 0x2400 "Illegal field in CDB".
+ */
+static int osd_illegal_op(int host_no, struct scsi_cmd *cmd)
+{
 	cmd->len = 0;
+	sense_descriptor_build(cmd, ILLEGAL_REQUEST, 0x24, 0);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
+/*
+ * Many commands are duplicate from SPC because we must return different
+ * sense format.
+ */
+static int osd_test_unit(int host_no, struct scsi_cmd *cmd)
+{
+	int ret;
+
+	if (!cmd->dev)
+		ret = osd_illegal_op(host_no, cmd);
+	else
+		ret = spc_test_unit(host_no, cmd);
+	return ret;
+}
+
+
+static int osd_request_sense(int host_no, struct scsi_cmd *cmd)
+{
+	cmd->len = 0;
+	sense_descriptor_build(cmd, NO_SENSE, 0, 0);
+	return SAM_STAT_GOOD;
+}
+
+static int osd_report_luns(int host_no, struct scsi_cmd *cmd)
+{
+	int ret;
+
+	ret = spc_report_luns(host_no, cmd);
+	if (ret == SAM_STAT_CHECK_CONDITION) {
+		/*
+		 * Ick.  Translate descriptor format.
+		 */
+		uint8_t key = cmd->sense_buffer[2];
+		uint8_t asc = cmd->sense_buffer[12];
+		uint8_t ascq = cmd->sense_buffer[13];
+		sense_descriptor_build(cmd, key, asc, ascq);
+	}
+	return ret;
+}
+
 struct device_type_template osd_template = {
 	.name	= "osd",
 	.ops	= {
-		[0x00 ... 0x0f] = {spc_illegal_op},
+		/* 0x00 */
+		{osd_test_unit,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_request_sense,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
 
 		/* 0x10 */
-		{spc_illegal_op,},
-		{spc_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
 		{osd_inquiry,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-
-		[0x20 ... 0x6f] = {spc_illegal_op},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+
+		[0x20 ... 0x6f] = {osd_illegal_op},
 
 		/* 0x70 */
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
 		{osd_varlen_cdb,},
 
-		[0x80 ... 0xff] = {spc_illegal_op},
+		[0x80 ... 0x9f] = {osd_illegal_op},
+
+		/* 0xA0 */
+		{osd_report_luns,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+
+		[0xb0 ... 0xff] = {osd_illegal_op},
 	}
 };
diff --git a/usr/osd.h b/usr/osd.h
deleted file mode 100644
index fe9f43c..0000000
--- a/usr/osd.h
+++ /dev/null
@@ -1,33 +0,0 @@
-#ifndef __OSD_H
-#define __OSD_H
-
-/* varlen cdb service actions for OSD-2 (before SNIA changes 17 jan 07) */
-#define OSD_APPEND			0x8807
-#define OSD_CREATE			0x8802
-#define OSD_CREATE_AND_WRITE		0x8812
-#define OSD_CREATE_COLLECTION		0x8815
-#define OSD_CREATE_PARTITION		0x880b
-#define OSD_FLUSH			0x8808
-#define OSD_FLUSH_COLLECTION		0x881a
-#define OSD_FLUSH_OSD			0x881c
-#define OSD_FLUSH_PARTITION		0x881b
-#define OSD_FORMAT_OSD			0x8801
-#define OSD_GET_ATTRIBUTES		0x880e
-#define OSD_GET_MEMBER_ATTRIBUTES	0x8822
-#define OSD_LIST			0x8803
-#define OSD_LIST_COLLECTION		0x8817
-#define OSD_PERFORM_SCSI_COMMAND	0x8f7e
-#define OSD_PERFORM_TASK_MGMT_FUNC	0x8f7f
-#define OSD_QUERY			0x8820
-#define OSD_READ			0x8805
-#define OSD_REMOVE			0x880a
-#define OSD_REMOVE_COLLECTION		0x8816
-#define OSD_REMOVE_MEMBER_OBJECTS	0x8821
-#define OSD_REMOVE_PARTITION		0x880c
-#define OSD_SET_ATTRIBUTES		0x880f
-#define OSD_SET_KEY			0x8818
-#define OSD_SET_MASTER_KEY		0x8819
-#define OSD_SET_MEMBER_ATTRIBUTES	0x8823
-#define OSD_WRITE			0x8806
-
-#endif
-- 
1.5.0.2



From pw at osc.edu  Mon Mar  5 21:37:22 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 5 Mar 2007 15:37:22 -0500
Subject: [Stgt-devel] [PATCH] parse iscsi AHS header for extended CDB
Message-ID: <20070305203722.GD17606@osc.edu>

Modify iscsi target code to understand AHS header when it contains
an extended CDB, and pass this into target for processing.  Assumes
panasas bidirectional patches to the kernel to pickup struct
iscsi_ecdb_ahdr.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |  125 +++++++++++++++++++++++++++++++++-------------------
 usr/iscsi/iscsid.h |    2 +
 2 files changed, 81 insertions(+), 46 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 3178df6..9c326dc 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -3,6 +3,7 @@
  *
  * (C) 2005-2006 FUJITA Tomonori <tomof at acm.org>
  * (C) 2005-2006 Mike Christie <michaelc at cs.wisc.edu>
+ * (C) 2007 Pete Wyckoff <pw at osc.edu>
  *
  * This code is based on Ardis's iSCSI implementation.
  *   http://www.ardistech.com/iscsi/
@@ -902,7 +903,9 @@ static void iscsi_free_cmd_task(struct iscsi_task *task)
 	target_cmd_done(conn->session->iscsi_nexus_id, task->tag);
 	list_del(&task->c_hlist);
 	if (task->c_buffer) {
-		if ((unsigned long) task->c_buffer != task->addr)
+		/* task->data was set on the input, if not changed, no
+		 * buffer was allocated by scsi layer */
+		if ((unsigned long) task->data != task->addr)
 			free((void *) (unsigned long) task->addr);
 	}
 	iscsi_free_task(task);
@@ -976,29 +979,43 @@ static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
-	unsigned long uaddr = (unsigned long) task->c_buffer;
+	unsigned long uaddr = (unsigned long) task->data;
+	uint8_t rw = req->flags & ISCSI_FLAG_CMD_WRITE;
+	uint8_t *cdb, cdbbuf[260];
+	int cdblen;
 	int err = 0;
 
-	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
-		if (task->r2t_count) {
-			if (task->unsol_count)
-				;
-			else
-				list_add_tail(&task->c_list, &task->conn->tx_clist);
-		} else
-			err = target_cmd_queue(conn->session->iscsi_nexus_id,
-					       req->cdb, 16,
-					       req->flags & ISCSI_FLAG_CMD_WRITE,
-					       uaddr, req->lun,
-					       ntohl(req->data_length),
-					       cmd_attr(task), req->itt);
-	} else
-		err = target_cmd_queue(conn->session->iscsi_nexus_id,
-				       req->cdb, 16,
-				       req->flags & ISCSI_FLAG_CMD_WRITE,
-				       uaddr, req->lun, ntohl(req->data_length),
-				       cmd_attr(task), req->itt);
+	if (rw && task->r2t_count) {
+		if (!task->unsol_count)
+			list_add_tail(&task->c_list, &task->conn->tx_clist);
+		goto noqueue;
+	}
+
+	cdb = req->cdb;
+	cdblen = 16;
+	if (req->hlength) {
+		/* concatenate extended cdb */
+		struct iscsi_ecdb_ahdr *ahs_extcdb = task->ahs;
+		if (ahs_extcdb->ahstype == ISCSI_AHSTYPE_CDB) {
+			int extlen = ntohs(ahs_extcdb->ahslength) - 1;
+			dprintf("extcdb len %d\n", extlen);
+			if (extlen + 16 > sizeof(cdbbuf)) {
+				err = -ENOMEM;
+				goto noqueue;
+			}
+			memcpy(cdbbuf, cdb, 16);
+			memcpy(cdbbuf + 16, ahs_extcdb->ecdb, extlen);
+			cdb = cdbbuf;
+			cdblen = 16 + extlen;
+		}
+	}
+
+	err = target_cmd_queue(conn->session->iscsi_nexus_id,
+			       cdb, cdblen, rw, uaddr, req->lun,
+			       ntohl(req->data_length),
+			       cmd_attr(task), req->itt);
 
+noqueue:
 	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
 
 	return err;
@@ -1222,6 +1239,7 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 {
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &conn->req.bhs;
 	struct iscsi_task *task;
+	int ahslen, ahslen_round, dlen, dlen_round, tot_data_length;
 	int len;
 
 	task = __iscsi_task_rx_start(conn);
@@ -1229,26 +1247,45 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 		return -ENOMEM;
 	task->tag = req->itt;
 
-	dprintf("%u %x %d %d %x\n", conn->session->tsih,
+	ahslen = req->hlength * 4;
+	dlen = ntoh24(req->dlength);  /* just part in this PDU */
+	tot_data_length = ntohl(req->data_length);  /* all data */
+
+	dprintf("%u %x %d %d %x task %p lens %d %d %d\n", conn->session->tsih,
 		req->cdb[0], ntohl(req->data_length),
-		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
+		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt,
+		task, ahslen, dlen, tot_data_length);
 
-	len = ntohl(req->data_length);
-	if (len) {
-		task->c_buffer = valloc(len);
+	/*
+	 * Allocate both AHS space from this PDU, and data from this
+	 * and all subsequent PDUs, at once.  Since the AHS and initial
+	 * data segments are padded to 4-byte boundaries, space things
+	 * so that a single read() does the right thing.
+	 */
+	if (ahslen || tot_data_length) {
+		/* round up each separately */
+		ahslen_round = (ahslen + 3) & ~3;
+		dlen_round = (dlen + 3) & ~3;
+		len = tot_data_length;  /* make sure to alloc padding */
+		if (len < dlen_round)
+			len = dlen_round;
+		task->c_buffer = valloc(ahslen_round + len);
 		if (!task->c_buffer) {
 			iscsi_free_task(task);
 			return -ENOMEM;
 		}
-		dprintf("%p\n", task->c_buffer);
+		task->ahs = task->c_buffer;
+		task->data = task->c_buffer + ahslen_round;
+
+		/* next amount to read from this PDU, and where to put it */
+		conn->rx_size = ahslen_round + dlen_round;
+		conn->rx_buffer = task->c_buffer;
 	}
 
 	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
-		conn->rx_size = ntoh24(req->dlength);
-		conn->rx_buffer = task->c_buffer;
-		task->r2t_count = ntohl(req->data_length) - conn->rx_size;
+		task->r2t_count = tot_data_length - dlen;  /* bytes left */
 		task->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
-		task->offset = conn->rx_size;
+		task->offset = dlen;
 
 		dprintf("%d %d %d %d\n", conn->rx_size, task->r2t_count,
 			task->unsol_count, task->offset);
@@ -1582,35 +1619,31 @@ static void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
 
 		switch (conn->rx_iostate) {
 		case IOSTATE_READ_BHS:
-			conn->rx_iostate = IOSTATE_READ_AHS_DATA;
 			conn->req.ahssize = conn->req.bhs.hlength * 4;
 			conn->req.datasize = ntoh24(conn->req.bhs.dlength);
-			conn->rx_size = (conn->req.ahssize + conn->req.datasize + 3) & -4;
-
-			if (conn->req.ahssize) {
-				eprintf("FIXME: we cannot handle ahs\n");
-				conn->state = STATE_CLOSE;
-				break;
-			}
 
 			if (conn->state == STATE_SCSI) {
+				/* sets up rx_buffer and rx_size */
 				res = iscsi_task_rx_start(conn);
 				if (res) {
 					conn->state = STATE_CLOSE;
 					break;
 				}
+			} else {
+				/* use req_buffer to store the bits */
+				conn->rx_buffer = conn->req_buffer;
+				conn->req.ahs = conn->rx_buffer;
+				conn->rx_size = (conn->req.ahssize + 3) & ~3;
+				conn->req.data = conn->rx_buffer + conn->rx_size;
+				conn->rx_size += (conn->req.datasize + 3) & ~3;
 			}
-
 			if (conn->rx_size) {
-				if (conn->state != STATE_SCSI) {
-					conn->rx_buffer = conn->req_buffer;
-					conn->req.ahs = conn->rx_buffer;
-				}
-				conn->req.data =
-					conn->rx_buffer + conn->req.ahssize;
+				conn->rx_iostate = IOSTATE_READ_AHS_DATA;
 				goto read_again;
 			}
 
+			/* fall through */
+
 		case IOSTATE_READ_AHS_DATA:
 			if (conn->state == STATE_SCSI) {
 				res = iscsi_task_rx_done(conn);
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 4887043..ea09967 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -112,6 +112,8 @@ struct iscsi_task {
 	int exp_r2tsn;
 
 	void *c_buffer;
+	void *ahs;  /* these point into c_buffer, parts after bhs */
+	void *data;
 
 	/*
 	 * temp hack.
-- 
1.5.0.2



From pw at osc.edu  Mon Mar  5 21:38:14 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 5 Mar 2007 15:38:14 -0500
Subject: [Stgt-devel] [PATCH] bidirectional
Message-ID: <20070305203814.GE17606@osc.edu>

Make bidirectional transfers work.  Also updates iscsi code to use
new kernel data structures for extended CDBs in Panasas patch.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |  234 ++++++++++++++++++++++++++++++++++++++++------------
 usr/iscsi/iscsid.h |   22 +++--
 2 files changed, 193 insertions(+), 63 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 9c326dc..1cbb2c3 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -739,10 +739,15 @@ static void cmnd_finish(struct iscsi_connection *conn)
 	}
 }
 
+/*
+ * Send the final command response.  For successful (and non-bidirectional)
+ * tasks that return data, this packet is not required.
+ */
 static int iscsi_cmd_rsp_build(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
+	uint32_t residual;
 
 	dprintf("%p %x\n", task, task->scmd->scb[0]);
 
@@ -756,6 +761,31 @@ static int iscsi_cmd_rsp_build(struct iscsi_task *task)
 	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
 	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
 
+	/* we never have write under/over flow, no way to signal that
+	 * back from the target currently. */
+
+	residual = 0;
+	if (task->dir == BIDIRECTIONAL) {
+		if (task->len < task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
+			residual = task->read_len - task->len;
+		} else if (task->len > task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
+			residual = task->len - task->read_len;
+		}
+		rsp->bi_residual_count = cpu_to_be32(residual);
+		rsp->residual_count = 0;
+	} else {
+		if (task->len < task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+			residual = task->read_len - task->len;
+		} else if (task->len > task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+			residual = task->len - task->read_len;
+		}
+		rsp->residual_count = cpu_to_be32(residual);
+	}
+
 	return 0;
 }
 
@@ -770,6 +800,9 @@ static int iscsi_sense_rsp_build(struct iscsi_task *task)
 	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
 	struct iscsi_sense_data *sense;
 	unsigned char sense_len;
+ 	uint32_t residual;
+
+	dprintf("%p %x %d\n", task, task->scmd->scb[0], task->scmd->sense_len);
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_CMD_RSP;
@@ -777,6 +810,34 @@ static int iscsi_sense_rsp_build(struct iscsi_task *task)
 	rsp->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp->response = ISCSI_STATUS_CMD_COMPLETED;
 	rsp->cmd_status = SAM_STAT_CHECK_CONDITION;
+	rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
+
+	/* we never have write under/over flow, no way to signal that
+	 * back from the target currently. */
+
+	residual = 0;
+	if (task->dir == BIDIRECTIONAL) {
+		if (task->len < task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
+			residual = task->read_len - task->len;
+		} else if (task->len > task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
+			residual = task->len - task->read_len;
+		}
+		rsp->bi_residual_count = cpu_to_be32(residual);
+		rsp->residual_count = 0;
+	} else {
+		if (task->len < task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+			residual = task->read_len - task->len;
+		} else if (task->len > task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+			residual = task->len - task->read_len;
+		}
+		rsp->residual_count = cpu_to_be32(residual);
+	}
 
 	sense = (struct iscsi_sense_data *)task->scmd->sense_buffer;
 	sense_len = task->scmd->sense_len;
@@ -791,23 +852,25 @@ static int iscsi_sense_rsp_build(struct iscsi_task *task)
 	return 0;
 }
 
+/*
+ * Send a data-in PDU.  If status was 0, collapse the response message
+ * into the last data-in PDU.
+ */
 static int iscsi_data_rsp_build(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
-	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
-	int residual, datalen, exp_datalen = ntohl(req->data_length);
+	int datalen, exp_datalen = task->read_len;
 	int max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
+ 	uint32_t residual;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
 	rsp->itt = task->tag;
 	rsp->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-	rsp->cmd_status = ISCSI_STATUS_CMD_COMPLETED;
 
 	rsp->offset = cpu_to_be32(task->offset);
-	rsp->datasn = cpu_to_be32(task->data_sn++);
-	rsp->cmd_status = task->result;
+	rsp->datasn = cpu_to_be32(task->exp_r2tsn++);
 
 	datalen = min(exp_datalen, task->len);
 	datalen -= task->offset;
@@ -815,21 +878,26 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 	dprintf("%d %d %d %d %x\n", datalen, exp_datalen, task->len, max_burst, rsp->itt);
 
 	if (datalen <= max_burst) {
-		rsp->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
-		if (task->len < exp_datalen) {
-			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-			residual = exp_datalen - task->len;
-		} else if (task->len > exp_datalen) {
-			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
-			residual = task->len - exp_datalen;
-		} else
-			residual = 0;
-		rsp->residual_count = cpu_to_be32(residual);
+		rsp->flags = ISCSI_FLAG_CMD_FINAL;
+
+		/* collapse status into final packet if successful */
+		if (task->result == 0 && task->dir != BIDIRECTIONAL) {
+			rsp->flags |= ISCSI_FLAG_DATA_STATUS;
+			if (task->len < exp_datalen) {
+				rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+				residual = exp_datalen - task->len;
+			} else if (task->len > exp_datalen) {
+				rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+				residual = task->len - exp_datalen;
+			} else
+				residual = 0;
+			rsp->cmd_status = task->result;
+			rsp->statsn = cpu_to_be32(conn->stat_sn++);
+			rsp->residual_count = cpu_to_be32(residual);
+		}
 	} else
 		datalen = max_burst;
 
-	if (rsp->flags & ISCSI_FLAG_CMD_FINAL)
-		rsp->statsn = cpu_to_be32(conn->stat_sn++);
 	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
 	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
 
@@ -975,30 +1043,46 @@ static int cmd_attr(struct iscsi_task *task)
 	return attr;
 }
 
+/*
+ * Try to execute the command.  Called when the initial scsi command PDU
+ * arrives and after each finished data burst.  If there is still data-out
+ * unreceived, put back on the queue to wait until that is done.
+ */
 static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
 	unsigned long uaddr = (unsigned long) task->data;
 	uint8_t rw = req->flags & ISCSI_FLAG_CMD_WRITE;
-	uint8_t *cdb, cdbbuf[260];
+	uint32_t data_len;
+	uint8_t *cdb, cdbbuf[260], *ahs, ahslen;
 	int cdblen;
 	int err = 0;
 
-	if (rw && task->r2t_count) {
-		if (!task->unsol_count)
+	/* wait for more data; if unsol, initiator will send without r2t */
+	if (task->r2t_count) {
+		if (!task->waiting_unsol)
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
 		goto noqueue;
 	}
 
+	task->offset = 0;  /* for use as transmit pointer for data-ins */
+
+	/* build full cdb for target, possibly using ahs */
 	cdb = req->cdb;
 	cdblen = 16;
-	if (req->hlength) {
+	ahs = task->ahs;
+	ahslen = req->hlength * 4;
+	if (ahslen >= 4) {
 		/* concatenate extended cdb */
-		struct iscsi_ecdb_ahdr *ahs_extcdb = task->ahs;
+		struct iscsi_ecdb_ahdr *ahs_extcdb = (void *) ahs;
 		if (ahs_extcdb->ahstype == ISCSI_AHSTYPE_CDB) {
 			int extlen = ntohs(ahs_extcdb->ahslength) - 1;
 			dprintf("extcdb len %d\n", extlen);
+			if (4 + extlen > ahslen) {
+				err = -EINVAL;
+				goto noqueue;
+			}
 			if (extlen + 16 > sizeof(cdbbuf)) {
 				err = -ENOMEM;
 				goto noqueue;
@@ -1007,13 +1091,40 @@ static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 			memcpy(cdbbuf + 16, ahs_extcdb->ecdb, extlen);
 			cdb = cdbbuf;
 			cdblen = 16 + extlen;
+
+			/* advance pointers for possible bidi */
+			ahs += 4 + extlen;
+			ahslen -= 4 + extlen;
 		}
 	}
 
+	/* figure out incoming (write) and outgoing (read) sizes */
+	data_len = 0;
+	task->write_len = 0;
+	if (task->dir == WRITE || task->dir == BIDIRECTIONAL) {
+		task->write_len = ntohl(req->data_length);
+		data_len = task->write_len;
+	}
+	task->read_len = 0;
+	if (task->dir == BIDIRECTIONAL && ahslen >= 8) {
+		struct iscsi_rlength_ahdr *ahs_bidi = (void *) ahs;
+		if (ahs_bidi->ahstype == ISCSI_AHSTYPE_RLENGTH) {
+			task->read_len = ntohl(ahs_bidi->read_length);
+			dprintf("bidi read len %u\n", task->read_len);
+		}
+	}
+	if (task->dir == READ) {
+		task->read_len = ntohl(req->data_length);
+		data_len = task->read_len;
+	}
+
+	/*
+	 * When done, target will call iscsi_scsi_cmd_done with
+	 * addr and len of data-in, as well as sense.
+	 */
 	err = target_cmd_queue(conn->session->iscsi_nexus_id,
 			       cdb, cdblen, rw, uaddr, req->lun,
-			       ntohl(req->data_length),
-			       cmd_attr(task), req->itt);
+			       data_len, cmd_attr(task), req->itt);
 
 noqueue:
 	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
@@ -1103,6 +1214,17 @@ static int iscsi_task_execute(struct iscsi_task *task)
 		tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 		break;
 	case ISCSI_OP_SCSI_CMD:
+		/* convenient directionality for our internal use */
+		if (hdr->flags & ISCSI_FLAG_CMD_READ) {
+			if (hdr->flags & ISCSI_FLAG_CMD_WRITE)
+				task->dir = BIDIRECTIONAL;
+			else
+				task->dir = READ;
+		} else if (hdr->flags & ISCSI_FLAG_CMD_WRITE) {
+			task->dir = WRITE;
+		} else
+			task->dir = NONE;
+
 		err = iscsi_scsi_cmd_execute(task);
 		break;
 	case ISCSI_OP_SCSI_TMFUNC:
@@ -1128,12 +1250,14 @@ static int iscsi_data_out_rx_done(struct iscsi_task *task)
 	int err = 0;
 
 	if (hdr->ttt == cpu_to_be32(ISCSI_RESERVED_TAG)) {
+		/* unsolicited data, accumulate until final */
 		if (hdr->flags & ISCSI_FLAG_CMD_FINAL) {
-			task->unsol_count = 0;
+			task->waiting_unsol = 0;
 			if (!task_pending(task))
 				err = iscsi_scsi_cmd_execute(task);
 		}
 	} else {
+		/* response to a r2t we sent */
 		if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL))
 			return err;
 
@@ -1160,7 +1284,7 @@ found:
 		task->r2t_count,
 		ntoh24(req->dlength), be32_to_cpu(req->offset));
 
-	conn->rx_buffer = (void *) (unsigned long) task->c_buffer;
+	conn->rx_buffer = task->c_buffer;
 	conn->rx_buffer += be32_to_cpu(req->offset);
 	conn->rx_size = ntoh24(req->dlength);
 
@@ -1183,6 +1307,7 @@ static int iscsi_task_queue(struct iscsi_task *task)
 	dprintf("%x %x %x\n", be32_to_cpu(req->statsn), session->exp_cmd_sn,
 		req->opcode);
 
+	/* immediate live outside of the CmdSN space */
 	if (req->opcode & ISCSI_OP_IMMEDIATE)
 		return iscsi_task_execute(task);
 
@@ -1251,9 +1376,9 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 	dlen = ntoh24(req->dlength);  /* just part in this PDU */
 	tot_data_length = ntohl(req->data_length);  /* all data */
 
-	dprintf("%u %x %d %d %x task %p lens %d %d %d\n", conn->session->tsih,
+	dprintf("%u %x %d %d task %p lens %d %d %d\n", conn->session->tsih,
 		req->cdb[0], ntohl(req->data_length),
-		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt,
+		req->flags & ISCSI_FLAG_CMD_ATTR_MASK,
 		task, ahslen, dlen, tot_data_length);
 
 	/*
@@ -1284,11 +1409,11 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 
 	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
 		task->r2t_count = tot_data_length - dlen;  /* bytes left */
-		task->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
+		task->waiting_unsol = !(req->flags & ISCSI_FLAG_CMD_FINAL);
 		task->offset = dlen;
 
 		dprintf("%d %d %d %d\n", conn->rx_size, task->r2t_count,
-			task->unsol_count, task->offset);
+			task->waiting_unsol, task->offset);
 	}
 
 	list_add(&task->c_hlist, &conn->session->cmd_list);
@@ -1411,30 +1536,23 @@ static int iscsi_task_rx_start(struct iscsi_connection *conn)
 	return 0;
 }
 
+/*
+ * Send something.  Could be a data-in PDU or a response.  In theory
+ * this can happen while we are still waiting data-out, but in this
+ * implementation, all data-out is received first.
+ */
 static int iscsi_scsi_cmd_tx_start(struct iscsi_task *task)
 {
 	int err = 0;
-	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
 
 	if (task->r2t_count)
-		err = iscsi_r2t_build(task);
-	else {
-		/* Needs to clean up this mess. */
-
-		if (req->flags & ISCSI_FLAG_CMD_WRITE)
-			if (task->result)
-				err = iscsi_sense_rsp_build(task);
-			else
-				err = iscsi_cmd_rsp_build(task);
-		else {
-			if (task->result)
-				err = iscsi_sense_rsp_build(task);
-			else if (task->len)
-				err = iscsi_data_rsp_build(task);
-			else
-				err = iscsi_cmd_rsp_build(task);
-		}
-	}
+		err = iscsi_r2t_build(task);  /* still receiving data-out */
+	else if (task->offset < task->len)
+		err = iscsi_data_rsp_build(task);  /* sending data-in */
+	else if (task->result)
+		err = iscsi_sense_rsp_build(task);  /* final, status nonzero */
+	else
+		err = iscsi_cmd_rsp_build(task);  /* final response */
 
 	return err;
 }
@@ -1502,6 +1620,10 @@ static int iscsi_tm_tx_start(struct iscsi_task *task)
 	return 0;
 }
 
+/*
+ * Look at the response we just sent and figure out if there is anything
+ * more to do.
+ */
 static int iscsi_scsi_cmd_tx_done(struct iscsi_connection *conn)
 {
 	struct iscsi_hdr *hdr = &conn->rsp.bhs;
@@ -1511,8 +1633,9 @@ static int iscsi_scsi_cmd_tx_done(struct iscsi_connection *conn)
 	case ISCSI_OP_R2T:
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
-		if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL)) {
-			dprintf("more data %x\n", hdr->itt);
+		if (task->offset < task->len || task->result != 0
+		   || task->dir == BIDIRECTIONAL) {
+			dprintf("more data or sense or bidir %x\n", hdr->itt);
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
 			return 0;
 		}
@@ -1545,6 +1668,10 @@ static int iscsi_task_tx_done(struct iscsi_connection *conn)
 	return 0;
 }
 
+/*
+ * Pick a task that wants to transmit and switch the connection to
+ * begin the transmit state machine.
+ */
 static int iscsi_task_tx_start(struct iscsi_connection *conn)
 {
 	struct iscsi_task *task;
@@ -1556,10 +1683,9 @@ static int iscsi_task_tx_start(struct iscsi_connection *conn)
 	conn_write_pdu(conn);
 
 	task = list_entry(conn->tx_clist.next, struct iscsi_task, c_list);
-	dprintf("found a task %" PRIx64 " %u %u %u\n", task->tag,
+	dprintf("found a task %" PRIx64 " %u %u\n", task->tag,
 		ntohl(((struct iscsi_cmd *) (&task->req))->data_length),
-		task->offset,
-		task->r2t_count);
+		task->offset);
 
 	list_del(&task->c_list);
 
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index ea09967..3ae416e 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -31,12 +31,12 @@
 #define DIGEST_CRC32C           (1 << 1)
 
 #define sid64(isid, tsih)					\
-({								\
+(								\
 	(uint64_t) isid[0] <<  0 | (uint64_t) isid[1] <<  8 |	\
 	(uint64_t) isid[2] << 16 | (uint64_t) isid[3] << 24 |	\
 	(uint64_t) isid[4] << 32 | (uint64_t) isid[5] << 40 |	\
-	(uint64_t) tsih << 48;					\
-})
+	(uint64_t) tsih << 48					\
+)
 
 #define sid_to_tsih(sid) ((sid) >> 48)
 
@@ -98,18 +98,21 @@ struct iscsi_task {
 	struct list_head c_list;
 
 	unsigned long flags;
+	enum { NONE, WRITE, READ, BIDIRECTIONAL } dir;
+	uint32_t write_len;  /* from command pdu, write and read lengths */
+	uint32_t read_len;
 
 	uint64_t addr;
 	int result;
 	int len;
 	int rw;
 
-	int offset;
-	int data_sn;
-
-	int r2t_count;
-	int unsol_count;
-	int exp_r2tsn;
+ 	int offset;  /* progress in data buffer for rx or tx */
+ 
+ 	int r2t_count;      /* bytes to arrive in unsol data and to solicit */
+ 	int waiting_unsol;  /* bool, waiting for unsolicited data */
+ 
+ 	int exp_r2tsn;  /* next R2T or Data SN target should generate */
 
 	void *c_buffer;
 	void *ahs;  /* these point into c_buffer, parts after bhs */
@@ -145,6 +148,7 @@ struct iscsi_connection {
 	uint32_t stat_sn;
 	uint32_t exp_stat_sn;
 
+	/* these should be session-wide, not per-connection */
 	uint32_t cmd_sn;
 	uint32_t exp_cmd_sn;
 	uint32_t max_cmd_sn;
-- 
1.5.0.2



From rcj at linux.vnet.ibm.com  Wed Mar  7 18:45:15 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Wed, 7 Mar 2007 11:45:15 -0600
Subject: [Stgt-devel] Fix build problem for IBMVIO
Message-ID: <20070307174515.GD10814@austin.ibm.com>

Just a small patch to correct member names.  The problem is only
seen when compiling with 'IBMVIO=1' and causes the build to fail.
Changes 'sense_len' to 'len' and 'sense_uaddr' to 'uaddr' in
kspace_send_cmd_res(...)

Signed-off-by: Robert Jennings <rcj at linux.vnet.ibm.com>

---
 tgtif.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

Index: usr/tgtif.c
===================================================================
--- usr.orig/tgtif.c	2007-03-07 11:30:00.000000000 -0600
+++ usr/tgtif.c	2007-03-07 11:30:51.000000000 -0600
@@ -113,8 +113,8 @@
 	ev.p.cmd_rsp.host_no = it_nexus_to_host_no(nid);
 	ev.p.cmd_rsp.len = cmd->len;
 	ev.p.cmd_rsp.uaddr = cmd->uaddr;
-	ev.p.cmd_rsp.sense_len = cmd->sense_len;
-	ev.p.cmd_rsp.sense_uaddr = (unsigned long) cmd->sense_buffer;
+	ev.p.cmd_rsp.len = cmd->sense_len;
+	ev.p.cmd_rsp.uaddr = (unsigned long) cmd->sense_buffer;
 	ev.p.cmd_rsp.result = result;
 	ev.p.cmd_rsp.rw = cmd->rw;
 	ev.p.cmd_rsp.tag = cmd->tag;



From fujita.tomonori at lab.ntt.co.jp  Thu Mar  8 01:40:50 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 08 Mar 2007 09:40:50 +0900
Subject: [Stgt-devel] Fix build problem for IBMVIO
In-Reply-To: <20070307174515.GD10814@austin.ibm.com>
References: <20070307174515.GD10814@austin.ibm.com>
Message-ID: <20070308094050R.fujita.tomonori@lab.ntt.co.jp>

From: Robert Jennings <rcj at linux.vnet.ibm.com>
Subject: [Stgt-devel] Fix build problem for IBMVIO
Date: Wed, 7 Mar 2007 11:45:15 -0600

> Just a small patch to correct member names.  The problem is only
> seen when compiling with 'IBMVIO=1' and causes the build to fail.
> Changes 'sense_len' to 'len' and 'sense_uaddr' to 'uaddr' in
> kspace_send_cmd_res(...)

Thanks.

This is for the following patchset:

http://marc.theaimsgroup.com/?l=linux-scsi&m=117288338126613&w=2

The current user-space code should be cleanly compiled with my target
git tree:

http://git.kernel.org/?p=linux/kernel/git/tomo/linux-2.6-target.git;a=summary


> Signed-off-by: Robert Jennings <rcj at linux.vnet.ibm.com>
> 
> ---
>  tgtif.c |    4 ++--
>  1 file changed, 2 insertions(+), 2 deletions(-)
> 
> Index: usr/tgtif.c
> ===================================================================
> --- usr.orig/tgtif.c	2007-03-07 11:30:00.000000000 -0600
> +++ usr/tgtif.c	2007-03-07 11:30:51.000000000 -0600
> @@ -113,8 +113,8 @@
>  	ev.p.cmd_rsp.host_no = it_nexus_to_host_no(nid);
>  	ev.p.cmd_rsp.len = cmd->len;
>  	ev.p.cmd_rsp.uaddr = cmd->uaddr;
> -	ev.p.cmd_rsp.sense_len = cmd->sense_len;
> -	ev.p.cmd_rsp.sense_uaddr = (unsigned long) cmd->sense_buffer;
> +	ev.p.cmd_rsp.len = cmd->sense_len;
> +	ev.p.cmd_rsp.uaddr = (unsigned long) cmd->sense_buffer;
>  	ev.p.cmd_rsp.result = result;
>  	ev.p.cmd_rsp.rw = cmd->rw;
>  	ev.p.cmd_rsp.tag = cmd->tag;
> 
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
> 


From rcj at linux.vnet.ibm.com  Thu Mar  8 22:21:11 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Thu, 8 Mar 2007 15:21:11 -0600
Subject: [Stgt-devel] Segmentation fault on target update operation
Message-ID: <20070308212111.GA32735@austin.ibm.com>

In a case where the target driver doesn't have a target_update() method
defined tgtadm will segfault with a command-line like:

 # tgtadm --lld ibmvio --mode target --op update --tid=1 --name=invalid \
    --value=3

The name will not match "state" in mgmt.c:target_mgmt(...) for
OP_UPDATE and because there is no target_update() function for the
driver -EINVAL (-22) is returned to tgtadm.c:ipc_mgmt_rsp(...) and
stored in rsp.err where it then attempts:

  eprintf("%s\n", tgtadm_emsg[rsp.err]);

This cause a segfault in strlen().  So we could catch a value of -EINVAL
and use one of the existing strings in tgtadm_emsg or add a new one.
Not sure which is best suited for the job, "invalid request" or "unknown
parameter" would seem to fit for this case, but maybe not everything
you'd get -EINVAL for.

Regards,
Robert Jennings

--- usr.orig/tgtadm.c   2007-03-08 15:09:45.000000000 -0600
+++ usr/tgtadm.c        2007-03-08 15:11:27.000000000 -0600
@@ -202,6 +202,8 @@
 		}

 		if (rsp.err != TGTADM_SUCCESS) {
+			if (rsp.err == -EINVAL)
+				rsp.err = 15; /* "invalid request" */
 				eprintf("%s\n", tgtadm_emsg[rsp.err]);
 				return EINVAL;
 		}



From fujita.tomonori at lab.ntt.co.jp  Fri Mar  9 16:20:40 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 10 Mar 2007 00:20:40 +0900
Subject: [Stgt-devel] Segmentation fault on target update operation
In-Reply-To: <20070308212111.GA32735@austin.ibm.com>
References: <20070308212111.GA32735@austin.ibm.com>
Message-ID: <200703091520.l29FKeuL020052@r-dd.iij4u.or.jp>

From: Robert Jennings <rcj at linux.vnet.ibm.com>
Subject: [Stgt-devel] Segmentation fault on target update operation
Date: Thu, 8 Mar 2007 15:21:11 -0600

> In a case where the target driver doesn't have a target_update() method
> defined tgtadm will segfault with a command-line like:
> 
>  # tgtadm --lld ibmvio --mode target --op update --tid=1 --name=invalid \
>     --value=3
> 
> The name will not match "state" in mgmt.c:target_mgmt(...) for
> OP_UPDATE and because there is no target_update() function for the
> driver -EINVAL (-22) is returned to tgtadm.c:ipc_mgmt_rsp(...) and
> stored in rsp.err where it then attempts:

Thanks.

I changed target_mgmt() to return TGTADM_UNSUPPORTED_OPERATION instead
of -EINVAL.

Note that iscsi_target_update returns a negative value and tgtadm will
segfault. Well, mgmt.c is crappy. I'll clean it up later on.


From fujita.tomonori at lab.ntt.co.jp  Sun Mar 11 02:37:30 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 11 Mar 2007 10:37:30 +0900
Subject: [Stgt-devel] [PATCH 4/4] OSD command parser
In-Reply-To: <200703041513.l24FD0SC002879@r-dd.iij4u.or.jp>
References: <20070123161917.GB2885@osc.edu>
	<200702191433.l1JEX6Dn025494@r-dd.iij4u.or.jp>
	<200703041513.l24FD0SC002879@r-dd.iij4u.or.jp>
Message-ID: <200703110137.l2B1bVrr006692@r-dd.iij4u.or.jp>

From: FUJITA Tomonori <fujita.tomonori at lab.ntt.co.jp>
Subject: Re: [Stgt-devel] [PATCH 4/4] OSD command parser
Date: Mon, 05 Mar 2007 00:12:57 +0900

> I added the virtual cd patch that Ming wrote for IET as an
> example. You can export iso files as a cd drive. An initiator can see
> a cd drive, but it can't read the iso file. So there must be bugs,
> however I've not dig into it. Patches are welcome :)
> 
> You can export iso files in the following way:
> 
> tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.tulip.sys1.xyz --target-type cd
> tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 -b /home/fujita/debian-31r5-i386-businesscard.iso
> tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL

Seems it works now.

fujita at tulip:~$ lsscsi
[0:0:0:0]    disk    VMware,  VMware Virtual S 1.0   -
[0:0:1:0]    disk    VMware,  VMware Virtual S 1.0   -
[0:0:2:0]    disk    VMware,  VMware Virtual S 1.0   -
[0:0:3:0]    disk    VMware,  VMware Virtual S 1.0   -
[4:0:0:0]    cd/dvd  IET      VIRTUAL-CDROM    0     /dev/scd0

fujita at tulip:~$ df
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda1              3921528   2723936    998388  74% /
tmpfs                   258420         0    258420   0% /dev/shm
tmpfs                    10240       560      9680   6% /dev
/dev/scd0                31308     31308         0 100% /media/cdrom0

fujita at tulip:~$ ls /media/cdrom
README.html          README.txt   debian  install     pics
README.mirrors.html  autorun.bat  dists   isolinux    pool
README.mirrors.txt   autorun.inf  doc     md5sum.txt  tools

a mount command takes long (about one minite for me) though I don't
know why. So don't rush.


About ibmvio, I can use a cdrom drive after bootup. However, I can't
use it from SMS (I can see a cdrom drive but I can't boot up from it).

IBM Power guys, is it possible to boot up from a virtual cdrom drive
in SMS?


From pw at osc.edu  Thu Mar 15 19:56:02 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 15 Mar 2007 14:56:02 -0400
Subject: [Stgt-devel] iscsi ahs looks good
Message-ID: <20070315185602.GC856@osc.edu>

Noticed you have steadily been getting lots of nice features into
stgt.  I refreshed my patch set as of r832 and tested a bit.
Thought you may like to see some of my current set of patches (3).
Especially number two for some bugfixes.

		-- Pete


From pw at osc.edu  Thu Mar 15 19:57:04 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 15 Mar 2007 14:57:04 -0400
Subject: [Stgt-devel] [PATCH 1/3] osd sense fixup
Message-ID: <20070315185704.GD856@osc.edu>

OSD must use descriptor format sense data.  Support request sense and
report luns.  Add support for a couple more inquiry page codes.  Remove
list of actions; submit can deal with it.  They are obsolete anyway.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---

 usr/osd.c |  293 +++++++++++++++++++++++++++++++++++++++----------------------
 usr/osd.h |   33 -------
 2 files changed, 188 insertions(+), 138 deletions(-)

diff --git a/usr/osd.c b/usr/osd.c
index 9df1681..27c9b7d 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -1,7 +1,7 @@
 /*
  * SCSI object storage device command processing
  *
- * Copyright (C) 2006 Pete Wyckoff <pw at osc.edu>
+ * Copyright (C) 2006-2007 Pete Wyckoff <pw at osc.edu>
  *
  * Copyright (C) 2007 FUJITA Tomonori <tomof at acm.org>
  * Copyright (C) 2007 Mike Christie <michaelc at cs.wisc.edu>
@@ -13,6 +13,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <unistd.h>
 
 #include "list.h"
 #include "util.h"
@@ -21,19 +22,36 @@
 #include "driver.h"
 #include "scsi.h"
 #include "spc.h"
-#include "osd.h"
 
 #define PRODUCT_ID	"OSD"
 #define PRODUCT_REV	"0"
 
+/*
+ * Build a descriptor format sense header.  OSDs must return this,
+ * not fixed format.
+ */
+static void sense_descriptor_build(struct scsi_cmd *cmd, uint8_t key,
+				   uint8_t asc, uint8_t ascq)
+{
+	cmd->sense_buffer[0] = 0x72;  /* current, not deferred */
+	cmd->sense_buffer[1] = key;
+	cmd->sense_buffer[2] = asc;
+	cmd->sense_buffer[3] = ascq;
+	cmd->sense_len = 8;
+}
+
 static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	uint8_t *data, *scb = cmd->scb;
-	int len, ret = SAM_STAT_CHECK_CONDITION;
-	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
+	int evpd = scb[1] & 1;
+	uint8_t page_code = scb[2];
+	uint16_t alloc_len = (scb[3] << 8) | scb[4];
+	int len;
+	/* illegal field in CDB */
+	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
 	/* EVPD means need a page code */
-	if ((scb[1] & 0x3) == 0 && scb[2] != 0)
+	if ((scb[1] & 0x3) == 0 && page_code != 0)
 		goto sense;
 
 	data = valloc(pagesize);
@@ -44,13 +62,17 @@ static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
 	}
 	memset(data, 0, pagesize);
 
-	dprintf("%x %x\n", scb[1], scb[2]);
+	dprintf("%x %x\n", scb[1], page_code);
 
 	data[0] = TYPE_OSD;
 	if (!cmd->dev)
 		data[0] = TYPE_NO_LUN;
 
-	if ((scb[1] & 0x1) == 0) {
+	if (evpd == 0) {
+		if (alloc_len < 5)
+			goto sense;
+		if (page_code != 0)
+			goto sense;
 		data[2] = 5;  /* modern version */
 		data[3] = 0x02;  /* modern response format */
 		data[7] = 0x02;  /* support command queueing */
@@ -72,55 +94,64 @@ static int osd_inquiry(int host_no, struct scsi_cmd *cmd)
 			len = 64;
 		}
 		data[4] = len - 5;  /* additional length */
-		ret = SAM_STAT_GOOD;
 	} else {
+		if (alloc_len < 4)
+			goto sense;
 		if (!cmd->dev)
 			goto sense;
-
-		data[1] = scb[2];
-		if (scb[2] == 0x0) {
+		data[1] = page_code;
+		if (page_code == 0x0) {
 			/* supported VPD pages */
 			data[3] = 3;
 			data[4] = 0x0;
 			data[5] = 0x80;
 			data[6] = 0x83;
 			len = 7;
-			ret = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x80) {
-			/* unit serial number "    " */
-			data[3] = 4;
-			memset(data + 4, 0x20, 4);
-			len = 8;
-			ret = SAM_STAT_GOOD;
-		} else if (scb[2] == 0x83) {
+		} else if (page_code == 0x80) {
+			/* unit serial number */
+			char hostname[256];
+			gethostname(hostname, sizeof(hostname));
+			data[3] = strlen(hostname);
+			memcpy(data + 4, hostname, strlen(hostname)+1);
+			len = 4 + data[3];
+		} else if (page_code == 0x83) {
 			/* device identification */
 			data[3] = SCSI_ID_LEN + 4;
 			data[4] = 0x1;
 			data[5] = 0x1;
 			data[7] = SCSI_ID_LEN;
 			if (cmd->dev)
-				memcpy(data + 8, cmd->dev->scsi_id, SCSI_ID_LEN);
+				memcpy(data + 8, cmd->dev->scsi_id,
+				       SCSI_ID_LEN);
 			len = SCSI_ID_LEN + 8;
-			ret = SAM_STAT_GOOD;
+		} else if (page_code == 0xb0) {
+			/* osd information */
+			data[3] = 10-4; /* addl length */
+			data[4+3] = 2;
+			data[4+4] = 0;  /* nosec */
+			data[4+5] = 0;
+			len = 10;
+		} else if (page_code == 0xb1) {
+			data[3] = 20-4;  /* addl length */
+			memset(&data[4], 0xaa, 16);  /* random secy token */
+			len = 20;
 		}
 	}
 
-	if (ret != SAM_STAT_GOOD)
-		goto sense;
-
-	cmd->len = min_t(int, len, scb[4]);
-
+	cmd->uaddr = (uintptr_t) data;
+	cmd->len = min_t(int, len, alloc_len);
 	return SAM_STAT_GOOD;
+
 sense:
-	sense_data_build(cmd, key, asc, 0);
+	sense_descriptor_build(cmd, key, asc, 0);
 	cmd->len = 0;
 	return SAM_STAT_CHECK_CONDITION;
 }
 
-static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
+static int osd_varlen_cdb(int host_no __attribute__((unused)),
+			  struct scsi_cmd *cmd)
 {
 	int ret = SAM_STAT_GOOD;
-	uint16_t action;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x25;
 
 	dprintf("cdb[0] %x datalen %u\n", cmd->scb[0], cmd->len);
@@ -130,98 +161,150 @@ static int osd_varlen_cdb(int host_no, struct scsi_cmd *cmd)
 		goto sense;
 	}
 
-	action = (cmd->scb[8] << 8) | cmd->scb[9];
-
-	switch (action) {
-	case OSD_APPEND:
-	case OSD_CREATE:
-	case OSD_CREATE_AND_WRITE:
-	case OSD_CREATE_COLLECTION:
-	case OSD_CREATE_PARTITION:
-	case OSD_FLUSH:
-	case OSD_FLUSH_COLLECTION:
-	case OSD_FLUSH_OSD:
-	case OSD_FLUSH_PARTITION:
-	case OSD_FORMAT_OSD:
-	case OSD_GET_ATTRIBUTES:
-	case OSD_GET_MEMBER_ATTRIBUTES:
-	case OSD_LIST:
-	case OSD_LIST_COLLECTION:
-	case OSD_PERFORM_SCSI_COMMAND:
-	case OSD_PERFORM_TASK_MGMT_FUNC:
-	case OSD_QUERY:
-	case OSD_READ:
-	case OSD_REMOVE:
-	case OSD_REMOVE_COLLECTION:
-	case OSD_REMOVE_MEMBER_OBJECTS:
-	case OSD_REMOVE_PARTITION:
-	case OSD_SET_ATTRIBUTES:
-	case OSD_SET_KEY:
-	case OSD_SET_MASTER_KEY:
-	case OSD_SET_MEMBER_ATTRIBUTES:
-	case OSD_WRITE:
-		ret = cmd->c_target->bdt->bd_cmd_submit(cmd);
-		if (ret)
-			goto sense;
-		break;
-	default:
-		eprintf("unknown service action 0x%04x\n", action);
-		goto sense;
-	}
+	/* returns SAM status and fills sense */
+	ret = cmd->c_target->bdt->bd_cmd_submit(cmd);
+	return ret;
 
-	return SAM_STAT_GOOD;
 sense:
-	sense_data_build(cmd, key, asc, 0);
+	sense_descriptor_build(cmd, key, asc, 0);
+	cmd->len = 0;
+	return SAM_STAT_CHECK_CONDITION;
+}
+
+/*
+ * Return descriptor format, with asc/ascq 0x2400 "Illegal field in CDB".
+ */
+static int osd_illegal_op(int host_no, struct scsi_cmd *cmd)
+{
 	cmd->len = 0;
+	sense_descriptor_build(cmd, ILLEGAL_REQUEST, 0x24, 0);
 	return SAM_STAT_CHECK_CONDITION;
 }
 
+/*
+ * Many commands are duplicate from SPC because we must return different
+ * sense format.
+ */
+static int osd_test_unit(int host_no, struct scsi_cmd *cmd)
+{
+	int ret;
+
+	if (!cmd->dev)
+		ret = osd_illegal_op(host_no, cmd);
+	else
+		ret = spc_test_unit(host_no, cmd);
+	return ret;
+}
+
+
+static int osd_request_sense(int host_no, struct scsi_cmd *cmd)
+{
+	cmd->len = 0;
+	sense_descriptor_build(cmd, NO_SENSE, 0, 0);
+	return SAM_STAT_GOOD;
+}
+
+static int osd_report_luns(int host_no, struct scsi_cmd *cmd)
+{
+	int ret;
+
+	ret = spc_report_luns(host_no, cmd);
+	if (ret == SAM_STAT_CHECK_CONDITION) {
+		/*
+		 * Ick.  Translate descriptor format.
+		 */
+		uint8_t key = cmd->sense_buffer[2];
+		uint8_t asc = cmd->sense_buffer[12];
+		uint8_t ascq = cmd->sense_buffer[13];
+		sense_descriptor_build(cmd, key, asc, ascq);
+	}
+	return ret;
+}
+
 struct device_type_template osd_template = {
 	.type	= TYPE_OSD,
 	.name	= "osd",
 	.ops	= {
-		[0x00 ... 0x0f] = {spc_illegal_op},
+		/* 0x00 */
+		{osd_test_unit,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_request_sense,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
 
 		/* 0x10 */
-		{spc_illegal_op,},
-		{spc_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
 		{osd_inquiry,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-
-		[0x20 ... 0x6f] = {spc_illegal_op},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+
+		[0x20 ... 0x6f] = {osd_illegal_op},
 
 		/* 0x70 */
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
-		{spc_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
 		{osd_varlen_cdb,},
 
-		[0x80 ... 0xff] = {spc_illegal_op},
+		[0x80 ... 0x9f] = {osd_illegal_op},
+
+		/* 0xA0 */
+		{osd_report_luns,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+		{osd_illegal_op,},
+
+		[0xb0 ... 0xff] = {osd_illegal_op},
 	}
 };
diff --git a/usr/osd.h b/usr/osd.h
deleted file mode 100644
index fe9f43c..0000000
--- a/usr/osd.h
+++ /dev/null
@@ -1,33 +0,0 @@
-#ifndef __OSD_H
-#define __OSD_H
-
-/* varlen cdb service actions for OSD-2 (before SNIA changes 17 jan 07) */
-#define OSD_APPEND			0x8807
-#define OSD_CREATE			0x8802
-#define OSD_CREATE_AND_WRITE		0x8812
-#define OSD_CREATE_COLLECTION		0x8815
-#define OSD_CREATE_PARTITION		0x880b
-#define OSD_FLUSH			0x8808
-#define OSD_FLUSH_COLLECTION		0x881a
-#define OSD_FLUSH_OSD			0x881c
-#define OSD_FLUSH_PARTITION		0x881b
-#define OSD_FORMAT_OSD			0x8801
-#define OSD_GET_ATTRIBUTES		0x880e
-#define OSD_GET_MEMBER_ATTRIBUTES	0x8822
-#define OSD_LIST			0x8803
-#define OSD_LIST_COLLECTION		0x8817
-#define OSD_PERFORM_SCSI_COMMAND	0x8f7e
-#define OSD_PERFORM_TASK_MGMT_FUNC	0x8f7f
-#define OSD_QUERY			0x8820
-#define OSD_READ			0x8805
-#define OSD_REMOVE			0x880a
-#define OSD_REMOVE_COLLECTION		0x8816
-#define OSD_REMOVE_MEMBER_OBJECTS	0x8821
-#define OSD_REMOVE_PARTITION		0x880c
-#define OSD_SET_ATTRIBUTES		0x880f
-#define OSD_SET_KEY			0x8818
-#define OSD_SET_MASTER_KEY		0x8819
-#define OSD_SET_MEMBER_ATTRIBUTES	0x8823
-#define OSD_WRITE			0x8806
-
-#endif


From pw at osc.edu  Thu Mar 15 19:58:52 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 15 Mar 2007 14:58:52 -0400
Subject: [Stgt-devel] [PATCH 2/3] iscsi ahs bugfixes
Message-ID: <20070315185852.GE856@osc.edu>

Set scb in case of exthdr but not AHS exthdr (like non-extended bidir).
Return -errno for consistency, even though nothing actually looks at it.
Repair precedence problem with ?:.
Read into ahs buffer when ahs exists.
Use unrounded immediate length value when considering how much more data
    to fetch.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---

 usr/iscsi/iscsid.c |   29 ++++++++++++++---------------
 1 files changed, 14 insertions(+), 15 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index bad9888..804177b 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -968,17 +968,19 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 
 	scmd->cmd_nexus_id = conn->session->iscsi_nexus_id;
 
+	scmd->scb = req->cdb;
+	scmd->scb_len = sizeof(req->cdb);
+
 	if (task->ahs) {
 		struct iscsi_ecdb_ahdr *ahs_extcdb = task->ahs;
-		char *p = (void *)task->extdata;
 
 		if (ahs_extcdb->ahstype == ISCSI_AHSTYPE_CDB) {
 			int extcdb_len = ntohs(ahs_extcdb->ahslength) - 1;
+			uint8_t *p = (void *)task->extdata;
 
 			if (extcdb_len + sizeof(req->cdb) > 260) {
 				eprintf("invalid extcdb len %d\n", extcdb_len);
-
-				return EINVAL;
+				return -EINVAL;
 			}
 
 			memcpy(p, req->cdb, sizeof(req->cdb));
@@ -988,9 +990,6 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 			scmd->scb = p;
 			scmd->scb_len = sizeof(req->cdb) + extcdb_len;
 		}
-	} else {
-		scmd->scb = req->cdb;
-		scmd->scb_len = sizeof(req->cdb);
 	}
 
 	memcpy(scmd->lun, task->req.lun, sizeof(scmd->lun));
@@ -1240,7 +1239,7 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 		req->cdb[0], ahs_len, imm_len, data_len,
 		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
 
-	task_len = ahs_len ? sizeof(req->cdb) + ahs_len : 0
+	task_len = (ahs_len ? sizeof(req->cdb) + ahs_len : 0)
 		+ max(imm_len, data_len);
 
 	task = iscsi_alloc_task(conn, task_len);
@@ -1251,20 +1250,20 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 
 	task->tag = req->itt;
 
-	if (ahs_len || data_len) {
-		if (ahs_len) {
-			task->ahs = task->data + sizeof(req->cdb);
-			task->data = task->ahs + ahs_len;
-		}
-
+	if (ahs_len) {
+		task->ahs = task->data + sizeof(req->cdb);
+		task->data = task->ahs + ahs_len;
+		conn->rx_buffer = task->ahs;
 		conn->rx_size = ahs_len + imm_len;
+	} else if (data_len) {
 		conn->rx_buffer = task->data;
+		conn->rx_size = imm_len;
 	}
 
 	if (req->flags & ISCSI_FLAG_CMD_WRITE) {
-		task->r2t_count = data_len - imm_len;
+		task->offset = ntoh24(req->dlength);
+		task->r2t_count = data_len - task->offset;
 		task->unsol_count = !(req->flags & ISCSI_FLAG_CMD_FINAL);
-		task->offset = imm_len;
 
 		dprintf("%d %d %d %d\n", conn->rx_size, task->r2t_count,
 			task->unsol_count, task->offset);


From pw at osc.edu  Thu Mar 15 20:00:20 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 15 Mar 2007 15:00:20 -0400
Subject: [Stgt-devel] [PATCH 3/3] bidirectional
Message-ID: <20070315190020.GF856@osc.edu>

Make bidirectional transfers work.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---

 usr/iscsi/iscsid.c |  174 ++++++++++++++++++++++++++++++++++++++++------------
 usr/iscsi/iscsid.h |    4 +
 2 files changed, 138 insertions(+), 40 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 804177b..5ca19ea 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -743,6 +743,7 @@ static int iscsi_cmd_rsp_build(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
+	uint32_t residual;
 
 	dprintf("%p %x\n", task, task->scmd.scb[0]);
 
@@ -756,6 +757,31 @@ static int iscsi_cmd_rsp_build(struct iscsi_task *task)
 	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
 	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
 
+	/* we never have write under/over flow, no way to signal that
+	 * back from the target currently. */
+
+	residual = 0;
+	if (task->dir == BIDIRECTIONAL) {
+		if (task->len < task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
+			residual = task->read_len - task->len;
+		} else if (task->len > task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
+			residual = task->len - task->read_len;
+		}
+		rsp->bi_residual_count = cpu_to_be32(residual);
+		rsp->residual_count = 0;
+	} else {
+		if (task->len < task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+			residual = task->read_len - task->len;
+		} else if (task->len > task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+			residual = task->len - task->read_len;
+		}
+		rsp->residual_count = cpu_to_be32(residual);
+	}
+
 	return 0;
 }
 
@@ -770,6 +796,7 @@ static int iscsi_sense_rsp_build(struct iscsi_task *task)
 	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
 	struct iscsi_sense_data *sense;
 	unsigned char sense_len;
+ 	uint32_t residual;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_CMD_RSP;
@@ -777,6 +804,32 @@ static int iscsi_sense_rsp_build(struct iscsi_task *task)
 	rsp->flags = ISCSI_FLAG_CMD_FINAL;
 	rsp->response = ISCSI_STATUS_CMD_COMPLETED;
 	rsp->cmd_status = SAM_STAT_CHECK_CONDITION;
+	rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
+
+	/* XXX: copied from above, consider merging these functions */
+	residual = 0;
+	if (task->dir == BIDIRECTIONAL) {
+		if (task->len < task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
+			residual = task->read_len - task->len;
+		} else if (task->len > task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
+			residual = task->len - task->read_len;
+		}
+		rsp->bi_residual_count = cpu_to_be32(residual);
+		rsp->residual_count = 0;
+	} else {
+		if (task->len < task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+			residual = task->read_len - task->len;
+		} else if (task->len > task->read_len) {
+			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+			residual = task->len - task->read_len;
+		}
+		rsp->residual_count = cpu_to_be32(residual);
+	}
 
 	sense = (struct iscsi_sense_data *)task->scmd.sense_buffer;
 	sense_len = task->scmd.sense_len;
@@ -795,19 +848,17 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
-	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
-	int residual, datalen, exp_datalen = ntohl(req->data_length);
+	int datalen, exp_datalen = task->read_len;
 	int max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
+ 	uint32_t residual;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
 	rsp->itt = task->tag;
 	rsp->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
-	rsp->cmd_status = ISCSI_STATUS_CMD_COMPLETED;
 
 	rsp->offset = cpu_to_be32(task->offset);
-	rsp->datasn = cpu_to_be32(task->data_sn++);
-	rsp->cmd_status = task->result;
+	rsp->datasn = cpu_to_be32(task->exp_r2tsn++);
 
 	datalen = min(exp_datalen, task->len);
 	datalen -= task->offset;
@@ -815,21 +866,26 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 	dprintf("%d %d %d %d %x\n", datalen, exp_datalen, task->len, max_burst, rsp->itt);
 
 	if (datalen <= max_burst) {
-		rsp->flags = ISCSI_FLAG_CMD_FINAL | ISCSI_FLAG_DATA_STATUS;
-		if (task->len < exp_datalen) {
-			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-			residual = exp_datalen - task->len;
-		} else if (task->len > exp_datalen) {
-			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
-			residual = task->len - exp_datalen;
-		} else
-			residual = 0;
-		rsp->residual_count = cpu_to_be32(residual);
+		rsp->flags = ISCSI_FLAG_CMD_FINAL;
+
+		/* collapse status into final packet if successful */
+		if (task->result == 0 && task->dir != BIDIRECTIONAL) {
+			rsp->flags |= ISCSI_FLAG_DATA_STATUS;
+			if (task->len < exp_datalen) {
+				rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
+				residual = exp_datalen - task->len;
+			} else if (task->len > exp_datalen) {
+				rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
+				residual = task->len - exp_datalen;
+			} else
+				residual = 0;
+			rsp->cmd_status = task->result;
+			rsp->statsn = cpu_to_be32(conn->stat_sn++);
+			rsp->residual_count = cpu_to_be32(residual);
+		}
 	} else
 		datalen = max_burst;
 
-	if (rsp->flags & ISCSI_FLAG_CMD_FINAL)
-		rsp->statsn = cpu_to_be32(conn->stat_sn++);
 	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
 	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
 
@@ -933,6 +989,12 @@ int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *scmd)
 	task->len = scmd->len;
 	task->rw = scmd->rw;
 
+	if (task->len > task->read_len) {
+		dprintf("shrinking target len %d to initiator len %d\n",
+		        task->len, task->read_len);
+		task->len = task->read_len;
+	}
+
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
 	tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 
@@ -965,19 +1027,29 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
 	unsigned long uaddr = (unsigned long) task->data;
+	uint32_t data_len;
+	uint8_t *ahs;
+	int ahslen;
 
 	scmd->cmd_nexus_id = conn->session->iscsi_nexus_id;
 
 	scmd->scb = req->cdb;
 	scmd->scb_len = sizeof(req->cdb);
 
-	if (task->ahs) {
-		struct iscsi_ecdb_ahdr *ahs_extcdb = task->ahs;
+	ahs = task->ahs;
+	ahslen = req->hlength * 4;
+	if (ahslen >= 4) {
+		struct iscsi_ecdb_ahdr *ahs_extcdb = (void *) ahs;
 
 		if (ahs_extcdb->ahstype == ISCSI_AHSTYPE_CDB) {
 			int extcdb_len = ntohs(ahs_extcdb->ahslength) - 1;
 			char *p = (void *)task->extdata;
 
+			if (4 + extcdb_len > ahslen) {
+				eprintf("AHS len %d too short for extcdb %d\n",
+					ahslen, extcdb_len);
+				return -EINVAL;
+			}
 			if (extcdb_len + sizeof(req->cdb) > 260) {
 				eprintf("invalid extcdb len %d\n", extcdb_len);
 				return -EINVAL;
@@ -989,8 +1061,31 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 
 			scmd->scb = p;
 			scmd->scb_len = sizeof(req->cdb) + extcdb_len;
+
+			ahs += 4 + extcdb_len;
+			ahslen -= 4 + extcdb_len;
+		}
+	}
+
+	/* figure out incoming (write) and outgoing (read) sizes */
+	data_len = 0;
+	task->write_len = 0;
+	if (task->dir == WRITE || task->dir == BIDIRECTIONAL) {
+		task->write_len = ntohl(req->data_length);
+		data_len = task->write_len;
+	}
+	task->read_len = 0;
+	if (task->dir == BIDIRECTIONAL && ahslen >= 8) {
+		struct iscsi_rlength_ahdr *ahs_bidi = (void *) ahs;
+		if (ahs_bidi->ahstype == ISCSI_AHSTYPE_RLENGTH) {
+			task->read_len = ntohl(ahs_bidi->read_length);
+			dprintf("bidi read len %u\n", task->read_len);
 		}
 	}
+	if (task->dir == READ) {
+		task->read_len = ntohl(req->data_length);
+		data_len = task->read_len;
+	}
 
 	memcpy(scmd->lun, task->req.lun, sizeof(scmd->lun));
 	scmd->rw = req->flags & ISCSI_FLAG_CMD_WRITE;
@@ -1015,6 +1110,7 @@ static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 		goto no_queuing;
 	}
 
+	task->offset = 0;  /* for use as transmit pointer for data-ins */
 	err = iscsi_target_cmd_queue(task);
 no_queuing:
 	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
@@ -1104,6 +1200,17 @@ static int iscsi_task_execute(struct iscsi_task *task)
 		tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 		break;
 	case ISCSI_OP_SCSI_CMD:
+		/* convenient directionality for our internal use */
+		if (hdr->flags & ISCSI_FLAG_CMD_READ) {
+			if (hdr->flags & ISCSI_FLAG_CMD_WRITE)
+				task->dir = BIDIRECTIONAL;
+			else
+				task->dir = READ;
+		} else if (hdr->flags & ISCSI_FLAG_CMD_WRITE) {
+			task->dir = WRITE;
+		} else
+			task->dir = NONE;
+
 		err = iscsi_scsi_cmd_execute(task);
 		break;
 	case ISCSI_OP_SCSI_TMFUNC:
@@ -1392,27 +1499,15 @@ static int iscsi_task_rx_start(struct iscsi_connection *conn)
 static int iscsi_scsi_cmd_tx_start(struct iscsi_task *task)
 {
 	int err = 0;
-	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
 
 	if (task->r2t_count)
 		err = iscsi_r2t_build(task);
-	else {
-		/* Needs to clean up this mess. */
-
-		if (req->flags & ISCSI_FLAG_CMD_WRITE)
-			if (task->result)
-				err = iscsi_sense_rsp_build(task);
-			else
-				err = iscsi_cmd_rsp_build(task);
-		else {
-			if (task->result)
-				err = iscsi_sense_rsp_build(task);
-			else if (task->len)
-				err = iscsi_data_rsp_build(task);
-			else
-				err = iscsi_cmd_rsp_build(task);
-		}
-	}
+	else if (task->offset < task->len)
+		err = iscsi_data_rsp_build(task);
+	else if (task->result)
+		err = iscsi_sense_rsp_build(task);
+	else
+		err = iscsi_cmd_rsp_build(task);
 
 	return err;
 }
@@ -1489,8 +1584,9 @@ static int iscsi_scsi_cmd_tx_done(struct iscsi_connection *conn)
 	case ISCSI_OP_R2T:
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
-		if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL)) {
-			dprintf("more data %x\n", hdr->itt);
+		if (task->offset < task->len || task->result != 0
+		   || task->dir == BIDIRECTIONAL) {
+			dprintf("more data or sense or bidir %x\n", hdr->itt);
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
 			return 0;
 		}
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 6890a08..01b66e3 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -99,6 +99,9 @@ struct iscsi_task {
 	struct list_head c_list;
 
 	unsigned long flags;
+	enum { NONE, WRITE, READ, BIDIRECTIONAL } dir;
+	uint32_t write_len;  /* from command pdu, write and read lengths */
+	uint32_t read_len;
 
 	uint64_t addr;
 	int result;
@@ -106,7 +109,6 @@ struct iscsi_task {
 	int rw;
 
 	int offset;
-	int data_sn;
 
 	int r2t_count;
 	int unsol_count;


From dougg at torque.net  Thu Mar 15 23:58:47 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Thu, 15 Mar 2007 18:58:47 -0400
Subject: [Stgt-devel] target parser problems with SAS
Message-ID: <45F9CFA7.8050704@torque.net>

I'm looking at adding a SAS target to tgt. There is
already an in-kernel ramdisk type driver which works
on my LSI MPT Fusion hardware. Hence I suspect it can
be done. Unfortunately a big hammer may be required
on the existing tgt user space code.

It looks like SAS may be different from other SCSI
transports in that the target "pulls" data_out bytes
from the initiator. This means that for commands like
WRITE (SBC) and MODE SELECT the parser first receives
the cdb only. The parser then needs to determine the
byte count to be fetched and send that number back to
the transport. The parser will then get entered a second
time for the same cdb, this time with data attached.

In the case of SBC the byte count is not obvious to
the target code (in kernel). It is the lu context
(in user space) that knows the block size. Further
that block size may have been recently changed with
a FORMAT command.

For those interested in the low level details see the
SAS XFER_RDY frame in its transport layer. Even though
MPT Fusion firmware hides this level of detail, the
requirement remain to calculate the length of data to
"pull" on a WRITE like command. This "feature" might
explain why SAS disks have better queued write
performance than its FC and SPI cousins.


So, do folks want the various tgt parsers changed to
cope with SAS ??

Doug Gilbert



From fujita.tomonori at lab.ntt.co.jp  Fri Mar 16 06:44:21 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 16 Mar 2007 14:44:21 +0900
Subject: [Stgt-devel] [PATCH 1/3] osd sense fixup
In-Reply-To: <20070315185704.GD856@osc.edu>
References: <20070315185704.GD856@osc.edu>
Message-ID: <20070316144421C.fujita.tomonori@lab.ntt.co.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH 1/3] osd sense fixup
Date: Thu, 15 Mar 2007 14:57:04 -0400

> OSD must use descriptor format sense data.  Support request sense and
> report luns.  Add support for a couple more inquiry page codes.  Remove
> list of actions; submit can deal with it.  They are obsolete anyway.

descriptor format sense is not only for OSD. struct tgt_device needs
to have some SCSI parameters and sense_data_build() should follow them.

I added only d_sense and fixed sense_data_build().


From fujita.tomonori at lab.ntt.co.jp  Fri Mar 16 06:58:08 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 16 Mar 2007 14:58:08 +0900
Subject: [Stgt-devel] [PATCH 2/3] iscsi ahs bugfixes
In-Reply-To: <20070315185852.GE856@osc.edu>
References: <20070315185852.GE856@osc.edu>
Message-ID: <200703160558.l2G5wH66012305@r-dd.iij4u.or.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH 2/3] iscsi ahs bugfixes
Date: Thu, 15 Mar 2007 14:58:52 -0400

> Set scb in case of exthdr but not AHS exthdr (like non-extended bidir).
> Return -errno for consistency, even though nothing actually looks at it.
> Repair precedence problem with ?:.
> Read into ahs buffer when ahs exists.
> Use unrounded immediate length value when considering how much more data
>     to fetch.

Thanks! Merged.

I'll set up OSD testing environments shortly not to merge untested
code.


From dougg at torque.net  Fri Mar 16 14:38:22 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Fri, 16 Mar 2007 09:38:22 -0400
Subject: [Stgt-devel] [PATCH 1/3] osd sense fixup
In-Reply-To: <20070316144421C.fujita.tomonori@lab.ntt.co.jp>
References: <20070315185704.GD856@osc.edu>
	<20070316144421C.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <45FA9DCE.3080806@torque.net>

FUJITA Tomonori wrote:
> From: Pete Wyckoff <pw at osc.edu>
> Subject: [Stgt-devel] [PATCH 1/3] osd sense fixup
> Date: Thu, 15 Mar 2007 14:57:04 -0400
> 
>> OSD must use descriptor format sense data.  Support request sense and
>> report luns.  Add support for a couple more inquiry page codes.  Remove
>> list of actions; submit can deal with it.  They are obsolete anyway.
> 
> descriptor format sense is not only for OSD. struct tgt_device needs
> to have some SCSI parameters and sense_data_build() should follow them.
> 
> I added only d_sense and fixed sense_data_build().

I have a fair amount of descriptor sense data processing
code around the place:
   - in the linux scsi mid level
   - in sg3_utils (specifically sg_lib.c)
   - in the scsi_debug virtual LLD

The latter item is probably closest to what tgt needs.
Another device "type" that might be usefully put in
tgt is a SAT layer. To implement a SAT layer descriptor
sense generation is needed (since that is how FIS
registers are conveyed back to the initiator).


Has anyone ever thought of implementing the IMMED bit
is some SCSI cdbs? START STOP UNIT is one example.

Doug Gilbert





From pw at osc.edu  Fri Mar 16 21:13:45 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Fri, 16 Mar 2007 16:13:45 -0400
Subject: [Stgt-devel] [PATCH] one more iscsi ahs bug fix
Message-ID: <20070316201345.GA2940@osc.edu>

Try to fix the precedence bug again.  Binary + really does happen
before ternary ? : .

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---

 usr/iscsi/iscsid.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 6fd469d..131c838 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1241,7 +1241,7 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 		req->flags & ISCSI_FLAG_CMD_ATTR_MASK, req->itt);
 
 	task_len = max(imm_len, data_len) +
-		ahs_len ? sizeof(req->cdb) + ahs_len : 0;
+		(ahs_len ? sizeof(req->cdb) + ahs_len : 0);
 
 	task = iscsi_alloc_task(conn, task_len);
 	if (task)


From fujita.tomonori at lab.ntt.co.jp  Sat Mar 17 01:47:46 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 17 Mar 2007 09:47:46 +0900
Subject: [Stgt-devel] [PATCH] one more iscsi ahs bug fix
In-Reply-To: <20070316201345.GA2940@osc.edu>
References: <20070316201345.GA2940@osc.edu>
Message-ID: <200703170047.l2H0lk9j013681@r-dd.iij4u.or.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] one more iscsi ahs bug fix
Date: Fri, 16 Mar 2007 16:13:45 -0400

> Try to fix the precedence bug again.  Binary + really does happen
> before ternary ? : .

Ah... my bad.

Thanks, merged.


From mark_harvey at symantec.com  Sat Mar 17 01:29:44 2007
From: mark_harvey at symantec.com (Mark Harvey)
Date: Fri, 16 Mar 2007 17:29:44 -0700
Subject: [Stgt-devel] Not updating Serial Number in SCSI Inquiry page
	correctly.
Message-ID: <B3E98EAC5926D5498DDD341AE4B7D21CE5CA78@TUS1XCHCLUPIN05.enterprise.veritas.com>


In page 0x80 of SCSI Inquiry, forgot to decrement the destination
pointer.

===================================================================
--- spc.c       (revision 835)
+++ spc.c       (working copy)
@@ -108,7 +108,7 @@
                                p = data + 4 + tmp - 1;
                                q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
 
-                               for (; tmp > 0; tmp--, q)
+                               for (; tmp > 0; tmp--, q--)
                                        *(p--) = *q;
                        }
                } else if (scb[2] == 0x83) {

 

________________________________

Cheer
Mark Harvey



From fujita.tomonori at lab.ntt.co.jp  Sat Mar 17 06:06:20 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 17 Mar 2007 14:06:20 +0900
Subject: [Stgt-devel] Not updating Serial Number in SCSI Inquiry
	page	correctly.
In-Reply-To: <B3E98EAC5926D5498DDD341AE4B7D21CE5CA78@TUS1XCHCLUPIN05.enterprise.veritas.com>
References: <B3E98EAC5926D5498DDD341AE4B7D21CE5CA78@TUS1XCHCLUPIN05.enterprise.veritas.com>
Message-ID: <200703170506.l2H56KWV021077@r-dd.iij4u.or.jp>

From: "Mark Harvey" <mark_harvey at symantec.com>
Subject: [Stgt-devel] Not updating Serial Number in SCSI Inquiry page	correctly.
Date: Fri, 16 Mar 2007 17:29:44 -0700

> In page 0x80 of SCSI Inquiry, forgot to decrement the destination
> pointer.

Thanks.

> ===================================================================
> --- spc.c       (revision 835)
> +++ spc.c       (working copy)
> @@ -108,7 +108,7 @@
>                                 p = data + 4 + tmp - 1;
>                                 q = cmd->dev->scsi_sn + SCSI_SN_LEN - 1;
>  
> -                               for (; tmp > 0; tmp--, q)
> +                               for (; tmp > 0; tmp--, q--)
>                                         *(p--) = *q;

I fixed this in the following way (a bit consistent with p):

-					*(p--) = *q;
+					*(p--) = *(q--);


From fujita.tomonori at lab.ntt.co.jp  Sat Mar 17 15:20:11 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sat, 17 Mar 2007 23:20:11 +0900
Subject: [Stgt-devel] [PATCH 3/3] bidirectional
In-Reply-To: <20070315190020.GF856@osc.edu>
References: <20070315190020.GF856@osc.edu>
Message-ID: <200703171420.l2HEKCd3008175@r-dd.iij4u.or.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH 3/3] bidirectional
Date: Thu, 15 Mar 2007 15:00:20 -0400

> Make bidirectional transfers work.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>

Applied, thanks a lot.

I'll move some members in iscsi_task struct to scsi_cmd to make
bidirectional transfers work for all the transports.


From fujita.tomonori at lab.ntt.co.jp  Sun Mar 18 14:12:28 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Sun, 18 Mar 2007 22:12:28 +0900
Subject: [Stgt-devel] moved the user-space code to git
Message-ID: <200703181313.l2IDDE4o019757@r-dd.iij4u.or.jp>

I moved the user-space code from the svn repository to a git tree:

http://www.kernel.org/git/?p=linux/kernel/git/tomo/tgt.git;a=summary

Please submit patches in the Linux kernel way from now on.

I pushed only the current trunk. If you are interested in the past
experiments, check the branches in the svn repository. For your
convenience, I also put the svn dump at the web site:

http://stgt.berlios.de/tgt-svn-r849.dump.bz2


From pw at osc.edu  Sun Mar 18 16:03:33 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sun, 18 Mar 2007 11:03:33 -0400
Subject: [Stgt-devel] moved the user-space code to git
In-Reply-To: <200703181313.l2IDDE4o019757@r-dd.iij4u.or.jp>
References: <200703181313.l2IDDE4o019757@r-dd.iij4u.or.jp>
Message-ID: <20070318150333.GA20927@osc.edu>

fujita.tomonori at lab.ntt.co.jp wrote on Sun, 18 Mar 2007 22:12 +0900:
> I moved the user-space code from the svn repository to a git tree:
> 
> http://www.kernel.org/git/?p=linux/kernel/git/tomo/tgt.git;a=summary
> 
> Please submit patches in the Linux kernel way from now on.

Brilliant.  Now I can dump git-svn.  Can you send commit messages
to stgt-svn still?  Maybe you already did this.

		-- Pete


From fujita.tomonori at lab.ntt.co.jp  Sun Mar 18 16:08:08 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 19 Mar 2007 00:08:08 +0900
Subject: [Stgt-devel] moved the user-space code to git
In-Reply-To: <20070318150333.GA20927@osc.edu>
References: <200703181313.l2IDDE4o019757@r-dd.iij4u.or.jp>
	<20070318150333.GA20927@osc.edu>
Message-ID: <20070319000808H.fujita.tomonori@lab.ntt.co.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: Re: [Stgt-devel] moved the user-space code to git
Date: Sun, 18 Mar 2007 11:03:33 -0400

> fujita.tomonori at lab.ntt.co.jp wrote on Sun, 18 Mar 2007 22:12 +0900:
> > I moved the user-space code from the svn repository to a git tree:
> > 
> > http://www.kernel.org/git/?p=linux/kernel/git/tomo/tgt.git;a=summary
> > 
> > Please submit patches in the Linux kernel way from now on.
> 
> Brilliant.  Now I can dump git-svn.  Can you send commit messages
> to stgt-svn still?  Maybe you already did this.

Not yet. I'm not sure what git's hook I should use to do that. Does
anyone know?


From pw at osc.edu  Sun Mar 18 16:20:32 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sun, 18 Mar 2007 11:20:32 -0400
Subject: [Stgt-devel] [PATCH] remove iscsi old files
Message-ID: <20070318152032.GB20927@osc.edu>

Apparently a git conversion error.  Remove these old files.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/libistgt.c |   86 -------------
 usr/iscsi/log.c      |  345 --------------------------------------------------
 usr/iscsi/log.h      |   84 ------------
 3 files changed, 0 insertions(+), 515 deletions(-)
 delete mode 100644 usr/iscsi/libistgt.c
 delete mode 100644 usr/iscsi/log.c
 delete mode 100644 usr/iscsi/log.h

diff --git a/usr/iscsi/libistgt.c b/usr/iscsi/libistgt.c
deleted file mode 100644
index 50144c8..0000000
--- a/usr/iscsi/libistgt.c
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2006 FUJITA Tomonori <tomof at acm.org>
- * Copyright (C) 2006 Mike Christie
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * See the file COPYING included with this distribution for more details.
- */
-
-#include <ctype.h>
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <dirent.h>
-
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <fcntl.h>
-#include <linux/types.h>
-#include <linux/netlink.h>
-
-#include "iscsid.h"
-#include "tgtadm.h"
-
-static int ipc_connect(void)
-{
-	int fd, err;
-	struct sockaddr_un addr;
-
-	fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-	if (fd < 0)
-		return fd;
-
-	memset(&addr, 0, sizeof(addr));
-	addr.sun_family = AF_LOCAL;
-	memcpy((char *) &addr.sun_path + 1, ISTGT_NAMESPACE, strlen(ISTGT_NAMESPACE));
-
-	if ((err = connect(fd, (struct sockaddr *) &addr, sizeof(addr))) < 0)
-		fd = err;
-
-	return fd;
-}
-
-int ipc_mgmt(char *sbuf, char *rbuf)
-{
-	struct nlmsghdr *nlh = (struct nlmsghdr *) sbuf;
-	struct tgtadm_req *req;
-	int err = -EINVAL, fd;
-	char *params;
-
-	req = NLMSG_DATA(nlh);
-	params = (char *) req + sizeof(*req);
-
-	eprintf("%d %d %d %d %d %" PRIx64 " %" PRIx64 " %s\n", nlh->nlmsg_len,
-		req->typeid, req->mode, req->op, req->tid, req->sid, req->lun, params);
-
-	fd = ipc_connect();
-	if (fd < 0) {
-		eprintf("cannot connect istgtd\n");
-		return fd;
-	}
-
-	err = write(fd, sbuf, nlh->nlmsg_len);
-	if (err < 0) {
-		eprintf("cannot connect istgtd\n");
-		goto out;
-	}
-
-out:
-	close(fd);
-
-	return err;
-}
diff --git a/usr/iscsi/log.c b/usr/iscsi/log.c
deleted file mode 100644
index c85a967..0000000
--- a/usr/iscsi/log.c
+++ /dev/null
@@ -1,345 +0,0 @@
-/*
- * Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>
- *
- * Released under the terms of the GNU GPL v2.0.
- */
-
-#include <ctype.h>
-#include <string.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <syslog.h>
-#include <signal.h>
-#include <sys/shm.h>
-#include <sys/ipc.h>
-#include <sys/types.h>
-
-#include "log.h"
-
-#define SEMKEY	0xA7L
-#define LOGDBG 0
-
-#if LOGDBG
-#define logdbg(file, fmt, args...) fprintf(file, fmt, ##args)
-#else
-#define logdbg(file, fmt, args...) do {} while (0)
-#endif
-
-static char *log_name;
-static int is_daemon, is_debug;
-
-static int logarea_init (int size)
-{
-	int shmid;
-
-	logdbg(stderr,"enter logarea_init\n");
-
-	if ((shmid = shmget(IPC_PRIVATE, sizeof(struct logarea),
-			    0644 | IPC_CREAT | IPC_EXCL)) == -1)
-		return 1;
-
-	la = shmat(shmid, NULL, 0);
-	if (!la)
-		return 1;
-
-	if (size < MAX_MSG_SIZE)
-		size = LOG_SPACE_SIZE;
-
-	if ((shmid = shmget(IPC_PRIVATE, size,
-			    0644 | IPC_CREAT | IPC_EXCL)) == -1) {
-		shmdt(la);
-		return 1;
-	}
-
-	la->start = shmat(shmid, NULL, 0);
-	if (!la->start) {
-		shmdt(la);
-		return 1;
-	}
-	memset(la->start, 0, size);
-
-	la->empty = 1;
-	la->end = la->start + size;
-	la->head = la->start;
-	la->tail = la->start;
-
-	if ((shmid = shmget(IPC_PRIVATE, MAX_MSG_SIZE + sizeof(struct logmsg),
-			    0644 | IPC_CREAT | IPC_EXCL)) == -1) {
-		shmdt(la->start);
-		shmdt(la);
-		return 1;
-	}
-	la->buff = shmat(shmid, NULL, 0);
-	if (!la->buff) {
-		shmdt(la->start);
-		shmdt(la);
-		return 1;
-	}
-
-	if ((la->semid = semget(SEMKEY, 1, 0666 | IPC_CREAT)) < 0) {
-		shmdt(la->buff);
-		shmdt(la->start);
-		shmdt(la);
-		return 1;
-	}
-
-	la->semarg.val=1;
-	if (semctl(la->semid, 0, SETVAL, la->semarg) < 0) {
-		shmdt(la->buff);
-		shmdt(la->start);
-		shmdt(la);
-		return 1;
-	}
-
-	la->ops[0].sem_num = 0;
-	la->ops[0].sem_flg = 0;
-
-	return 0;
-
-}
-
-static void free_logarea (void)
-{
-	semctl(la->semid, 0, IPC_RMID, la->semarg);
-	shmdt(la->buff);
-	shmdt(la->start);
-	shmdt(la);
-	return;
-}
-
-#if LOGDBG
-static void dump_logarea (void)
-{
-	struct logmsg * msg;
-
-	logdbg(stderr, "\n==== area: start addr = %p, end addr = %p ====\n",
-		la->start, la->end);
-	logdbg(stderr, "|addr     |next     |prio|msg\n");
-
-	for (msg = (struct logmsg *)la->head; (void *)msg != la->tail;
-	     msg = msg->next)
-		logdbg(stderr, "|%p |%p |%i   |%s\n", (void *)msg, msg->next,
-				msg->prio, (char *)&msg->str);
-
-	logdbg(stderr, "|%p |%p |%i   |%s\n", (void *)msg, msg->next,
-			msg->prio, (char *)&msg->str);
-
-	logdbg(stderr, "\n\n");
-}
-#endif
-
-int log_enqueue (int prio, const char * fmt, va_list ap)
-{
-	int len, fwd;
-	char buff[MAX_MSG_SIZE];
-	struct logmsg * msg;
-	struct logmsg * lastmsg;
-
-	lastmsg = (struct logmsg *)la->tail;
-
-	if (!la->empty) {
-		fwd = sizeof(struct logmsg) +
-		      strlen((char *)&lastmsg->str) * sizeof(char) + 1;
-		la->tail += fwd;
-	}
-	vsnprintf(buff, MAX_MSG_SIZE, fmt, ap);
-	len = strlen(buff) * sizeof(char) + 1;
-
-	/* not enough space on tail : rewind */
-	if (la->head <= la->tail &&
-	    (len + sizeof(struct logmsg)) > (la->end - la->tail)) {
-		logdbg(stderr, "enqueue: rewind tail to %p\n", la->tail);
-			la->tail = la->start;
-	}
-
-	/* not enough space on head : drop msg */
-	if (la->head > la->tail &&
-	    (len + sizeof(struct logmsg)) > (la->head - la->tail)) {
-		logdbg(stderr, "enqueue: log area overrun, drop msg\n");
-
-		if (!la->empty)
-			la->tail = lastmsg;
-
-		return 1;
-	}
-
-	/* ok, we can stage the msg in the area */
-	la->empty = 0;
-	msg = (struct logmsg *)la->tail;
-	msg->prio = prio;
-	memcpy((void *)&msg->str, buff, len);
-	lastmsg->next = la->tail;
-	msg->next = la->head;
-
-	logdbg(stderr, "enqueue: %p, %p, %i, %s\n", (void *)msg, msg->next,
-		msg->prio, (char *)&msg->str);
-
-#if LOGDBG
-	dump_logarea();
-#endif
-	return 0;
-}
-
-int log_dequeue (void * buff)
-{
-	struct logmsg * src = (struct logmsg *)la->head;
-	struct logmsg * dst = (struct logmsg *)buff;
-	struct logmsg * lst = (struct logmsg *)la->tail;
-
-	if (la->empty)
-		return 1;
-
-	int len = strlen((char *)&src->str) * sizeof(char) +
-		  sizeof(struct logmsg) + 1;
-
-	dst->prio = src->prio;
-	memcpy(dst, src,  len);
-
-	if (la->tail == la->head)
-		la->empty = 1; /* we purge the last logmsg */
-	else {
-		la->head = src->next;
-		lst->next = la->head;
-	}
-	logdbg(stderr, "dequeue: %p, %p, %i, %s\n",
-		(void *)src, src->next, src->prio, (char *)&src->str);
-
-	memset((void *)src, 0,  len);
-
-	return la->empty;
-}
-
-/*
- * this one can block under memory pressure
- */
-static void log_syslog (void * buff)
-{
-	struct logmsg * msg = (struct logmsg *)buff;
-
-	syslog(msg->prio, "%s", (char *)&msg->str);
-}
-
-static void dolog(int prio, const char *fmt, va_list ap)
-{
-	if (is_daemon) {
-		la->ops[0].sem_op = -1;
-		if (semop(la->semid, la->ops, 1) < 0) {
-			syslog(LOG_ERR, "semop up failed");
-			return;
-		}
-
-		log_enqueue(prio, fmt, ap);
-
-		la->ops[0].sem_op = 1;
-		if (semop(la->semid, la->ops, 1) < 0) {
-			syslog(LOG_ERR, "semop down failed");
-			return;
-		}
-	} else {
-		fprintf(stderr, "%s: ", log_name);
-		vfprintf(stderr, fmt, ap);
-		fflush(stderr);
-	}
-}
-
-void log_warning(const char *fmt, ...)
-{
-	va_list ap;
-	va_start(ap, fmt);
-	dolog(LOG_WARNING, fmt, ap);
-	va_end(ap);
-}
-
-void log_error(const char *fmt, ...)
-{
-	va_list ap;
-	va_start(ap, fmt);
-	dolog(LOG_ERR, fmt, ap);
-	va_end(ap);
-}
-
-void log_debug(const char *fmt, ...)
-{
-	if (!is_debug)
-		return;
-
-	va_list ap;
-	va_start(ap, fmt);
-	dolog(LOG_DEBUG, fmt, ap);
-	va_end(ap);
-}
-
-static void log_flush(void)
-{
-	while (!la->empty) {
-		la->ops[0].sem_op = -1;
-		if (semop(la->semid, la->ops, 1) < 0) {
-			syslog(LOG_ERR, "semop up failed");
-			exit(1);
-		}
-		log_dequeue(la->buff);
-		la->ops[0].sem_op = 1;
-		if (semop(la->semid, la->ops, 1) < 0) {
-			syslog(LOG_ERR, "semop down failed");
-			exit(1);
-		}
-		log_syslog(la->buff);
-	}
-}
-
-int log_init(char *program_name, int size, int daemon, int debug)
-{
-	is_daemon = daemon;
-	is_debug = debug;
-
-	logdbg(stderr,"enter log_init\n");
-	log_name = program_name;
-	if (is_daemon) {
-		struct sigaction sa_old;
-		struct sigaction sa_new;
-		pid_t pid;
-
-		openlog(log_name, 0, LOG_DAEMON);
-		setlogmask (LOG_UPTO (LOG_DEBUG));
-
-		if (logarea_init(size)) {
-			syslog(LOG_ERR, "failed to initialize the logger\n");
-			return 1;
-		}
-
-		pid = fork();
-		if (pid < 0) {
-			syslog(LOG_ERR, "fail to fork the logger\n");
-			return 1;
-		} else if (pid) {
-			syslog(LOG_WARNING,
-			       "Target daemon logger with pid=%d started!\n", pid);
-			return 0;
-		}
-
-		/* flush on daemon's crash */
-		sa_new.sa_handler = (void*)log_flush;
-		sigemptyset(&sa_new.sa_mask);
-		sa_new.sa_flags = 0;
-		sigaction(SIGSEGV, &sa_new, &sa_old );
-
-		while(1) {
-			log_flush();
-			sleep(1);
-		}
-		exit(0);
-	}
-
-	return 0;
-}
-
-void log_close (void)
-{
-	if (is_daemon) {
-		closelog();
-		free_logarea();
-	}
-	return;
-}
diff --git a/usr/iscsi/log.h b/usr/iscsi/log.h
deleted file mode 100644
index 35ce374..0000000
--- a/usr/iscsi/log.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
- * iSCSI Safe Logging and Tracing Library
- *
- * Copyright (C) 2004 Dmitry Yusupov, Alex Aizman
- * maintained by open-iscsi at googlegroups.com
- *
- * circular buffer code based on log.c from dm-multipath project
- *
- * heavily based on code from log.c:
- *   Copyright (C) 2002-2003 Ardis Technolgies <roman at ardistech.com>,
- *   licensed under the terms of the GNU GPL v2.0,
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published
- * by the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * See the file COPYING included with this distribution for more details.
- */
-
-#ifndef LOG_H
-#define LOG_H
-
-#include <sys/sem.h>
-
-union semun {
-	int val;
-	struct semid_ds *buf;
-	unsigned short int *array;
-	struct seminfo *__buf;
-};
-
-#define LOG_SPACE_SIZE 16384
-#define MAX_MSG_SIZE 256
-
-extern int log_daemon;
-extern int log_level;
-
-struct logmsg {
-	short int prio;
-	void *next;
-	char *str;
-};
-
-struct logarea {
-	int empty;
-	void *head;
-	void *tail;
-	void *start;
-	void *end;
-	char *buff;
-	struct sembuf ops[1];
-	int semid;
-	union semun semarg;
-};
-
-struct logarea *la;
-
-extern int log_init (char * progname, int size, int daemon, int debug);
-extern void log_close (void);
-extern void dump_logmsg (void *);
-extern void log_warning(const char *fmt, ...)
-	__attribute__ ((format (printf, 1, 2)));
-extern void log_error(const char *fmt, ...)
-	__attribute__ ((format (printf, 1, 2)));
-extern void log_debug(const char *fmt, ...)
-	__attribute__ ((format (printf, 1, 2)));
-
-#define eprintf(fmt, args...)						\
-do {									\
-	log_error("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-} while (0)
-
-#define dprintf(fmt, args...)						\
-do {									\
-	log_debug("%s(%d) " fmt, __FUNCTION__, __LINE__, ##args);	\
-} while (0)
-
-#endif	/* LOG_H */
-- 
1.5.0.3



From pw at osc.edu  Sun Mar 18 16:23:24 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sun, 18 Mar 2007 11:23:24 -0400
Subject: [Stgt-devel] [PATCH] quiet gcc warnings
Message-ID: <20070318152324.GC20927@osc.edu>

Quiet some useless gcc warnings about char signedness.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    2 +-
 usr/spc.c          |    6 +++---
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 30892ce..e7e2d91 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1044,7 +1044,7 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 
 		if (ahs_extcdb->ahstype == ISCSI_AHSTYPE_CDB) {
 			int extcdb_len = ntohs(ahs_extcdb->ahslength) - 1;
-			char *p = (void *)task->extdata;
+			uint8_t *p = (void *)task->extdata;
 
 			if (4 + extcdb_len > ahslen) {
 				eprintf("AHS len %d too short for extcdb %d\n",
diff --git a/usr/spc.c b/usr/spc.c
index 7221915..80e6ce1 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -63,9 +63,9 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 		data[4] = 59;
 		data[7] = 0x02;
 		memset(data + 8, 0x20, 28);
-		strncpy(data + 8, VENDOR_ID, 8);
-		strncpy(data + 16, product_id, 16);
-		strncpy(data + 32, PRODUCT_REV, 4);
+		strncpy((char *) data + 8, VENDOR_ID, 8);
+		strncpy((char *) data + 16, product_id, 16);
+		strncpy((char *) data + 32, PRODUCT_REV, 4);
 		data[58] = 0x03;
 		data[59] = 0x20;
 		data[60] = 0x09;
-- 
1.5.0.3



From fujita.tomonori at lab.ntt.co.jp  Tue Mar 20 17:02:07 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 21 Mar 2007 01:02:07 +0900
Subject: [Stgt-devel] [PATCH] remove iscsi old files
In-Reply-To: <20070318152032.GB20927@osc.edu>
References: <20070318152032.GB20927@osc.edu>
Message-ID: <200703201602.l2KG287i027851@r-dd.iij4u.or.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] remove iscsi old files
Date: Sun, 18 Mar 2007 11:20:32 -0400

> Apparently a git conversion error.  Remove these old files.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>

Thanks, merged.


From fujita.tomonori at lab.ntt.co.jp  Tue Mar 20 17:05:02 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 21 Mar 2007 01:05:02 +0900
Subject: [Stgt-devel] [PATCH] quiet gcc warnings
In-Reply-To: <20070318152324.GC20927@osc.edu>
References: <20070318152324.GC20927@osc.edu>
Message-ID: <200703201605.l2KG53Rv027946@r-dd.iij4u.or.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] quiet gcc warnings
Date: Sun, 18 Mar 2007 11:23:24 -0400

> Quiet some useless gcc warnings about char signedness.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>

Thanks again, merged.


From markh794 at gmail.com  Wed Mar 21 02:39:04 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 21 Mar 2007 12:39:04 +1100
Subject: [Stgt-devel] Adding Virtial Tape & Changer targets
Message-ID: <f29db9a80703201839j53186d4evebe459befc2571b5@mail.gmail.com>

A quick introduction.

I am planning on adding support to the stgt for both SSC and SMC
devices with the aim of full Virtual Tape Library support.

I have a working VTL based around the scsi_debug kernel module +
char-device 'back-end' to pass SCSI commands thru to user-space
daemons (which poll the char device looking for work to do). These
daemons act as the SSC or SMC devices.

This VTL I have had working for over 12mths.

However there are some limitations (like a kernel module required for
each OS port).

I want to move this code base across to an iSCSI frame-work and have
finally given up on the Intel iSCSI Reference code base.

There are some aspects of the stgt code that I would like to modify to
make this 'port' a little easier.

There is a lack of a 'generic' pointer for any data structures used
for each target.
i.e. I would like to malloc() required storage space to keep MODE/LOG
SENSE data per target.
===================================================================
--- tgtd.h      (revision 849)
+++ tgtd.h      (working copy)
@@ -47,6 +47,9 @@

        /* TODO: needs a structure for lots of device parameters */
        uint8_t d_sense;
+
+       /* For each device's private use */
+       void    * priv_p;
 };

  struct scsi_cmd {

===================================================================


I suppose what I am asking is:
1. Is this list interested in the SSC & SMC code base as/when I get it working ?
2. Should I submit all code in a couple of big chunks - e.g. smc.c,
ssc.c etc once I have got something worthy to submit ?
Or submit small incremental bits as they are added ? e.g. SCSI command
at a time.

So far, while testing of this code base, I have modified the Makefile
to include the following conditional compile time options. The SBC
code is still included.
e.g.
make KERNELSRC=/usr/src/linux-2.6.20.1 ISCSI=1 SSC=1 SMC=1

Would this be the 'right' way to go, or should it just be compiled
anyway - like the sbc code?


I would also like to see "int (*device_init)()" return a status code
instead of being a "void (*device_init)()", and a corresponding "int
(*device_shutdown)()" defined in the device_type_template.

I have patches if they are welcome.


From fujita.tomonori at lab.ntt.co.jp  Wed Mar 21 04:19:20 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 21 Mar 2007 12:19:20 +0900
Subject: [Stgt-devel] Adding Virtial Tape & Changer targets
In-Reply-To: <f29db9a80703201839j53186d4evebe459befc2571b5@mail.gmail.com>
References: <f29db9a80703201839j53186d4evebe459befc2571b5@mail.gmail.com>
Message-ID: <200703210319.l2L3JLQk015319@r-dd.iij4u.or.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] Adding Virtial Tape & Changer targets
Date: Wed, 21 Mar 2007 12:39:04 +1100

> A quick introduction.
> 
> I am planning on adding support to the stgt for both SSC and SMC
> devices with the aim of full Virtual Tape Library support.

Great!


> I have a working VTL based around the scsi_debug kernel module +
> char-device 'back-end' to pass SCSI commands thru to user-space
> daemons (which poll the char device looking for work to do). These
> daemons act as the SSC or SMC devices.
> 
> This VTL I have had working for over 12mths.
> 
> However there are some limitations (like a kernel module required for
> each OS port).
> 
> I want to move this code base across to an iSCSI frame-work and have
> finally given up on the Intel iSCSI Reference code base.
> 
> There are some aspects of the stgt code that I would like to modify to
> make this 'port' a little easier.
> 
> There is a lack of a 'generic' pointer for any data structures used
> for each target.
> i.e. I would like to malloc() required storage space to keep MODE/LOG
> SENSE data per target.
> ===================================================================
> --- tgtd.h      (revision 849)
> +++ tgtd.h      (working copy)
> @@ -47,6 +47,9 @@
> 
>         /* TODO: needs a structure for lots of device parameters */
>         uint8_t d_sense;
> +
> +       /* For each device's private use */
> +       void    * priv_p;
>  };
> 
>   struct scsi_cmd {
> 
> ===================================================================

Yeah, we need something like that.


> I suppose what I am asking is:
> 1. Is this list interested in the SSC & SMC code base as/when I get it working ?

Surely. I'm happy to merge them.


> 2. Should I submit all code in a couple of big chunks - e.g. smc.c,
> ssc.c etc once I have got something worthy to submit ?
> Or submit small incremental bits as they are added ? e.g. SCSI command
> at a time.

You can send smc.c and ssc.c as a single big patch
respectively. Probabaly you need some small patches to change stgt for
smc.c and ssc.c.


> So far, while testing of this code base, I have modified the Makefile
> to include the following conditional compile time options. The SBC
> code is still included.
> e.g.
> make KERNELSRC=/usr/src/linux-2.6.20.1 ISCSI=1 SSC=1 SMC=1
>
> Would this be the 'right' way to go, or should it just be compiled
> anyway - like the sbc code?

If SSC and SMC need patched header files like IBMVIO and XEN driver
and passthrough with bsg, you need compile time options. If not, you
don't need them.


> I would also like to see "int (*device_init)()" return a status code
> instead of being a "void (*device_init)()", and a corresponding "int
> (*device_shutdown)()" defined in the device_type_template.

No problem. device_init() is used only for OSD and a workaround. They
are expected to be changed to support other device types like SSC and
SMC.


From dougg at torque.net  Wed Mar 21 04:41:43 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Tue, 20 Mar 2007 23:41:43 -0400
Subject: [Stgt-devel] Adding Virtial Tape & Changer targets
In-Reply-To: <f29db9a80703201839j53186d4evebe459befc2571b5@mail.gmail.com>
References: <f29db9a80703201839j53186d4evebe459befc2571b5@mail.gmail.com>
Message-ID: <4600A977.20906@torque.net>

Mark Harvey wrote:
> A quick introduction.
> 
> I am planning on adding support to the stgt for both SSC and SMC
> devices with the aim of full Virtual Tape Library support.
> 
> I have a working VTL based around the scsi_debug kernel module +
> char-device 'back-end' to pass SCSI commands thru to user-space
> daemons (which poll the char device looking for work to do). These
> daemons act as the SSC or SMC devices.
> 
> This VTL I have had working for over 12mths.
> 
> However there are some limitations (like a kernel module required for
> each OS port).
> 
> I want to move this code base across to an iSCSI frame-work and have
> finally given up on the Intel iSCSI Reference code base.
> 
> There are some aspects of the stgt code that I would like to modify to
> make this 'port' a little easier.
> 
> There is a lack of a 'generic' pointer for any data structures used
> for each target.
> i.e. I would like to malloc() required storage space to keep MODE/LOG
> SENSE data per target.

Mark,
Do you need to implement MODE SELECT? It isn't in stgt
or any other command that has metadata to be parsed
in the data_out buffer.

As far as I can see that needs a "double parse". The
first time with the cdb alone so the parser can
work out the allocation length. That length is them
passed back to the transport which fetches a data_out
buffer of that size from the initiator. Then the
transport needs to revisit the parser, this time
with cdb+data_out.


Doug Gilbert


From markh794 at gmail.com  Wed Mar 21 05:22:17 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Wed, 21 Mar 2007 15:22:17 +1100
Subject: [Stgt-devel] Adding Virtial Tape & Changer targets
In-Reply-To: <4600A977.20906@torque.net>
References: <f29db9a80703201839j53186d4evebe459befc2571b5@mail.gmail.com>
	<4600A977.20906@torque.net>
Message-ID: <f29db9a80703202122iabb43acu643f4f8dead5f3fa@mail.gmail.com>

On 3/21/07, Douglas Gilbert <dougg at torque.net> wrote:
>
> Mark Harvey wrote:
> > A quick introduction.
> >
> > I am planning on adding support to the stgt for both SSC and SMC
> > devices with the aim of full Virtual Tape Library support.
> >
> > I have a working VTL based around the scsi_debug kernel module +
> > char-device 'back-end' to pass SCSI commands thru to user-space
> > daemons (which poll the char device looking for work to do). These
> > daemons act as the SSC or SMC devices.
> >
> > This VTL I have had working for over 12mths.
> >
> > However there are some limitations (like a kernel module required for
> > each OS port).
> >
> > I want to move this code base across to an iSCSI frame-work and have
> > finally given up on the Intel iSCSI Reference code base.
> >
> > There are some aspects of the stgt code that I would like to modify to
> > make this 'port' a little easier.
> >
> > There is a lack of a 'generic' pointer for any data structures used
> > for each target.
> > i.e. I would like to malloc() required storage space to keep MODE/LOG
> > SENSE data per target.
>
> Mark,
> Do you need to implement MODE SELECT? It isn't in stgt
> or any other command that has metadata to be parsed
> in the data_out buffer.
>
> As far as I can see that needs a "double parse". The
> first time with the cdb alone so the parser can
> work out the allocation length. That length is them
> passed back to the transport which fetches a data_out
> buffer of that size from the initiator. Then the
> transport needs to revisit the parser, this time
> with cdb+data_out.
>
>
> Doug Gilbert
>

Hi Doug,

Both MODE SELECT/MODE SENSE and LOG SELECT/LOG SENSE commands are used by
NetBackup (Which I support for a living - and the main force behind writing
the VTL).

Although, NetBackup really only uses the MODE SELECT to place the tape
device into variable block mode, so limited support will be OK. (i.e. The
block-descriptor block)

There are also a few 16byte CDB commands (READ / WRITE ATTRIBUTE) used by
the latest version of NetBackup which I also would like to implement.
Certainly the WRITE ATTRIBUTE would fit your description of metadata in the
data_out phase.

Cheers
Mark
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070321/2f261120/attachment.html>

From blackmagic02881 at gmail.com  Wed Mar 21 14:44:09 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 21 Mar 2007 09:44:09 -0400
Subject: [Stgt-devel] Adding Virtial Tape & Changer targets
In-Reply-To: <f29db9a80703201839j53186d4evebe459befc2571b5@mail.gmail.com>
References: <f29db9a80703201839j53186d4evebe459befc2571b5@mail.gmail.com>
Message-ID: <1174484649.3688.6.camel@dhcp-107.ibrix.com>

On Wed, 2007-03-21 at 12:39 +1100, Mark Harvey wrote:
> A quick introduction.
> 
> I am planning on adding support to the stgt for both SSC and SMC
> devices with the aim of full Virtual Tape Library support.
> 
> I have a working VTL based around the scsi_debug kernel module +
> char-device 'back-end' to pass SCSI commands thru to user-space
> daemons (which poll the char device looking for work to do). These
> daemons act as the SSC or SMC devices.
> 
> This VTL I have had working for over 12mths. 

side question, your SSC/SMC code support to emulate one particular
VT/VTL or you will provide a framework to allow the emulation of
multiple different types of VTLs and VTs?

suggest you to release the code early so people can give you more
feedback.

thanks for the great work.

Ming




From mark_harvey at symantec.com  Wed Mar 21 21:32:18 2007
From: mark_harvey at symantec.com (Mark Harvey)
Date: Wed, 21 Mar 2007 13:32:18 -0700
Subject: [Stgt-devel]  Adding Virtual Tape & Changer targets
In-Reply-To: <1174484649.3688.6.camel@dhcp-107.ibrix.com>
References: <f29db9a80703201839j53186d4evebe459befc2571b5@mail.gmail.com>
	<1174484649.3688.6.camel@dhcp-107.ibrix.com>
Message-ID: <B3E98EAC5926D5498DDD341AE4B7D21CEBE37E@TUS1XCHCLUPIN05.enterprise.veritas.com>


The aim is to support the SSC-3 and SMC-3 standards - eventually. No
actual code that says "emulate robot xyz".
The vtl code I'm using reports as a STK L700 with no ill side effects.

The actual VENDOR Ident, Product Ident etc for the SCSI Inquiry string
are to be retrieved from a configuration file - and hence code
independent.

I hope nobody shoots me for hijacking the '-b <backing file>' option for
use as the configuration file for SSC and SMC devices..

Once I clean up some comments in the code, I shall post a diff.

Cheers
Mark Harvey

-----Original Message-----
From: stgt-devel-bounces at lists.berlios.de
[mailto:stgt-devel-bounces at lists.berlios.de] On Behalf Of Ming Zhang
Sent: Thursday, 22 March 2007 12:44 AM
To: Mark Harvey
Cc: stgt-devel at lists.berlios.de
Subject: Re: [Stgt-devel] Adding Virtial Tape & Changer targets

On Wed, 2007-03-21 at 12:39 +1100, Mark Harvey wrote:
> A quick introduction.
> 
> I am planning on adding support to the stgt for both SSC and SMC
> devices with the aim of full Virtual Tape Library support.
> 
> I have a working VTL based around the scsi_debug kernel module +
> char-device 'back-end' to pass SCSI commands thru to user-space
> daemons (which poll the char device looking for work to do). These
> daemons act as the SSC or SMC devices.
> 
> This VTL I have had working for over 12mths. 

side question, your SSC/SMC code support to emulate one particular
VT/VTL or you will provide a framework to allow the emulation of
multiple different types of VTLs and VTs?

suggest you to release the code early so people can give you more
feedback.

thanks for the great work.

Ming


_______________________________________________
Stgt-devel mailing list
Stgt-devel at lists.berlios.de
https://lists.berlios.de/mailman/listinfo/stgt-devel


From pw at osc.edu  Wed Mar 21 21:37:32 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 21 Mar 2007 16:37:32 -0400
Subject: [Stgt-devel] [PATCH] iscsi: handle dataout padding
Message-ID: <20070321203732.GA8766@osc.edu>

All iscsi segments are padded to 4 bytes.  Do this for dataout
too.  Bug seen on transferring certain sizes.  Also return error
from tx_start to avoid segfault from "initiator bug" cases.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 5be2cce..b22f6a9 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1272,7 +1272,7 @@ found:
 
 	conn->rx_buffer = task->data;
 	conn->rx_buffer += be32_to_cpu(req->offset);
-	conn->rx_size = ntoh24(req->dlength);
+	conn->rx_size = roundup(ntoh24(req->dlength), 4);
 
 	task->offset += ntoh24(req->dlength);
 	task->r2t_count -= ntoh24(req->dlength);
@@ -1495,7 +1495,7 @@ static int iscsi_task_rx_start(struct iscsi_connection *conn)
 		break;
 	}
 
-	return 0;
+	return err;
 }
 
 static int iscsi_scsi_cmd_tx_start(struct iscsi_task *task)
-- 
1.5.0.3



From pw at osc.edu  Wed Mar 21 21:38:01 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Wed, 21 Mar 2007 16:38:01 -0400
Subject: [Stgt-devel] [PATCH] iscsi: refactor residual calculation
Message-ID: <20070321203801.GB8766@osc.edu>

Break out iscsi residual calculation into a shared function
to avoid code duplication.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |   83 +++++++++++++++++----------------------------------
 1 files changed, 28 insertions(+), 55 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index b22f6a9..9941637 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -740,28 +740,12 @@ static void cmnd_finish(struct iscsi_connection *conn)
 	}
 }
 
-static int iscsi_cmd_rsp_build(struct iscsi_task *task)
+static void calc_residual(struct iscsi_cmd_rsp *rsp, struct iscsi_task *task)
 {
-	struct iscsi_connection *conn = task->conn;
-	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
-	uint32_t residual;
-
-	dprintf("%p %x\n", task, task->scmd.scb[0]);
-
-	memset(rsp, 0, sizeof(*rsp));
-	rsp->opcode = ISCSI_OP_SCSI_CMD_RSP;
-	rsp->itt = task->tag;
-	rsp->flags = ISCSI_FLAG_CMD_FINAL;
-	rsp->response = ISCSI_STATUS_CMD_COMPLETED;
-	rsp->cmd_status = task->result;
-	rsp->statsn = cpu_to_be32(conn->stat_sn++);
-	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
-	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
+	uint32_t residual = 0;
 
 	/* we never have write under/over flow, no way to signal that
 	 * back from the target currently. */
-
-	residual = 0;
 	if (task->dir == BIDIRECTIONAL) {
 		if (task->len < task->read_len) {
 			rsp->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
@@ -782,6 +766,26 @@ static int iscsi_cmd_rsp_build(struct iscsi_task *task)
 		}
 		rsp->residual_count = cpu_to_be32(residual);
 	}
+}
+
+static int iscsi_cmd_rsp_build(struct iscsi_task *task)
+{
+	struct iscsi_connection *conn = task->conn;
+	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
+
+	dprintf("%p %x\n", task, task->scmd.scb[0]);
+
+	memset(rsp, 0, sizeof(*rsp));
+	rsp->opcode = ISCSI_OP_SCSI_CMD_RSP;
+	rsp->itt = task->tag;
+	rsp->flags = ISCSI_FLAG_CMD_FINAL;
+	rsp->response = ISCSI_STATUS_CMD_COMPLETED;
+	rsp->cmd_status = task->result;
+	rsp->statsn = cpu_to_be32(conn->stat_sn++);
+	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
+	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
+
+	calc_residual(rsp, task);
 
 	return 0;
 }
@@ -797,7 +801,6 @@ static int iscsi_sense_rsp_build(struct iscsi_task *task)
 	struct iscsi_cmd_rsp *rsp = (struct iscsi_cmd_rsp *) &conn->rsp.bhs;
 	struct iscsi_sense_data *sense;
 	unsigned char sense_len;
- 	uint32_t residual;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_CMD_RSP;
@@ -809,29 +812,8 @@ static int iscsi_sense_rsp_build(struct iscsi_task *task)
 	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
 	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
 
-	/* XXX: copied from above, consider merging these functions */
-	residual = 0;
-	if (task->dir == BIDIRECTIONAL) {
-		if (task->len < task->read_len) {
-			rsp->flags |= ISCSI_FLAG_CMD_BIDI_UNDERFLOW;
-			residual = task->read_len - task->len;
-		} else if (task->len > task->read_len) {
-			rsp->flags |= ISCSI_FLAG_CMD_BIDI_OVERFLOW;
-			residual = task->len - task->read_len;
-		}
-		rsp->bi_residual_count = cpu_to_be32(residual);
-		rsp->residual_count = 0;
-	} else {
-		if (task->len < task->read_len) {
-			rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-			residual = task->read_len - task->len;
-		} else if (task->len > task->read_len) {
-			rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
-			residual = task->len - task->read_len;
-		}
-		rsp->residual_count = cpu_to_be32(residual);
-	}
-
+	calc_residual(rsp, task);
+	
 	sense = (struct iscsi_sense_data *)task->scmd.sense_buffer;
 	sense_len = task->scmd.sense_len;
 
@@ -849,9 +831,8 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
-	int datalen, exp_datalen = task->read_len;
+	int datalen;
 	int max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
- 	uint32_t residual;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
@@ -861,10 +842,10 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 	rsp->offset = cpu_to_be32(task->offset);
 	rsp->datasn = cpu_to_be32(task->exp_r2tsn++);
 
-	datalen = min(exp_datalen, task->len);
+	datalen = min_t(uint32_t, task->read_len, task->len);
 	datalen -= task->offset;
 
-	dprintf("%d %d %d %d %x\n", datalen, exp_datalen, task->len, max_burst, rsp->itt);
+	dprintf("%d %d %d %d %x\n", datalen, task->read_len, task->len, max_burst, rsp->itt);
 
 	if (datalen <= max_burst) {
 		rsp->flags = ISCSI_FLAG_CMD_FINAL;
@@ -872,17 +853,9 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 		/* collapse status into final packet if successful */
 		if (task->result == 0 && task->dir != BIDIRECTIONAL) {
 			rsp->flags |= ISCSI_FLAG_DATA_STATUS;
-			if (task->len < exp_datalen) {
-				rsp->flags |= ISCSI_FLAG_CMD_UNDERFLOW;
-				residual = exp_datalen - task->len;
-			} else if (task->len > exp_datalen) {
-				rsp->flags |= ISCSI_FLAG_CMD_OVERFLOW;
-				residual = task->len - exp_datalen;
-			} else
-				residual = 0;
 			rsp->cmd_status = task->result;
 			rsp->statsn = cpu_to_be32(conn->stat_sn++);
-			rsp->residual_count = cpu_to_be32(residual);
+			calc_residual((struct iscsi_cmd_rsp *) rsp, task);
 		}
 	} else
 		datalen = max_burst;
-- 
1.5.0.3



From blackmagic02881 at gmail.com  Wed Mar 21 21:38:57 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 21 Mar 2007 16:38:57 -0400
Subject: [Stgt-devel] Adding Virtual Tape & Changer targets
In-Reply-To: <B3E98EAC5926D5498DDD341AE4B7D21CEBE37E@TUS1XCHCLUPIN05.enterprise.veritas.com>
References: <f29db9a80703201839j53186d4evebe459befc2571b5@mail.gmail.com>
	<1174484649.3688.6.camel@dhcp-107.ibrix.com>
	<B3E98EAC5926D5498DDD341AE4B7D21CEBE37E@TUS1XCHCLUPIN05.enterprise.veritas.com>
Message-ID: <1174509537.4262.21.camel@dhcp-107.ibrix.com>

On Wed, 2007-03-21 at 13:32 -0700, Mark Harvey wrote:
> The aim is to support the SSC-3 and SMC-3 standards - eventually. No
> actual code that says "emulate robot xyz".

different robots will have different capability and even the code
support every feature defined in SSC and SMC, it still need to present
it to host as a specific model.

but of course having more features implemented and allowing each model
to assemble them is nice.

> The vtl code I'm using reports as a STK L700 with no ill side effects.
> 

which VT model u report?

> The actual VENDOR Ident, Product Ident etc for the SCSI Inquiry string
> are to be retrieved from a configuration file - and hence code
> independent.
> 
> I hope nobody shoots me for hijacking the '-b <backing file>' option for
> use as the configuration file for SSC and SMC devices..

it will be wonderful if a VTL can be configurable purely from a file.
and virtual device in tgt is in user space so open a file is really
ok. ;)

aha, u work for the company who make VBE, so can u run a VBE
interoperability test on your code?!

> 
> Once I clean up some comments in the code, I shall post a diff.
> 
> Cheers
> Mark Harvey
> 
> -----Original Message-----
> From: stgt-devel-bounces at lists.berlios.de
> [mailto:stgt-devel-bounces at lists.berlios.de] On Behalf Of Ming Zhang
> Sent: Thursday, 22 March 2007 12:44 AM
> To: Mark Harvey
> Cc: stgt-devel at lists.berlios.de
> Subject: Re: [Stgt-devel] Adding Virtial Tape & Changer targets
> 
> On Wed, 2007-03-21 at 12:39 +1100, Mark Harvey wrote:
> > A quick introduction.
> > 
> > I am planning on adding support to the stgt for both SSC and SMC
> > devices with the aim of full Virtual Tape Library support.
> > 
> > I have a working VTL based around the scsi_debug kernel module +
> > char-device 'back-end' to pass SCSI commands thru to user-space
> > daemons (which poll the char device looking for work to do). These
> > daemons act as the SSC or SMC devices.
> > 
> > This VTL I have had working for over 12mths. 
> 
> side question, your SSC/SMC code support to emulate one particular
> VT/VTL or you will provide a framework to allow the emulation of
> multiple different types of VTLs and VTs?
> 
> suggest you to release the code early so people can give you more
> feedback.
> 
> thanks for the great work.
> 
> Ming
> 
> 
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From markh794 at gmail.com  Thu Mar 22 00:13:41 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 22 Mar 2007 10:13:41 +1100
Subject: [Stgt-devel] Adding Virtual Tape & Changer targets
In-Reply-To: <1174509537.4262.21.camel@dhcp-107.ibrix.com>
References: <f29db9a80703201839j53186d4evebe459befc2571b5@mail.gmail.com>
	<1174484649.3688.6.camel@dhcp-107.ibrix.com>
	<B3E98EAC5926D5498DDD341AE4B7D21CEBE37E@TUS1XCHCLUPIN05.enterprise.veritas.com>
	<1174509537.4262.21.camel@dhcp-107.ibrix.com>
Message-ID: <f29db9a80703211613o2bc16f11x639e1685b75858ae@mail.gmail.com>

On 3/22/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> On Wed, 2007-03-21 at 13:32 -0700, Mark Harvey wrote:
> > The aim is to support the SSC-3 and SMC-3 standards - eventually. No
> > actual code that says "emulate robot xyz".
>
> different robots will have different capability and even the code
> support every feature defined in SSC and SMC, it still need to present
> it to host as a specific model.
>
> but of course having more features implemented and allowing each model
> to assemble them is nice.
>
> > The vtl code I'm using reports as a STK L700 with no ill side effects.
> >
>
> which VT model u report?
>
> > The actual VENDOR Ident, Product Ident etc for the SCSI Inquiry string
> > are to be retrieved from a configuration file - and hence code
> > independent.
> >
> > I hope nobody shoots me for hijacking the '-b <backing file>' option for
> > use as the configuration file for SSC and SMC devices..
>
> it will be wonderful if a VTL can be configurable purely from a file.
> and virtual device in tgt is in user space so open a file is really
> ok. ;)
>
> aha, u work for the company who make VBE, so can u run a VBE
> interoperability test on your code?!
This is the reason for creating the VTL code.
i.e.
Lack of available hardware to support NetBackup.
Real tape libraries cost lots of $$$ and trying to get one per support
tech is just unrealistic.
There is also lots of different flavors of operating systems in the
support lab, so interoperability testing with different iSCSI
initiators will be possible.

The BackupExec support guys are also co-located on the same floor so
I'll be able to get interoperability tests with BackupExec as well
using the Microsoft iSCSI initiator.

In a previous life, I also installed and configured NetWorker (Its
been 5+ years since I touched this, but I should be able to figure out
how to run it again).

I'm also interested in Persistent SCSI reserve/release - latest
version of NetBackup (in beta at the moment) will be using this so
this will be another area of code I'll most likely be looking at. Once
the tape drive & library side of things are working..

>
> >
> > Once I clean up some comments in the code, I shall post a diff.
> >
> > Cheers
> > Mark Harvey
> >
> > -----Original Message-----
> > From: stgt-devel-bounces at lists.berlios.de
> > [mailto:stgt-devel-bounces at lists.berlios.de] On Behalf Of Ming Zhang
> > Sent: Thursday, 22 March 2007 12:44 AM
> > To: Mark Harvey
> > Cc: stgt-devel at lists.berlios.de
> > Subject: Re: [Stgt-devel] Adding Virtial Tape & Changer targets
> >
> > On Wed, 2007-03-21 at 12:39 +1100, Mark Harvey wrote:
> > > A quick introduction.
> > >
> > > I am planning on adding support to the stgt for both SSC and SMC
> > > devices with the aim of full Virtual Tape Library support.
> > >
> > > I have a working VTL based around the scsi_debug kernel module +
> > > char-device 'back-end' to pass SCSI commands thru to user-space
> > > daemons (which poll the char device looking for work to do). These
> > > daemons act as the SSC or SMC devices.
> > >
> > > This VTL I have had working for over 12mths.
> >
> > side question, your SSC/SMC code support to emulate one particular
> > VT/VTL or you will provide a framework to allow the emulation of
> > multiple different types of VTLs and VTs?
> >
> > suggest you to release the code early so people can give you more
> > feedback.
> >
> > thanks for the great work.
> >
> > Ming
> >
> >
> > _______________________________________________
> > Stgt-devel mailing list
> > Stgt-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/stgt-devel
>
>


From markh794 at gmail.com  Thu Mar 22 03:37:57 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Thu, 22 Mar 2007 13:37:57 +1100
Subject: [Stgt-devel] Initial patch to add Tape and Library support
Message-ID: <f29db9a80703211937v67943c7euae051c5e50018118@mail.gmail.com>

Sorry for the 'attachment' but it seems a little too big to include in-line.

I can chop it up if requested.

Note: Most (read all except Inquiry) commands are not supported yet.

Regards
Mark
-------------- next part --------------
A non-text attachment was scrubbed...
Name: patch-set
Type: application/octet-stream
Size: 33170 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070322/28643ca6/attachment.obj>

From fujita.tomonori at lab.ntt.co.jp  Thu Mar 22 15:05:42 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 22 Mar 2007 23:05:42 +0900 (JST)
Subject: [Stgt-devel] [PATCH] iscsi: refactor residual calculation
In-Reply-To: <20070321203801.GB8766@osc.edu>
References: <20070321203801.GB8766@osc.edu>
Message-ID: <20070322053347T.fujita.tomonori@lab.ntt.co.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] iscsi: refactor residual calculation
Date: Wed, 21 Mar 2007 16:38:01 -0400

> Break out iscsi residual calculation into a shared function
> to avoid code duplication.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>

Thanks. I got:

fujita at ac:~/git/tgt$ git-am --whitespace=error ~/Mail/iscsi/stgt/1410

Applying 'iscsi: refactor residual calculation'

Adds trailing whitespace.
.dotest/patch:103:
fatal: 1 line adds trailing whitespaces.
Patch failed at 0001.
When you have resolved this problem run "git-am --resolved".
If you would prefer to skip this patch, instead run "git-am --skip".


I fixed and merged this patch.


From fujita.tomonori at lab.ntt.co.jp  Thu Mar 22 15:05:43 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 22 Mar 2007 23:05:43 +0900 (JST)
Subject: [Stgt-devel] [PATCH] iscsi: handle dataout padding
In-Reply-To: <20070321203732.GA8766@osc.edu>
References: <20070321203732.GA8766@osc.edu>
Message-ID: <20070322053612K.fujita.tomonori@lab.ntt.co.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] iscsi: handle dataout padding
Date: Wed, 21 Mar 2007 16:37:32 -0400

> All iscsi segments are padded to 4 bytes.  Do this for dataout
> too.  Bug seen on transferring certain sizes.  Also return error
> from tx_start to avoid segfault from "initiator bug" cases.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Thu Mar 22 16:54:10 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 23 Mar 2007 00:54:10 +0900 (JST)
Subject: [Stgt-devel] Initial patch to add Tape and Library support
In-Reply-To: <f29db9a80703211937v67943c7euae051c5e50018118@mail.gmail.com>
References: <f29db9a80703211937v67943c7euae051c5e50018118@mail.gmail.com>
Message-ID: <20070322071628E.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] Initial patch to add Tape and Library support
Date: Thu, 22 Mar 2007 13:37:57 +1100

> Sorry for the 'attachment' but it seems a little too big to include in-line.
> 
> I can chop it up if requested.
> 
> Note: Most (read all except Inquiry) commands are not supported yet.

diff -urN -x TAGS -x .svn reference/doc/README.vtl vtl/doc/README.vtl
--- reference/doc/README.vtl	1970-01-01 10:00:00.000000000 +1000
+++ vtl/doc/README.vtl	2007-03-22 10:57:24.000000000 +1100
@@ -0,0 +1,35 @@
+Initial support for SCSI Streaming and SCSI Medium Changer devices.
+markh794 at gmail dot com
+mark_harvey at symantec dot com
+
+
+To set up a changer and tape device..
+./usr/tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2007-03:marks-vtl_smc:`hostname` --target-type changer
+./usr/tgtadm --lld iscsi --op new --mode target --tid 2 -T iqn.2007-03:marks-vtl_ssc:`hostname` --target-type tape
+
+I'm hijacking the 'backing device' for use as the configuration file.

This isn't a good idea. tgt doesn't use any configuration files (or
database). Everything should be configured via tgtadm. We leave
storing configurations to other projects like Openfiler.


diff -urN -x TAGS -x .svn reference/usr/target.c vtl/usr/target.c
--- reference/usr/target.c	2007-03-20 08:06:54.000000000 +1100
+++ vtl/usr/target.c	2007-03-22 05:43:28.000000000 +1100
@@ -37,7 +37,7 @@
 #include "tgtadm.h"
 
 extern struct device_type_template sbc_template, mmc_template, osd_template,
-	spt_template;
+			ssc_template, smc_template, spt_template;
 
 static LIST_HEAD(target_list);
 
@@ -239,11 +239,16 @@
 
 	snprintf(device->scsi_id, sizeof(device->scsi_id),
 		 "deadbeaf%d:%" PRIu64, tid, lun);
+	snprintf(device->scsi_sn, sizeof(device->scsi_sn),
+		 "beaf%d%" PRIu64, tid, lun);
 
 	tgt_cmd_queue_init(&device->cmd_queue);
 
-	if (target->dev_type_template.device_init)
-		target->dev_type_template.device_init(device);
+	if(target->dev_type_template.device_init) {
+		err = target->dev_type_template.device_init(device);
+		if(err)
+			return err;
+	}

We need to kill a new target that has been already created. I'll take
care about it.

 
@@ -259,6 +264,7 @@
 {
 	struct target *target;
 	struct tgt_device *device;
+	int	err;
 
 	dprintf("%u %" PRIu64 "\n", tid, lun);
 
@@ -271,12 +277,17 @@
 	if (!list_empty(&device->cmd_queue.queue))
 		return TGTADM_LUN_ACTIVE;
 
+	err = target->dev_type_template.device_shutdown(device);
+
 	free(device->path);
 	list_del(&device->device_siblings);
 
 	target->bst->bs_close(device);
 	free(device);
-	return 0;
+	if(err)
+		return err;
+	else
+		return 0;

ditto.
 


From pw at osc.edu  Sun Mar 25 17:21:41 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sun, 25 Mar 2007 11:21:41 -0400
Subject: [Stgt-devel] [PATCH] free leaked target name
Message-ID: <20070325152141.GA26830@osc.edu>

Target destroy leaked name.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/target.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/usr/target.c b/usr/target.c
index e6a9e76..f48839e 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -1266,7 +1266,7 @@ int tgt_target_destroy(int tid)
 	}
 
 	free(target->account.in_aids);
-
+	free(target->name);
 	free(target);
 
 	return 0;
-- 
1.5.0.5



From dougg at torque.net  Thu Mar 22 21:32:00 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Thu, 22 Mar 2007 16:32:00 -0400
Subject: [Stgt-devel] Initial patch to add Tape and Library support
In-Reply-To: <20070322071628E.fujita.tomonori@lab.ntt.co.jp>
References: <f29db9a80703211937v67943c7euae051c5e50018118@mail.gmail.com>
	<20070322071628E.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <4602E7C0.2050300@torque.net>

FUJITA Tomonori wrote:
> From: "Mark Harvey" <markh794 at gmail.com>
> Subject: [Stgt-devel] Initial patch to add Tape and Library support
> Date: Thu, 22 Mar 2007 13:37:57 +1100
> 
>> Sorry for the 'attachment' but it seems a little too big to include in-line.
>>
>> I can chop it up if requested.
>>
>> Note: Most (read all except Inquiry) commands are not supported yet.
> 
> diff -urN -x TAGS -x .svn reference/doc/README.vtl vtl/doc/README.vtl
> --- reference/doc/README.vtl	1970-01-01 10:00:00.000000000 +1000
> +++ vtl/doc/README.vtl	2007-03-22 10:57:24.000000000 +1100
> @@ -0,0 +1,35 @@
> +Initial support for SCSI Streaming and SCSI Medium Changer devices.
> +markh794 at gmail dot com
> +mark_harvey at symantec dot com
> +
> +
> +To set up a changer and tape device..
> +./usr/tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2007-03:marks-vtl_smc:`hostname` --target-type changer
> +./usr/tgtadm --lld iscsi --op new --mode target --tid 2 -T iqn.2007-03:marks-vtl_ssc:`hostname` --target-type tape
> +
> +I'm hijacking the 'backing device' for use as the configuration file.
> 
> This isn't a good idea. tgt doesn't use any configuration files (or
> database). Everything should be configured via tgtadm. We leave
> storing configurations to other projects like Openfiler.

Do the current stgt kernel based transport drivers come
up in an "off the bus state"? If they are visible to
the transport before tgtd and tgtadm have got their acts
together then you have a problem.

I noticed a problem with a MPT SAS HBA. Its firmware settings
make it a SAS target and (perhaps prior to any mpt* drivers
being loaded) SAS SMP inititiators in that SAS domain will
be prompted to re-run discovery during which the firmware
identifiers itself as a SSP target. Then an INQUIRY gets sent
as _all_ SCSI targets should respond to that, even if there
are no logical units.

Doug Gilbert




From markh794 at gmail.com  Thu Mar 22 22:09:31 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Fri, 23 Mar 2007 08:09:31 +1100
Subject: [Stgt-devel] Initial patch to add Tape and Library support
In-Reply-To: <4602E7C0.2050300@torque.net>
References: <f29db9a80703211937v67943c7euae051c5e50018118@mail.gmail.com>
	<20070322071628E.fujita.tomonori@lab.ntt.co.jp>
	<4602E7C0.2050300@torque.net>
Message-ID: <f29db9a80703221409g1a8eb99byf0543a6762fa9468@mail.gmail.com>

On 3/23/07, Douglas Gilbert <dougg at torque.net> wrote:
> FUJITA Tomonori wrote:
> > From: "Mark Harvey" <markh794 at gmail.com>
> > Subject: [Stgt-devel] Initial patch to add Tape and Library support
> > Date: Thu, 22 Mar 2007 13:37:57 +1100
> >
> >> Sorry for the 'attachment' but it seems a little too big to include in-line.
> >>
> >> I can chop it up if requested.
> >>
> >> Note: Most (read all except Inquiry) commands are not supported yet.
> >
> > diff -urN -x TAGS -x .svn reference/doc/README.vtl vtl/doc/README.vtl
> > --- reference/doc/README.vtl  1970-01-01 10:00:00.000000000 +1000
> > +++ vtl/doc/README.vtl        2007-03-22 10:57:24.000000000 +1100
> > @@ -0,0 +1,35 @@
> > +Initial support for SCSI Streaming and SCSI Medium Changer devices.
> > +markh794 at gmail dot com
> > +mark_harvey at symantec dot com
> > +
> > +
> > +To set up a changer and tape device..
> > +./usr/tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2007-03:marks-vtl_smc:`hostname` --target-type changer
> > +./usr/tgtadm --lld iscsi --op new --mode target --tid 2 -T iqn.2007-03:marks-vtl_ssc:`hostname` --target-type tape
> > +
> > +I'm hijacking the 'backing device' for use as the configuration file.
> >
> > This isn't a good idea. tgt doesn't use any configuration files (or
> > database). Everything should be configured via tgtadm. We leave
> > storing configurations to other projects like Openfiler.
>
> Do the current stgt kernel based transport drivers come
> up in an "off the bus state"? If they are visible to
> the transport before tgtd and tgtadm have got their acts
> together then you have a problem.
>
> I noticed a problem with a MPT SAS HBA. Its firmware settings
> make it a SAS target and (perhaps prior to any mpt* drivers
> being loaded) SAS SMP inititiators in that SAS domain will
> be prompted to re-run discovery during which the firmware
> identifiers itself as a SSP target. Then an INQUIRY gets sent
> as _all_ SCSI targets should respond to that, even if there
> are no logical units.
>
> Doug Gilbert

I noticed a sense key of "Inquiry Data has changed" ASC/ASCQ of 3f/03
which I have always assumed would be used for this type of scenario.

It's always been on my 'list of things to test'. Just to see if the
Linux SCSI upper layers would actually re-issue an Inquiry and
re-configure to the updated settings.


From markh794 at gmail.com  Sat Mar 24 07:39:05 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Sat, 24 Mar 2007 17:39:05 +1100
Subject: [Stgt-devel] tgtadm syntax additions (long)
Message-ID: <f29db9a80703232339o6828fd9fx9751a75bba3d3a9e@mail.gmail.com>

As the idea of hijacking the 'backing file' for use as a configuration
file, I have put together some ideas for adding to the syntax of
tgtadm to allow the configuration and customization of SSC and SMC
devices.

I have not attempted to implement any of the syntax, but am posting to
the list for comments before putting any effort into coding.

Here goes....


tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
--value=[value]

Where value is:

If device_type == 1 (SSC)

 VendorIdent="SONY"
 ProductIdent="SDX-900V"
 ProductRev="5401"
 SerialNumber="XYZZY_10"

If device_type == 8 (SMC), in addition to SSC values...
 VendorIdent="STK"
 ProductIdent="L700"
 ProductRev="5400"
 SerialNumber="XYZZY"

To configure
 (Reserve address space)
 ElementType=[1|2|3] StartAddress=[number] Quanity=[number]
Sides=[1|2] (Single/double sided)

 (To reserve address space for 'drives')
 ElementType=4 StartAddress=[number] Quanity=[number] Type="ssc|smc|sbc"

 (To 'tie' a previously known SerialNumber to this Address..)
 ElementType=4 Address=[Within Range from above] SerialNumber="xxxxx"

To 'populate' slots with 'media'
 ElementType=[2|3] BarCode="string"

where   ElementType 1 == Medium Transport (picker arm)
        ElementType 2 == Storage Element (Slots in robot)
        ElementType 3 == Import/Export Element (mailslots/Cartridge Access Port)
        ElementType 4 == Data Transport (SSC/SBC/MMC device - Tape,
Optical, CD/DVD)

Limits:
VendorIdent, ProductIdent, ProductRev & SerialNumber can all be on one line...

For Medium changers
 - We first need to 'reserve' number of slots for each element type:
 - Then Tie device S/No to a slot
 - Next fill Storage Slots and Import/Export with 'media'


tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
VendorIdent="QUANTUM"
tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
ProductIdent="SDLT600"
tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
ProductRev="0001"
tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
SerialNumber="XYZZY_10"

or
tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
        VendorIdent="QUANTUM" ProductIdent="SDLT600" \
        ProductRev="0001" SerialNumber="XYZZY_10"

tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=1 \
        VendorIdent="QUANTUM" ProductIdent="SDLT600" \
        ProductRev="0001" SerialNumber="XYZZY_11"

tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=2 \
        VendorIdent="QUANTUM" ProductIdent="SDLT600" \
        ProductRev="0001" SerialNumber="XYZZY_12"

tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=3 \
        VendorIdent="QUANTUM" ProductIdent="SDLT600" \
        ProductRev="0001" SerialNumber="XYZZY_13"

tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        VendorIdent="STK" ProductIdent="L180" \
        ProductRev="0001" SerialNumber="XYZZY"

Allocate 1 picker at address 256...
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        ElementType=1 StartAddress=256 Quanity=1 Sides=2

Allocate 800 slots starting at address 1024
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        ElementType=2 StartAddress=1024 Quanity=800 Sides=2

Allocate 10 Import/Export slots starting at address 128
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        ElementType=3 StartAddress=128 Quanity=10 Sides=2

Allocate room for 8 drives
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        ElementType=4 StartAddress=1 Quanity=8 Sides=1

'Assign drive SerialNumber with slot'
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        ElementType=4 Address=1 SerialNumber=XYZZY_10

tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        ElementType=4 Address=2 SerialNumber=XYZZY_11

tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        ElementType=4 Address=3 SerialNumber=XYZZY_12

tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        ElementType=4 Address=4 SerialNumber=XYZZY_13


Add media to storage Element
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        ElementType=2 Address=4 BarCode="ABC123L3"

Add media to import/export Element
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
        ElementType=3 Address=1 BarCode="CLN001"



tgtadm --lld iscsi --mode target --op show
Target 1: iqn.2007-03:marks-vtl_ssc:laptop
    System information:
        Type: tape
        Driver: iscsi
        Status: running
    I_T nexus information:
    LUN information:
        LUN: 0
            SCSI ID: deadbeaf2:0
            SCSI SN: beaf20
            VendorIdentification : QUANTUM
            ProductIdentification: SDLT600
            ProductRevision      : 0001
        LUN: 1
            SCSI ID: deadbeaf2:1
            SCSI SN: beaf21
            VendorIdentification : QUANTUM
            ProductIdentification: SDLT600
            ProductRevision      : 0001
        LUN: 2
            SCSI ID: deadbeaf2:2
            SCSI SN: beaf22
            VendorIdentification : QUANTUM
            ProductIdentification: SDLT600
            ProductRevision      : 0001
        LUN: 3
            SCSI ID: deadbeaf2:3
            SCSI SN: beaf23
            VendorIdentification : QUANTUM
            ProductIdentification: SDLT600
            ProductRevision      : 0001
    Account information:
    ACL information:
        ALL
Target 2: iqn.2007-03:marks-vtl_smc:laptop
    System information:
        Type: changer
        Driver: iscsi
        Status: running
    I_T nexus information:
    LUN information:
        LUN: 0
            SCSI ID: deadbeaf1:0
            SCSI SN: beaf10
            Size: 1K
            Backing store: /var/tmp/l1
            VendorIdentification : STK
            ProductIdentification: L700
            ProductRevision      : 0001
          Device Configuration:
            Medium Transport     : 1
            Storage Element      : 800
            Import/Export Element: 10
            Data Transport       : 8
    Account information:
    ACL information:
        ALL


From markh794 at gmail.com  Mon Mar 26 02:19:21 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Mon, 26 Mar 2007 10:19:21 +1000
Subject: [Stgt-devel] VTL - tgtadm syntax additions (Long)
Message-ID: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>

As the idea of hijacking the 'backing file' for use as a configuration
file has not received the most positive resonse, I have put together
some ideas for adding to the syntax of tgtadm to allow the
configuration and customization of SSC and SMC devices.

I have not attempted to implement any of the syntax, but am posting to
the list for comments before putting any effort into coding.

Here goes....


tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
--value=[value]

Where value is:

If device_type == 1 (SSC)

 VendorIdent="SONY"
 ProductIdent="SDX-900V"
 ProductRev="5401"
 SerialNumber="XYZZY_10"

If device_type == 8 (SMC), in addition to SSC values...
 VendorIdent="STK"
 ProductIdent="L700"
 ProductRev="5400"
 SerialNumber="XYZZY"

To configure
 (Reserve address space)
 ElementType=[1|2|3] StartAddress=[number] Quanity=[number]
Sides=[1|2] (Single/double sided)

 (To reserve address space for 'drives')
 ElementType=4 StartAddress=[number] Quanity=[number] Type="ssc|smc|sbc"

 (To 'tie' a previously known SerialNumber to this Address..)
 ElementType=4 Address=[Within Range from above] SerialNumber="xxxxx"

To 'populate' slots with 'media'
 ElementType=[2|3] BarCode="string"

where   ElementType 1 == Medium Transport (picker arm)
       ElementType 2 == Storage Element (Slots in robot)
       ElementType 3 == Import/Export Element (mailslots/Cartridge Access Port)
       ElementType 4 == Data Transport (SSC/SBC/MMC device - Tape,
Optical, CD/DVD)

Limits:
VendorIdent, ProductIdent, ProductRev & SerialNumber can all be on one line...

For Medium changers
 - We first need to 'reserve' number of slots for each element type:
 - Then Tie device S/No to a slot
 - Next fill Storage Slots and Import/Export with 'media'


tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
VendorIdent="QUANTUM"
tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
ProductIdent="SDLT600"
tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
ProductRev="0001"
tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
SerialNumber="XYZZY_10"

or
tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
       VendorIdent="QUANTUM" ProductIdent="SDLT600" \
       ProductRev="0001" SerialNumber="XYZZY_10"

tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=1 \
       VendorIdent="QUANTUM" ProductIdent="SDLT600" \
       ProductRev="0001" SerialNumber="XYZZY_11"

tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=2 \
       VendorIdent="QUANTUM" ProductIdent="SDLT600" \
       ProductRev="0001" SerialNumber="XYZZY_12"

tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=3 \
       VendorIdent="QUANTUM" ProductIdent="SDLT600" \
       ProductRev="0001" SerialNumber="XYZZY_13"

tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
       VendorIdent="STK" ProductIdent="L180" \
       ProductRev="0001" SerialNumber="XYZZY"

Allocate 1 picker at address 256...
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
       ElementType=1 StartAddress=256 Quanity=1 Sides=2

Allocate 800 slots starting at address 1024
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
       ElementType=2 StartAddress=1024 Quanity=800 Sides=2

Allocate 10 Import/Export slots starting at address 128
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
       ElementType=3 StartAddress=128 Quanity=10 Sides=2

Allocate room for 8 drives
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
       ElementType=4 StartAddress=1 Quanity=8 Sides=1

'Assign drive SerialNumber with slot'
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
       ElementType=4 Address=1 SerialNumber=XYZZY_10

tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
       ElementType=4 Address=2 SerialNumber=XYZZY_11

tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
       ElementType=4 Address=3 SerialNumber=XYZZY_12

tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
       ElementType=4 Address=4 SerialNumber=XYZZY_13


Add media to storage Element
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
       ElementType=2 Address=4 BarCode="ABC123L3"

Add media to import/export Element
tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
       ElementType=3 Address=1 BarCode="CLN001"


An example of a configured system.
tgtadm --lld iscsi --mode target --op show
Target 1: iqn.2007-03:marks-vtl_ssc:laptop
   System information:
       Type: tape
       Driver: iscsi
       Status: running
   I_T nexus information:
   LUN information:
       LUN: 0
           SCSI ID: deadbeaf2:0
           SCSI SN: beaf20
           VendorIdentification : QUANTUM
           ProductIdentification: SDLT600
           ProductRevision      : 0001
       LUN: 1
           SCSI ID: deadbeaf2:1
           SCSI SN: beaf21
           VendorIdentification : QUANTUM
           ProductIdentification: SDLT600
           ProductRevision      : 0001
       LUN: 2
           SCSI ID: deadbeaf2:2
           SCSI SN: beaf22
           VendorIdentification : QUANTUM
           ProductIdentification: SDLT600
           ProductRevision      : 0001
       LUN: 3
           SCSI ID: deadbeaf2:3
           SCSI SN: beaf23
           VendorIdentification : QUANTUM
           ProductIdentification: SDLT600
           ProductRevision      : 0001
   Account information:
   ACL information:
       ALL
Target 2: iqn.2007-03:marks-vtl_smc:laptop
   System information:
       Type: changer
       Driver: iscsi
       Status: running
   I_T nexus information:
   LUN information:
       LUN: 0
           SCSI ID: deadbeaf1:0
           SCSI SN: beaf10
           Size: 1K
           Backing store: /var/tmp/l1
           VendorIdentification : STK
           ProductIdentification: L700
           ProductRevision      : 0001
         Device Configuration:
           Medium Transport     : 1
           Storage Element      : 800
           Import/Export Element: 10
           Data Transport       : 8
   Account information:
   ACL information:
       ALL


From blackmagic02881 at gmail.com  Mon Mar 26 03:28:10 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Sun, 25 Mar 2007 21:28:10 -0400
Subject: [Stgt-devel] VTL - tgtadm syntax additions (Long)
In-Reply-To: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>
References: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>
Message-ID: <1174872490.3609.31.camel@localhost.localdomain>

On Mon, 2007-03-26 at 10:19 +1000, Mark Harvey wrote:
> As the idea of hijacking the 'backing file' for use as a configuration
> file has not received the most positive resonse, I have put together
> some ideas for adding to the syntax of tgtadm to allow the
> configuration and customization of SSC and SMC devices.

looks fine to me. then u also need command to load/eject virtual
cartridge? and each cartridge will need some parameters as well?



> 
> I have not attempted to implement any of the syntax, but am posting to
> the list for comments before putting any effort into coding.
> 
> Here goes....
> 
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
> --value=[value]
> 
> Where value is:
> 
> If device_type == 1 (SSC)
> 
>  VendorIdent="SONY"
>  ProductIdent="SDX-900V"
>  ProductRev="5401"
>  SerialNumber="XYZZY_10"
> 
> If device_type == 8 (SMC), in addition to SSC values...
>  VendorIdent="STK"
>  ProductIdent="L700"
>  ProductRev="5400"
>  SerialNumber="XYZZY"
> 
> To configure
>  (Reserve address space)
>  ElementType=[1|2|3] StartAddress=[number] Quanity=[number]
> Sides=[1|2] (Single/double sided)
> 
>  (To reserve address space for 'drives')
>  ElementType=4 StartAddress=[number] Quanity=[number] Type="ssc|smc|sbc"
> 
>  (To 'tie' a previously known SerialNumber to this Address..)
>  ElementType=4 Address=[Within Range from above] SerialNumber="xxxxx"
> 
> To 'populate' slots with 'media'
>  ElementType=[2|3] BarCode="string"
> 
> where   ElementType 1 == Medium Transport (picker arm)
>        ElementType 2 == Storage Element (Slots in robot)
>        ElementType 3 == Import/Export Element (mailslots/Cartridge Access Port)
>        ElementType 4 == Data Transport (SSC/SBC/MMC device - Tape,
> Optical, CD/DVD)
> 
> Limits:
> VendorIdent, ProductIdent, ProductRev & SerialNumber can all be on one line...
> 
> For Medium changers
>  - We first need to 'reserve' number of slots for each element type:
>  - Then Tie device S/No to a slot
>  - Next fill Storage Slots and Import/Export with 'media'
> 
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
> VendorIdent="QUANTUM"
> tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
> ProductIdent="SDLT600"
> tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
> ProductRev="0001"
> tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
> SerialNumber="XYZZY_10"
> 
> or
> tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 \
>        VendorIdent="QUANTUM" ProductIdent="SDLT600" \
>        ProductRev="0001" SerialNumber="XYZZY_10"
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=1 \
>        VendorIdent="QUANTUM" ProductIdent="SDLT600" \
>        ProductRev="0001" SerialNumber="XYZZY_11"
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=2 \
>        VendorIdent="QUANTUM" ProductIdent="SDLT600" \
>        ProductRev="0001" SerialNumber="XYZZY_12"
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=3 \
>        VendorIdent="QUANTUM" ProductIdent="SDLT600" \
>        ProductRev="0001" SerialNumber="XYZZY_13"
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>        VendorIdent="STK" ProductIdent="L180" \
>        ProductRev="0001" SerialNumber="XYZZY"
> 
> Allocate 1 picker at address 256...
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>        ElementType=1 StartAddress=256 Quanity=1 Sides=2
> 
> Allocate 800 slots starting at address 1024
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>        ElementType=2 StartAddress=1024 Quanity=800 Sides=2
> 
> Allocate 10 Import/Export slots starting at address 128
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>        ElementType=3 StartAddress=128 Quanity=10 Sides=2
> 
> Allocate room for 8 drives
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>        ElementType=4 StartAddress=1 Quanity=8 Sides=1
> 
> 'Assign drive SerialNumber with slot'
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>        ElementType=4 Address=1 SerialNumber=XYZZY_10
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>        ElementType=4 Address=2 SerialNumber=XYZZY_11
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>        ElementType=4 Address=3 SerialNumber=XYZZY_12
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>        ElementType=4 Address=4 SerialNumber=XYZZY_13
> 
> 
> Add media to storage Element
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>        ElementType=2 Address=4 BarCode="ABC123L3"
> 
> Add media to import/export Element
> tgtadm --lld iscsi --mode logicalunit --op update --tid=2 --lun=0 \
>        ElementType=3 Address=1 BarCode="CLN001"
> 
> 
> An example of a configured system.
> tgtadm --lld iscsi --mode target --op show
> Target 1: iqn.2007-03:marks-vtl_ssc:laptop
>    System information:
>        Type: tape
>        Driver: iscsi
>        Status: running
>    I_T nexus information:
>    LUN information:
>        LUN: 0
>            SCSI ID: deadbeaf2:0
>            SCSI SN: beaf20
>            VendorIdentification : QUANTUM
>            ProductIdentification: SDLT600
>            ProductRevision      : 0001
>        LUN: 1
>            SCSI ID: deadbeaf2:1
>            SCSI SN: beaf21
>            VendorIdentification : QUANTUM
>            ProductIdentification: SDLT600
>            ProductRevision      : 0001
>        LUN: 2
>            SCSI ID: deadbeaf2:2
>            SCSI SN: beaf22
>            VendorIdentification : QUANTUM
>            ProductIdentification: SDLT600
>            ProductRevision      : 0001
>        LUN: 3
>            SCSI ID: deadbeaf2:3
>            SCSI SN: beaf23
>            VendorIdentification : QUANTUM
>            ProductIdentification: SDLT600
>            ProductRevision      : 0001
>    Account information:
>    ACL information:
>        ALL
> Target 2: iqn.2007-03:marks-vtl_smc:laptop
>    System information:
>        Type: changer
>        Driver: iscsi
>        Status: running
>    I_T nexus information:
>    LUN information:
>        LUN: 0
>            SCSI ID: deadbeaf1:0
>            SCSI SN: beaf10
>            Size: 1K
>            Backing store: /var/tmp/l1
>            VendorIdentification : STK
>            ProductIdentification: L700
>            ProductRevision      : 0001
>          Device Configuration:
>            Medium Transport     : 1
>            Storage Element      : 800
>            Import/Export Element: 10
>            Data Transport       : 8
>    Account information:
>    ACL information:
>        ALL
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From dougg at torque.net  Mon Mar 26 05:19:01 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Sun, 25 Mar 2007 23:19:01 -0400
Subject: [Stgt-devel] VTL - tgtadm syntax additions (Long)
In-Reply-To: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>
References: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>
Message-ID: <46073BA5.60600@torque.net>

Mark Harvey wrote:
> As the idea of hijacking the 'backing file' for use as a configuration
> file has not received the most positive resonse, I have put together
> some ideas for adding to the syntax of tgtadm to allow the
> configuration and customization of SSC and SMC devices.
> 
> I have not attempted to implement any of the syntax, but am posting to
> the list for comments before putting any effort into coding.
> 
> Here goes....
> 
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
> --value=[value]
> 
> Where value is:
> 
> If device_type == 1 (SSC)
> 
>  VendorIdent="SONY"
>  ProductIdent="SDX-900V"
>  ProductRev="5401"
>  SerialNumber="XYZZY_10"

Mark,
How about adding some place holders for logical unit
world wide names? For example:
  eui64="..."
  naa2="...."
  naa5="5000334441112720"
  naa6="..."
  scsi_name="..."

Building a comprehensive device identification VPD page
(0x83) should be an interesting challenge as it is made
up of 3 parts:
  a) logical unit identification (derived from my suggestion
     in the previous paragraph perhaps)
  b) target device identification (target HBA related or
     constructed)
  c) target port identification (target HBA related)


Note that if the stgt infrastructure was being used to
bridge between two SCSI transports (say iSCSI and SAS)
then parts b) and c) need to be reconstructed.

Doug Gilbert


From fujita.tomonori at lab.ntt.co.jp  Mon Mar 26 06:05:38 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 26 Mar 2007 13:05:38 +0900 (JST)
Subject: [Stgt-devel] [PATCH] free leaked target name
In-Reply-To: <20070325152141.GA26830@osc.edu>
References: <20070325152141.GA26830@osc.edu>
Message-ID: <20070324091442V.fujita.tomonori@lab.ntt.co.jp>

From: Pete Wyckoff <pw at osc.edu>
Subject: [Stgt-devel] [PATCH] free leaked target name
Date: Sun, 25 Mar 2007 11:21:41 -0400

> Target destroy leaked name.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>

Applied, thanks.


From fujita.tomonori at lab.ntt.co.jp  Mon Mar 26 06:05:38 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 26 Mar 2007 13:05:38 +0900 (JST)
Subject: [Stgt-devel] VTL - tgtadm syntax additions (Long)
In-Reply-To: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>
References: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>
Message-ID: <20070324091155O.fujita.tomonori@lab.ntt.co.jp>

From: "Mark Harvey" <markh794 at gmail.com>
Subject: [Stgt-devel] VTL - tgtadm syntax additions (Long)
Date: Mon, 26 Mar 2007 10:19:21 +1000

> As the idea of hijacking the 'backing file' for use as a configuration
> file has not received the most positive resonse, I have put together
> some ideas for adding to the syntax of tgtadm to allow the
> configuration and customization of SSC and SMC devices.
> 
> I have not attempted to implement any of the syntax, but am posting to
> the list for comments before putting any effort into coding.
> 
> Here goes....
> 
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
> --value=[value]
> 
> Where value is:
> 
> If device_type == 1 (SSC)
> 
>  VendorIdent="SONY"
>  ProductIdent="SDX-900V"
>  ProductRev="5401"
>  SerialNumber="XYZZY_10"
> 
> If device_type == 8 (SMC), in addition to SSC values...
>  VendorIdent="STK"
>  ProductIdent="L700"
>  ProductRev="5400"
>  SerialNumber="XYZZY"
> 
> To configure
>  (Reserve address space)
>  ElementType=[1|2|3] StartAddress=[number] Quanity=[number]
> Sides=[1|2] (Single/double sided)
> 
>  (To reserve address space for 'drives')
>  ElementType=4 StartAddress=[number] Quanity=[number] Type="ssc|smc|sbc"
> 
>  (To 'tie' a previously known SerialNumber to this Address..)
>  ElementType=4 Address=[Within Range from above] SerialNumber="xxxxx"
> 
> To 'populate' slots with 'media'
>  ElementType=[2|3] BarCode="string"
> 
> where   ElementType 1 == Medium Transport (picker arm)
>        ElementType 2 == Storage Element (Slots in robot)
>        ElementType 3 == Import/Export Element (mailslots/Cartridge Access Port)
>        ElementType 4 == Data Transport (SSC/SBC/MMC device - Tape,
> Optical, CD/DVD)
> 
> Limits:
> VendorIdent, ProductIdent, ProductRev & SerialNumber can all be on one line...
> 
> For Medium changers
>  - We first need to 'reserve' number of slots for each element type:
>  - Then Tie device S/No to a slot
>  - Next fill Storage Slots and Import/Export with 'media'
> 
> 
> tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
> VendorIdent="QUANTUM"
> tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
> ProductIdent="SDLT600"
> tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
> ProductRev="0001"
> tgtadm --lld iscsi --mode logicalunit --op update --tid=[] --lun=[]
> SerialNumber="XYZZY_10"

tgtadm adopts a syntax similar to open-iscsi. That is, it can do
something like:

tgtadm --lld iscsi --mode target --op update --tid 1 --name MaxRecvDataSegmentLength --value 16384

So why can't we do:

tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 --name VendorIdent --value QUANTUM



From markh794 at gmail.com  Mon Mar 26 08:37:22 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Mon, 26 Mar 2007 16:37:22 +1000
Subject: [Stgt-devel] VTL - tgtadm syntax additions (Long)
In-Reply-To: <1174872490.3609.31.camel@localhost.localdomain>
References: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>
	<1174872490.3609.31.camel@localhost.localdomain>
Message-ID: <f29db9a80703252337ob45ee7cq8dc46858d1bbf70d@mail.gmail.com>

On 3/26/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> On Mon, 2007-03-26 at 10:19 +1000, Mark Harvey wrote:
> > As the idea of hijacking the 'backing file' for use as a configuration
> > file has not received the most positive resonse, I have put together
> > some ideas for adding to the syntax of tgtadm to allow the
> > configuration and customization of SSC and SMC devices.
>
> looks fine to me. then u also need command to load/eject virtual
> cartridge? and each cartridge will need some parameters as well?

Good point. To load virtual media into a single SSC device, some way
of a user being able to identify the virtual media name will be
required (from a command line).

The 'load' and unload / eject commands are sent to the tape drive
itself. Its more a matter of being able to specify the media ID /
barcode. The Load command is an 'open()', while a eject is a 'close()'

There will be some sort of internal interface between the SMC and SSC
so a 'path name' to the virtual media can be passed. e.g. A MOVE
MEDIUM command will basically pass the virtual media name (filename)
to the SSC Logical unit.

My current implementation (non-iSCSI) uses a messageQ. I'll most
likely use what every the tgtadm/tgtd uses. Currently I pass "load
barcode" to load "stand-alone" media and the SMC device sends a 'lload
barcode' command via the messageQ.

Regards
Mark

>
> >
> > I have not attempted to implement any of the syntax, but am posting to
> > the list for comments before putting any effort into coding.
[snip]


From markh794 at gmail.com  Mon Mar 26 08:41:58 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Mon, 26 Mar 2007 16:41:58 +1000
Subject: [Stgt-devel] VTL - tgtadm syntax additions (Long)
In-Reply-To: <20070324091155O.fujita.tomonori@lab.ntt.co.jp>
References: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>
	<20070324091155O.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <f29db9a80703252341v15aa6591ye13676282f370aac@mail.gmail.com>

[snip]
>
> tgtadm --lld iscsi --mode target --op update --tid 1 --name MaxRecvDataSegmentLength --value 16384
>
> So why can't we do:
>
> tgtadm --lld iscsi --mode logicalunit --op update --tid=1 --lun=0 --name VendorIdent --value QUANTUM
>
>

I'm more worried about the maximum length of a string I can pass at
the command line. For some reason I have 1024 chars in the back of my
mind.

Again, I have not looked at the tgtadm code, so I'll follow the syntax
used by tgtadm.

Cheers for the feedback.
Mark


From blackmagic02881 at gmail.com  Mon Mar 26 15:39:12 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Mon, 26 Mar 2007 09:39:12 -0400
Subject: [Stgt-devel] VTL - tgtadm syntax additions (Long)
In-Reply-To: <f29db9a80703252337ob45ee7cq8dc46858d1bbf70d@mail.gmail.com>
References: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>
	<1174872490.3609.31.camel@localhost.localdomain>
	<f29db9a80703252337ob45ee7cq8dc46858d1bbf70d@mail.gmail.com>
Message-ID: <1174916352.3667.12.camel@dhcp-119.ibrix.com>

On Mon, 2007-03-26 at 16:37 +1000, Mark Harvey wrote:
> On 3/26/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > On Mon, 2007-03-26 at 10:19 +1000, Mark Harvey wrote:
> > > As the idea of hijacking the 'backing file' for use as a configuration
> > > file has not received the most positive resonse, I have put together
> > > some ideas for adding to the syntax of tgtadm to allow the
> > > configuration and customization of SSC and SMC devices.
> >
> > looks fine to me. then u also need command to load/eject virtual
> > cartridge? and each cartridge will need some parameters as well?
> 
> Good point. To load virtual media into a single SSC device, some way
> of a user being able to identify the virtual media name will be
> required (from a command line).

yes, need a barcode, and maybe a WORM media or not, and blah blah u can
think of. :P

> 
> The 'load' and unload / eject commands are sent to the tape drive
> itself. Its more a matter of being able to specify the media ID /
> barcode. The Load command is an 'open()', while a eject is a 'close()'

yes. we have 2 set, one set from backup app and another from emulation
the user actions on physical drives.

> 
> There will be some sort of internal interface between the SMC and SSC
> so a 'path name' to the virtual media can be passed. e.g. A MOVE
> MEDIUM command will basically pass the virtual media name (filename)
> to the SSC Logical unit.

yes, will you emulate ADI as well?

> 
> My current implementation (non-iSCSI) uses a messageQ. I'll most
> likely use what every the tgtadm/tgtd uses. Currently I pass "load
> barcode" to load "stand-alone" media and the SMC device sends a 'lload
> barcode' command via the messageQ.

sounds ok to me. as long as these commands are defined in a command
table and documented!


> 
> Regards
> Mark
> 
> >
> > >
> > > I have not attempted to implement any of the syntax, but am posting to
> > > the list for comments before putting any effort into coding.
> [snip]
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel



From dougg at torque.net  Mon Mar 26 21:31:13 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Mon, 26 Mar 2007 15:31:13 -0400
Subject: [Stgt-devel] libaio + libaio-devel dependency, not in FC6
Message-ID: <46081F81.6020804@torque.net>

Building stgt fails on FC6 due to the dependency on
libaio and libaio-devel. That can be fixed with:
# yum install libaio libaio-devel

Perhaps there should be a note in the README.

Doug Gilbert


From dougg at torque.net  Tue Mar 27 00:37:19 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Mon, 26 Mar 2007 18:37:19 -0400
Subject: [Stgt-devel] [PATCH] invalid command operation code (0x20,0)
Message-ID: <46084B1F.70708@torque.net>

SPC-4 (rev 9) section 4.3.1 all the way back to SCSI-2
defines what to do when the first byte (i.e. the operation
code) is not supported. It is treated differently from
the "invalid field in cdb" case.

Doug Gilbert


-------------- next part --------------
A non-text attachment was scrubbed...
Name: spc_ill_op.diff
Type: text/x-patch
Size: 339 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20070326/93299a87/attachment.bin>

From fujita.tomonori at lab.ntt.co.jp  Tue Mar 27 03:23:47 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Tue, 27 Mar 2007 10:23:47 +0900
Subject: [Stgt-devel] [PATCH] invalid command operation code (0x20,0)
In-Reply-To: <46084B1F.70708@torque.net>
References: <46084B1F.70708@torque.net>
Message-ID: <20070327102347E.fujita.tomonori@lab.ntt.co.jp>

From: Douglas Gilbert <dougg at torque.net>
Subject: [Stgt-devel] [PATCH] invalid command operation code (0x20,0)
Date: Mon, 26 Mar 2007 18:37:19 -0400

> SPC-4 (rev 9) section 4.3.1 all the way back to SCSI-2
> defines what to do when the first byte (i.e. the operation
> code) is not supported. It is treated differently from
> the "invalid field in cdb" case.

Merged, thanks.

I would greatly apprecate if you could send a patch in the Linux
kernel way (no attachment and with your Singed-off-by) next time.


From markh794 at gmail.com  Tue Mar 27 03:30:22 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Tue, 27 Mar 2007 11:30:22 +1000
Subject: [Stgt-devel] VTL - tgtadm syntax additions (Long)
In-Reply-To: <1174916352.3667.12.camel@dhcp-119.ibrix.com>
References: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>
	<1174872490.3609.31.camel@localhost.localdomain>
	<f29db9a80703252337ob45ee7cq8dc46858d1bbf70d@mail.gmail.com>
	<1174916352.3667.12.camel@dhcp-119.ibrix.com>
Message-ID: <f29db9a80703261830r419c9c5fy5547c4b9922c581c@mail.gmail.com>

On 3/26/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> On Mon, 2007-03-26 at 16:37 +1000, Mark Harvey wrote:
> > On 3/26/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > On Mon, 2007-03-26 at 10:19 +1000, Mark Harvey wrote:
> > > > As the idea of hijacking the 'backing file' for use as a configuration
> > > > file has not received the most positive resonse, I have put together
> > > > some ideas for adding to the syntax of tgtadm to allow the
> > > > configuration and customization of SSC and SMC devices.
> > >
> > > looks fine to me. then u also need command to load/eject virtual
> > > cartridge? and each cartridge will need some parameters as well?
> >
> > Good point. To load virtual media into a single SSC device, some way
> > of a user being able to identify the virtual media name will be
> > required (from a command line).
>
> yes, need a barcode, and maybe a WORM media or not, and blah blah u can
> think of. :P
The 'media type' is set in the virtual media 'header'. I reserve the
first xxx bytes of the file for MAM, where the media type is defined.
e.g. WORM, Cleaning, Data etc.

I have another utility to make the virtual media. i.e. Create a file
and create a default MAM record.

>
> >
> > The 'load' and unload / eject commands are sent to the tape drive
> > itself. Its more a matter of being able to specify the media ID /
> > barcode. The Load command is an 'open()', while a eject is a 'close()'
>
> yes. we have 2 set, one set from backup app and another from emulation
> the user actions on physical drives.
>
> >
> > There will be some sort of internal interface between the SMC and SSC
> > so a 'path name' to the virtual media can be passed. e.g. A MOVE
> > MEDIUM command will basically pass the virtual media name (filename)
> > to the SSC Logical unit.
>
> yes, will you emulate ADI as well?
ADI ??

> > My current implementation (non-iSCSI) uses a messageQ. I'll most
> > likely use what every the tgtadm/tgtd uses. Currently I pass "load
> > barcode" to load "stand-alone" media and the SMC device sends a 'lload
> > barcode' command via the messageQ.
>
> sounds ok to me. as long as these commands are defined in a command
> table and documented!
> >
> > Regards
> > Mark
> >
> > >
> > > >
> > > > I have not attempted to implement any of the syntax, but am posting to
> > > > the list for comments before putting any effort into coding.
> > [snip]
> > _______________________________________________
> > Stgt-devel mailing list
> > Stgt-devel at lists.berlios.de
> > https://lists.berlios.de/mailman/listinfo/stgt-devel
>
>


From dougg at torque.net  Tue Mar 27 04:40:25 2007
From: dougg at torque.net (Douglas Gilbert)
Date: Mon, 26 Mar 2007 22:40:25 -0400
Subject: [Stgt-devel] VTL - tgtadm syntax additions (Long)
In-Reply-To: <f29db9a80703261830r419c9c5fy5547c4b9922c581c@mail.gmail.com>
References: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>	<1174872490.3609.31.camel@localhost.localdomain>	<f29db9a80703252337ob45ee7cq8dc46858d1bbf70d@mail.gmail.com>	<1174916352.3667.12.camel@dhcp-119.ibrix.com>
	<f29db9a80703261830r419c9c5fy5547c4b9922c581c@mail.gmail.com>
Message-ID: <46088419.7040502@torque.net>

Mark Harvey wrote:
> On 3/26/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
>> On Mon, 2007-03-26 at 16:37 +1000, Mark Harvey wrote:
>>> On 3/26/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
>>>> On Mon, 2007-03-26 at 10:19 +1000, Mark Harvey wrote:
>>>>> As the idea of hijacking the 'backing file' for use as a configuration
>>>>> file has not received the most positive resonse, I have put together
>>>>> some ideas for adding to the syntax of tgtadm to allow the
>>>>> configuration and customization of SSC and SMC devices.
>>>> looks fine to me. then u also need command to load/eject virtual
>>>> cartridge? and each cartridge will need some parameters as well?
>>> Good point. To load virtual media into a single SSC device, some way
>>> of a user being able to identify the virtual media name will be
>>> required (from a command line).
>> yes, need a barcode, and maybe a WORM media or not, and blah blah u can
>> think of. :P
> The 'media type' is set in the virtual media 'header'. I reserve the
> first xxx bytes of the file for MAM, where the media type is defined.
> e.g. WORM, Cleaning, Data etc.
> 
> I have another utility to make the virtual media. i.e. Create a file
> and create a default MAM record.
> 
>>> The 'load' and unload / eject commands are sent to the tape drive
>>> itself. Its more a matter of being able to specify the media ID /
>>> barcode. The Load command is an 'open()', while a eject is a 'close()'
>> yes. we have 2 set, one set from backup app and another from emulation
>> the user actions on physical drives.
>>
>>> There will be some sort of internal interface between the SMC and SSC
>>> so a 'path name' to the virtual media can be passed. e.g. A MOVE
>>> MEDIUM command will basically pass the virtual media name (filename)
>>> to the SSC Logical unit.
>> yes, will you emulate ADI as well?
> ADI ??

Perhaps the "Automation/Driver Interface" which has
a command set known as ADC and a transport layer
known as ADT.
Here is an abstract for ADC:
"Media changer (automation) devices use a private
communication link for monitoring and controlling
the removable medium devices (drives) installed
in them. The proposed Automation/Drive Interface -
Commands - 2 (ADC-2) standard specifies commands
issued by automation devices to the drives."

http://www.t10.org/ftp/t10/drafts/adc/adc-r07.pdf
http://www.t10.org/ftp/t10/drafts/adt/adt-r14.pdf

Doug Gilbert


From blackmagic02881 at gmail.com  Tue Mar 27 04:54:34 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Mon, 26 Mar 2007 22:54:34 -0400
Subject: [Stgt-devel] VTL - tgtadm syntax additions (Long)
In-Reply-To: <f29db9a80703261830r419c9c5fy5547c4b9922c581c@mail.gmail.com>
References: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>
	<1174872490.3609.31.camel@localhost.localdomain>
	<f29db9a80703252337ob45ee7cq8dc46858d1bbf70d@mail.gmail.com>
	<1174916352.3667.12.camel@dhcp-119.ibrix.com>
	<f29db9a80703261830r419c9c5fy5547c4b9922c581c@mail.gmail.com>
Message-ID: <1174964074.5930.39.camel@localhost.localdomain>

On Tue, 2007-03-27 at 11:30 +1000, Mark Harvey wrote:
> On 3/26/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > On Mon, 2007-03-26 at 16:37 +1000, Mark Harvey wrote:
> > > On 3/26/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> > > > On Mon, 2007-03-26 at 10:19 +1000, Mark Harvey wrote:
> > > > > As the idea of hijacking the 'backing file' for use as a configuration
> > > > > file has not received the most positive resonse, I have put together
> > > > > some ideas for adding to the syntax of tgtadm to allow the
> > > > > configuration and customization of SSC and SMC devices.
> > > >
> > > > looks fine to me. then u also need command to load/eject virtual
> > > > cartridge? and each cartridge will need some parameters as well?
> > >
> > > Good point. To load virtual media into a single SSC device, some way
> > > of a user being able to identify the virtual media name will be
> > > required (from a command line).
> >
> > yes, need a barcode, and maybe a WORM media or not, and blah blah u can
> > think of. :P
> The 'media type' is set in the virtual media 'header'. I reserve the
> first xxx bytes of the file for MAM, where the media type is defined.
> e.g. WORM, Cleaning, Data etc.
> 
> I have another utility to make the virtual media. i.e. Create a file
> and create a default MAM record.

ok. so tgtadm only need to load and unload it.

> 
> >
> > >
> > > The 'load' and unload / eject commands are sent to the tape drive
> > > itself. Its more a matter of being able to specify the media ID /
> > > barcode. The Load command is an 'open()', while a eject is a 'close()'
> >
> > yes. we have 2 set, one set from backup app and another from emulation
> > the user actions on physical drives.
> >
> > >
> > > There will be some sort of internal interface between the SMC and SSC
> > > so a 'path name' to the virtual media can be passed. e.g. A MOVE
> > > MEDIUM command will basically pass the virtual media name (filename)
> > > to the SSC Logical unit.
> >
> > yes, will you emulate ADI as well?
> ADI ??

as Doug pointed out, ADC and ADI. sorry for confusion.


> 
> > > My current implementation (non-iSCSI) uses a messageQ. I'll most
> > > likely use what every the tgtadm/tgtd uses. Currently I pass "load
> > > barcode" to load "stand-alone" media and the SMC device sends a 'lload
> > > barcode' command via the messageQ.
> >
> > sounds ok to me. as long as these commands are defined in a command
> > table and documented!
> > >
> > > Regards
> > > Mark
> > >
> > > >
> > > > >
> > > > > I have not attempted to implement any of the syntax, but am posting to
> > > > > the list for comments before putting any effort into coding.
> > > [snip]
> > > _______________________________________________
> > > Stgt-devel mailing list
> > > Stgt-devel at lists.berlios.de
> > > https://lists.berlios.de/mailman/listinfo/stgt-devel
> >
> >



From markh794 at gmail.com  Tue Mar 27 05:08:30 2007
From: markh794 at gmail.com (Mark Harvey)
Date: Tue, 27 Mar 2007 13:08:30 +1000
Subject: [Stgt-devel] VTL - tgtadm syntax additions (Long)
In-Reply-To: <46088419.7040502@torque.net>
References: <f29db9a80703251719m6b8894b8h5e769aa6a7fbeafc@mail.gmail.com>
	<1174872490.3609.31.camel@localhost.localdomain>
	<f29db9a80703252337ob45ee7cq8dc46858d1bbf70d@mail.gmail.com>
	<1174916352.3667.12.camel@dhcp-119.ibrix.com>
	<f29db9a80703261830r419c9c5fy5547c4b9922c581c@mail.gmail.com>
	<46088419.7040502@torque.net>
Message-ID: <f29db9a80703262008p79ce86acj81bd368122a468c5@mail.gmail.com>

On 3/27/07, Douglas Gilbert <dougg at torque.net> wrote:
> Mark Harvey wrote:
> > On 3/26/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> >> On Mon, 2007-03-26 at 16:37 +1000, Mark Harvey wrote:
> >>> On 3/26/07, Ming Zhang <blackmagic02881 at gmail.com> wrote:
> >>>> On Mon, 2007-03-26 at 10:19 +1000, Mark Harvey wrote:
> >>>>> As the idea of hijacking the 'backing file' for use as a configuration
> >>>>> file has not received the most positive resonse, I have put together
> >>>>> some ideas for adding to the syntax of tgtadm to allow the
> >>>>> configuration and customization of SSC and SMC devices.
> >>>> looks fine to me. then u also need command to load/eject virtual
> >>>> cartridge? and each cartridge will need some parameters as well?
> >>> Good point. To load virtual media into a single SSC device, some way
> >>> of a user being able to identify the virtual media name will be
> >>> required (from a command line).
> >> yes, need a barcode, and maybe a WORM media or not, and blah blah u can
> >> think of. :P
> > The 'media type' is set in the virtual media 'header'. I reserve the
> > first xxx bytes of the file for MAM, where the media type is defined.
> > e.g. WORM, Cleaning, Data etc.
> >
> > I have another utility to make the virtual media. i.e. Create a file
> > and create a default MAM record.
> >
> >>> The 'load' and unload / eject commands are sent to the tape drive
> >>> itself. Its more a matter of being able to specify the media ID /
> >>> barcode. The Load command is an 'open()', while a eject is a 'close()'
> >> yes. we have 2 set, one set from backup app and another from emulation
> >> the user actions on physical drives.
> >>
> >>> There will be some sort of internal interface between the SMC and SSC
> >>> so a 'path name' to the virtual media can be passed. e.g. A MOVE
> >>> MEDIUM command will basically pass the virtual media name (filename)
> >>> to the SSC Logical unit.
> >> yes, will you emulate ADI as well?
> > ADI ??
>
> Perhaps the "Automation/Driver Interface" which has
> a command set known as ADC and a transport layer
> known as ADT.
> Here is an abstract for ADC:
> "Media changer (automation) devices use a private
> communication link for monitoring and controlling
> the removable medium devices (drives) installed
> in them. The proposed Automation/Drive Interface -
> Commands - 2 (ADC-2) standard specifies commands
> issued by automation devices to the drives."
>
> http://www.t10.org/ftp/t10/drafts/adc/adc-r07.pdf
> http://www.t10.org/ftp/t10/drafts/adt/adt-r14.pdf
>
> Doug Gilbert
>
Many thanks for the pointer..

So much to learn, so little time. :)

I'm downloading them now.

Mark


From pauw at o2.ie  Wed Mar 28 15:22:03 2007
From: pauw at o2.ie (Albert Pauw)
Date: Wed, 28 Mar 2007 15:22:03 +0200
Subject: [Stgt-devel] CRC32C not working
Message-ID: <129d1ff129d589.129d589129d1ff@o2.ie>

I am new to stgt and am just starting playing with it since a few days.

I am using stgt.r849 en open-iscsi.r779

Here are my findings using HeaderDigest CRC32C:

- Trying to set HeaderDigest in stgt to None,CRC32C it only stores CRC32C when I check it back

- I am able to login with open-iscsi, stgt responds with a HeaderDigest CRC32C and the login continues to the next phase

- From now on I see messages like:
iscsi_tcp: hdrdgst error recv 0x42040000 calc 0x4d2da980
 connection1:0: iscsi: detected conn error (1014)
iscsi_tcp: hdrdgst error recv 0x42040000 calc 0x8a8a100a
 connection1:0: iscsi: detected conn error (1014)
iscsi_tcp: hdrdgst error recv 0x42040000 calc 0x7eb94a7c
 connection1:0: iscsi: detected conn error (1014)
iscsi_tcp: hdrdgst error recv 0x42040000 calc 0x2915ef
 connection1:0: iscsi: detected conn error (1014)
 connection1:0: iscsi: detected conn error (1011)
 connection1:0: iscsi: detected conn error (1011)
 connection1:0: iscsi: detected conn error (1011)
 connection1:0: iscsi: detected conn error (1011)
 connection1:0: iscsi: detected conn error (1011)
 connection1:0: iscsi: detected conn error (1011)
 connection1:0: iscsi: detected conn error (1011)

So it seems that CRC32C for HeaderDigest is not working.

For DataDigest more or less the same holds, except that I get the scsi disk info correct, here's the log of that:

scsi 3:0:0:0: Direct-Access     IET      VIRTUAL-DISK     0    PQ: 0 ANSI: 4
 connection2:0: iscsi: detected conn error (1015)
SCSI device sdb: 2048000 512-byte hdwr sectors (1049 MB)
 connection2:0: iscsi: detected conn error (1015)
sdb: Write Protect is off
sdb: Mode Sense: 77 00 00 08
 connection2:0: iscsi: detected conn error (1015)
 connection2:0: iscsi: detected conn error (1015)


Albert




From fujita.tomonori at lab.ntt.co.jp  Wed Mar 28 16:25:24 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Wed, 28 Mar 2007 23:25:24 +0900
Subject: [Stgt-devel] CRC32C not working
In-Reply-To: <129d1ff129d589.129d589129d1ff@o2.ie>
References: <129d1ff129d589.129d589129d1ff@o2.ie>
Message-ID: <20070328232524D.fujita.tomonori@lab.ntt.co.jp>

From: Albert Pauw <pauw at o2.ie>
Subject: [Stgt-devel] CRC32C not working
Date: Wed, 28 Mar 2007 15:22:03 +0200

> I am new to stgt and am just starting playing with it since a few days.
> 
> I am using stgt.r849 en open-iscsi.r779
> 
> Here are my findings using HeaderDigest CRC32C:

Sorry, HeaderDigest and DataDigest are not implemented yet.


From hugang at soulinfo.com  Thu Mar 29 07:35:48 2007
From: hugang at soulinfo.com (Hu Gang)
Date: Thu, 29 Mar 2007 13:35:48 +0800
Subject: [Stgt-devel] [patch] support different type in one target.
Message-ID: <20070329133548.74c19163@hugang-laptop>

support different type in one target.

all of the logical units at same target must same type. this patch extend current tgt to support different type in one target.
 
./tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2001-04.com.example:storage.disk2.amiens.sys1.xyz
./tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 0 -b /p/ref/ubuntu-7.04-beta-alternate-i386.iso --target-type cd
./tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 -b /tmp/100M --target-type disk
./tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL
./tgtadm --lld iscsi --op show --mode target

Signed-off-by: hu gang <hugang at soulinfo.com>
---

 usr/bs_aio.c |    2 +-
 usr/mgmt.c   |    5 ++--
 usr/mmc.c    |    2 +-
 usr/osd.c    |    2 +-
 usr/sbc.c    |    2 +-
 usr/scsi.c   |    2 +-
 usr/spc.c    |    4 ++-
 usr/spt.c    |    2 +-
 usr/target.c |   68 ++++++++++++++++++++++++++++++----------------------------
 usr/target.h |    5 ----
 usr/tgtd.h   |   38 ++++++++++++++++++++------------
 11 files changed, 68 insertions(+), 64 deletions(-)

diff --git a/usr/bs_aio.c b/usr/bs_aio.c
index c10be4b..733265f 100644
--- a/usr/bs_aio.c
+++ b/usr/bs_aio.c
@@ -77,7 +77,7 @@ retry:
 
 	ret = io_getevents(info->ctx, 1, MAX_AIO_REQS, info->events, NULL);
 	nr = ret;
-	dprintf("%d", ret);
+	dprintf("%d,%d\n", ret, errno);
 	if (nr > 0) {
 	rewrite:
 		ret = write(info->done_fd[1], &nr, sizeof(nr));
diff --git a/usr/mgmt.c b/usr/mgmt.c
index ce73425..aa135ee 100644
--- a/usr/mgmt.c
+++ b/usr/mgmt.c
@@ -77,8 +77,7 @@ static int target_mgmt(int lld_no, struc
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_target_create(lld_no, req->tid, mtask->buf,
-					req->target_type);
+		err = tgt_target_create(lld_no, req->tid, mtask->buf);
 		break;
 	case OP_DELETE:
 		err = tgt_target_destroy(req->tid);
@@ -169,7 +168,7 @@ static int device_mgmt(int lld_no, struc
 
 	switch (req->op) {
 	case OP_NEW:
-		err = tgt_device_create(req->tid, req->lun, params);
+		err = tgt_device_create(req->tid, req->lun, req->target_type, params);
 		break;
 	case OP_DELETE:
 		err = tgt_device_destroy(req->tid, req->lun);
diff --git a/usr/mmc.c b/usr/mmc.c
index 6c6acfb..4eab50b 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -35,7 +35,7 @@ static int mmc_rw(int host_no, struct sc
 	int ret;
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << MMC_BLK_SHIFT);
-	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
+	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		cmd->offset = 0;
 		cmd->len = 0;
diff --git a/usr/osd.c b/usr/osd.c
index 26cc511..da3853b 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -130,7 +130,7 @@ static int osd_varlen_cdb(int host_no, s
 	}
 
 /* 	return SAM_STAT_GOOD; */
-	return cmd->c_target->bst->bs_cmd_submit(cmd);
+	return cmd->dev->bst->bs_cmd_submit(cmd);
 }
 
 static void device_osd_init(struct scsi_lu *lu)
diff --git a/usr/sbc.c b/usr/sbc.c
index f4f625f..edcd6e8 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -53,7 +53,7 @@ static int sbc_rw(int host_no, struct sc
 	}
 
 	cmd->offset = (scsi_rw_offset(cmd->scb) << BLK_SHIFT);
-	ret = cmd->c_target->bst->bs_cmd_submit(cmd);
+	ret = cmd->dev->bst->bs_cmd_submit(cmd);
 	if (ret) {
 		key = HARDWARE_ERROR;
 		asc = 0;
diff --git a/usr/scsi.c b/usr/scsi.c
index dbc1474..d616cf4 100644
--- a/usr/scsi.c
+++ b/usr/scsi.c
@@ -119,5 +119,5 @@ uint64_t scsi_rw_offset(uint8_t *scb)
 int scsi_cmd_perform(int host_no, struct scsi_cmd *cmd)
 {
 	unsigned char op = cmd->scb[0];
-	return cmd->c_target->dev_type_template.ops[op].cmd_perform(host_no, cmd);
+	return cmd->dev->dev_type_template.ops[op].cmd_perform(host_no, cmd);
 }
diff --git a/usr/spc.c b/usr/spc.c
index ef8b62d..f5c7c86 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -39,8 +39,8 @@ int spc_inquiry(int host_no, struct scsi
 	int len, ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data;
 	uint8_t *scb = cmd->scb;
-	unsigned char device_type = cmd->c_target->dev_type_template.type;
-	char *product_id = cmd->c_target->dev_type_template.pid;
+	unsigned char device_type = cmd->dev->dev_type_template.type;
+	char *product_id = cmd->dev->dev_type_template.pid;
 	unsigned char key = ILLEGAL_REQUEST, asc = 0x24;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
diff --git a/usr/spt.c b/usr/spt.c
index ffcda5e..3d6b97d 100644
--- a/usr/spt.c
+++ b/usr/spt.c
@@ -67,7 +67,7 @@ static int spt_cmd_perform(int host_no, 
 	struct device_type_operations *ops;
 
 	if (!cmd->dev) {
-		ops = cmd->c_target->dev_type_template.ops;
+		ops = cmd->dev->dev_type_template.ops;
 		return ops[cmd->scb[0]].cmd_perform(host_no, cmd);
 	}
 
diff --git a/usr/target.c b/usr/target.c
index f48839e..b49b143 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -166,7 +166,7 @@ static int tgt_device_path_update(struct
 	if (!path)
 		return TGTADM_NOMEM;
 
-	err = target->bst->bs_open(lu, path, &dev_fd, &size);
+	err = lu->bst->bs_open(lu, path, &dev_fd, &size);
 	if (err) {
 		free(path);
 		return TGTADM_INVALID_REQUEST;
@@ -198,12 +198,13 @@ __device_lookup(int tid, uint64_t lun, s
 	return lu;
 }
 
-int tgt_device_create(int tid, uint64_t lun, char *args)
+int tgt_device_create(int tid, uint64_t lun, uint32_t t_type, char *args)
 {
 	char *p;
 	int err;
 	struct target *target;
 	struct scsi_lu *lu, *pos;
+    struct backingstore_template *bst;
 
 	dprintf("%d %" PRIu64 "\n", tid, lun);
 
@@ -225,9 +226,34 @@ int tgt_device_create(int tid, uint64_t 
 		return TGTADM_INVALID_REQUEST;
 	p++;
 
-	lu = zalloc(sizeof(*lu) + target->bst->bs_datasize);
+    /* FIXME */
+	if (t_type == TYPE_SPT)
+		bst = &sg_bst;
+	else
+		bst = tgt_drivers[target->lid]->default_bst;
+
+	lu = zalloc(sizeof(*lu) + bst->bs_datasize);
 	if (!lu)
 		return TGTADM_NOMEM;
+    lu->bst = bst;
+
+	switch (t_type) {
+	case TYPE_DISK:
+		lu->dev_type_template = sbc_template;
+		break;
+	case TYPE_ROM:
+		lu->dev_type_template = mmc_template;
+		break;
+	case TYPE_OSD:
+		lu->dev_type_template = osd_template;
+		break;
+	case TYPE_SPT:
+		lu->dev_type_template = spt_template;
+		break;
+	default:
+		free(lu);
+		return TGTADM_INVALID_REQUEST;
+	}
 
 	err = tgt_device_path_update(target, lu, p);
 	if (err) {
@@ -243,8 +269,8 @@ int tgt_device_create(int tid, uint64_t 
 
 	tgt_cmd_queue_init(&lu->cmd_queue);
 
-	if (target->dev_type_template.device_init)
-		target->dev_type_template.device_init(lu);
+	if (lu->dev_type_template.device_init)
+		lu->dev_type_template.device_init(lu);
 
 	list_for_each_entry(pos, &target->device_list, device_siblings) {
 		if (lu->lun < pos->lun)
@@ -275,7 +301,7 @@ int tgt_device_destroy(int tid, uint64_t
 	free(lu->path);
 	list_del(&lu->device_siblings);
 
-	target->bst->bs_close(lu);
+	lu->bst->bs_close(lu);
 	free(lu);
 	return 0;
 }
@@ -509,7 +535,7 @@ static void __cmd_done(struct target *ta
 		if (cmd->dev->addr)
 			do_munmap = 0;
 	}
-	err = target->bst->bs_cmd_done(do_munmap,
+	err = cmd->dev->bst->bs_cmd_done(do_munmap,
 				       !cmd->mmapped,
 				       cmd->uaddr, cmd->len);
 
@@ -1073,7 +1099,7 @@ int tgt_target_show_all(char *buf, int r
 			 _TAB2 "Status: %s\n",
 			 target->tid,
 			 target->name,
-			 target->dev_type_template.name,
+			 /*target->dev_type_template.name*/"",
 			 tgt_drivers[target->lid]->name,
 			 target_state_name(target->target_state));
 
@@ -1140,7 +1166,7 @@ char *tgt_targetname(int tid)
 
 #define DEFAULT_NR_ACCOUNT 16
 
-int tgt_target_create(int lld, int tid, char *args, int t_type)
+int tgt_target_create(int lld, int tid, char *args)
 {
 	int i;
 	struct target *target, *pos;
@@ -1174,24 +1200,6 @@ int tgt_target_create(int lld, int tid, 
 	if (!target)
 		return TGTADM_NOMEM;
 
-	switch (t_type) {
-	case TYPE_DISK:
-		target->dev_type_template = sbc_template;
-		break;
-	case TYPE_ROM:
-		target->dev_type_template = mmc_template;
-		break;
-	case TYPE_OSD:
-		target->dev_type_template = osd_template;
-		break;
-	case TYPE_SPT:
-		target->dev_type_template = spt_template;
-		break;
-	default:
-		free(target);
-		return TGTADM_INVALID_REQUEST;
-	}
-
 	target->name = strdup(targetname);
 	if (!target->name) {
 		free(target);
@@ -1212,12 +1220,6 @@ int tgt_target_create(int lld, int tid, 
 
 	INIT_LIST_HEAD(&target->device_list);
 
-	/* FIXME */
-	if (t_type == TYPE_SPT)
-		target->bst = &sg_bst;
-	else
-		target->bst = tgt_drivers[lld]->default_bst;
-
 	target->target_state = SCSI_TARGET_RUNNING;
 	target->lid = lld;
 
diff --git a/usr/target.h b/usr/target.h
index fe2e21e..847e4ac 100644
--- a/usr/target.h
+++ b/usr/target.h
@@ -44,14 +44,9 @@ struct target {
 
 	struct tgt_cmd_queue cmd_queue;
 
-	struct backingstore_template *bst;
-
 	struct list_head acl_list;
 
 	struct tgt_account account;
-
-	/* we don't use a pointer because a lld could change this. */
-	struct device_type_template dev_type_template;
 };
 
 struct it_nexus {
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 7eecc0a..de7d889 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -34,6 +34,23 @@ struct tgt_cmd_queue {
 	struct list_head queue;
 };
 
+struct scsi_lu;
+struct scsi_cmd;
+
+struct device_type_operations {
+	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
+};
+
+struct device_type_template {
+	unsigned char type;
+	char *name;
+	char *pid;
+
+	void (*device_init)(struct scsi_lu *dev);
+
+	struct device_type_operations ops[256];
+};
+
 struct scsi_lu {
 	int fd;
 	uint64_t addr; /* persistent mapped address */
@@ -54,6 +71,10 @@ struct scsi_lu {
 
 	/* TODO: needs a structure for lots of device parameters */
 	uint8_t d_sense;
+
+    struct device_type_template dev_type_template;
+    struct backingstore_template *bst;
+    void *private;
 };
 
 struct scsi_cmd {
@@ -102,32 +123,19 @@ static inline int kreq_init(void)	\
 }
 #endif
 
-struct device_type_operations {
-	int (*cmd_perform)(int host_no, struct scsi_cmd *cmd);
-};
-
-struct device_type_template {
-	unsigned char type;
-	char *name;
-	char *pid;
-
-	void (*device_init)(struct scsi_lu *dev);
-
-	struct device_type_operations ops[256];
-};
 
 extern int kspace_send_tsk_mgmt_res(uint64_t nid, uint64_t mid, int result);
 extern int kspace_send_cmd_res(uint64_t nid, int result, struct scsi_cmd *);
 
 extern int ipc_init(void);
-extern int tgt_device_create(int tid, uint64_t lun, char *args);
+extern int tgt_device_create(int tid, uint64_t lun, uint32_t type, char *args);
 extern int tgt_device_destroy(int tid, uint64_t lun);
 extern int tgt_device_update(int tid, uint64_t dev_id, char *name);
 extern int device_reserve(uint64_t nid, uint64_t lun, uint64_t reserve_id);
 extern int device_release(uint64_t nid, uint64_t lun, uint64_t reserve_id, int force);
 extern int device_reserved(uint64_t nid, uint64_t lun, uint64_t reserve_id);
 
-extern int tgt_target_create(int lld, int tid, char *args, int t_type);
+extern int tgt_target_create(int lld, int tid, char *args);
 extern int tgt_target_destroy(int tid);
 extern int tgt_target_bind(int tid, int host_no, int lld);
 extern char *tgt_targetname(int tid);


From hugang at soulinfo.com  Thu Mar 29 08:07:57 2007
From: hugang at soulinfo.com (Hu Gang)
Date: Thu, 29 Mar 2007 14:07:57 +0800
Subject: [Stgt-devel] modularization target types.
Message-ID: <20070329140757.65effa6a@hugang-laptop>

this patch adding support mutiple scsi type as a modules.

Signed-off-by: hu gang <hugang at soulinfo.com>

---

 usr/mmc.c    |    5 +++++
 usr/osd.c    |    5 +++++
 usr/sbc.c    |    5 +++++
 usr/target.c |   61 +++++++++++++++++++++++++++++++++++++++++++---------------
 usr/tgtd.h   |    4 ++++
 5 files changed, 64 insertions(+), 16 deletions(-)

diff --git a/usr/mmc.c b/usr/mmc.c
index 4eab50b..cbba763 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -213,3 +213,8 @@ struct device_type_template mmc_template
 		[0xb0 ... 0xff] = {spc_illegal_op},
 	}
 };
+
+__attribute__((constructor)) static void mmc_init(void)
+{
+    device_type_register(&mmc_template);
+}
diff --git a/usr/osd.c b/usr/osd.c
index da3853b..1612a20 100644
--- a/usr/osd.c
+++ b/usr/osd.c
@@ -209,3 +209,8 @@ struct device_type_template osd_template
 		[0xb0 ... 0xff] = {spc_illegal_op},
 	}
 };
+
+__attribute__((constructor)) static void osd_init(void)
+{
+        device_type_register(&osd_template);
+}
diff --git a/usr/sbc.c b/usr/sbc.c
index edcd6e8..66c0c2e 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -465,3 +465,8 @@ struct device_type_template sbc_template
 		[0xb0 ... 0xff] = {spc_illegal_op},
 	}
 };
+
+__attribute__((constructor)) static void sbc_init(void)
+{
+        device_type_register(&sbc_template);
+}
diff --git a/usr/target.c b/usr/target.c
index b49b143..e986985 100644
--- a/usr/target.c
+++ b/usr/target.c
@@ -36,8 +36,37 @@ #include "target.h"
 #include "scsi.h"
 #include "tgtadm.h"
 
-extern struct device_type_template sbc_template, mmc_template, osd_template,
-	spt_template;
+static LIST_HEAD(type_list);
+
+int device_type_register(struct device_type_template *t)
+{
+    list_add_tail(&t->list_entry, &type_list);
+    return 0;
+}
+
+static struct device_type_template *device_type_find_name(const char *name)
+{
+    struct device_type_template *t;
+    
+    list_for_each_entry(t, &type_list, list_entry) {
+        if (strcmp(name, t->name) == 0)
+            return t;
+    }
+
+    return NULL;
+}
+
+static struct device_type_template *device_type_find_type(unsigned char type)
+{
+    struct device_type_template *t;
+    
+    list_for_each_entry(t, &type_list, list_entry) {
+        if (t->type == type)
+            return t;
+    }
+
+    return NULL;
+}
 
 static LIST_HEAD(target_list);
 
@@ -205,6 +234,7 @@ int tgt_device_create(int tid, uint64_t 
 	struct target *target;
 	struct scsi_lu *lu, *pos;
     struct backingstore_template *bst;
+    struct device_type_template *tt;
 
 	dprintf("%d %" PRIu64 "\n", tid, lun);
 
@@ -237,23 +267,12 @@ int tgt_device_create(int tid, uint64_t 
 		return TGTADM_NOMEM;
     lu->bst = bst;
 
-	switch (t_type) {
-	case TYPE_DISK:
-		lu->dev_type_template = sbc_template;
-		break;
-	case TYPE_ROM:
-		lu->dev_type_template = mmc_template;
-		break;
-	case TYPE_OSD:
-		lu->dev_type_template = osd_template;
-		break;
-	case TYPE_SPT:
-		lu->dev_type_template = spt_template;
-		break;
-	default:
+    tt = device_type_find_type(t_type);
+    if (tt == NULL) {
 		free(lu);
 		return TGTADM_INVALID_REQUEST;
 	}
+    lu->dev_type_template = *tt;
 
 	err = tgt_device_path_update(target, lu, p);
 	if (err) {
@@ -1089,6 +1108,7 @@ int tgt_target_show_all(char *buf, int r
 	struct scsi_lu *lu;
 	struct acl_entry *acl;
 	struct it_nexus *nexus;
+    struct device_type_template *dtt;
 
 	list_for_each_entry(target, &target_list, target_siblings) {
 		shprintf(total, buf, rest,
@@ -1148,6 +1168,15 @@ int tgt_target_show_all(char *buf, int r
 		list_for_each_entry(acl, &target->acl_list, aclent_list)
 			shprintf(total, buf, rest, _TAB2 "%s\n", acl->address);
 	}
+
+    shprintf(total, buf, rest, "Device type:\n");
+    list_for_each_entry(dtt, &type_list, list_entry) {
+        shprintf(total, buf, rest, 
+                _TAB1 "Device Type: %d\n"
+                _TAB2 "Device Name: %s\n"
+                _TAB2 "Device Pid : %s\n",
+                dtt->type, dtt->name, dtt->pid ? dtt->pid : "");
+    }
 	return total;
 overflow:
 	return max;
diff --git a/usr/tgtd.h b/usr/tgtd.h
index de7d889..413271e 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -49,8 +49,12 @@ struct device_type_template {
 	void (*device_init)(struct scsi_lu *dev);
 
 	struct device_type_operations ops[256];
+
+    struct list_head list_entry;
 };
 
+extern int device_type_register(struct device_type_template *);
+
 struct scsi_lu {
 	int fd;
 	uint64_t addr; /* persistent mapped address */


From pauw at o2.ie  Thu Mar 29 10:19:15 2007
From: pauw at o2.ie (Albert Pauw)
Date: Thu, 29 Mar 2007 10:19:15 +0200
Subject: [Stgt-devel]  Fix build problem for IBMVIO
Message-ID: <12d45be12d024d.12d024d12d45be@o2.ie>

 	ev.p.cmd_rsp.len = cmd->len;
 	ev.p.cmd_rsp.uaddr = cmd->uaddr;
-	ev.p.cmd_rsp.sense_len = cmd->sense_len;
-	ev.p.cmd_rsp.sense_uaddr = (unsigned long) cmd->sense_buffer;
+	ev.p.cmd_rsp.len = cmd->sense_len;
+	ev.p.cmd_rsp.uaddr = (unsigned long) cmd->sense_buffer;

I have some problems with this patch. When applied the variables ev.p.cmd_rsp.len and ev.p.cmd_rsp.uaddr get assigned twice each, with different values. The last one (the modified one) gets used. So one of them is unnecessary. 

Maybe that is already taken care of in the final patch, but since I am only using svn and not the git tree I can't tell.

Albert



From pauw at o2.ie  Fri Mar 30 12:21:45 2007
From: pauw at o2.ie (Albert Pauw)
Date: Fri, 30 Mar 2007 12:21:45 +0200
Subject: [Stgt-devel] [PATCH] iscsi: handle dataout padding
Message-ID: <14f2fee14efca2.14efca214f2fee@o2.ie>

> 	}
>  
> -	return 0;
> +	return err;
> }

When I apply this bit of the patch I get spurious messages like:

 connection7:0: iscsi: detected conn error (1011)

while it seems to work fine. I assume that by returning always 0 the error gets ignored. So this last bit probably reveals something nasty happening.

Albert 



From fujita.tomonori at lab.ntt.co.jp  Fri Mar 30 13:16:56 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 30 Mar 2007 20:16:56 +0900 (JST)
Subject: [Stgt-devel] [PATCH] iscsi: handle dataout padding
In-Reply-To: <14f2fee14efca2.14efca214f2fee@o2.ie>
References: <14f2fee14efca2.14efca214f2fee@o2.ie>
Message-ID: <20070329090038Z.fujita.tomonori@lab.ntt.co.jp>

From: Albert Pauw <pauw at o2.ie>
Subject: Re: [Stgt-devel] [PATCH] iscsi: handle dataout padding
Date: Fri, 30 Mar 2007 12:21:45 +0200

> > 	}
> >  
> > -	return 0;
> > +	return err;
> > }
> 
> When I apply this bit of the patch I get spurious messages like:
> 
>  connection7:0: iscsi: detected conn error (1011)
>
> while it seems to work fine. I assume that by returning always 0 the
> error gets ignored. So this last bit probably reveals something nasty
> happening.

It's due to a bug about noop out handling. It was fixed in the git
tree.

Please use the git tree. I'll never update the svn tree. I leave it
alone just for the history.


From pauw at o2.ie  Fri Mar 30 18:48:39 2007
From: pauw at o2.ie (Albert Pauw)
Date: Fri, 30 Mar 2007 18:48:39 +0200
Subject: [Stgt-devel] mutual login failed
Message-ID: <14fabe514f80a7.14f80a714fabe5@o2.ie>

I tried mutual login (in and outgoing) but it failed.
Using wireshark and comparing the same sequence with another target (Wasabi) I found the following:

The target answers wrong after the correct first part. The outgoing username is not offered, but the password is (encrypted). So when the target needs to answer the initiator with its own CHAP_N and CHAP_R it fills in the CHAP_R (assuming that is correct) but the outgoing name is not filled in the CHAP_N field, it is empty.

So the login fails.



