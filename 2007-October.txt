From rcj at linux.vnet.ibm.com  Mon Oct  1 21:56:26 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Mon, 1 Oct 2007 14:56:26 -0500
Subject: [Stgt-devel] [Patch 1/1] device_reserved fastpath
Message-ID: <20071001195626.GA32253@austin.ibm.com>

Maintain a count of logical units with reservations in the target 
structure.  For each IO we'll save traversing the entire list of 
logical units for a target to check for a reservation.  Attach more 
than one logicalunit to a target and this saves that many more 
lookups per IO.

Signed-off-by: rcj at linux.vnet.ibm.com

---
 usr/target.c |    8 ++++++++
 usr/target.h |    1 +
 2 files changed, 9 insertions(+)

Index: b/usr/target.c
===================================================================
--- a/usr/target.c
+++ b/usr/target.c
@@ -331,6 +331,9 @@ int tgt_device_destroy(int tid, uint64_t
 		lu->bst->bs_close(lu);
 	}
 
+	if (lu->reserve_id)
+		(target->reservations)--;
+
 	list_del(&lu->device_siblings);
 	free(lu);
 
@@ -409,6 +412,7 @@ int device_reserve(struct scsi_cmd *cmd)
 		return -EBUSY;
 	}
 
+	(cmd->c_target->reservations)++;
 	lu->reserve_id = cmd->cmd_itn_id;
 	return 0;
 }
@@ -426,6 +430,7 @@ int device_release(int tid, uint64_t itn
 
 	if (force || lu->reserve_id == itn_id) {
 		lu->reserve_id = 0;
+		(target->reservations)--;
 		return 0;
 	}
 
@@ -436,6 +441,9 @@ int device_reserved(struct scsi_cmd *cmd
 {
 	struct scsi_lu *lu;
 
+	if (cmd->c_target->reservations == 0)
+		return 0;
+
 	lu = device_lookup(cmd->c_target, cmd->dev->lun);
 	if (!lu || !lu->reserve_id || lu->reserve_id == cmd->cmd_itn_id)
 		return 0;
Index: b/usr/target.h
===================================================================
--- a/usr/target.h
+++ b/usr/target.h
@@ -25,6 +25,7 @@ struct target {
 
 	int tid;
 	int lid;
+	uint reservations;
 
 	enum scsi_target_state target_state;
 


From rcj at linux.vnet.ibm.com  Wed Oct  3 15:35:34 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Wed, 3 Oct 2007 08:35:34 -0500
Subject: [Stgt-devel] [appologies] Mailing list issues
Message-ID: <20071003133533.GA10883@austin.ibm.com>

Please respond to me privately (if you would) to confirm that mail
delivery is functional.

According to the few people I have asked off list, it appears that mail
delivery to this list may not be functioning.  I wanted to send this
message out to see if it is still not working while I open a bug with
berliOS.  Thank you and sorry for this test message.

--Rob Jennings


From blackmagic02881 at gmail.com  Wed Oct  3 22:12:08 2007
From: blackmagic02881 at gmail.com (Ming Zhang)
Date: Wed, 03 Oct 2007 16:12:08 -0400
Subject: [Stgt-devel] [appologies] Mailing list issues
In-Reply-To: <20071003133533.GA10883@austin.ibm.com>
References: <20071003133533.GA10883@austin.ibm.com>
Message-ID: <1191442328.3587.23.camel@dhcp-117.ibrix.com>

i got it from list.

Ming

On Wed, 2007-10-03 at 08:35 -0500, Robert Jennings wrote:
> Please respond to me privately (if you would) to confirm that mail
> delivery is functional.
> 
> According to the few people I have asked off list, it appears that mail
> delivery to this list may not be functioning.  I wanted to send this
> message out to see if it is still not working while I open a bug with
> berliOS.  Thank you and sorry for this test message.
> 
> --Rob Jennings
> _______________________________________________
> Stgt-devel mailing list
> Stgt-devel at lists.berlios.de
> https://lists.berlios.de/mailman/listinfo/stgt-devel
-- 
Ming Zhang


@#$%^ purging memory... (*!%
http://blackmagic02881.wordpress.com/
http://www.linkedin.com/in/blackmagic02881
--------------------------------------------



From pw at osc.edu  Thu Oct  4 19:20:35 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 4 Oct 2007 13:20:35 -0400
Subject: [Stgt-devel] iSER
In-Reply-To: <20070909181242.GA9302@osc.edu>
References: <20070903132326.GA8441@lemming.cita.utoronto.ca>
	<20070903170223.GA28887@osc.edu>
	<20070904032420.GA20306@lemming.cita.utoronto.ca>
	<20070904201912.GA6840@osc.edu>
	<20070905144618.GA26761@lemming.cita.utoronto.ca>
	<20070909153032.GA27634@lemming.cita.utoronto.ca>
	<20070909181242.GA9302@osc.edu>
Message-ID: <20071004172035.GA15236@osc.edu>

pw at osc.edu wrote on Sun, 09 Sep 2007 14:12 -0400:
> robin.humble+stgt at anu.edu.au wrote on Sun, 09 Sep 2007 11:30 -0400:
> > Summary:
> >  - 2.6.21 seems to be a good kernel. 2.6.22 or newer, or RedHat's OFED 1.2
> >    patched kernels all seem to have iSER bugs that make them unusable.
> >  - as everything works in 2.6.21 presumably this means there's nothing
> >    wrong with the iSER implementation in tgtd. well done! :)
> 
> Well, that's good and bad news.  Nice to know that things do work at times,
> but we have to figure out what happened in the initiator now.  Or maybe tgt
> is making some bad assumptions.

This all turned out to be a known bug in the mthca IB driver in
kernels older than 2.6.21.  Including the rhel5 kernel.  The
initiator uses FMR for memory registrations, and a certain popular
chipset was prone to random scribbling on old registrations,
yielding wrong data in the application or unexplainable kernel
crashes.  Nothing wrong in the target.

> > with the 2.6.22.6 kernel and iSER I couldn't find any corruption
> > issues using dd to /dev/sdc. however (as reported previously) if I put
> > an ext3 filesystem on the iSER device and then dd to a file in the ext3
> > filsystem then pretty much immediately I get:
> >   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196611, length 1
> >   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196612, length 1
> >   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196613, length 1
> >   ...
> > 
> > I get the same type of errors with 2.6.23-rc5 too.
> 
> I'm still not been able to reproduce this, at least on my
> 2.6.22-rc5.  One of these days we'll move to some newer kernels
> here, but have been sort of waiting for the bidi approaches to
> stabilize somewhat.

Maybe this is fixed.  I did find one possible case where the Send
result may have gone out before the final RDMA write, in the case
when the target is starved for RDMA slots.  But I never saw the
problem myself, so can't say for sure.

In fact, I hacked up the bs-sync code to calculate the result
expected by the test application lmdd, rather than read it off disk,
and could achieve your high throughputs but never any corruptions.
It ran all night last night.

Anyway, there's a new git out there with this one new patch and some
kernel initiator warnings in the README.iser doc.

		-- Pete


From fujita.tomonori at lab.ntt.co.jp  Fri Oct  5 01:06:11 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 05 Oct 2007 08:06:11 +0900
Subject: [Stgt-devel] iSER
In-Reply-To: <20071004172035.GA15236@osc.edu>
References: <20070909153032.GA27634@lemming.cita.utoronto.ca>
	<20070909181242.GA9302@osc.edu> <20071004172035.GA15236@osc.edu>
Message-ID: <20071005080611P.fujita.tomonori@lab.ntt.co.jp>

On Thu, 4 Oct 2007 13:20:35 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> pw at osc.edu wrote on Sun, 09 Sep 2007 14:12 -0400:
> > robin.humble+stgt at anu.edu.au wrote on Sun, 09 Sep 2007 11:30 -0400:
> > > Summary:
> > >  - 2.6.21 seems to be a good kernel. 2.6.22 or newer, or RedHat's OFED 1.2
> > >    patched kernels all seem to have iSER bugs that make them unusable.
> > >  - as everything works in 2.6.21 presumably this means there's nothing
> > >    wrong with the iSER implementation in tgtd. well done! :)
> > 
> > Well, that's good and bad news.  Nice to know that things do work at times,
> > but we have to figure out what happened in the initiator now.  Or maybe tgt
> > is making some bad assumptions.
> 
> This all turned out to be a known bug in the mthca IB driver in
> kernels older than 2.6.21.  Including the rhel5 kernel.  The
> initiator uses FMR for memory registrations, and a certain popular
> chipset was prone to random scribbling on old registrations,
> yielding wrong data in the application or unexplainable kernel
> crashes.  Nothing wrong in the target.
> 
> > > with the 2.6.22.6 kernel and iSER I couldn't find any corruption
> > > issues using dd to /dev/sdc. however (as reported previously) if I put
> > > an ext3 filesystem on the iSER device and then dd to a file in the ext3
> > > filsystem then pretty much immediately I get:
> > >   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196611, length 1
> > >   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196612, length 1
> > >   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196613, length 1
> > >   ...
> > > 
> > > I get the same type of errors with 2.6.23-rc5 too.
> > 
> > I'm still not been able to reproduce this, at least on my
> > 2.6.22-rc5.  One of these days we'll move to some newer kernels
> > here, but have been sort of waiting for the bidi approaches to
> > stabilize somewhat.
> 
> Maybe this is fixed.  I did find one possible case where the Send
> result may have gone out before the final RDMA write, in the case
> when the target is starved for RDMA slots.  But I never saw the
> problem myself, so can't say for sure.
> 
> In fact, I hacked up the bs-sync code to calculate the result
> expected by the test application lmdd, rather than read it off disk,
> and could achieve your high throughputs but never any corruptions.
> It ran all night last night.
> 
> Anyway, there's a new git out there with this one new patch and some
> kernel initiator warnings in the README.iser doc.

Sounds promising. voltaire guys, any chance to try Pete's latest tree?


From robin.humble+stgt at anu.edu.au  Fri Oct  5 15:07:04 2007
From: robin.humble+stgt at anu.edu.au (Robin Humble)
Date: Fri, 5 Oct 2007 09:07:04 -0400
Subject: [Stgt-devel] iSER
In-Reply-To: <20071004172035.GA15236@osc.edu>
References: <20070903132326.GA8441@lemming.cita.utoronto.ca>
	<20070903170223.GA28887@osc.edu>
	<20070904032420.GA20306@lemming.cita.utoronto.ca>
	<20070904201912.GA6840@osc.edu>
	<20070905144618.GA26761@lemming.cita.utoronto.ca>
	<20070909153032.GA27634@lemming.cita.utoronto.ca>
	<20070909181242.GA9302@osc.edu> <20071004172035.GA15236@osc.edu>
Message-ID: <20071005130704.GA6681@lemming.cita.utoronto.ca>

On Thu, Oct 04, 2007 at 01:20:35PM -0400, Pete Wyckoff wrote:
>pw at osc.edu wrote on Sun, 09 Sep 2007 14:12 -0400:
>> robin.humble+stgt at anu.edu.au wrote on Sun, 09 Sep 2007 11:30 -0400:
>> > with the 2.6.22.6 kernel and iSER I couldn't find any corruption
>> > issues using dd to /dev/sdc. however (as reported previously) if I put
>> > an ext3 filesystem on the iSER device and then dd to a file in the ext3
>> > filsystem then pretty much immediately I get:
>> >   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196611, length 1
>> >   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196612, length 1
>> >   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196613, length 1
>> >   ...
>> > I get the same type of errors with 2.6.23-rc5 too.

eventually (with Pete and Erez's offline help) I managed to reproduce
this without a filesystem by using sufficiently large and preferably
random lmdd's. eg.
  lmdd of=internal ipat=1 if=/dev/sdc bs=800000 count=2000 rand=6000m mismatch=10
however, that's kinda irrelevant 'cos...

>Maybe this is fixed.  I did find one possible case where the Send
>result may have gone out before the final RDMA write, in the case
>when the target is starved for RDMA slots.  But I never saw the
>problem myself, so can't say for sure.

... yes! that has fixed the problem.

now lmdd to the block device, or ext3 with multiple bonnie++'s or
iozone multithreaded etc. all work as expected.

well done finding the bug! :-)

performance is good. backing store is a 7G file on a ramfs, 2.6.22.6
kernels with OFED 1.2.5 modules and userland, dual dual core Xeon
2.66Ghz, CentOS5 x86_64, initiator with mem=512M, DDR IB.

~650MB/s writes and 280MB/s reads with eg.
  dd if=/dev/zero of=/dev/sdc bs=1M count=6000
 
bonnie++
 1.03 ------Sequential Output------ --Sequential Input- --Random-
      -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
 Size K/sec %CP K/sec %CP K/sec %CP K/sec %CP K/sec %CP  /sec %CP
   4G 79119  99 464995 98 171640 28 70948  81 291538 23 +++++ +++
   6G 79061  99 459926 93 165442 27 70987  80 291262 23 15929  41

so ~450 MiB/s writes and 280 MiB/s reads.
or bonnie++ in semaphore mode:
 2-way (-s 2g) min aggregate write/read of ~480/380 MiB/s
 4-way (-s 1g) min aggregate write/read of ~525/570 MiB/s

and about the same from iozone:
min throughput * threads from a single client doing iozone 1,2,4-way is:
 iozone -s 4g -r 256k -i 0 -i 1 -t 1
        write   =  481869.34 KB/sec
        read    =  293940.09 KB/sec
 iozone -s 2g -r 256k -i 0 -i 1 -t 2
        write   =  252719.98 KB/sec   * 2 = 505440 KB/s
        read    =  196478.64 KB/sec   * 2 = 392957 KB/s
 iozone -s 1g -r 256k -i 0 -i 1 -t 4
        write   =  132325.09 KB/sec   * 4 = 529300 KB/s
        read    =  136420.22 KB/sec   * 4 = 545681 KB/s

cheers,
robin


From robin.humble+stgt at anu.edu.au  Fri Oct  5 17:57:02 2007
From: robin.humble+stgt at anu.edu.au (Robin Humble)
Date: Fri, 5 Oct 2007 11:57:02 -0400
Subject: [Stgt-devel] iSER
In-Reply-To: <20071004172035.GA15236@osc.edu>
References: <20070903132326.GA8441@lemming.cita.utoronto.ca>
	<20070903170223.GA28887@osc.edu>
	<20070904032420.GA20306@lemming.cita.utoronto.ca>
	<20070904201912.GA6840@osc.edu>
	<20070905144618.GA26761@lemming.cita.utoronto.ca>
	<20070909153032.GA27634@lemming.cita.utoronto.ca>
	<20070909181242.GA9302@osc.edu> <20071004172035.GA15236@osc.edu>
Message-ID: <20071005155701.GA9292@lemming.cita.utoronto.ca>

On Thu, Oct 04, 2007 at 01:20:35PM -0400, Pete Wyckoff wrote:
>This all turned out to be a known bug in the mthca IB driver in
>kernels older than 2.6.21.  Including the rhel5 kernel.  The

just FYI, a iSER testing kernel:
  http://people.redhat.com/dzickus/el5/52.el5/
referenced from this:
  https://bugzilla.redhat.com/show_bug.cgi?id=234352
has the required one-liner patch to fix mthca, so maybe it'll be fixed
in RHEL soon.

the 2.6.18-52.el5 kernel + stock CentOS5 userland + the iSER git
appears to be fine under testing, and has a tad better read performance
than 2.6.22.6

Version  1.03 ------Sequential Output------ --Sequential Input- --Random-
              -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks--
x11        1G 78579  99 417268 92 208824 34 85054  96 340290 25 +++++ +++
x11        4G 78341  99 446128 96 194134 29 86896  98 343078 25 +++++ +++
x11        6G 78720  99 457873 98 191004 28 86464  97 347046 24 +++++ +++

cheers,
robin


From erezz at Voltaire.COM  Mon Oct  8 17:36:16 2007
From: erezz at Voltaire.COM (Erez Zilber)
Date: Mon, 08 Oct 2007 17:36:16 +0200
Subject: [Stgt-devel] iSER
In-Reply-To: <20071005080611P.fujita.tomonori@lab.ntt.co.jp>
References: <20070909153032.GA27634@lemming.cita.utoronto.ca>	<20070909181242.GA9302@osc.edu>
	<20071004172035.GA15236@osc.edu>
	<20071005080611P.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <470A4E70.0@Voltaire.COM>

FUJITA Tomonori wrote:
> On Thu, 4 Oct 2007 13:20:35 -0400
> Pete Wyckoff <pw at osc.edu> wrote:
>
>   
>> pw at osc.edu wrote on Sun, 09 Sep 2007 14:12 -0400:
>>     
>>> robin.humble+stgt at anu.edu.au wrote on Sun, 09 Sep 2007 11:30 -0400:
>>>       
>>>> Summary:
>>>>  - 2.6.21 seems to be a good kernel. 2.6.22 or newer, or RedHat's OFED 1.2
>>>>    patched kernels all seem to have iSER bugs that make them unusable.
>>>>  - as everything works in 2.6.21 presumably this means there's nothing
>>>>    wrong with the iSER implementation in tgtd. well done! :)
>>>>         
>>> Well, that's good and bad news.  Nice to know that things do work at times,
>>> but we have to figure out what happened in the initiator now.  Or maybe tgt
>>> is making some bad assumptions.
>>>       
>> This all turned out to be a known bug in the mthca IB driver in
>> kernels older than 2.6.21.  Including the rhel5 kernel.  The
>> initiator uses FMR for memory registrations, and a certain popular
>> chipset was prone to random scribbling on old registrations,
>> yielding wrong data in the application or unexplainable kernel
>> crashes.  Nothing wrong in the target.
>>
>>     
>>>> with the 2.6.22.6 kernel and iSER I couldn't find any corruption
>>>> issues using dd to /dev/sdc. however (as reported previously) if I put
>>>> an ext3 filesystem on the iSER device and then dd to a file in the ext3
>>>> filsystem then pretty much immediately I get:
>>>>   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196611, length 1
>>>>   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196612, length 1
>>>>   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196613, length 1
>>>>   ...
>>>>
>>>> I get the same type of errors with 2.6.23-rc5 too.
>>>>         
>>> I'm still not been able to reproduce this, at least on my
>>> 2.6.22-rc5.  One of these days we'll move to some newer kernels
>>> here, but have been sort of waiting for the bidi approaches to
>>> stabilize somewhat.
>>>       
>> Maybe this is fixed.  I did find one possible case where the Send
>> result may have gone out before the final RDMA write, in the case
>> when the target is starved for RDMA slots.  But I never saw the
>> problem myself, so can't say for sure.
>>
>> In fact, I hacked up the bs-sync code to calculate the result
>> expected by the test application lmdd, rather than read it off disk,
>> and could achieve your high throughputs but never any corruptions.
>> It ran all night last night.
>>
>> Anyway, there's a new git out there with this one new patch and some
>> kernel initiator warnings in the README.iser doc.
>>     
>
> Sounds promising. voltaire guys, any chance to try Pete's latest tree?

We ran some tests on it and it looks ok now (still trying to make it 
crash :-) ). We will run more nasty tests soon, and if anything goes 
wrong, we will report. We will also try to get some performance numbers 
(BW, iops) from our storage.

Thanks to Pete for donating the iSER code and fixing bugs.

Erez


From nejc.porenta at gmail.com  Tue Oct  9 10:46:17 2007
From: nejc.porenta at gmail.com (Jernej Porenta)
Date: Tue, 9 Oct 2007 10:46:17 +0200
Subject: [Stgt-devel] iSER tgtd performance
Message-ID: <df5c931c0710090146n5de87f22i41ac0753a8a565a@mail.gmail.com>

Heya all,

I am using OSC git tgt tree for testing iSER with virtualization. My
research focus in on I/O performance in virtualization tehniques
(OpenVZ, VMWare server, Xen).

I am using CentOS5 + OFED1.2.5 where it is possible (on target and
OpenVZ) with Dell 1950 servers with 4GB ram with Mellanox single port
memfree infiniband cards.

On target node i usually setup my iSCSI target like this:
dd if=/dev/zero bs=1k count=1 seek=1048575 of=/dev/shm/tid1lun1
./tgtadm --lld iscsi --mode target --op new --tid 1 --targetname node1.nejc.net
./tgtadm --lld iscsi --mode target --op bind --tid 1 --initiator-address ALL
./tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 1
--backing-store /dev/shm/tid1lun1

And the performance from client using ib_iser, measured with disktest,
is around 1030MB/s which is quite impressive.

But the performance drops significantly when I increase the backing
store size to 3.5GB. Usually I get around 400MB/s. This
happens with tmpfs or with /dev/ram0.

Could you tell me what is the reason for that? Maybe internal kernel
stuff or anything else.

My init scripts on target and client are available here:
http://www.nejc.net/diploma/tgtd/

Thanks for developing such great software again...

cheers, Jernej


From pw at osc.edu  Wed Oct 10 05:17:45 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 9 Oct 2007 23:17:45 -0400
Subject: [Stgt-devel] iSER tgtd performance
In-Reply-To: <df5c931c0710090146n5de87f22i41ac0753a8a565a@mail.gmail.com>
References: <df5c931c0710090146n5de87f22i41ac0753a8a565a@mail.gmail.com>
Message-ID: <20071010031745.GC28356@osc.edu>

nejc.porenta at gmail.com wrote on Tue, 09 Oct 2007 10:46 +0200:
> I am using OSC git tgt tree for testing iSER with virtualization. My
> research focus in on I/O performance in virtualization tehniques
> (OpenVZ, VMWare server, Xen).
> 
> I am using CentOS5 + OFED1.2.5 where it is possible (on target and
> OpenVZ) with Dell 1950 servers with 4GB ram with Mellanox single port
> memfree infiniband cards.
> 
> On target node i usually setup my iSCSI target like this:
> dd if=/dev/zero bs=1k count=1 seek=1048575 of=/dev/shm/tid1lun1
> ./tgtadm --lld iscsi --mode target --op new --tid 1 --targetname node1.nejc.net
> ./tgtadm --lld iscsi --mode target --op bind --tid 1 --initiator-address ALL
> ./tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 1
> --backing-store /dev/shm/tid1lun1
> 
> And the performance from client using ib_iser, measured with disktest,
> is around 1030MB/s which is quite impressive.
> 
> But the performance drops significantly when I increase the backing
> store size to 3.5GB. Usually I get around 400MB/s. This
> happens with tmpfs or with /dev/ram0.

Apparently you have DDR IB cards.  1030 MB/s is quite amazing.
We've only seen 920-ish for reads with SDR, 850-ish for writes.

The tests you are running.  Disktest does big linear reads/writes to
its iscsi block device?  If you stay within the first 1GB for both
test setups you describe, I would expect the same performance.  But
if you wander up closer to the 3.5 GB area for the larger ram disk,
the Linux VM will probably start pushing some of the older pages out
to swap.  It likes to keep some amount of memory free.

If you just want to torture the network, you can edit bs_sync.c to
stub out the pread64 and pwrite64 calls, and just set ret to
cmd->len.  Of course, hopefully disktest doesn't ever look at the
read results.  :)  Maybe you could use scsi_debug on the target with
"fake_rw" to do the same thing.

> My init scripts on target and client are available here:
> http://www.nejc.net/diploma/tgtd/

Scripts look fine.  Is it necessary to turn off HeaderDigest on the
initiator side?  I had hoped that iscsiadm would realize it was
asked to use iser and turn off HeaderDigest and DataDigest on its
own, but never got around to testing that.

		-- Pete


From nejc.porenta at gmail.com  Wed Oct 10 10:35:20 2007
From: nejc.porenta at gmail.com (Jernej Porenta)
Date: Wed, 10 Oct 2007 10:35:20 +0200
Subject: [Stgt-devel] iSER tgtd performance
In-Reply-To: <20071010031745.GC28356@osc.edu>
References: <df5c931c0710090146n5de87f22i41ac0753a8a565a@mail.gmail.com>
	<20071010031745.GC28356@osc.edu>
Message-ID: <df5c931c0710100135l76d7b3bbrd79d3bbb4fcd69e1@mail.gmail.com>

On 10/10/07, Pete Wyckoff <pw at osc.edu> wrote:
>
> Apparently you have DDR IB cards.  1030 MB/s is quite amazing.
> We've only seen 920-ish for reads with SDR, 850-ish for writes.
>
> The tests you are running.  Disktest does big linear reads/writes to
> its iscsi block device?  If you stay within the first 1GB for both
> test setups you describe, I would expect the same performance.  But
> if you wander up closer to the 3.5 GB area for the larger ram disk,
> the Linux VM will probably start pushing some of the older pages out
> to swap.  It likes to keep some amount of memory free.
>

Yes I have DDR IB cards (and I figured out that that might be the issue).

I made some additional tests with disktest
(http://www.open-iscsi.org/bits/disktest.tar.gz). I have added 4GB RAM
to target machine so now it has 8GB and created several ramdisks and
testing bandwidth throughput with several clients on same client
machine. Here are the results:
- 2GB target: 2 clients - each 280MB/s, 3 clients - each 215MB/s
- 1GB target: 1 client - 900MB/s, 2 clients - each 350MB/s, 3 clients 238MB/s

each client had different LUN target.

I have also made some tests with target size 512MB but the results
were beyond 2.5GB/s so I believe that there must be something wrong
with disktest or Linux buffers screw up the test.

I am planning to do some testing with IOzone or bonnie++, so results
might follow...

I use disktest like that:
./disktest -PT -T120 -pr -h1 -K1 -B256K -IB /dev/sdb

I also tried testing target from 2 different machines:
- 3GB target: 1 client - 440MB/s, 2 clients - each 420MB/s
- 2GB target: 1 client - 470MB/s, 2 clients - each 470MB/s
- 1GB target 1 client - 900MB/s, 2 clients - each 850MB/s

I assume that there might be some IO buffers somewhere, so I assume
that normal speed would be around 450MB/s. Same results Robin got:
https://lists.berlios.de/pipermail/stgt-devel/2007-October/001063.html

>
> > My init scripts on target and client are available here:
> > http://www.nejc.net/diploma/tgtd/
>
> Scripts look fine.  Is it necessary to turn off HeaderDigest on the
> initiator side?  I had hoped that iscsiadm would realize it was
> asked to use iser and turn off HeaderDigest and DataDigest on its
> own, but never got around to testing that.

I had some troubles with HeaderDigest at the beginning so I turned it
to none and it stayed in my scripts. I tried it now and it is not
working without it

I have also tried tgtd with iSER with TCP connection over IPoIB but
disktest reported read errors. From the begining everything went just
fine, but afterwards the read requests started to fail and the
performance dropped significantly, so I tried iSCSI enterprise target
software for TCP and it worked well, so I believe that there might be
a bug in tgtd software but I am unable to reproduce it, because if I
turn on the debug option, the performance drops because of 100% CPU
usage on the target. And believe it or not, everything works if CPU
usage on target is 100%, so there are some issues with highspeed tgtd
IPoIB target :)

Again thanks for your help...

cheers from Slovenia, Jernej


From jcasale at ActiveNetwerx.com  Wed Oct 10 16:48:27 2007
From: jcasale at ActiveNetwerx.com (Joseph L. Casale)
Date: Wed, 10 Oct 2007 08:48:27 -0600
Subject: [Stgt-devel] Target error during bench test
Message-ID: <1C8CF1EA1A5B5940B81B0710B2A4C93820CA0DA177@an-ex.ActiveNetwerx.int>

I have tgt running on CentOS 5 (Final) kernel version 2.6.22.6 with Adaptec SRCS16 controllers, the target has one disc (sda) for os and one disc (sdb) for tgt and an Intel Pro 1000 MT NIC. Tgt has a partition on sdb exported as a device using defaults as per tgt readme, the rest of the space is unused. The target was configured entirely with scstadmin.

The client is also running CentOS 5 (Final) kernel version 2.6.18-8.el5 with the open-scsi ini that ships with it. It has a Broadcom NC7781 PCI-X Gigabit NIC.

I am running the tests from http://iscsi.studiokubota.com/ and bench.pid.out shows a problem with the tar test. Attached is my message.1, given this info can anyone shed some light on what is happening to the target to cause this failure?

Thank you for your help,
jlc


-------------- next part --------------
A non-text attachment was scrubbed...
Name: messages.1
Type: application/octet-stream
Size: 74319 bytes
Desc: messages.1
URL: <https://lists.berlios.de/pipermail/stgt-devel/attachments/20071010/90a9fffa/attachment.obj>

From jcasale at ActiveNetwerx.com  Wed Oct 10 18:17:37 2007
From: jcasale at ActiveNetwerx.com (Joseph L. Casale)
Date: Wed, 10 Oct 2007 10:17:37 -0600
Subject: [Stgt-devel] Target error during bench test
In-Reply-To: <1C8CF1EA1A5B5940B81B0710B2A4C93820CA0DA177@an-ex.ActiveNetwerx.int>
References: <1C8CF1EA1A5B5940B81B0710B2A4C93820CA0DA177@an-ex.ActiveNetwerx.int>
Message-ID: <1C8CF1EA1A5B5940B81B0710B2A4C93820CA0DA17C@an-ex.ActiveNetwerx.int>

Sorry guys, I incorrectly stated I used scstadmin to configure it but it was tgtadm.
Tgt was built from the latest source as well.

Thanks,
jlc

-----Original Message-----
From: stgt-devel-bounces at lists.berlios.de [mailto:stgt-devel-bounces at lists.berlios.de] On Behalf Of Joseph L. Casale
Sent: October-10-07 8:48 AM
To: 'stgt-devel at lists.berlios.de'
Subject: [Stgt-devel] Target error during bench test

I have tgt running on CentOS 5 (Final) kernel version 2.6.22.6 with Adaptec SRCS16 controllers, the target has one disc (sda) for os and one disc (sdb) for tgt and an Intel Pro 1000 MT NIC. Tgt has a partition on sdb exported as a device using defaults as per tgt readme, the rest of the space is unused. The target was configured entirely with scstadmin.

The client is also running CentOS 5 (Final) kernel version 2.6.18-8.el5 with the open-scsi ini that ships with it. It has a Broadcom NC7781 PCI-X Gigabit NIC.

I am running the tests from http://iscsi.studiokubota.com/ and bench.pid.out shows a problem with the tar test. Attached is my message.1, given this info can anyone shed some light on what is happening to the target to cause this failure?

Thank you for your help,
jlc






From fujita.tomonori at lab.ntt.co.jp  Thu Oct 11 07:57:42 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 11 Oct 2007 14:57:42 +0900
Subject: [Stgt-devel] iSER
In-Reply-To: <470A4E70.0@Voltaire.COM>
References: <20071004172035.GA15236@osc.edu>
	<20071005080611P.fujita.tomonori@lab.ntt.co.jp>
	<470A4E70.0@Voltaire.COM>
Message-ID: <20071011145742C.fujita.tomonori@lab.ntt.co.jp>

On Mon, 08 Oct 2007 17:36:16 +0200
Erez Zilber <erezz at Voltaire.COM> wrote:

> FUJITA Tomonori wrote:
> > On Thu, 4 Oct 2007 13:20:35 -0400
> > Pete Wyckoff <pw at osc.edu> wrote:
> >
> >   
> >> pw at osc.edu wrote on Sun, 09 Sep 2007 14:12 -0400:
> >>     
> >>> robin.humble+stgt at anu.edu.au wrote on Sun, 09 Sep 2007 11:30 -0400:
> >>>       
> >>>> Summary:
> >>>>  - 2.6.21 seems to be a good kernel. 2.6.22 or newer, or RedHat's OFED 1.2
> >>>>    patched kernels all seem to have iSER bugs that make them unusable.
> >>>>  - as everything works in 2.6.21 presumably this means there's nothing
> >>>>    wrong with the iSER implementation in tgtd. well done! :)
> >>>>         
> >>> Well, that's good and bad news.  Nice to know that things do work at times,
> >>> but we have to figure out what happened in the initiator now.  Or maybe tgt
> >>> is making some bad assumptions.
> >>>       
> >> This all turned out to be a known bug in the mthca IB driver in
> >> kernels older than 2.6.21.  Including the rhel5 kernel.  The
> >> initiator uses FMR for memory registrations, and a certain popular
> >> chipset was prone to random scribbling on old registrations,
> >> yielding wrong data in the application or unexplainable kernel
> >> crashes.  Nothing wrong in the target.
> >>
> >>     
> >>>> with the 2.6.22.6 kernel and iSER I couldn't find any corruption
> >>>> issues using dd to /dev/sdc. however (as reported previously) if I put
> >>>> an ext3 filesystem on the iSER device and then dd to a file in the ext3
> >>>> filsystem then pretty much immediately I get:
> >>>>   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196611, length 1
> >>>>   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196612, length 1
> >>>>   Sep  9 21:46:22 x11 kernel: EXT3-fs error (device sdc): ext3_new_block: Allocating block in system zone - blocks from 196613, length 1
> >>>>   ...
> >>>>
> >>>> I get the same type of errors with 2.6.23-rc5 too.
> >>>>         
> >>> I'm still not been able to reproduce this, at least on my
> >>> 2.6.22-rc5.  One of these days we'll move to some newer kernels
> >>> here, but have been sort of waiting for the bidi approaches to
> >>> stabilize somewhat.
> >>>       
> >> Maybe this is fixed.  I did find one possible case where the Send
> >> result may have gone out before the final RDMA write, in the case
> >> when the target is starved for RDMA slots.  But I never saw the
> >> problem myself, so can't say for sure.
> >>
> >> In fact, I hacked up the bs-sync code to calculate the result
> >> expected by the test application lmdd, rather than read it off disk,
> >> and could achieve your high throughputs but never any corruptions.
> >> It ran all night last night.
> >>
> >> Anyway, there's a new git out there with this one new patch and some
> >> kernel initiator warnings in the README.iser doc.
> >>     
> >
> > Sounds promising. voltaire guys, any chance to try Pete's latest tree?
> 
> We ran some tests on it and it looks ok now (still trying to make it 
> crash :-) ). We will run more nasty tests soon, and if anything goes 
> wrong, we will report. We will also try to get some performance numbers 
> (BW, iops) from our storage.

Cool.

Pete, the iSER patchset is ready for re-submission?

BTW, can you elaborate on the following commit?

http://git.osc.edu/?p=tgt.git;a=commit;h=8d9eae7acd041fc10a7cfe560c1c280dcc290fa1


What type of commands hit this bug?


Thanks,


From fujita.tomonori at lab.ntt.co.jp  Thu Oct 11 08:04:39 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Thu, 11 Oct 2007 15:04:39 +0900
Subject: [Stgt-devel] Target error during bench test
In-Reply-To: <1C8CF1EA1A5B5940B81B0710B2A4C93820CA0DA177@an-ex.ActiveNetwerx.int>
References: <1C8CF1EA1A5B5940B81B0710B2A4C93820CA0DA177@an-ex.ActiveNetwerx.int>
Message-ID: <20071011150439W.fujita.tomonori@lab.ntt.co.jp>

On Wed, 10 Oct 2007 08:48:27 -0600
"Joseph L. Casale" <jcasale at ActiveNetwerx.com> wrote:

> I have tgt running on CentOS 5 (Final) kernel version 2.6.22.6 with Adaptec SRCS16 controllers, the target has one disc (sda) for os and one disc (sdb) for tgt and an Intel Pro 1000 MT NIC. Tgt has a partition on sdb exported as a device using defaults as per tgt readme, the rest of the space is unused. The target was configured entirely with scstadmin.
> 
> The client is also running CentOS 5 (Final) kernel version 2.6.18-8.el5 with the open-scsi ini that ships with it. It has a Broadcom NC7781 PCI-X Gigabit NIC.
> 
> I am running the tests from http://iscsi.studiokubota.com/ and bench.pid.out shows a problem with the tar test. Attached is my message.1, given this info can anyone shed some light on what is happening to the target to cause this failure?

Looks like that lots of commands were aborted.

Does Pete's patch work for you?

http://git.osc.edu/?p=tgt.git;a=commitdiff;h=8d9eae7acd041fc10a7cfe560c1c280dcc290fa1


From pw at osc.edu  Thu Oct 11 20:22:53 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 11 Oct 2007 14:22:53 -0400
Subject: [Stgt-devel] iSER
In-Reply-To: <20071011145742C.fujita.tomonori@lab.ntt.co.jp>
References: <20071004172035.GA15236@osc.edu>
	<20071005080611P.fujita.tomonori@lab.ntt.co.jp>
	<470A4E70.0@Voltaire.COM>
	<20071011145742C.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20071011182253.GA26746@osc.edu>

fujita.tomonori at lab.ntt.co.jp wrote on Thu, 11 Oct 2007 14:57 +0900:
> Pete, the iSER patchset is ready for re-submission?

I think so.  There are no major outstanding issues that I know about
now.  Let me know if you want to see another round of emails on
this.  Or we can just iterate on your questions as you view the git.

> BTW, can you elaborate on the following commit?
> 
> http://git.osc.edu/?p=tgt.git;a=commit;h=8d9eae7acd041fc10a7cfe560c1c280dcc290fa1
> 
> What type of commands hit this bug?

First, the original commit referred to in that log fixes an issue
where the target would spin with nothing to do.  A request comes in,
gets handed off to bs_sync, but the conn->fd was still EPOLLIN |
EPOLLOUT.  tgtd main thread would keep trying to send something,
looping.  But now, looking at that old tree, I can't convince myself
how this was ever a problem.  The only bad thing that happens
without this old patch, now, is one extra trip through
iscsi_task_tx_start() which always prints "no more data", but that
doesn't seem like a huge deal.  Maybe I'm missing something today,
or was missing something back then.  Or fixed some real bug in the
interim.

The new commit you ask about essentially reverts the original
commit.  The problem I was seeing is that with multiple commands
outstanding, turning off EPOLLOUT on conn->fd would prohibit any
task responses from being sent on the connection.  That epoll
setting is for the entire connection, not for the individual task
that is just beginning execution.  So you could have 10 tasks on
task->c_list, waiting to send responses back to the initiator.  Then
one new request is received and is submitted via
iscsi_scsi_cmd_execute().  This disables EPOLLOUT, and the waiting
10 tasks do not get sent until some other task happens to complete
in bs_sync and re-enables EPOLLOUT polling on the connection fd.

The net effect of the two patches is zero.  Just some minor code
path rewrite with no logic change.  Sorry for the churn.

		-- Pete


From pw at osc.edu  Thu Oct 11 20:38:29 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Thu, 11 Oct 2007 14:38:29 -0400
Subject: [Stgt-devel] iSER tgtd performance
In-Reply-To: <df5c931c0710100135l76d7b3bbrd79d3bbb4fcd69e1@mail.gmail.com>
References: <df5c931c0710090146n5de87f22i41ac0753a8a565a@mail.gmail.com>
	<20071010031745.GC28356@osc.edu>
	<df5c931c0710100135l76d7b3bbrd79d3bbb4fcd69e1@mail.gmail.com>
Message-ID: <20071011183829.GB26746@osc.edu>

nejc.porenta at gmail.com wrote on Wed, 10 Oct 2007 10:35 +0200:
> Yes I have DDR IB cards (and I figured out that that might be the issue).
> 
> I made some additional tests with disktest
> (http://www.open-iscsi.org/bits/disktest.tar.gz). I have added 4GB RAM
> to target machine so now it has 8GB and created several ramdisks and
> testing bandwidth throughput with several clients on same client
> machine. Here are the results:
> - 2GB target: 2 clients - each 280MB/s, 3 clients - each 215MB/s
> - 1GB target: 1 client - 900MB/s, 2 clients - each 350MB/s, 3 clients 238MB/s
> 
> each client had different LUN target.

Wow.  That's not so good how it degrades.  These clients are in
different VMs running on the same host?  I have never tried such
a configuration.  Could it be issues with accessing the NIC?

With two programs, both submitting SCSI commands to the same
kernel, I have not seen any degradation.  But I only tried a single
LUN.

Be sure to watch "vmstat 1" or the blinkie lights on the disk to
make sure you are not falling out of RAM somehow.

Remember you can remove the effect of the RAM disk and OS on the
target by disabling read/write as I mentioned earlier.

> I am planning to do some testing with IOzone or bonnie++, so results
> might follow...
> 
> I use disktest like that:
> ./disktest -PT -T120 -pr -h1 -K1 -B256K -IB /dev/sdb
> 
> I also tried testing target from 2 different machines:
> - 3GB target: 1 client - 440MB/s, 2 clients - each 420MB/s
> - 2GB target: 1 client - 470MB/s, 2 clients - each 470MB/s
> - 1GB target 1 client - 900MB/s, 2 clients - each 850MB/s

Yeah, this is more what one would expect.  Will be interested to see
if you manage further to narrow down the issue with large RAM disks
being significantly slower like that.  I can't think of anything in
the target itself that would cause that---maybe some feature of the
linux VM, or chipset IO TLBs (if you have those), or NIC memory
management and connection switching.

> I had some troubles with HeaderDigest at the beginning so I turned it
> to none and it stayed in my scripts. I tried it now and it is not
> working without it

Thanks for this feedback.  Might be nice for someone to patch up
open-iscsi to disable digests if rdma transport_name is selected.
No reason to force the user to do this step.

> I have also tried tgtd with iSER with TCP connection over IPoIB but
> disktest reported read errors. From the begining everything went just
> fine, but afterwards the read requests started to fail and the
> performance dropped significantly, so I tried iSCSI enterprise target
> software for TCP and it worked well, so I believe that there might be
> a bug in tgtd software but I am unable to reproduce it, because if I
> turn on the debug option, the performance drops because of 100% CPU
> usage on the target. And believe it or not, everything works if CPU
> usage on target is 100%, so there are some issues with highspeed tgtd
> IPoIB target :)

tgtd on TCP on IPoIB does not use iSER.  Just normal TCP.  Unless
you forgot to change the initiator's node.transport_name back to tcp.

Would definitely like to hear more about these non-RDMA problems in
tgtd.  Everything works fine here over 1 Gb/s ethernet TCP and IPoIB
TCP.  Though the latter gets only around 2 Gb/s (with logging off).
If you can narrow things down a bit, it would be helpful.

		-- Pete


From fujita.tomonori at lab.ntt.co.jp  Fri Oct 12 03:48:32 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Fri, 12 Oct 2007 10:48:32 +0900
Subject: [Stgt-devel] iSER
In-Reply-To: <20071011182253.GA26746@osc.edu>
References: <470A4E70.0@Voltaire.COM>
	<20071011145742C.fujita.tomonori@lab.ntt.co.jp>
	<20071011182253.GA26746@osc.edu>
Message-ID: <20071012104832H.fujita.tomonori@lab.ntt.co.jp>

On Thu, 11 Oct 2007 14:22:53 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> fujita.tomonori at lab.ntt.co.jp wrote on Thu, 11 Oct 2007 14:57 +0900:
> > Pete, the iSER patchset is ready for re-submission?
> 
> I think so.  There are no major outstanding issues that I know about
> now.  Let me know if you want to see another round of emails on
> this.  Or we can just iterate on your questions as you view the git.

Can you please submit an updated patchset to the mailing list?

It's easier to review and comment on it. And there might be other
people who are interested in them.


> > BTW, can you elaborate on the following commit?
> > 
> > http://git.osc.edu/?p=tgt.git;a=commit;h=8d9eae7acd041fc10a7cfe560c1c280dcc290fa1
> > 
> > What type of commands hit this bug?
> 
> First, the original commit referred to in that log fixes an issue
> where the target would spin with nothing to do.  A request comes in,
> gets handed off to bs_sync, but the conn->fd was still EPOLLIN |
> EPOLLOUT.  tgtd main thread would keep trying to send something,
> looping.  But now, looking at that old tree, I can't convince myself
> how this was ever a problem.  The only bad thing that happens
> without this old patch, now, is one extra trip through
> iscsi_task_tx_start() which always prints "no more data", but that
> doesn't seem like a huge deal.  Maybe I'm missing something today,
> or was missing something back then.  Or fixed some real bug in the
> interim.
> 
> The new commit you ask about essentially reverts the original
> commit.  The problem I was seeing is that with multiple commands
> outstanding, turning off EPOLLOUT on conn->fd would prohibit any
> task responses from being sent on the connection.  That epoll
> setting is for the entire connection, not for the individual task
> that is just beginning execution.  So you could have 10 tasks on
> task->c_list, waiting to send responses back to the initiator.  Then
> one new request is received and is submitted via
> iscsi_scsi_cmd_execute().  This disables EPOLLOUT, and the waiting
> 10 tasks do not get sent until some other task happens to complete
> in bs_sync and re-enables EPOLLOUT polling on the connection fd.

Thanks. I see the point. Surely we should remove the line:

tgt_event_modify(conn->fd, EPOLLIN);


> The net effect of the two patches is zero.  Just some minor code
> path rewrite with no logic change.  Sorry for the churn.

There is one logic change. The original iscsi_scsi_cmd_execute()
always calls:

static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
{
	struct iscsi_connection *conn = task->conn;
	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
	uint8_t rw = req->flags & ISCSI_FLAG_CMD_WRITE;
	int err = 0;

	if (rw && task->r2t_count) {
		if (!task->unsol_count)
			list_add_tail(&task->c_list, &task->conn->tx_clist);
		goto no_queuing;
	}

	task->offset = 0;  /* for use as transmit pointer for data-ins */
	err = iscsi_target_cmd_queue(task);
no_queuing:
	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);

	return err;
}


Do you think that we need this? I guess that we don't need it but it's
a safer option.


From pw at osc.edu  Fri Oct 12 18:34:58 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Fri, 12 Oct 2007 12:34:58 -0400
Subject: [Stgt-devel] iSER
In-Reply-To: <20071012104832H.fujita.tomonori@lab.ntt.co.jp>
References: <470A4E70.0@Voltaire.COM>
	<20071011145742C.fujita.tomonori@lab.ntt.co.jp>
	<20071011182253.GA26746@osc.edu>
	<20071012104832H.fujita.tomonori@lab.ntt.co.jp>
Message-ID: <20071012163458.GA28286@osc.edu>

fujita.tomonori at lab.ntt.co.jp wrote on Fri, 12 Oct 2007 10:48 +0900:
> Can you please submit an updated patchset to the mailing list?
> 
> It's easier to review and comment on it. And there might be other
> people who are interested in them.

Will do.

> There is one logic change. The original iscsi_scsi_cmd_execute()
> always calls:
> 
> static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
> {
> 	struct iscsi_connection *conn = task->conn;
> 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
> 	uint8_t rw = req->flags & ISCSI_FLAG_CMD_WRITE;
> 	int err = 0;
> 
> 	if (rw && task->r2t_count) {
> 		if (!task->unsol_count)
> 			list_add_tail(&task->c_list, &task->conn->tx_clist);
> 		goto no_queuing;
> 	}
> 
> 	task->offset = 0;  /* for use as transmit pointer for data-ins */
> 	err = iscsi_target_cmd_queue(task);
> no_queuing:
> 	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
> 
> 	return err;
> }
> 
> Do you think that we need this? I guess that we don't need it but it's
> a safer option.

Hrm.  We've decided to execute the task.  But maybe all the data
hasn't arrived yet.  If unsolicited data has all shown up, and we
still need to generate more R2Ts, put task on tx_clist and turn
on EPOLLOUT.  That's pretty straightforward.

But if all the write data is in, and we queue the task to run, there
is no way it will be ready to transmit again.  Until target calls
iscsi_scsi_cmd_done(), which it always does, both for sync and async
backing stores.

So the only way we could need this extra EPOLLOUT line is if there
were a bug elsewhere, in my opinion.  For a sync target, it will
just duplicate the call at the end of cmd_done().  For an async
target, it will force a trip through iscsi_task_tx_start() that
will turn it off as soon as it sees that tx_clist is empty.

I tried it with and without.  Didn't seem to matter.  Extra call
is very fast, sub-microsecond.  You can do a clean revert or take
the patch when I send it---your call.

		-- Pete


From tomof at acm.org  Sun Oct 14 04:15:36 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 14 Oct 2007 11:15:36 +0900
Subject: [Stgt-devel] iSER
In-Reply-To: <20071012163458.GA28286@osc.edu>
References: <20071011182253.GA26746@osc.edu>
	<20071012104832H.fujita.tomonori@lab.ntt.co.jp>
	<20071012163458.GA28286@osc.edu>
Message-ID: <20071014111731D.tomof@acm.org>

On Fri, 12 Oct 2007 12:34:58 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> fujita.tomonori at lab.ntt.co.jp wrote on Fri, 12 Oct 2007 10:48 +0900:
> > Can you please submit an updated patchset to the mailing list?
> > 
> > It's easier to review and comment on it. And there might be other
> > people who are interested in them.
> 
> Will do.

Thanks.


> > There is one logic change. The original iscsi_scsi_cmd_execute()
> > always calls:
> > 
> > static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
> > {
> > 	struct iscsi_connection *conn = task->conn;
> > 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
> > 	uint8_t rw = req->flags & ISCSI_FLAG_CMD_WRITE;
> > 	int err = 0;
> > 
> > 	if (rw && task->r2t_count) {
> > 		if (!task->unsol_count)
> > 			list_add_tail(&task->c_list, &task->conn->tx_clist);
> > 		goto no_queuing;
> > 	}
> > 
> > 	task->offset = 0;  /* for use as transmit pointer for data-ins */
> > 	err = iscsi_target_cmd_queue(task);
> > no_queuing:
> > 	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
> > 
> > 	return err;
> > }
> > 
> > Do you think that we need this? I guess that we don't need it but it's
> > a safer option.
> 
> Hrm.  We've decided to execute the task.  But maybe all the data
> hasn't arrived yet.  If unsolicited data has all shown up, and we
> still need to generate more R2Ts, put task on tx_clist and turn
> on EPOLLOUT.  That's pretty straightforward.
> 
> But if all the write data is in, and we queue the task to run, there
> is no way it will be ready to transmit again.  Until target calls
> iscsi_scsi_cmd_done(), which it always does, both for sync and async
> backing stores.
> 
> So the only way we could need this extra EPOLLOUT line is if there
> were a bug elsewhere, in my opinion.  For a sync target, it will
> just duplicate the call at the end of cmd_done().  For an async
> target, it will force a trip through iscsi_task_tx_start() that
> will turn it off as soon as it sees that tx_clist is empty.

Yeah, I think so.


> I tried it with and without.  Didn't seem to matter.  Extra call
> is very fast, sub-microsecond.  You can do a clean revert or take
> the patch when I send it---your call.

I did a clean revert just because the original code have been tested
for a long time in my lab.

As you said, I think that we don't need to set EPOLLIN|EPOLLOUT there
so I'm happy to change it later on (after lots of testings).


From erezz at Voltaire.COM  Mon Oct 15 11:45:41 2007
From: erezz at Voltaire.COM (Erez Zilber)
Date: Mon, 15 Oct 2007 11:45:41 +0200
Subject: [Stgt-devel] login over iSER without HeaderDigest/DataDigest (was:
	iSER tgtd performance)
In-Reply-To: <20071010031745.GC28356@osc.edu>
References: <df5c931c0710090146n5de87f22i41ac0753a8a565a@mail.gmail.com>
	<20071010031745.GC28356@osc.edu>
Message-ID: <471336C5.20608@Voltaire.COM>


> Scripts look fine.  Is it necessary to turn off HeaderDigest on the
> initiator side?  I had hoped that iscsiadm would realize it was
> asked to use iser and turn off HeaderDigest and DataDigest on its
> own, but never got around to testing that.
>   

open-iscsi handles the HeaderDigest/DataDigest issue. You can use the 
iscsi_discovery script (which is in open-iscsi tree). It is easier to 
use than running iscsiadm. It does the following:

    * Discovers the node
    * Tries to connect & login over iSER (without
      HeaderDigest/DataDigest). If it's successful, it sets the node's
      transport to iSER. Else, it sets it to TCP.
    * Logs out (if necessary)

Erez


From pw at osc.edu  Mon Oct 15 23:00:29 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Mon, 15 Oct 2007 17:00:29 -0400
Subject: [Stgt-devel] login over iSER without HeaderDigest/DataDigest
	(was: iSER	tgtd performance)
In-Reply-To: <471336C5.20608@Voltaire.COM>
References: <df5c931c0710090146n5de87f22i41ac0753a8a565a@mail.gmail.com>
	<20071010031745.GC28356@osc.edu> <471336C5.20608@Voltaire.COM>
Message-ID: <20071015210029.GA11086@osc.edu>

erezz at Voltaire.COM wrote on Mon, 15 Oct 2007 11:45 +0200:
> open-iscsi handles the HeaderDigest/DataDigest issue. You can use the 
> iscsi_discovery script (which is in open-iscsi tree). It is easier to 
> use than running iscsiadm. It does the following:
> 
>    * Discovers the node
>    * Tries to connect & login over iSER (without
>      HeaderDigest/DataDigest). If it's successful, it sets the node's
>      transport to iSER. Else, it sets it to TCP.
>    * Logs out (if necessary)

Maybe that is the better approach---script these sorts of things up
in userspace rather than make guesses in iscsid.  (User wants iSER
and HeaderDigest.  Switch to TCP or disable digest?)

		-- Pete


From pw at osc.edu  Tue Oct 16 17:20:21 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:20:21 -0400
Subject: [Stgt-devel] [PATCH 08/20] iser virtualize malloc
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <8d2b6cf668663c5ea180d67c60c865cf3fa249de.1192554396.git.pw@osc.edu>

Virtualize malloc and free when dealing with memory that the
transport will use.  It must be per-connection for RDMA.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |   14 ++++++++++++++
 usr/iscsi/iscsid.c    |    8 ++++----
 usr/iscsi/transport.h |    4 ++++
 3 files changed, 22 insertions(+), 4 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index c775594..0d189c7 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -241,6 +241,18 @@ void iscsi_event_modify(int fd, int events)
 		eprintf("tgt_event_modify failed\n");
 }
 
+void *iscsi_tcp_malloc(struct iscsi_connection *conn __attribute__((unused)),
+		       size_t sz)
+{
+	return malloc(sz);
+}
+
+void iscsi_tcp_free(struct iscsi_connection *conn __attribute__((unused)),
+		    void *buf)
+{
+	free(buf);
+}
+
 struct iscsi_transport iscsi_tcp = {
 	.name			= "iscsi",
 	.rdma			= 0,
@@ -251,4 +263,6 @@ struct iscsi_transport iscsi_tcp = {
 	.ep_close		= iscsi_tcp_close,
 	.ep_show		= iscsi_tcp_show,
 	.ep_event_modify	= iscsi_event_modify,
+	.ep_malloc		= iscsi_tcp_malloc,
+	.ep_free		= iscsi_tcp_free,
 };
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 8463947..59f226c 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -967,7 +967,7 @@ iscsi_alloc_task(struct iscsi_connection *conn, int ext_len)
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
 	struct iscsi_task *task;
 
-	task = malloc(sizeof(*task) + ext_len);
+	task = conn->tp->ep_malloc(conn, sizeof(*task) + ext_len);
 	if (!task)
 		return NULL;
 	memset(task, 0, sizeof(*task));
@@ -989,8 +989,8 @@ void iscsi_free_task(struct iscsi_task *task)
 	struct iscsi_connection *conn = task->conn;
 
 	if (task->addr && task->addr != (unsigned long) task->data)
-		free((void *) (unsigned long) task->addr);
-	free(task);
+		conn->tp->ep_free(conn, (void *) (unsigned long) task->addr);
+	conn->tp->ep_free(conn, task);
 	/* from alloc */
 	conn_put(conn);
 }
@@ -1129,7 +1129,7 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 			void *buf;
 
 			len = roundup(task->read_len, 4);
-			buf = malloc(len);
+			buf = conn->tp->ep_malloc(conn, len);
 			if (!buf)
 				return -ENOMEM;
 			scmd->bidi_uaddr = (unsigned long) buf;
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index 9660396..c37d0da 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -1,6 +1,8 @@
 #ifndef __TRANSPORT_H
 #define __TRANSPORT_H
 
+struct iscsi_connection;
+
 struct iscsi_transport {
 	const char *name;
 	int rdma;
@@ -12,6 +14,8 @@ struct iscsi_transport {
 	size_t (*ep_close) (int ep);
 	int (*ep_show) (int ep, char *buf, int rest);
 	void (*ep_event_modify) (int ep, int events);
+	void *(*ep_malloc) (struct iscsi_connection *conn, size_t sz);
+	void (*ep_free) (struct iscsi_connection *conn, void *buf);
 };
 
 extern struct iscsi_transport iscsi_tcp;
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:19:07 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:19:07 -0400
Subject: [Stgt-devel] [PATCH 06/20] iser list del init
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <bdd74df53ac270f481d5932040e662cf94951660.1192554396.git.pw@osc.edu>

Add this handy function for removing an item from a list and
initializing its list pointers.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/list.h |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/usr/list.h b/usr/list.h
index 3e85c9b..d2e0019 100644
--- a/usr/list.h
+++ b/usr/list.h
@@ -83,4 +83,10 @@ static inline void list_del(struct list_head *entry)
 	entry->next = entry->prev = NULL;
 }
 
+static inline void list_del_init(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	INIT_LIST_HEAD(entry);
+}
+
 #endif
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:19:51 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:19:51 -0400
Subject: [Stgt-devel] [PATCH 07/20] iser virtualize event modify
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <6f71376b0db8fe6819ff2577abe75d5f2c6b7fae.1192554396.git.pw@osc.edu>

Make event modification a transport-specific operation.  TCP
has a nice transmit flow control mechanism that relies on
checking that the socket is writeable.  RDMA cannot take
advantage of this.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |   26 ++++++++++++++++++--------
 usr/iscsi/iscsid.c    |   20 +++++++++++---------
 usr/iscsi/transport.h |    1 +
 3 files changed, 30 insertions(+), 17 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 0c35aa5..c775594 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -232,13 +232,23 @@ static int iscsi_tcp_show(int ep, char *buf, int rest)
 	return total > 0 ? total : 0;
 }
 
+void iscsi_event_modify(int fd, int events)
+{
+	int ret;
+
+	ret = tgt_event_modify(fd, events);
+	if (ret)
+		eprintf("tgt_event_modify failed\n");
+}
+
 struct iscsi_transport iscsi_tcp = {
-	.name		= "iscsi",
-	.rdma		= 0,
-	.ep_init	= iscsi_tcp_init,
-	.ep_read	= iscsi_tcp_read,
-	.ep_write_begin	= iscsi_tcp_write_begin,
-	.ep_write_end	= iscsi_tcp_write_end,
-	.ep_close	= iscsi_tcp_close,
-	.ep_show	= iscsi_tcp_show,
+	.name			= "iscsi",
+	.rdma			= 0,
+	.ep_init		= iscsi_tcp_init,
+	.ep_read		= iscsi_tcp_read,
+	.ep_write_begin		= iscsi_tcp_write_begin,
+	.ep_write_end		= iscsi_tcp_write_end,
+	.ep_close		= iscsi_tcp_close,
+	.ep_show		= iscsi_tcp_show,
+	.ep_event_modify	= iscsi_event_modify,
 };
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 5d90b06..8463947 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1037,7 +1037,7 @@ static int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *scmd)
 	}
 
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
-	tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+	task->conn->tp->ep_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 
 	return 0;
 }
@@ -1167,7 +1167,7 @@ static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 	task->offset = 0;  /* for use as transmit pointer for data-ins */
 	err = iscsi_target_cmd_queue(task);
 no_queuing:
-	tgt_event_modify(conn->fd, EPOLLIN|EPOLLOUT);
+	conn->tp->ep_event_modify(conn->fd, EPOLLIN | EPOLLOUT);
 
 	return err;
 }
@@ -1197,7 +1197,7 @@ static int iscsi_tm_done(struct mgmt_req *mreq)
 		break;
 	}
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
-	tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+	task->conn->tp->ep_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
 	return 0;
 }
 
@@ -1253,7 +1253,8 @@ static int iscsi_task_execute(struct iscsi_task *task)
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_LOGOUT:
 		list_add_tail(&task->c_list, &task->conn->tx_clist);
-		tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+		task->conn->tp->ep_event_modify(task->conn->fd,
+						EPOLLIN | EPOLLOUT);
 		break;
 	case ISCSI_OP_SCSI_CMD:
 		/* convenient directionality for our internal use */
@@ -1273,7 +1274,8 @@ static int iscsi_task_execute(struct iscsi_task *task)
 		err = iscsi_tm_execute(task);
 		if (err) {
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
-			tgt_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+			task->conn->tp->ep_event_modify(task->conn->fd,
+							EPOLLIN | EPOLLOUT);
 		}
 		break;
 	case ISCSI_OP_TEXT:
@@ -1717,7 +1719,7 @@ static int iscsi_task_tx_start(struct iscsi_connection *conn)
 
 nodata:
 	dprintf("no more data\n");
-	tgt_event_modify(conn->fd, EPOLLIN);
+	conn->tp->ep_event_modify(conn->fd, EPOLLIN);
 	return -EAGAIN;
 }
 
@@ -1881,7 +1883,7 @@ again:
 			conn_read_pdu(conn);
 	} else {
 		conn_write_pdu(conn);
-		tgt_event_modify(fd, EPOLLOUT);
+		conn->tp->ep_event_modify(fd, EPOLLOUT);
 		ret = cmnd_execute(conn);
 		if (ret)
 			conn->state = STATE_CLOSE;
@@ -2025,7 +2027,7 @@ static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		else {
 			conn->state = STATE_SCSI;
 			conn_read_pdu(conn);
-			tgt_event_modify(fd, EPOLLIN);
+			conn->tp->ep_event_modify(fd, EPOLLIN);
 		}
 		break;
 	case STATE_EXIT:
@@ -2036,7 +2038,7 @@ static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		break;
 	default:
 		conn_read_pdu(conn);
-		tgt_event_modify(fd, EPOLLIN);
+		conn->tp->ep_event_modify(fd, EPOLLIN);
 		break;
 	}
 }
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index ec34bb0..9660396 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -11,6 +11,7 @@ struct iscsi_transport {
 	void (*ep_write_end)(int ep);
 	size_t (*ep_close) (int ep);
 	int (*ep_show) (int ep, char *buf, int rest);
+	void (*ep_event_modify) (int ep, int events);
 };
 
 extern struct iscsi_transport iscsi_tcp;
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:19:05 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:19:05 -0400
Subject: [Stgt-devel] [PATCH 05/20] iser cpu to be 64
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <e5cfc5455c00b450121a9f6c6e80f6643cecf0bd.1192554396.git.pw@osc.edu>

Define underscore-free 64-bit versions of CPU to big-endian conversions,
for consistency with the rest of iscsi.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.h |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index a8c8cb1..2f6c7c8 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -33,8 +33,10 @@
 
 #define cpu_to_be16(x)	__cpu_to_be16(x)
 #define cpu_to_be32(x)	__cpu_to_be32(x)
+#define cpu_to_be64(x)	__cpu_to_be64(x)
 #define be16_to_cpu(x)	__be16_to_cpu(x)
 #define be32_to_cpu(x)	__be32_to_cpu(x)
+#define be64_to_cpu(x)	__be64_to_cpu(x)
 
 #define ISCSI_NAME_LEN 256
 
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:21:27 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:21:27 -0400
Subject: [Stgt-devel] [PATCH 20/20] iser wait for rdma completion
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <a38a932a9bfedb8e76284f706b40d2ba9debe57a.1192554396.git.pw@osc.edu>

If we just sent a DATA_IN, do not do anything else until the completion
arrives.  Sending the response back to the initiator before the RDMA
completed could be disastrous.  The completion handler will put us back
on the tx list.

Likely very much unneeded.  Local RDMA Write completion means nothing.
Rely on the fact that the Send goes after the RDMA Write operations,
but no need to wait for them to complete, just ensure they all went out.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_rdma.c |   21 +++++++++++++++++----
 usr/iscsi/iscsid.c     |   19 ++++++++++++++-----
 2 files changed, 31 insertions(+), 9 deletions(-)

diff --git a/usr/iscsi/iscsi_rdma.c b/usr/iscsi/iscsi_rdma.c
index f4c6c23..ab4b3f2 100644
--- a/usr/iscsi/iscsi_rdma.c
+++ b/usr/iscsi/iscsi_rdma.c
@@ -94,6 +94,7 @@ struct rdmalist {
 	struct ibv_send_wr wr;
 	struct list_head list;
 	struct iscsi_task *task;  /* to get iser_task for remote stag and va */
+	int final_rdma;
 };
 
 /*
@@ -917,6 +918,14 @@ static void handle_wc(struct ibv_wc *wc)
 
 		iscsi_rdma_event_modify(ci->iscsi_conn, EPOLLIN | EPOLLOUT);
 		list_add(&rdmal->list, &ci->rdmal);
+
+		/* now let it transmit the final response, as we know
+		 * the RDMAs have completed */
+		if (rdmal->final_rdma) {
+			struct iscsi_task *task = rdmal->task;
+			list_add_tail(&task->c_list, &task->conn->tx_clist);
+		}
+
 		if (waiting_rdma_slot) {
 			waiting_rdma_slot = 0;
 			num_tx_ready = 1;
@@ -1374,7 +1383,8 @@ static void iscsi_iser_write_end(struct iscsi_connection *iscsi_conn)
  */
 static int iser_post_rdma_wr(struct conn_info *ci, struct iscsi_task *task,
 			     void *buf, ssize_t size, int op,
-			     uint64_t remote_va, uint32_t remote_rkey)
+			     uint64_t remote_va, uint32_t remote_rkey,
+			     int final_rdma)
 {
 	int ret;
 	struct rdmalist *rdmal;
@@ -1395,6 +1405,8 @@ static int iser_post_rdma_wr(struct conn_info *ci, struct iscsi_task *task,
 	rdmal->wr.wr.rdma.remote_addr = remote_va;
 	rdmal->wr.wr.rdma.rkey = remote_rkey;
 
+	rdmal->final_rdma = final_rdma;
+
 	ret = ibv_post_send(ci->qp_hndl, &rdmal->wr, &bad_wr);
 	if (ret)
 		eprintf("ibv_post_send ret %d\n", ret);
@@ -1423,7 +1435,7 @@ static int iscsi_rdma_rdma_read(struct iscsi_connection *conn)
 		(unsigned long long) itask->rem_write_va);
 
 	ret = iser_post_rdma_wr(ci, task, buf, len, IBV_WR_RDMA_READ,
-				itask->rem_write_va, itask->rem_write_stag);
+				itask->rem_write_va, itask->rem_write_stag, 0);
 	if (ret < 0)
 		return ret;
 
@@ -1448,6 +1460,7 @@ static int iscsi_rdma_rdma_write(struct iscsi_connection *conn)
 	struct iser_task *itask = task->trans_data;
 	struct iscsi_pdu *rsp = &conn->rsp;
 	struct iscsi_data_rsp *datain = (struct iscsi_data_rsp *) &rsp->bhs;
+	int final_rdma = (task->offset == task->len);
 	uint32_t offset;
 	int ret;
 
@@ -1458,7 +1471,7 @@ static int iscsi_rdma_rdma_write(struct iscsi_connection *conn)
 
 	ret = iser_post_rdma_wr(ci, task, rsp->data, rsp->datasize,
 				IBV_WR_RDMA_WRITE, itask->rem_read_va + offset,
-				itask->rem_read_stag);
+				itask->rem_read_stag, final_rdma);
 	if (ret < 0)
 		return ret;
 
@@ -1467,7 +1480,7 @@ static int iscsi_rdma_rdma_write(struct iscsi_connection *conn)
 	 * rdma to finish before sending the completion.  Then we'll stick
 	 * ourselves back on the list.
 	 */
-	if (task->offset == task->len) {
+	if (final_rdma) {
 		iscsi_rdma_event_modify(ci->iscsi_conn, EPOLLIN);
 	} else {
 		/* poke ourselves to do the next rdma */
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 7f882fa..3479ee7 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1708,12 +1708,21 @@ static int iscsi_scsi_cmd_tx_done(struct iscsi_connection *conn)
 	case ISCSI_OP_R2T:
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
-		if (task->offset < task->len || task->result != 0
-		   || task->dir == BIDIRECTIONAL || conn->tp->rdma) {
-			dprintf("more data or sense or bidir %x\n", hdr->itt);
-			list_add_tail(&task->c_list, &task->conn->tx_clist);
-			return 0;
+		if (conn->tp->rdma) {
+			/* keep sending RDMA writes, but wait until they
+			 * are done before sending final response */
+			if (task->offset < task->len)
+			    list_add_tail(&task->c_list, &task->conn->tx_clist);
+		} else {
+			if (task->offset < task->len || task->result != 0
+			   || task->dir == BIDIRECTIONAL) {
+				dprintf("more data or sense or bidir %x\n",
+					hdr->itt);
+				list_add_tail(&task->c_list,
+					      &task->conn->tx_clist);
+			}
 		}
+		break;
 	case ISCSI_OP_SCSI_CMD_RSP:
 		iscsi_free_cmd_task(task);
 		break;
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:18:57 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:18:57 -0400
Subject: [Stgt-devel] [PATCH 03/20] iser transport buf
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <f17443cbe8da015aee7d63a04e7f4ee6094cc831.1192554396.git.pw@osc.edu>

For RDMA, it is often nice to use data from a pool of pre-registered
buffers.  To do this, the transport allocates memory for a response and
passes it down to the devices to fill.  Some operations, though,
allocate their own buffers and return that new memory instead.  These
are usually small and the allocation is just done for convenience to
avoid length bounds checking.  Copy the data into the provided transport
buffer instead.

If the transport does not provide a buffer at cmd->uaddr, the newly
alloced buffer is returned as before.

Also fixes some leaks of these extra buffers in error paths, and cleans
up unreachable code in ibmvio inquiry.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/ibmvio/ibmvio.c |   25 +++++++++----------------
 usr/mmc.c           |    6 ++----
 usr/sbc.c           |    3 +--
 usr/smc.c           |    9 +++++----
 usr/spc.c           |   36 +++++++++++++++++++++++++++---------
 usr/spc.h           |    1 +
 6 files changed, 45 insertions(+), 35 deletions(-)

diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index cdd3782..a0002cf 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -143,10 +143,16 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	uint8_t *data, *scb = cmd->scb;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
+	uint32_t len;
 
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
 
+	dprintf("%x %x\n", scb[1], scb[2]);
+
+	if (scb[1] & 0x3)
+		return spc_inquiry(host_no, cmd);
+
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
@@ -155,23 +161,12 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	}
 	memset(data, 0, pagesize);
 
-	dprintf("%x %x\n", scb[1], scb[2]);
-
-	if (!(scb[1] & 0x3)) {
-		cmd->len = __ibmvio_inquiry(host_no, cmd, data);
-		ret = SAM_STAT_GOOD;
-	} else
-		return spc_inquiry(host_no, cmd);
-
-	if (ret != SAM_STAT_GOOD)
-		goto sense;
-
-	cmd->len = min_t(int, cmd->len, scb[4]);
-	cmd->uaddr = (unsigned long) data;
+	len = __ibmvio_inquiry(host_no, cmd, data);
 
 	if (cmd->dev->lun != cmd->dev_id)
 		data[0] = TYPE_NO_LUN;
 
+	spc_return_buf(cmd, data, min_t(int, len, scb[4]));
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
@@ -194,7 +189,6 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 	struct list_head *dev_list = &cmd->c_target->device_list;
 	uint64_t lun, *data;
 	int idx, alen, oalen, nr_luns, rbuflen = 4096;
-	int *len = &cmd->len;
 	uint8_t *lun_buf = cmd->lun;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
@@ -210,7 +204,6 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 		goto sense;
 	}
 	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long)data;
 
 	alen &= ~(8 - 1);
 	oalen = alen;
@@ -240,7 +233,7 @@ static int ibmvio_report_luns(int host_no, struct scsi_cmd *cmd)
 
 done:
 	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
-	*len = min(oalen, nr_luns * 8 + 8);
+	spc_return_buf(cmd, data, min(oalen, nr_luns * 8 + 8));
 	return SAM_STAT_GOOD;
 sense:
 	*len = 0;
diff --git a/usr/mmc.c b/usr/mmc.c
index 0a0c033..b0b5d41 100644
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -75,7 +75,6 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long) data;
 
 	/* forged for single session data cd only. all iso file fall into this */
 	if (cmd->scb[1] & 0x2) {
@@ -94,7 +93,7 @@ static int mmc_read_toc(int host_no, struct scsi_cmd *cmd)
 		data[6] = 0x01;
 	}
 
-	cmd->len = data[1] + 2;
+	spc_return_buf(cmd, data, data[1] + 2);
 
 	return SAM_STAT_GOOD;
 }
@@ -111,14 +110,13 @@ static int mmc_read_capacity(int host_no, struct scsi_cmd *cmd)
 		return SAM_STAT_CHECK_CONDITION;
 	}
 	memset(data, 0, pagesize);
-	cmd->uaddr = (unsigned long) data;
 
 	size = cmd->dev->size >> MMC_BLK_SHIFT;
 
 	data[0] = (size >> 32) ?
 		__cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
 	data[1] = __cpu_to_be32(1U << MMC_BLK_SHIFT);
-	cmd->len = 8;
+	spc_return_buf(cmd, data, 8);
 
 	return SAM_STAT_GOOD;
 }
diff --git a/usr/sbc.c b/usr/sbc.c
index d862e6b..1a47a24 100644
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -121,15 +121,14 @@ static int sbc_read_capacity(int host_no, struct scsi_cmd *cmd)
 		asc = ASC_INTERNAL_TGT_FAILURE;
 		goto sense;
 	}
-	cmd->uaddr = (unsigned long) data;
 
 	size = cmd->dev->size >> BLK_SHIFT;
 
 	data[0] = (size >> 32) ?
 		__cpu_to_be32(0xffffffff) : __cpu_to_be32(size - 1);
 	data[1] = __cpu_to_be32(1U << BLK_SHIFT);
-	cmd->len = 8;
 
+	spc_return_buf(cmd, data, 8);
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
diff --git a/usr/smc.c b/usr/smc.c
index df38b25..7b99a42 100644
--- a/usr/smc.c
+++ b/usr/smc.c
@@ -282,8 +282,10 @@ static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
 	}
 	memset(data, 0, pagesize);
 
-	if (scb[11])	/* Reserved byte */
+	if (scb[11]) {	/* Reserved byte */
+		free(data);
 		goto sense;
+	}
 
 	switch(element_type) {
 	case ELEMENT_ANY:
@@ -333,6 +335,7 @@ static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
 						  dvcid, voltag);
 		break;
 	default:
+		free(data);
 		goto sense;
 		break;
 	}
@@ -340,10 +343,8 @@ static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
 	/* Lastly, fill in data header */
 	len = element_status_data_hdr(data, dvcid, voltag, first, count);
 
-	cmd->len = min_t(int, len, alloc_len);
-	cmd->uaddr = (unsigned long) data;
 	cmd->rw = READ;
-
+	spc_return_buf(cmd, data, min_t(int, len, alloc_len));
 	return SAM_STAT_GOOD;
 
 sense:
diff --git a/usr/spc.c b/usr/spc.c
index 45a0430..1d7625d 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -140,6 +140,22 @@ void update_vpd_83(struct scsi_lu *lu, void *id)
 	strncpy((char *)data + 4, id, SCSI_ID_LEN);
 }
 
+/*
+ * Helper to move return data into read result buffer allocated by transport,
+ * if one exists.
+ */
+void spc_return_buf(struct scsi_cmd *cmd, void *data, uint32_t len)
+{
+	if (cmd->uaddr) {
+		memcpy((void *) (unsigned long) cmd->uaddr, data,
+		       min(cmd->len, len));
+		free(data);
+	} else {
+		cmd->uaddr = (unsigned long) data;
+	}
+	cmd->len = len;
+}
+
 int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 {
 	int len = 0, ret = SAM_STAT_CHECK_CONDITION;
@@ -234,15 +250,17 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 		}
 	}
 
-	if (ret != SAM_STAT_GOOD)
+	if (ret != SAM_STAT_GOOD) {
+		free(data);
 		goto sense;
+	}
 
-	cmd->len = min_t(int, len, scb[4]);
-	cmd->uaddr = (unsigned long) data;
-
+	if (scb[4] < len)
+	    len = scb[4];
 	if (cmd->dev->lun != cmd->dev_id)
 		data[0] = TYPE_NO_LUN;
 
+	spc_return_buf(cmd, data, len);
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
@@ -297,9 +315,8 @@ int spc_report_luns(int host_no, struct scsi_cmd *cmd)
 		}
 	}
 
-	cmd->uaddr = (unsigned long)data;
 	*((uint32_t *) data) = __cpu_to_be32(nr_luns * 8);
-	cmd->len = min(oalen, nr_luns * 8 + 8);
+	spc_return_buf(cmd, data, min(oalen, nr_luns * 8 + 8));
 	return SAM_STAT_GOOD;
 sense:
 	cmd->len = 0;
@@ -373,7 +390,7 @@ static int build_mode_page(uint8_t *data, struct mode_pg *pg)
 int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 {
 	int len = 0;
-	uint8_t *data, *scb, mode6, dbd, pcode, subpcode;
+	uint8_t *data = NULL, *scb, mode6, dbd, pcode, subpcode;
 	uint16_t alloc_len;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
@@ -436,11 +453,12 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 		data[7] = dbd ? 0 : BLOCK_DESCRIPTOR_LEN;
 	}
 
-	cmd->len = len;
-	cmd->uaddr = (unsigned long)data;
+	spc_return_buf(cmd, data, len);
 	return SAM_STAT_GOOD;
 
 sense:
+	if (data)
+		free(data);
 	cmd->len = 0;
 	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
diff --git a/usr/spc.h b/usr/spc.h
index dfb8987..766212e 100644
--- a/usr/spc.h
+++ b/usr/spc.h
@@ -1,6 +1,7 @@
 #ifndef __SPC_H
 #define __SPC_H
 
+extern void spc_return_buf(struct scsi_cmd *cmd, void *data, uint32_t len);
 extern int spc_inquiry(int host_no, struct scsi_cmd *cmd);
 extern int spc_report_luns(int host_no, struct scsi_cmd *cmd);
 extern int spc_start_stop(int host_no, struct scsi_cmd *cmd);
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:21:23 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:21:23 -0400
Subject: [Stgt-devel] [PATCH 14/20] iser transport mxdsl
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <005fd62cf055ec62b662d6de8491d54325917476.1192554396.git.pw@osc.edu>

The RDMA transport chooses the size for data-in and data-out
transfers, as these operations are not visible to the initiator.
MaxXmitDataSegmentLength applies only to control-type PDUs, not
to RDMA data transfers.  Add a per-connection parameter to hold
the data transfer size chosen by the transport, with the proper
default for TCP.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/conn.c   |    2 ++
 usr/iscsi/iscsid.c |   16 ++++++++++------
 usr/iscsi/iscsid.h |    1 +
 3 files changed, 13 insertions(+), 6 deletions(-)

diff --git a/usr/iscsi/conn.c b/usr/iscsi/conn.c
index 9b0c3b9..b1d3937 100644
--- a/usr/iscsi/conn.c
+++ b/usr/iscsi/conn.c
@@ -65,6 +65,8 @@ struct iscsi_connection *conn_alloc(unsigned int trans_len)
 	conn->refcount = 1;
 	conn->state = STATE_FREE;
 	param_set_defaults(conn->session_param, session_keys);
+	conn->data_inout_max_size =
+		conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
 
 	INIT_LIST_HEAD(&conn->clist);
 	INIT_LIST_HEAD(&conn->tx_clist);
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 0d7ad43..8b7b48e 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -474,6 +474,10 @@ static void login_finish(struct iscsi_connection *conn)
 
 	switch (conn->session_type) {
 	case SESSION_NORMAL:
+		/* update based on negotiations (but conn_init can override) */
+		conn->data_inout_max_size =
+			conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
+
 		/*
 		 * Allocate transport resources for this connection.
 		 */
@@ -916,7 +920,6 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_data_rsp *rsp = (struct iscsi_data_rsp *) &conn->rsp.bhs;
 	int datalen;
-	int max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
 
 	memset(rsp, 0, sizeof(*rsp));
 	rsp->opcode = ISCSI_OP_SCSI_DATA_IN;
@@ -929,9 +932,10 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 	datalen = min_t(uint32_t, task->read_len, task->len);
 	datalen -= task->offset;
 
-	dprintf("%d %d %d %d %x\n", datalen, task->read_len, task->len, max_burst, rsp->itt);
+	dprintf("%d %d %d %d %x\n", datalen, task->read_len, task->len,
+		conn->data_inout_max_size, rsp->itt);
 
-	if (datalen <= max_burst) {
+	if (datalen <= conn->data_inout_max_size) {
 		rsp->flags = ISCSI_FLAG_CMD_FINAL;
 
 		/* collapse status into final packet if successful */
@@ -942,7 +946,7 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 			calc_residual((struct iscsi_cmd_rsp *) rsp, task);
 		}
 	} else
-		datalen = max_burst;
+		datalen = conn->data_inout_max_size;
 
 	rsp->exp_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn);
 	rsp->max_cmdsn = cpu_to_be32(conn->session->exp_cmd_sn + MAX_QUEUE_CMD);
@@ -961,7 +965,7 @@ static int iscsi_r2t_build(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_r2t_rsp *rsp = (struct iscsi_r2t_rsp *) &conn->rsp.bhs;
-	int length, max_burst = conn->session_param[ISCSI_PARAM_MAX_XMIT_DLENGTH].val;
+	int length;
 
 	memset(rsp, 0, sizeof(*rsp));
 
@@ -973,7 +977,7 @@ static int iscsi_r2t_build(struct iscsi_task *task)
 	rsp->r2tsn = cpu_to_be32(task->exp_r2tsn++);
 	rsp->data_offset = cpu_to_be32(task->offset);
 	rsp->ttt = (unsigned long) task;
-	length = min(task->r2t_count, max_burst);
+	length = min(task->r2t_count, conn->data_inout_max_size);
 	rsp->data_length = cpu_to_be32(length);
 
 	return 0;
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 915c47d..c1fab67 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -141,6 +141,7 @@ struct iscsi_connection {
 
 	int tid;
 	struct param session_param[ISCSI_PARAM_MAX];
+	int data_inout_max_size;
 
 	char *initiator;
 	uint8_t isid[6];
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:21:23 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:21:23 -0400
Subject: [Stgt-devel] [PATCH 15/20] iser rounding
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <6dae60a5f3d8f3947bceeb57f3c7c4bcead8fadb.1192554396.git.pw@osc.edu>

RDMA data packets are not padded up to 4 byte boundaries, unlike TCP.
Reasons for this can be found in doc/README.iser.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |   24 +++++++++++++++++-------
 1 files changed, 17 insertions(+), 7 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 8b7b48e..6d5471e 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1157,7 +1157,9 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 			uint32_t len;
 			void *buf;
 
-			len = roundup(task->read_len, 4);
+			len = task->read_len;
+			if (!conn->tp->rdma)
+				len = roundup(len, 4);
 			buf = conn->tp->ep_malloc(conn, len);
 			if (!buf)
 				return -ENOMEM;
@@ -1423,8 +1425,12 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 	int ahs_len, imm_len, data_len, task_len;
 
 	ahs_len = roundup(req->hlength * 4, 4);
-	imm_len = roundup(ntoh24(req->dlength), 4);
-	data_len = roundup(ntohl(req->data_length), 4);
+	imm_len = ntoh24(req->dlength);
+	data_len = ntohl(req->data_length);
+	if (!conn->tp->rdma) {
+		imm_len = roundup(imm_len, 4);
+		data_len = roundup(data_len, 4);
+	}
 
 	dprintf("%u %x %d %d %d %x %x\n", conn->session->tsih,
 		req->cdb[0], ahs_len, imm_len, data_len,
@@ -1808,7 +1814,7 @@ again:
 		}
 		conn->req.ahssize = conn->req.bhs.hlength * 4;
 		conn->req.datasize = ntoh24(conn->req.bhs.dlength);
-		conn->rx_size = roundup(conn->req.ahssize, 4);
+		conn->rx_size = conn->req.ahssize;
 		if (conn->rx_size) {
 			conn->rx_buffer = conn->req.ahs;
 			conn->rx_iostate = IOSTATE_RX_AHS;
@@ -1857,7 +1863,10 @@ again:
 		}
 		conn->rx_iostate = IOSTATE_RX_INIT_DATA;
 	case IOSTATE_RX_INIT_DATA:
-		conn->rx_size = roundup(conn->req.datasize, 4);
+		if (conn->tp->rdma)
+			conn->rx_size = conn->req.datasize;
+		else
+			conn->rx_size = roundup(conn->req.datasize, 4);
 		if (conn->rx_size) {
 			conn->rx_iostate = IOSTATE_RX_DATA;
 			conn->rx_buffer = conn->req.data;
@@ -1997,12 +2006,13 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 			break;
 	case IOSTATE_TX_INIT_DATA:
 		if (conn->rsp.datasize) {
-			int pad;
+			int pad = 0;
 
 			conn->tx_iostate = IOSTATE_TX_DATA;
 			conn->tx_buffer = conn->rsp.data;
 			conn->tx_size = conn->rsp.datasize;
-			pad = conn->tx_size & (PAD_WORD_LEN - 1);
+			if (!conn->tp->rdma)
+				pad = conn->tx_size & (PAD_WORD_LEN - 1);
 			if (pad) {
 				pad = PAD_WORD_LEN - pad;
 				memset(conn->tx_buffer + conn->tx_size, 0, pad);
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:42:06 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:42:06 -0400
Subject: [Stgt-devel] [PATCH 12/20] iser task transport data
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <0fedc67b8354029f7a5780ab291a1afeebc9493f.1192554396.git.pw@osc.edu>

RDMA will need to store some per-task data to use initiator-provided tags
in later RDMA operations.  Provide some space for this and hook into the
transport at task initialization time.

Based on the patch by Erez Zilber <erezz at voltaire.com>.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |    6 ++++++
 usr/iscsi/iscsid.c    |   15 ++++++++++++---
 usr/iscsi/iscsid.h    |    8 ++++----
 usr/iscsi/transport.h |    3 +++
 4 files changed, 25 insertions(+), 7 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 566dd9e..53cf0e5 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -215,6 +215,10 @@ static int iscsi_tcp_conn_init(struct iscsi_connection *conn)
 	return 0;
 }
 
+static void iscsi_tcp_task_init(struct iscsi_task *task)
+{
+}
+
 static size_t iscsi_tcp_read(struct iscsi_connection *conn, void *buf,
 			     size_t nbytes)
 {
@@ -316,8 +320,10 @@ int iscsi_tcp_getpeername(struct iscsi_connection *conn, struct sockaddr *sa,
 struct iscsi_transport iscsi_tcp = {
 	.name			= "iscsi",
 	.rdma			= 0,
+	.task_trans_len		= 0,
 	.ep_init		= iscsi_tcp_init,
 	.ep_conn_init		= iscsi_tcp_conn_init,
+	.ep_task_init		= iscsi_tcp_task_init,
 	.ep_read		= iscsi_tcp_read,
 	.ep_write_begin		= iscsi_tcp_write_begin,
 	.ep_write_end		= iscsi_tcp_write_end,
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 27b17f4..0d7ad43 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -985,18 +985,25 @@ iscsi_alloc_task(struct iscsi_connection *conn, int ext_len)
 	struct iscsi_hdr *req = (struct iscsi_hdr *) &conn->req.bhs;
 	struct iscsi_task *task;
 
-	task = conn->tp->ep_malloc(conn, sizeof(*task) + ext_len);
+	task = conn->tp->ep_malloc(conn, sizeof(*task) +
+				   conn->tp->task_trans_len + ext_len);
 	if (!task)
 		return NULL;
-	memset(task, 0, sizeof(*task));
+	memset(task, 0, sizeof(*task) + conn->tp->task_trans_len);
 
 	memcpy(&task->req, req, sizeof(*req));
 	task->conn = conn;
 	INIT_LIST_HEAD(&task->c_hlist);
 	INIT_LIST_HEAD(&task->c_list);
 
-	if (ext_len)
+	if (conn->tp->task_trans_len)
+		task->trans_data = (void *) &task[1];
+
+	if (ext_len) {
+		task->extdata = (void *)((uintptr_t) &task[1] +
+				      conn->tp->task_trans_len);
 		task->data = task->extdata;
+	}
 
 	conn_get(conn);
 	return task;
@@ -1430,6 +1437,8 @@ static int iscsi_scsi_cmd_rx_start(struct iscsi_connection *conn)
 
 	task->tag = req->itt;
 
+	conn->tp->ep_task_init(task);
+
 	if (ahs_len) {
 		task->ahs = task->data + sizeof(req->cdb);
 		task->data = task->ahs + ahs_len;
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index d4b4799..915c47d 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -122,12 +122,12 @@ struct iscsi_task {
 	int unsol_count;
 	int exp_r2tsn;
 
-	void *ahs;
-	void *data;
-
 	struct scsi_cmd scmd;
 
-	unsigned long extdata[0];
+	void *trans_data;   /* transport specific data */
+	void *extdata;      /* extra data, after transport, incl ahs and data */
+	void *ahs;
+	void *data;
 };
 
 struct iscsi_connection {
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index 3421371..a8b8680 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -4,13 +4,16 @@
 #include <sys/socket.h>
 
 struct iscsi_connection;
+struct iscsi_task;
 
 struct iscsi_transport {
 	const char *name;
 	int rdma;
+	int task_trans_len;
 
 	int (*ep_init) (void);
 	int (*ep_conn_init) (struct iscsi_connection *conn);
+	void (*ep_task_init) (struct iscsi_task *task);
 	size_t (*ep_read) (struct iscsi_connection *conn, void *buf,
 			   size_t nbytes);
 	size_t (*ep_write_begin) (struct iscsi_connection *conn, void *buf,
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:21:26 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:21:26 -0400
Subject: [Stgt-devel] [PATCH 19/20] iser flush before disconn
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <9388035f4da72b26d0dde09445776bc84b0cf861.1192554396.git.pw@osc.edu>

It sometimes happens that the CQ will have a flushed work request
before we have gotten around to picking up the CM disconnect event.
Don't exit if this happens, just complain a bit.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_rdma.c |   35 +++++++++++++++++------------------
 1 files changed, 17 insertions(+), 18 deletions(-)

diff --git a/usr/iscsi/iscsi_rdma.c b/usr/iscsi/iscsi_rdma.c
index 9e6bac6..f4c6c23 100644
--- a/usr/iscsi/iscsi_rdma.c
+++ b/usr/iscsi/iscsi_rdma.c
@@ -1045,27 +1045,26 @@ static void iser_rx_progress_one(struct iser_device *dev)
 		}
 
 		VALGRIND_MAKE_MEM_DEFINED(&wc, sizeof(wc));
-		if (wc.status != IBV_WC_SUCCESS) {
-			if (wc.status == IBV_WC_WR_FLUSH_ERR) {
-				recvl = ptr_from_int64(wc.wr_id);
-				ci = recvl->conn;
-				if (ci->draining) {
-					--ci->recvl_posted;
-					if (ci->freed && ci->recvl_posted == 0)
-						iscsi_rdma_conn_free(
-							ci->iscsi_conn);
-					continue;
-				}
+		if (wc.status == IBV_WC_SUCCESS) {
+			handle_wc(&wc);
+			if (++numwc == MAX_RX_PROGRESS) {
+				num_rx_ready = 1;
+				break;
+			}
+		} else if (wc.status == IBV_WC_WR_FLUSH_ERR) {
+			recvl = ptr_from_int64(wc.wr_id);
+			ci = recvl->conn;
+			if (ci->draining) {
+				--ci->recvl_posted;
+				if (ci->freed && ci->recvl_posted == 0)
+					iscsi_rdma_conn_free(ci->iscsi_conn);
+			} else {
+				eprintf("conn %p flush recv\n", ci);
+				/* call disconnect now? */
 			}
+		} else {
 			eprintf("bad WC status %d for wr_id 0x%llx\n",
 				wc.status, (unsigned long long) wc.wr_id);
-			exit(1);
-		}
-
-		handle_wc(&wc);
-		if (++numwc == MAX_RX_PROGRESS) {
-			num_rx_ready = 1;
-			break;
 		}
 	}
 }
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:21:24 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:21:24 -0400
Subject: [Stgt-devel] [PATCH 16/20] iser params
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <f95af5713c1de674b0792b7742c6babe91c7be83.1192554396.git.pw@osc.edu>

Add iSCSI parameters as defined in the draft iSER specification.
Handle special parameter cases for RDMA:

    - no digests
    - do not offer iSER parameters unless initiator requests them
    - do not offer MRDSL (use [IT]RDSL instead)

Except do not advertise MaxOutstandingUnexpectedPDUs just yet, as
the open-iscsi initiatior does not understand it.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_if.h |    5 +++++
 usr/iscsi/iscsid.c   |   21 ++++++++++++++++++++-
 usr/iscsi/param.c    |   38 ++++++++++++++++++++++++++++++++++++++
 usr/iscsi/target.c   |    8 ++++++++
 4 files changed, 71 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/iscsi_if.h b/usr/iscsi/iscsi_if.h
index 58a76a2..b4f1e04 100644
--- a/usr/iscsi/iscsi_if.h
+++ b/usr/iscsi/iscsi_if.h
@@ -215,6 +215,11 @@ enum iscsi_param {
 	ISCSI_PARAM_OFMARKINT,
 	ISCSI_PARAM_IFMARKINT,
 	ISCSI_PARAM_MAXCONNECTIONS,
+	/* iSER draft */
+	ISCSI_PARAM_RDMA_EXTENSIONS,
+	ISCSI_PARAM_TARGET_RDSL,
+	ISCSI_PARAM_INITIATOR_RDSL,
+	ISCSI_PARAM_MAX_OUTST_PDU,
 	/* must always be last */
 	ISCSI_PARAM_MAX,
 };
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 6d5471e..d7c7128 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -270,7 +270,7 @@ static void login_security_done(struct iscsi_connection *conn)
 static void text_scan_login(struct iscsi_connection *conn)
 {
 	char *key, *value, *data;
-	int datasize, idx;
+	int datasize, idx, is_rdma = 0;
 	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *)&conn->rsp.bhs;
 
 	data = conn->req.data;
@@ -289,6 +289,9 @@ static void text_scan_login(struct iscsi_connection *conn)
 			if (idx == ISCSI_PARAM_MAX_RECV_DLENGTH)
 				idx = ISCSI_PARAM_MAX_XMIT_DLENGTH;
 
+			if (idx == ISCSI_PARAM_RDMA_EXTENSIONS)
+				is_rdma = 1;
+
 			if (param_str_to_val(session_keys, idx, value, &val) < 0) {
 				if (conn->session_param[idx].state
 				    == KEY_STATE_START) {
@@ -335,6 +338,15 @@ static void text_scan_login(struct iscsi_connection *conn)
 			text_key_add(conn, key, "NotUnderstood");
 	}
 
+	if (is_rdma) {
+		/* do not try to do digests, not supported in iser */
+		conn->session_param[ISCSI_PARAM_HDRDGST_EN].val = DIGEST_NONE;
+		conn->session_param[ISCSI_PARAM_DATADGST_EN].val = DIGEST_NONE;
+	} else {
+		/* do not offer RDMA, initiator must explicitly request */
+		conn->session_param[ISCSI_PARAM_RDMA_EXTENSIONS].val = 0;
+	}
+
 out:
 	return;
 }
@@ -354,6 +366,13 @@ static int text_check_param(struct iscsi_connection *conn)
 					p[i].state = KEY_STATE_DONE;
 					continue;
 				}
+				if (p[ISCSI_PARAM_RDMA_EXTENSIONS].val == 1) {
+					if (i == ISCSI_PARAM_MAX_RECV_DLENGTH)
+						continue;
+				} else {
+					if (i >= ISCSI_PARAM_RDMA_EXTENSIONS)
+						continue;
+				}
 				memset(buf, 0, sizeof(buf));
 				param_val_to_str(session_keys, i, p[i].val,
 						 buf);
diff --git a/usr/iscsi/param.c b/usr/iscsi/param.c
index 9eac62c..76236d1 100644
--- a/usr/iscsi/param.c
+++ b/usr/iscsi/param.c
@@ -118,6 +118,18 @@ static int minimum_check_val(struct iscsi_key *key, unsigned int *val)
 	return 0;
 }
 
+static int min_or_zero_check_val(struct iscsi_key *key, unsigned int *val)
+{
+	int err = 0;
+
+	if (*val != 0 && (*val < key->min || key->max < *val)) {
+		*val = key->min;
+		err = -EINVAL;
+	}
+
+	return 0;
+}
+
 static int maximum_check_val(struct iscsi_key *key, unsigned int *val)
 {
 	int err = 0;
@@ -140,6 +152,16 @@ static int minimum_set_val(struct param *param, int idx, unsigned int *val)
 	return 0;
 }
 
+static int min_or_zero_set_val(struct param *param, int idx, unsigned int *val)
+{
+	if (*val > param[idx].val || *val == 0)
+		*val = param[idx].val;
+	else
+		param[idx].val = *val;
+
+	return 0;
+}
+
 static int maximum_set_val(struct param *param, int idx, unsigned int *val)
 {
 	if (param[idx].val > *val)
@@ -265,6 +287,13 @@ static struct iscsi_key_ops minimum_ops = {
 	.set_val = minimum_set_val,
 };
 
+static struct iscsi_key_ops min_or_zero_ops = {
+	.val_to_str = range_val_to_str,
+	.str_to_val = range_str_to_val,
+	.check_val = min_or_zero_check_val,
+	.set_val = min_or_zero_set_val,
+};
+
 static struct iscsi_key_ops maximum_ops = {
 	.val_to_str = range_val_to_str,
 	.str_to_val = range_str_to_val,
@@ -345,6 +374,15 @@ struct iscsi_key session_keys[] = {
 	{"IFMarkInt", 2048, 1, 65535, &marker_ops},
 	[ISCSI_PARAM_MAXCONNECTIONS] =
 	{"MaxConnections", 1, 1, 65535, &minimum_ops},
+	/* iSER draft */
+	[ISCSI_PARAM_RDMA_EXTENSIONS] =
+	{"RDMAExtensions", 0, 0, 1, &and_ops},
+	[ISCSI_PARAM_TARGET_RDSL] =
+	{"TargetRecvDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_INITIATOR_RDSL] =
+	{"InitiatorRecvDataSegmentLength", 8192, 512, 16777215, &minimum_ops},
+	[ISCSI_PARAM_MAX_OUTST_PDU] =
+	{"MaxOutstandingUnexpectedPDUs", 0, 2, 4294967295U, &min_or_zero_ops},
 	[ISCSI_PARAM_MAX] =
 	{NULL,},
 };
diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
index ab0685f..d7c1d57 100644
--- a/usr/iscsi/target.c
+++ b/usr/iscsi/target.c
@@ -283,6 +283,14 @@ int iscsi_target_create(struct target *t)
 		[ISCSI_PARAM_OFMARKINT] = {0, 2048},
 		[ISCSI_PARAM_IFMARKINT] = {0, 2048},
 		[ISCSI_PARAM_MAXCONNECTIONS] = {0, 1},
+#ifdef ISCSI_RDMA
+		[ISCSI_PARAM_RDMA_EXTENSIONS] = {0, 1},
+#else
+		[ISCSI_PARAM_RDMA_EXTENSIONS] = {0, 0},
+#endif
+		[ISCSI_PARAM_TARGET_RDSL] = {0, 262144},
+		[ISCSI_PARAM_INITIATOR_RDSL] = {0, 262144},
+		[ISCSI_PARAM_MAX_OUTST_PDU] =  {0, 0},  /* not in open-iscsi */
 	};
 
 	target = malloc(sizeof(*target));
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:21:25 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:21:25 -0400
Subject: [Stgt-devel] [PATCH 18/20] iser core
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <1bf0a2c95f1f14897186ad57628c0c159229adc1.1192554396.git.pw@osc.edu>

Core iSCSI RDMA support.  Adds the iscsi_rdma.c file that implements the
RDMA transport.  Enabled only if ISCSI_RDMA is defined during the build,
in which case RDMA libraries and headers must be present on the system.

The iscsi TX handler redirects R2T and DATA_IN packets to new transport
functions for RDMA mode.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/Makefile           |    5 +
 usr/iscsi/iscsi_rdma.c | 1688 ++++++++++++++++++++++++++++++++++++++++++++++++
 usr/iscsi/iscsid.c     |   25 +
 usr/iscsi/transport.c  |    3 +
 usr/iscsi/transport.h  |    3 +
 5 files changed, 1724 insertions(+), 0 deletions(-)
 create mode 100644 usr/iscsi/iscsi_rdma.c

diff --git a/usr/Makefile b/usr/Makefile
index addf5be..745eaba 100644
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -38,6 +38,11 @@ TGTD_OBJS += $(addprefix iscsi/, conn.o param.o session.o \
 		isns.o libcrc32c.o)
 TGTD_OBJS += bs_sync.o
 LIBS += -lcrypto -lpthread
+ifneq ($(ISCSI_RDMA),)
+CFLAGS += -DISCSI_RDMA
+TGTD_OBJS += iscsi/iscsi_rdma.o
+LIBS += -libverbs -lrdmacm
+endif
 endif
 
 ifneq ($(FCP),)
diff --git a/usr/iscsi/iscsi_rdma.c b/usr/iscsi/iscsi_rdma.c
new file mode 100644
index 0000000..9e6bac6
--- /dev/null
+++ b/usr/iscsi/iscsi_rdma.c
@@ -0,0 +1,1688 @@
+/*
+ * iSCSI extensions for RDMA (iSER) data path
+ *
+ * Copyright (C) 2007 Dennis Dalessandro (dennis at osc.edu)
+ * Copyright (C) 2007 Ananth Devulapalli (ananth at osc.edu)
+ * Copyright (C) 2007 Pete Wyckoff (pw at osc.edu)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <assert.h>
+#include <netdb.h>
+#include <sys/epoll.h>
+#include <infiniband/verbs.h>
+#include <rdma/rdma_cma.h>
+
+#include "util.h"
+#include "iscsid.h"
+
+#if defined(HAVE_VALGRIND) && !defined(NDEBUG)
+#include <valgrind/memcheck.h>
+#else
+#define VALGRIND_MAKE_MEM_DEFINED(addr, len)
+#endif
+
+/*
+ * The IB-extended version from the kernel.  Stags and VAs are in
+ * big-endian format.
+ */
+struct iser_hdr {
+	uint8_t   flags;
+	uint8_t   rsvd[3];
+	uint32_t  write_stag; /* write rkey */
+	uint64_t  write_va;
+	uint32_t  read_stag;  /* read rkey */
+	uint64_t  read_va;
+} __attribute__((packed));
+
+#define ISER_WSV	(0x08)
+#define ISER_RSV	(0x04)
+#define ISCSI_CTRL	(0x10)
+#define ISER_HELLO	(0x20)
+#define ISER_HELLORPLY	(0x30)
+
+struct conn_info;
+
+/*
+ * Posted receives for control messages.  All must start with the conn
+ * pointer, which will be followed up from a work request during a flush,
+ * when it is not known what type to expect.
+ */
+struct recvlist {
+	struct conn_info *conn;
+	struct ibv_sge sge;
+	void *buf;
+	struct ibv_recv_wr wr;
+	unsigned long bytes_recvd;
+};
+
+/*
+ * Posted sends for control messages.
+ */
+struct sendlist {
+	struct conn_info *conn;
+	struct ibv_sge sge;
+	void *buf;
+	struct ibv_send_wr wr;
+	struct list_head list;
+};
+
+/*
+ * RDMA read and write operations.
+ */
+struct rdmalist {
+	struct conn_info *conn;
+	struct ibv_sge sge;
+	struct ibv_send_wr wr;
+	struct list_head list;
+	struct iscsi_task *task;  /* to get iser_task for remote stag and va */
+};
+
+/*
+ * Each SCSI command may have its own RDMA parameters.  These appear on
+ * the connection then later are assigned to the particular task to be
+ * used when the target responds.
+ */
+struct iser_task {
+	/* read and write from the initiator's point of view */
+	uint32_t rem_read_stag, rem_write_stag;
+	uint64_t rem_read_va, rem_write_va;
+};
+
+struct iser_device;
+
+/*
+ * Parallels iscsi_connection.  Adds more fields for iser.
+ */
+struct conn_info {
+	struct ibv_qp *qp_hndl;
+	struct rdma_cm_id *cma_id;
+	struct iscsi_connection *iscsi_conn;
+	struct iser_device *dev;
+	struct sockaddr_storage peer_addr;  /* initiator address */
+	struct sockaddr_storage self_addr;  /* target address */
+	unsigned int ssize, rsize, max_outst_pdu;
+	unsigned int readb, writeb;
+
+	/* read and write from the initiator's point of view */
+	uint32_t rem_read_stag, rem_write_stag;
+	uint64_t rem_read_va, rem_write_va;
+
+	enum {
+	    LOGIN_PHASE_START,      /* keep 1 send spot and 1 recv posted */
+	    LOGIN_PHASE_LAST_SEND,  /* need 1 more send before ff */
+	    LOGIN_PHASE_FF,         /* full feature */
+	} login_phase;
+
+	void *srbuf;    /* registered space for non-rdma send and recv */
+	void *listbuf;  /* space for the send, recv, rdma list elements */
+	struct ibv_mr *srmr;   /* mr for registered srbuf */
+
+	/* lists of free send, rdma slots */
+	struct list_head sendl, rdmal;
+
+	/* no recvl: just always immediately repost */
+	/* but count so we can drain CQ on close */
+	int recvl_posted;
+
+	/* login phase resources, freed at full-feature */
+	void *srbuf_login;
+	void *listbuf_login;
+	struct ibv_mr *srmr_login;
+	struct list_head sendl_login, recvl_login;
+
+	/* points to the current recvlist, sendlist items for each conn */
+	struct recvlist *rcv_comm_event;
+	struct sendlist *send_comm_event;
+
+	/* to chain this connection onto the list of those ready to tx */
+	struct list_head conn_tx_ready;
+
+	/* list of all iser conns */
+	struct list_head iser_conn_list;
+
+	/* to consume posted receives after disconnect */
+	int draining;
+
+	/* when free has been called, waits until all posted msgs complete */
+	int freed;
+};
+
+/*
+ * Pre-registered memory.  Buffers are allocated by iscsi from us, handed
+ * to device to fill, then iser can send them directly without registration.
+ * Also for write path.
+ */
+struct mempool {
+	struct list_head list;
+	void *buf;
+};
+
+/*
+ * Shared variables for a particular device.  The conn[] array will
+ * have to be broken out when multiple device support is added, maybe with
+ * a pointer into this "device" struct.
+ */
+struct iser_device {
+	struct list_head list;
+	struct ibv_context *ibv_hndl;
+	struct ibv_pd *pd;
+	struct ibv_cq *cq;
+	struct ibv_comp_channel *cq_channel;
+
+	/* mempool registered buffer, list area, handle */
+	void *mempool_regbuf;
+	void *mempool_listbuf;
+	struct ibv_mr *mempool_mr;
+
+	/* free and allocated mempool entries */
+	struct list_head mempool_free, mempool_alloc;
+};
+
+/* global, across all devices */
+static struct rdma_event_channel *rdma_evt_channel;
+static struct rdma_cm_id *cma_listen_id;
+static struct list_head conn_tx_ready;  /* conns with tasks ready to tx */
+
+/* accepted at RDMA layer, but not yet established */
+static struct list_head temp_conn;
+
+/* all devices */
+static struct list_head iser_dev_list;
+
+/* all iser connections */
+static struct list_head iser_conn_list;
+
+/* if any task needs an rdma read or write slot to proceed */
+static int waiting_rdma_slot;
+
+/* progress available, used with tgt_counter_event */
+static int num_tx_ready;
+static int num_rx_ready;
+
+#define uint64_from_ptr(p) (uint64_t)(uintptr_t)(p)
+#define ptr_from_int64(p) (void *)(unsigned long)(p)
+
+#define ISCSI_LISTEN_PORT 3260
+
+/*
+ * Crazy hard-coded linux iser settings need 128 * 8 slots + slop, plus
+ * room for our rdmas and send requests.
+ */
+#define MAX_WQE 1800
+
+/*
+ * Number of outstanding RDMAs per command; should instead wait for previous
+ * RDMAs to complete before starting new ones.
+ *
+ * The RDMA size is completely up to the target.  Parameters IRDSL and TRDSL
+ * only apply to control-type PDUs.  We allocate only so many rdma slots
+ * per connection, but many tasks might be in progress on the connection.
+ * Internal flow control stops tasks when there are no slots.
+ *
+ * RDMA size tradeoffs:
+ *    big RDMA operations are more efficient
+ *    small RDMA operations better for fairness with many clients
+ *    small RDMA operations allow better pipelining
+ *    eventually target devices may not want to have to malloc and return
+ *        entire buffer to transport in one go
+ */
+#define RDMA_PER_CONN 20
+#define RDMA_TRANSFER_SIZE (512 * 1024)
+
+/*
+ * Number of allocatable buffers, each of this size.  Headers are added
+ * so that iscsi alloctations fit.  Do at least 128 for linux iser.
+ */
+#define MEMPOOL_NUM (192)
+#define MEMPOOL_SIZE roundup(512 * 1024 + \
+			     sizeof(struct iscsi_task) + \
+			     sizeof(struct iser_hdr) + \
+			     sizeof(struct iscsi_hdr) + \
+			     sizeof(struct iscsi_ecdb_ahdr) + \
+			     sizeof(struct iscsi_rlength_ahdr), 4096)
+
+static void iser_cqe_handler(int fd, int events, void *data);
+static void iser_rx_progress(int *counter, void *data);
+static void iser_rdma_read_completion(struct rdmalist *rdma);
+static void iscsi_rdma_conn_free(struct iscsi_connection *conn);
+static int iscsi_rdma_show(struct iscsi_connection *iscsi_conn, char *buf,
+			   int rest);
+static void iscsi_rdma_event_modify(struct iscsi_connection *conn, int events);
+
+/*
+ * Called when ready for full feature, builds resources.
+ */
+static int iser_init_comm(struct conn_info *conn)
+{
+	unsigned int i;
+	int ret = -1;
+	unsigned long size;
+	uint8_t *srbuf, *listbuf;
+	struct sendlist *sendl;
+	struct recvlist *recvl;
+	struct rdmalist *rdmal;
+	struct ibv_recv_wr *bad_wr;
+	int rdma_per_conn = RDMA_PER_CONN;
+
+	dprintf("sizing %u/%u outst %u\n", conn->ssize, conn->rsize,
+		conn->max_outst_pdu);
+
+	size = (conn->rsize + conn->ssize) * conn->max_outst_pdu;
+	conn->srbuf = malloc(size);
+	if (!conn->srbuf) {
+		eprintf("malloc srbuf %lu\n", size);
+		goto out;
+	}
+
+	conn->srmr = ibv_reg_mr(conn->dev->pd, conn->srbuf, size,
+				IBV_ACCESS_LOCAL_WRITE);
+	if (!conn->srmr) {
+		eprintf("register srbuf\n");
+		goto out;
+	}
+
+	INIT_LIST_HEAD(&conn->sendl);
+	INIT_LIST_HEAD(&conn->rdmal);
+
+	size = conn->max_outst_pdu * sizeof(struct sendlist) +
+	       conn->max_outst_pdu * sizeof(struct recvlist) +
+	       conn->max_outst_pdu * rdma_per_conn * sizeof(struct rdmalist);
+	conn->listbuf = malloc(size);
+	if (!conn->listbuf) {
+		eprintf("malloc listbuf %lu\n", size);
+		goto out;
+	}
+	memset(conn->listbuf, 0, size);
+
+	srbuf = conn->srbuf;
+	listbuf = conn->listbuf;
+	for (i = 0; i < conn->max_outst_pdu; i++) {
+		sendl = (void *) listbuf;
+		listbuf += sizeof(*sendl);
+		sendl->buf = srbuf;
+		srbuf += conn->ssize;
+		sendl->conn = conn;
+
+		sendl->sge.addr = uint64_from_ptr(sendl->buf);
+		sendl->sge.length = conn->ssize;
+		sendl->sge.lkey = conn->srmr->lkey;
+
+		sendl->wr.wr_id = uint64_from_ptr(sendl);
+		sendl->wr.sg_list = &sendl->sge;
+		sendl->wr.num_sge = 1;
+		sendl->wr.opcode = IBV_WR_SEND;
+		sendl->wr.send_flags = IBV_SEND_SIGNALED;
+		list_add_tail(&sendl->list, &conn->sendl);
+	}
+
+	for (i = 0; i < conn->max_outst_pdu; i++) {
+		recvl = (void *) listbuf;
+		listbuf += sizeof(*recvl);
+		recvl->buf = srbuf;
+		srbuf += conn->rsize;
+		recvl->conn = conn;
+
+		recvl->sge.addr = uint64_from_ptr(recvl->buf);
+		recvl->sge.length = conn->rsize;
+		recvl->sge.lkey = conn->srmr->lkey;
+
+		recvl->wr.wr_id = uint64_from_ptr(recvl);
+		recvl->wr.sg_list = &recvl->sge;
+		recvl->wr.num_sge = 1;
+
+		ret = ibv_post_recv(conn->qp_hndl, &recvl->wr, &bad_wr);
+		if (ret) {
+			eprintf("ibv_post_recv (%d/%d): %m\n", i,
+				conn->max_outst_pdu);
+			exit(1);
+		}
+		++conn->recvl_posted;
+	}
+
+	for (i = 0; i < conn->max_outst_pdu * rdma_per_conn; i++) {
+		rdmal = (void *) listbuf;
+		listbuf += sizeof(*rdmal);
+		rdmal->conn = conn;
+		rdmal->sge.lkey = conn->dev->mempool_mr->lkey;
+
+		rdmal->wr.wr_id = uint64_from_ptr(rdmal);
+		rdmal->wr.sg_list = &rdmal->sge;
+		rdmal->wr.num_sge = 1;
+		rdmal->wr.send_flags = IBV_SEND_SIGNALED;
+		list_add_tail(&rdmal->list, &conn->rdmal);
+	}
+
+	ret = 0;
+
+out:
+	return ret;
+}
+
+/*
+ * Called at accept time, builds resources just for login phase.
+ */
+static int iser_init_comm_login(struct conn_info *conn)
+{
+	unsigned int i;
+	int ret = -1;
+	unsigned long size;
+	uint8_t *srbuf, *listbuf;
+	struct sendlist *sendl;
+	struct recvlist *recvl;
+	struct ibv_recv_wr *bad_wr;
+
+	dprintf("sizing %u/%u outst %u\n", conn->ssize, conn->rsize,
+		conn->max_outst_pdu);
+
+	size = (conn->rsize + conn->ssize) * conn->max_outst_pdu;
+	conn->srbuf_login = malloc(size);
+	if (!conn->srbuf_login) {
+		eprintf("malloc srbuf %lu\n", size);
+		goto out;
+	}
+
+	conn->srmr_login = ibv_reg_mr(conn->dev->pd, conn->srbuf_login, size,
+				      IBV_ACCESS_LOCAL_WRITE);
+	if (!conn->srmr_login) {
+		eprintf("ibv_reg_mr srbuf failed\n");
+		goto out;
+	}
+
+	INIT_LIST_HEAD(&conn->sendl_login);
+	INIT_LIST_HEAD(&conn->recvl_login);
+
+	size = conn->max_outst_pdu * sizeof(struct sendlist) +
+	       conn->max_outst_pdu * sizeof(struct recvlist);
+	conn->listbuf_login = malloc(size);
+	if (!conn->listbuf_login) {
+		eprintf("malloc listbuf %lu\n", size);
+		goto out;
+	}
+	memset(conn->listbuf_login, 0, size);
+
+	srbuf = conn->srbuf_login;
+	listbuf = conn->listbuf_login;
+	for (i = 0; i < conn->max_outst_pdu; i++) {
+		sendl = (void *) listbuf;
+		listbuf += sizeof(*sendl);
+		sendl->buf = srbuf;
+		srbuf += conn->ssize;
+		sendl->conn = conn;
+
+		sendl->sge.addr = uint64_from_ptr(sendl->buf);
+		sendl->sge.length = conn->ssize;
+		sendl->sge.lkey = conn->srmr_login->lkey;
+
+		sendl->wr.wr_id = uint64_from_ptr(sendl);
+		sendl->wr.sg_list = &sendl->sge;
+		sendl->wr.num_sge = 1;
+		sendl->wr.opcode = IBV_WR_SEND;
+		sendl->wr.send_flags = IBV_SEND_SIGNALED;
+		list_add_tail(&sendl->list, &conn->sendl_login);
+	}
+
+	for (i = 0; i < conn->max_outst_pdu; i++) {
+		recvl = (void *) listbuf;
+		listbuf += sizeof(*recvl);
+		recvl->buf = srbuf;
+		srbuf += conn->rsize;
+		recvl->conn = conn;
+
+		recvl->sge.addr = uint64_from_ptr(recvl->buf);
+		recvl->sge.length = conn->rsize;
+		recvl->sge.lkey = conn->srmr_login->lkey;
+
+		recvl->wr.wr_id = uint64_from_ptr(recvl);
+		recvl->wr.sg_list = &recvl->sge;
+		recvl->wr.num_sge = 1;
+		recvl->wr.next = NULL;
+
+		ret = ibv_post_recv(conn->qp_hndl, &recvl->wr, &bad_wr);
+		if (ret) {
+			eprintf("ibv_post_recv: %m\n");
+			goto out;
+		}
+	}
+
+	ret = 0;
+
+out:
+	return ret;
+}
+
+/*
+ * On connection shutdown.
+ */
+static void iser_free_comm(struct conn_info *ci)
+{
+	int ret;
+
+	dprintf("freeing conn %p\n", ci);
+
+	/* release mr and free the lists */
+	dprintf("dereg mr %p\n", ci->srmr);
+	ret = ibv_dereg_mr(ci->srmr);
+	if (ret)
+		eprintf("ibv_dereg_mr\n");
+	free(ci->srbuf);
+	free(ci->listbuf);
+}
+
+/*
+ * When ready for full-feature mode, free login-phase resources.
+ */
+static void iser_free_comm_login(struct conn_info *ci)
+{
+	int ret;
+
+	if (ci->srbuf_login == NULL)
+		return;
+
+	dprintf("freeing, login phase %d\n", ci->login_phase);
+
+	/* release mr and free the lists */
+	ret = ibv_dereg_mr(ci->srmr_login);
+	if (ret)
+		eprintf("ibv_dereg_mr\n");
+	free(ci->srbuf_login);
+	free(ci->listbuf_login);
+	ci->srbuf_login = NULL;  /* remember freed */
+}
+
+/*
+ * One pool of registered memory per device (per PD that is).
+ */
+static int iser_init_mempool(struct iser_device *dev)
+{
+	struct mempool *mp;
+	uint8_t *regbuf, *listbuf;
+	int i;
+
+	regbuf = malloc(MEMPOOL_NUM * MEMPOOL_SIZE);
+	if (!regbuf) {
+		eprintf("malloc regbuf %zu\n", MEMPOOL_NUM * MEMPOOL_SIZE);
+		return -ENOMEM;
+	}
+
+	listbuf = malloc(MEMPOOL_NUM * sizeof(*mp));
+	if (!listbuf) {
+		eprintf("malloc listbuf %zu\n", MEMPOOL_NUM * sizeof(*mp));
+		free(regbuf);
+		return -ENOMEM;
+	}
+
+	dev->mempool_mr = ibv_reg_mr(dev->pd, regbuf,
+				     MEMPOOL_NUM * MEMPOOL_SIZE,
+				     IBV_ACCESS_LOCAL_WRITE);
+	if (!dev->mempool_mr) {
+		eprintf("register regbuf\n");
+		free(regbuf);
+		free(listbuf);
+		return -1;
+	}
+
+	dev->mempool_regbuf = regbuf;
+	dev->mempool_listbuf = listbuf;
+	INIT_LIST_HEAD(&dev->mempool_free);
+	INIT_LIST_HEAD(&dev->mempool_alloc);
+
+	for (i = 0; i < MEMPOOL_NUM; i++) {
+		mp = (void *) listbuf;
+		listbuf += sizeof(*mp);
+		mp->buf = regbuf;
+		regbuf += MEMPOOL_SIZE;
+		list_add_tail(&mp->list, &dev->mempool_free);
+	}
+
+	return 0;
+}
+
+/*
+ * First time a new connection is received on an RDMA device, record
+ * it and build a PD and static memory.
+ */
+static int iser_device_init(struct iser_device *dev)
+{
+	struct ibv_device_attr device_attr;
+	int cqe_num;
+	int ret = -1;
+
+	dprintf("dev %p\n", dev);
+	dev->pd = ibv_alloc_pd(dev->ibv_hndl);
+	if (dev->pd == NULL) {
+		eprintf("ibv_alloc_pd failed\n");
+		goto out;
+	}
+
+	ret = iser_init_mempool(dev);
+	if (ret) {
+		eprintf("iser_init_mempool failed\n");
+		goto out;
+	}
+
+	ret = ibv_query_device(dev->ibv_hndl, &device_attr);
+	if (ret < 0) {
+		eprintf("ibv_query_device: %m\n");
+		goto out;
+	}
+	cqe_num = device_attr.max_cqe;
+	dprintf("max %d CQEs\n", cqe_num);
+
+	ret = -1;
+	dev->cq_channel = ibv_create_comp_channel(dev->ibv_hndl);
+	if (dev->cq_channel == NULL) {
+		eprintf("ibv_create_comp_channel failed: %m\n");
+		goto out;
+	}
+
+	dev->cq = ibv_create_cq(dev->ibv_hndl, cqe_num, NULL,
+				dev->cq_channel, 0);
+	if (dev->cq == NULL) {
+		eprintf("ibv_create_cq failed: %m\n");
+		goto out;
+	}
+
+	ret = ibv_req_notify_cq(dev->cq, 0);
+	if (ret) {
+		eprintf("ibv_req_notify failed: %s\n", strerror(ret));
+		goto out;
+	}
+
+	ret = tgt_event_add(dev->cq_channel->fd, EPOLLIN, iser_cqe_handler,
+			    dev);
+	if (ret) {
+		eprintf("tgt_event_add failed: %m\n");
+		goto out;
+
+	}
+
+	list_add(&dev->list, &iser_dev_list);
+
+out:
+	return ret;
+}
+
+static void iser_accept_connection(struct rdma_cm_event *event)
+{
+	int ret, found;
+	struct ibv_qp_init_attr qp_init_attr;
+	struct iscsi_connection *conn;
+	struct conn_info *ci;
+	struct iser_device *dev;
+	unsigned int hdrsz;
+	struct rdma_conn_param conn_param = {
+		.responder_resources = 1,
+		.initiator_depth = 1,
+		.retry_count = 5,
+	};
+
+	dprintf("entry\n");
+
+	/* find device */
+	found = 0;
+	list_for_each_entry(dev, &iser_dev_list, list) {
+		if (dev->ibv_hndl == event->id->verbs) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		dev = malloc(sizeof(*dev));
+		if (dev == NULL) {
+			eprintf("unable to allocate dev\n");
+			goto reject;
+		}
+		dev->ibv_hndl = event->id->verbs;
+		ret = iser_device_init(dev);
+		if (ret) {
+			free(dev);
+			goto reject;
+		}
+	}
+
+	/* build a new connection structure */
+	conn = conn_alloc(sizeof(*ci));
+	if (!conn) {
+		eprintf("unable to allocate conn\n");
+		goto reject;
+	}
+	ci = conn->trans_data;
+	ci->iscsi_conn = conn;
+	ci->iscsi_conn->tp = &iscsi_iser;
+	conn_read_pdu(ci->iscsi_conn);
+	ci->cma_id = event->id;
+	ci->dev = dev;
+	ci->login_phase = LOGIN_PHASE_START;
+	INIT_LIST_HEAD(&ci->conn_tx_ready);
+	list_add(&ci->iser_conn_list, &temp_conn);
+	/* initiator sits at dst, we are src */
+	memcpy(&ci->peer_addr, &event->id->route.addr.dst_addr,
+	       sizeof(ci->peer_addr));
+	memcpy(&ci->self_addr, &event->id->route.addr.src_addr,
+	       sizeof(ci->self_addr));
+#ifndef NDEBUG
+	{
+		char str[256];
+
+		iscsi_rdma_show(conn, str, sizeof(str));
+		str[sizeof(str)-1] = 0;
+		dprintf("new conn %p from %s\n", ci, str);
+	}
+#endif
+
+	/* create qp next */
+	memset(&qp_init_attr, 0, sizeof(qp_init_attr));
+	/* wire both send and recv to the same CQ */
+	qp_init_attr.send_cq =  dev->cq;
+	qp_init_attr.recv_cq  = dev->cq;
+	qp_init_attr.cap.max_send_wr = MAX_WQE;
+	qp_init_attr.cap.max_recv_wr = MAX_WQE;
+	qp_init_attr.cap.max_send_sge = 1;  /* scatter/gather entries */
+	qp_init_attr.cap.max_recv_sge = 1;
+	qp_init_attr.qp_type = IBV_QPT_RC;
+	/* only generate completion queue entries if requested */
+	qp_init_attr.sq_sig_all = 0;
+
+	ret = rdma_create_qp(ci->cma_id, dev->pd, &qp_init_attr);
+	if (ret) {
+		eprintf("create qp failed\n");
+		conn_put(ci->iscsi_conn);
+		goto reject;
+	}
+	ci->qp_hndl = ci->cma_id->qp;
+	VALGRIND_MAKE_MEM_DEFINED(ci->qp_hndl, sizeof(*ci->qp_hndl));
+
+	ci->rcv_comm_event = NULL;
+	ci->send_comm_event = NULL;
+	ci->readb = 0;
+	ci->writeb = 0;
+
+	/*
+	 * Post buffers for the login phase, only.
+	 */
+	hdrsz = sizeof(struct iser_hdr) +
+		sizeof(struct iscsi_hdr) +
+		sizeof(struct iscsi_ecdb_ahdr) +
+		sizeof(struct iscsi_rlength_ahdr);
+	ci->ssize = hdrsz + 8192;
+	ci->rsize = hdrsz + 8192;
+	ci->max_outst_pdu = 1;
+	ret = iser_init_comm_login(ci);
+	if (ret) {
+		iser_free_comm_login(ci);
+		conn_put(ci->iscsi_conn);
+		goto reject;
+	}
+
+	/* now we can actually accept the connection */
+	ret = rdma_accept(ci->cma_id, &conn_param);
+	if (ret) {
+		eprintf("rdma_accept failed\n");
+		iser_free_comm_login(ci);
+		conn_put(ci->iscsi_conn);
+		goto reject;
+	}
+
+	return;
+
+reject:
+	ret = rdma_reject(event->id, NULL, 0);
+	if (ret)
+		eprintf("rdma_reject failed: %s\n", strerror(-ret));
+}
+
+/*
+ * Finish putting the connection together, now that the other side
+ * has ACKed our acceptance.  Moves it from the temp_conn to the
+ * iser_conn_list.
+ *
+ * Release the temporary conn_info and glue it into iscsi_conn.
+ */
+static void iser_conn_established(struct rdma_cm_event *event)
+{
+	int found = 0;
+	struct conn_info *ci;
+
+	/* find it in connection list */
+	list_for_each_entry(ci, &temp_conn, iser_conn_list) {
+		if (ci->cma_id == event->id) {
+			found = 1;
+			break;
+		}
+	}
+	if (!found) {
+		eprintf("cma id %p not found\n", event->id);
+		return;
+	}
+	dprintf("established conn %p\n", ci);
+	list_del(&ci->iser_conn_list);
+	list_add(&ci->iser_conn_list, &iser_conn_list);
+}
+
+static void iser_disconnect(struct rdma_cm_event *ev)
+{
+	struct conn_info *ci;
+
+	/*
+	 * If not found, initiator disconnected first, so tell iscsi about
+	 * it; else iscsi already did the conn_close.
+	 */
+	dprintf("initiator disconn, QP %d\n", ev->id->qp->qp_num);
+	list_for_each_entry(ci, &iser_conn_list, iser_conn_list) {
+		if (ci->qp_hndl->qp_num == ev->id->qp->qp_num) {
+			ci->iscsi_conn->state = STATE_CLOSE;
+			conn_close(ci->iscsi_conn);
+			break;
+		}
+	}
+}
+
+/*
+ * Handle RDMA connection events.
+ */
+static void iser_handle_rdmacm(int fd __attribute__((unused)),
+			       int events __attribute__((unused)),
+			       void *data __attribute__((unused)))
+{
+	int ret;
+	struct rdma_cm_event *event;
+	struct rdma_cm_id *destroy_cm_id = NULL;
+
+	dprintf("entry\n");
+	ret = rdma_get_cm_event(rdma_evt_channel, &event);
+	if (ret) {
+		eprintf("rdma_get_cm_event failed\n");
+		return;
+	}
+
+	VALGRIND_MAKE_MEM_DEFINED(event, sizeof(*event));
+	switch (event->event) {
+	case RDMA_CM_EVENT_CONNECT_REQUEST:
+		iser_accept_connection(event);
+		break;
+	case RDMA_CM_EVENT_ESTABLISHED:
+		iser_conn_established(event);
+		break;
+	case RDMA_CM_EVENT_DISCONNECTED:
+		iser_disconnect(event);
+		destroy_cm_id = event->id;
+		break;
+	default:
+		eprintf("unknown event %d\n", event->event);
+		break;
+	}
+
+	ret = rdma_ack_cm_event(event);
+	if (ret) {
+		eprintf("ack cm event failed\n");
+		return;
+	}
+
+	if (destroy_cm_id) {
+		ret = rdma_destroy_id(destroy_cm_id);
+		if (ret)
+			eprintf("rdma_destroy_id failed\n");
+	}
+}
+
+/*
+ * Deal with just one work completion.
+ */
+static void handle_wc(struct ibv_wc *wc)
+{
+	int ret;
+	struct recvlist *recvl;
+	struct sendlist *sendl;
+	struct rdmalist *rdmal;
+	struct conn_info *ci;
+	struct ibv_recv_wr *bad_wr;
+
+	switch (wc->opcode) {
+	case IBV_WC_SEND:
+		dprintf("outgoing rsp complete\n");
+		sendl = ptr_from_int64(wc->wr_id);
+		ci = sendl->conn;
+		if (ci->login_phase == LOGIN_PHASE_START) {
+		    list_add(&sendl->list, &ci->sendl_login);
+		} else if (ci->login_phase == LOGIN_PHASE_LAST_SEND) {
+			/* release login resources */
+			dprintf("last login send completed, release, to ff\n");
+			iser_free_comm_login(ci);
+			ci->login_phase = LOGIN_PHASE_FF;
+			break;
+		} else {
+		    list_add(&sendl->list, &ci->sendl);
+		}
+		break;
+
+	case IBV_WC_RECV:
+		dprintf("incoming cmd, len %d\n", wc->byte_len);
+		recvl = ptr_from_int64(wc->wr_id);
+		ci = recvl->conn;
+		--ci->recvl_posted;
+		if (ci->iscsi_conn->state == STATE_CLOSE)
+			goto close_err;
+
+		recvl->bytes_recvd = wc->byte_len;
+		VALGRIND_MAKE_MEM_DEFINED(recvl->buf, recvl->bytes_recvd);
+
+		/*
+		 * Global pointer to the working receive on this connection
+		 * for reads from iscsid.c.
+		 */
+		ci->rcv_comm_event = recvl;
+		iscsi_rx_handler(ci->iscsi_conn);
+		ci->rcv_comm_event = NULL;
+
+		if (ci->login_phase == LOGIN_PHASE_LAST_SEND) {
+			/* do not repost, just one more send then reinit */
+			dprintf("transitioning to full-feature, no repost\n");
+			break;
+		}
+
+		dprintf("incoming cmd proc done, repost\n");
+		ret = ibv_post_recv(ci->qp_hndl, &recvl->wr, &bad_wr);
+		if (ret) {
+			eprintf("ibv_post_recv failed\n");
+			exit(1);
+		}
+		++ci->recvl_posted;
+		break;
+
+	case IBV_WC_RDMA_WRITE:
+		dprintf("RDMA write done\n");
+		rdmal = ptr_from_int64(wc->wr_id);
+		ci = rdmal->conn;
+		if (ci->iscsi_conn->state == STATE_CLOSE)
+			goto close_err;
+
+		iscsi_rdma_event_modify(ci->iscsi_conn, EPOLLIN | EPOLLOUT);
+		list_add(&rdmal->list, &ci->rdmal);
+		if (waiting_rdma_slot) {
+			waiting_rdma_slot = 0;
+			num_tx_ready = 1;
+		}
+		break;
+
+	case IBV_WC_RDMA_READ:
+		dprintf("RDMA read done, len %d\n", wc->byte_len);
+		rdmal = ptr_from_int64(wc->wr_id);
+		ci = rdmal->conn;
+		if (ci->iscsi_conn->state == STATE_CLOSE)
+			goto close_err;
+
+		assert(rdmal->sge.length == wc->byte_len);
+		iser_rdma_read_completion(rdmal);
+		list_add(&rdmal->list, &ci->rdmal);
+		if (waiting_rdma_slot) {
+			waiting_rdma_slot = 0;
+			num_tx_ready = 1;
+		}
+		break;
+
+	default:
+		eprintf("unexpected opcode %d\n", wc->opcode);
+		exit(1);
+	}
+
+	return;
+
+close_err:
+	eprintf("conn state set to closed .. IMPLEMENT ME\n");
+	exit(1);
+}
+
+/*
+ * Called directly from main event loop when a CQ notification is
+ * available.
+ */
+static void iser_cqe_handler(int fd __attribute__((unused)),
+			     int events __attribute__((unused)),
+			     void *data)
+{
+	int ret;
+	void *cq_context;
+	struct iser_device *dev = data;
+
+	ret = ibv_get_cq_event(dev->cq_channel, &dev->cq, &cq_context);
+	if (ret != 0) {
+		eprintf("notification, but no CQ event\n");
+		exit(1);
+	}
+
+	ibv_ack_cq_events(dev->cq, 1);
+
+	ret = ibv_req_notify_cq(dev->cq, 0);
+	if (ret) {
+		eprintf("ibv_req_notify_cq: %s\n", strerror(ret));
+		exit(1);
+	}
+
+	iser_rx_progress(NULL, dev);
+}
+
+/*
+ * Called from tgtd when num_tx_ready (counter) non-zero.  Walks the
+ * list of active connections and tries to push tx on each, until nothing
+ * is ready anymore.  No progress limit here.
+ */
+static void iser_tx_progress(int *counter __attribute__((unused)),
+			     void *data __attribute__((unused)))
+{
+	int reloop, ret;
+	struct conn_info *ci, *cin;
+	struct iscsi_connection *conn;
+
+	dprintf("entry\n");
+	num_tx_ready = 0;
+
+	do {
+		reloop = 0;
+		list_for_each_entry_safe(ci, cin, &conn_tx_ready,
+					 conn_tx_ready) {
+			conn = ci->iscsi_conn;
+			if (conn->state == STATE_CLOSE) {
+				dprintf("ignoring tx for closed conn\n");
+			} else {
+				dprintf("trying tx\n");
+				ret = iscsi_tx_handler(conn);
+				if (conn->state == STATE_CLOSE) {
+					conn_close(conn);
+					dprintf("connection %p closed\n", ci);
+				} else {
+					if (ret == 0) {
+						reloop = 1;
+					} else {
+						/* but leave on tx ready list */
+						waiting_rdma_slot = 1;
+					}
+				}
+			}
+		}
+	} while (reloop);
+}
+
+/*
+ * Could read as many entries as possible without blocking, but
+ * that just fills up a list of tasks.  Instead pop out of here
+ * so that tx progress, like issuing rdma reads and writes, can
+ * happen periodically.
+ */
+#define MAX_RX_PROGRESS 8
+static void iser_rx_progress_one(struct iser_device *dev)
+{
+	int ret, numwc = 0;
+	struct ibv_wc wc;
+	struct conn_info *ci;
+	struct recvlist *recvl;
+
+	for (;;) {
+		ret = ibv_poll_cq(dev->cq, 1, &wc);
+		if (ret < 0) {
+			eprintf("ibv_poll_cq %d\n", ret);
+			break;
+		} else if (ret == 0) {
+			break;
+		}
+
+		VALGRIND_MAKE_MEM_DEFINED(&wc, sizeof(wc));
+		if (wc.status != IBV_WC_SUCCESS) {
+			if (wc.status == IBV_WC_WR_FLUSH_ERR) {
+				recvl = ptr_from_int64(wc.wr_id);
+				ci = recvl->conn;
+				if (ci->draining) {
+					--ci->recvl_posted;
+					if (ci->freed && ci->recvl_posted == 0)
+						iscsi_rdma_conn_free(
+							ci->iscsi_conn);
+					continue;
+				}
+			}
+			eprintf("bad WC status %d for wr_id 0x%llx\n",
+				wc.status, (unsigned long long) wc.wr_id);
+			exit(1);
+		}
+
+		handle_wc(&wc);
+		if (++numwc == MAX_RX_PROGRESS) {
+			num_rx_ready = 1;
+			break;
+		}
+	}
+}
+
+/*
+ * Only one progress counter, must look across all devs.
+ */
+static void iser_rx_progress(int *counter __attribute__((unused)), void *data)
+{
+	struct iser_device *dev;
+
+	dprintf("entry\n");
+	num_rx_ready = 0;
+	if (data == NULL) {
+		list_for_each_entry(dev, &iser_dev_list, list)
+			iser_rx_progress_one(dev);
+	} else {
+		dev = data;
+		iser_rx_progress_one(dev);
+	}
+}
+
+/*
+ * Init entire iscsi transport.  Begin listening for connections.
+ */
+static int iscsi_rdma_init(void)
+{
+	int ret;
+	struct sockaddr_in sock_addr;
+	short int port = ISCSI_LISTEN_PORT;
+
+	rdma_evt_channel = rdma_create_event_channel();
+
+	if (!rdma_evt_channel) {
+		eprintf("cannot initialize RDMA; load kernel modules?\n");
+		return -1;
+	}
+
+	ret = rdma_create_id(rdma_evt_channel, &cma_listen_id, NULL,
+			     RDMA_PS_TCP);
+	if (ret) {
+		eprintf("rdma_create_id: %s\n", strerror(ret));
+		return -1;
+	}
+
+	memset(&sock_addr, 0, sizeof(sock_addr));
+	sock_addr.sin_family = AF_INET;
+	sock_addr.sin_port = htons(port);
+	sock_addr.sin_addr.s_addr = INADDR_ANY;
+	ret = rdma_bind_addr(cma_listen_id, (struct sockaddr *) &sock_addr);
+	if (ret) {
+		if (ret == -1)
+			eprintf("rdma_bind_addr -1: %m\n");
+		else
+			eprintf("rdma_bind_addr: %s\n", strerror(-ret));
+		return -1;
+	}
+
+	/* 0 == maximum backlog */
+	ret = rdma_listen(cma_listen_id, 0);
+	if (ret) {
+		if (ret == -1)
+			eprintf("rdma_listen -1: %m\n");
+		else
+			eprintf("rdma_listen: %s\n", strerror(-ret));
+		return -1;
+	}
+
+	dprintf("listening for iser connections on port %d\n", port);
+	ret = tgt_event_add(cma_listen_id->channel->fd, EPOLLIN,
+			    iser_handle_rdmacm, NULL);
+	if (ret)
+		return ret;
+
+	INIT_LIST_HEAD(&conn_tx_ready);
+	INIT_LIST_HEAD(&iser_dev_list);
+	INIT_LIST_HEAD(&iser_conn_list);
+	INIT_LIST_HEAD(&temp_conn);
+	num_tx_ready = 0;
+	num_rx_ready = 0;
+	ret = tgt_counter_event_add(&num_tx_ready, iser_tx_progress, NULL);
+	ret = tgt_counter_event_add(&num_rx_ready, iser_rx_progress, NULL);
+	return ret;
+}
+
+/*
+ * Allocate resources for this new connection.  Called after login, when
+ * final negotiated transfer parameters are known.
+ */
+static int iscsi_rdma_conn_init(struct iscsi_connection *conn)
+{
+	int ret = -1;
+	struct conn_info *ci = conn->trans_data;
+	unsigned int irdsl, trdsl, outst_pdu, hdrsz;
+
+	dprintf("entry\n");
+
+	/*
+	 * Build full feature connection structures, but leave around the
+	 * login ones until the final send finishes.
+	 */
+	ci->login_phase = LOGIN_PHASE_LAST_SEND;  /* one more send, then done */
+	irdsl = conn->session_param[ISCSI_PARAM_INITIATOR_RDSL].val;
+	trdsl = conn->session_param[ISCSI_PARAM_TARGET_RDSL].val;
+	outst_pdu = conn->session_param[ISCSI_PARAM_MAX_OUTST_PDU].val;
+
+	/* hack, ib/ulp/iser does not have this param, but reading the code
+	 * shows
+	 *    ISCSI_XMIT_CMDS_MAX=128
+	 *    ISER_INFLIGHT_DATAOUTS=8
+	 *    ISER_MAX_RX_MISC_PDUS=4
+	 *    ISER_MAX_TX_MISC_PDUS=6
+	 * and their formula for max tx dtos outstanding
+	 *    = cmds_max * (1 + dataouts) + rx_misc + tx_misc
+	 */
+	if (outst_pdu == 0)
+		outst_pdu = 128 * (1 + 8) + 6 + 4;
+
+	/* RDSLs do not include headers. */
+	hdrsz = sizeof(struct iser_hdr) +
+		sizeof(struct iscsi_hdr) +
+		sizeof(struct iscsi_ecdb_ahdr) +
+		sizeof(struct iscsi_rlength_ahdr);
+
+	ci->ssize = hdrsz + irdsl;
+	ci->rsize = hdrsz + trdsl;
+	ci->max_outst_pdu = outst_pdu;
+	ret = iser_init_comm(ci);
+	if (ret) {
+		eprintf("iser_init_comm failed\n");
+		goto out;
+	}
+
+	/*
+	 * How much data to grab in an RDMA operation, read or write.
+	 */
+	conn->data_inout_max_size = RDMA_TRANSFER_SIZE;
+
+out:
+	return ret;
+}
+
+/*
+ * Copy the remote va and stag that were temporarily saved in conn_info.
+ */
+static void iscsi_iser_task_init(struct iscsi_task *task)
+{
+	struct conn_info *ci = task->conn->trans_data;
+	struct iser_task *itask = task->trans_data;
+
+	itask->rem_read_stag = ci->rem_read_stag;
+	itask->rem_read_va = ci->rem_read_va;
+	itask->rem_write_stag = ci->rem_write_stag;
+	itask->rem_write_va = ci->rem_write_va;
+}
+
+static int iser_parse_hdr(struct conn_info *ci, struct recvlist *recvl)
+{
+	int ret = -1;
+	struct iser_hdr *hdr = recvl->buf;
+
+	switch (hdr->flags & 0xF0) {
+	case ISCSI_CTRL:
+		dprintf("control type PDU\n");
+		if (hdr->flags & ISER_RSV) {
+			ci->rem_read_stag = be32_to_cpu(hdr->read_stag);
+			ci->rem_read_va = be64_to_cpu(hdr->read_va);
+			dprintf("rstag %x va %llx\n",
+				ci->rem_read_stag,
+				(unsigned long long) ci->rem_read_va);
+		}
+		if (hdr->flags & ISER_WSV) {
+			ci->rem_write_stag = be32_to_cpu(hdr->write_stag);
+			ci->rem_write_va = be64_to_cpu(hdr->write_va);
+			dprintf("wstag %x va %llx\n",
+				ci->rem_write_stag,
+				(unsigned long long) ci->rem_write_va);
+		}
+		ret = 0;
+		break;
+	case ISER_HELLO:
+		dprintf("iSER Hello message??\n");
+		break;
+	default:
+		eprintf("malformed iser hdr, flags 0x%02x\n", hdr->flags);
+		break;
+	}
+
+	ci->readb = sizeof(*hdr);
+	return ret;
+}
+
+static size_t iscsi_iser_read(struct iscsi_connection *iscsi_conn, void *buf,
+			      size_t nbytes)
+{
+	int ret;
+	struct conn_info *ci = iscsi_conn->trans_data;
+	struct recvlist *recvl;
+
+	dprintf("buf %p nbytes %zu\n", buf, nbytes);
+	recvl = ci->rcv_comm_event;
+	assert(recvl != NULL);
+
+	if (ci->readb == 0) {
+		if (recvl->bytes_recvd < sizeof(struct iser_hdr))
+			return 0;
+
+		ret = iser_parse_hdr(ci, recvl);
+		if (ret != 0)
+			return 0;
+	}
+
+	if (ci->readb + nbytes > recvl->bytes_recvd) {
+		if (ci->readb > recvl->bytes_recvd)
+			nbytes = recvl->bytes_recvd;
+		else
+			nbytes = recvl->bytes_recvd - ci->readb;
+	}
+
+	/* always copy headers into iscsi task structure */
+	memcpy(buf, (char *) recvl->buf + ci->readb, nbytes);
+	ci->readb += nbytes;
+
+	if (ci->readb == recvl->bytes_recvd)
+		ci->readb = 0;
+
+	return nbytes;
+}
+
+static size_t iscsi_iser_write_begin(struct iscsi_connection *iscsi_conn,
+				     void *buf, size_t nbytes)
+{
+	struct conn_info *ci = iscsi_conn->trans_data;
+	struct sendlist *sendl;
+
+	if (ci->send_comm_event == NULL) {
+		/* find one, first time here */
+		struct list_head *ci_sendl = &ci->sendl;
+
+		if (ci->login_phase != LOGIN_PHASE_FF)
+			ci_sendl = &ci->sendl_login;
+
+		if (list_empty(ci_sendl)) {
+			/* bug, max outst pdu should constrain this */
+			eprintf("no free send slot\n");
+			exit(1);
+		}
+		sendl = list_entry(ci_sendl->next, typeof(*sendl), list);
+		list_del(&sendl->list);
+		ci->send_comm_event = sendl;
+		dprintf("new sendl %p len %zu\n", sendl, nbytes);
+	} else {
+		sendl = ci->send_comm_event;
+		dprintf("reuse sendl %p len %u + %zu\n", sendl, ci->writeb,
+			nbytes);
+	}
+
+	if (ci->writeb + nbytes > ci->ssize) {
+		eprintf("send buf overflow %d + %zd > %u\n", ci->writeb,
+			nbytes, ci->ssize);
+		exit(1);
+	}
+
+	if (ci->writeb == 0) {
+		/* insert iser hdr */
+		struct iser_hdr *hdr = sendl->buf;
+
+		memset(hdr, 0, sizeof(*hdr));
+		hdr->flags = ISCSI_CTRL;
+		ci->writeb = sizeof(*hdr);
+	}
+
+	memcpy((char *) sendl->buf + ci->writeb, buf, nbytes);
+	ci->writeb += nbytes;
+	return nbytes;
+}
+
+static void iscsi_iser_write_end(struct iscsi_connection *iscsi_conn)
+{
+	int ret;
+	struct ibv_send_wr *bad_wr;
+	struct conn_info *ci = iscsi_conn->trans_data;
+	struct sendlist *sendl;
+
+	sendl = ci->send_comm_event;  /* set from _write_begin above */
+	dprintf("sendl %p len %d\n", sendl, ci->writeb);
+
+	sendl->sge.length = ci->writeb;
+
+	ret = ibv_post_send(ci->qp_hndl, &sendl->wr, &bad_wr);
+	if (ret) {
+		/* bug, should have sized max_outst_pdu properly */
+		eprintf("ibv_post_send ret %d\n", ret);
+		exit(1);
+	}
+
+	ci->writeb = 0;  /* reset count */
+	ci->send_comm_event = NULL;
+
+	/* wake up the progress engine to do the done */
+	dprintf("inc progress to finish cmd\n");
+	num_tx_ready = 1;
+}
+
+/*
+ * Expected opcodes are: IBV_WR_RDMA_WRITE, IBV_WR_RDMA_READ.
+ */
+static int iser_post_rdma_wr(struct conn_info *ci, struct iscsi_task *task,
+			     void *buf, ssize_t size, int op,
+			     uint64_t remote_va, uint32_t remote_rkey)
+{
+	int ret;
+	struct rdmalist *rdmal;
+	struct ibv_send_wr *bad_wr;
+
+	if (list_empty(&ci->rdmal)) {
+		eprintf("no slot\n");
+		return -1;
+	}
+	rdmal = list_entry(ci->rdmal.next, typeof(*rdmal), list);
+	list_del(&rdmal->list);
+
+	rdmal->task = task;
+	rdmal->sge.addr = uint64_from_ptr(buf);
+	rdmal->sge.length = size;
+
+	rdmal->wr.opcode = op;
+	rdmal->wr.wr.rdma.remote_addr = remote_va;
+	rdmal->wr.wr.rdma.rkey = remote_rkey;
+
+	ret = ibv_post_send(ci->qp_hndl, &rdmal->wr, &bad_wr);
+	if (ret)
+		eprintf("ibv_post_send ret %d\n", ret);
+
+	return ret;
+}
+
+/*
+ * Convert the iscsi r2t request to an RDMA read and post it.
+ */
+static int iscsi_rdma_rdma_read(struct iscsi_connection *conn)
+{
+	struct conn_info *ci = conn->trans_data;
+	struct iscsi_task *task = conn->tx_task;
+	struct iser_task *itask = task->trans_data;
+	struct iscsi_r2t_rsp *r2t = (struct iscsi_r2t_rsp *) &conn->rsp.bhs;
+	uint8_t *buf;
+	uint32_t len;
+	int ret;
+
+	buf = (uint8_t *) task->data + task->offset;
+	len = be32_to_cpu(r2t->data_length);
+
+	dprintf("len %u stag %x va %llx\n",
+		len, itask->rem_write_stag,
+		(unsigned long long) itask->rem_write_va);
+
+	ret = iser_post_rdma_wr(ci, task, buf, len, IBV_WR_RDMA_READ,
+				itask->rem_write_va, itask->rem_write_stag);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * Initiator registers the entire buffer, but gives us a VA that
+	 * is advanced by immediate + unsolicited data amounts.  Advance
+	 * rem_va as we read, knowing that the target always grabs segments
+	 * in order.
+	 */
+	itask->rem_write_va += len;
+
+	return 0;
+}
+
+/*
+ * Convert the iscsi data-in response to an RDMA write and send it.
+ */
+static int iscsi_rdma_rdma_write(struct iscsi_connection *conn)
+{
+	struct conn_info *ci = conn->trans_data;
+	struct iscsi_task *task = conn->tx_task;
+	struct iser_task *itask = task->trans_data;
+	struct iscsi_pdu *rsp = &conn->rsp;
+	struct iscsi_data_rsp *datain = (struct iscsi_data_rsp *) &rsp->bhs;
+	uint32_t offset;
+	int ret;
+
+	offset = be32_to_cpu(datain->offset);
+
+	dprintf("offset %d len %d stag %x va %llx\n", offset, rsp->datasize,
+		itask->rem_read_stag, (unsigned long long) itask->rem_read_va);
+
+	ret = iser_post_rdma_wr(ci, task, rsp->data, rsp->datasize,
+				IBV_WR_RDMA_WRITE, itask->rem_read_va + offset,
+				itask->rem_read_stag);
+	if (ret < 0)
+		return ret;
+
+	/*
+	 * iscsi thinks we are txing, but really we're waiting for this
+	 * rdma to finish before sending the completion.  Then we'll stick
+	 * ourselves back on the list.
+	 */
+	if (task->offset == task->len) {
+		iscsi_rdma_event_modify(ci->iscsi_conn, EPOLLIN);
+	} else {
+		/* poke ourselves to do the next rdma */
+		num_tx_ready = 1;
+	}
+
+	return ret;
+}
+
+/*
+ * Called from CQ processing.  Hands completed write data to iscsi.
+ */
+static void iser_rdma_read_completion(struct rdmalist *rdmal)
+{
+	struct conn_info *ci = rdmal->conn;
+	struct iscsi_connection *conn = ci->iscsi_conn;
+	struct iscsi_task *task;
+
+	/* task is no longer conn->tx_task, look it up */
+	list_for_each_entry(task, &conn->session->cmd_list, c_hlist) {
+		if (task == rdmal->task)
+			goto found;
+	}
+	eprintf("no task\n");
+	return;
+
+found:
+	/* equivalent of iscsi_data_out_rx_start + _done */
+	conn->rx_buffer = ptr_from_int64(rdmal->sge.addr);
+	conn->rx_size = rdmal->sge.length;
+	task->offset += rdmal->sge.length;
+	task->r2t_count -= rdmal->sge.length;
+	VALGRIND_MAKE_MEM_DEFINED(conn->rx_buffer, conn->rx_size);
+
+	dprintf("itt %x len %u arrived, r2t_count %d\n", (uint32_t) task->tag,
+		rdmal->sge.length, task->r2t_count);
+
+	/*
+	 * We soliticed this data, so hdr->ttt is what we asked for.  Bypass
+	 * data_out_rx_done and just run the task.  If more r2t are needed,
+	 * this will generate them.
+	 */
+	iscsi_scsi_cmd_execute(task);
+
+	conn->rx_task = NULL;
+	conn_read_pdu(conn);
+}
+
+/*
+ * Close connection.  There is no device close function.  This is called
+ * from iscsi.
+ */
+static void iscsi_rdma_conn_close(struct iscsi_connection *conn)
+{
+	struct conn_info *ci = conn->trans_data;
+	int ret;
+
+	ret = rdma_disconnect(ci->cma_id);
+	if (ret)
+		eprintf("rdma_disconnect: %s\n", strerror(-ret));
+	dprintf("did rdma_disconnect\n");
+	list_del(&ci->conn_tx_ready);
+	list_del(&ci->iser_conn_list);
+	ci->draining = 1;
+}
+
+/*
+ * Called when the connection is freed, from iscsi, but won't do anything until
+ * all posted WRs have gone away.  So also called again from RX progress when
+ * it notices this happens.
+ */
+static void iscsi_rdma_conn_free(struct iscsi_connection *conn)
+{
+	struct conn_info *ci = conn->trans_data;
+	int ret;
+
+	dprintf("conn %p recvl %d\n", ci, ci->recvl_posted);
+	ci->freed = 1;
+
+	/* wait until all WRs flushed */
+	if (ci->recvl_posted != 0)
+		return;
+
+	iser_free_comm_login(ci);
+	if (ci->login_phase == LOGIN_PHASE_FF)
+		iser_free_comm(ci);
+
+	/* finally destory QP */
+	ret = ibv_destroy_qp(ci->qp_hndl);
+	if (ret)
+		eprintf("ibv_destroy_qp: %s\n", strerror(-ret));
+}
+
+static int iscsi_rdma_show(struct iscsi_connection *iscsi_conn, char *buf,
+			   int rest)
+{
+	int ret;
+	char host[NI_MAXHOST];
+	struct conn_info *ci = iscsi_conn->trans_data;
+
+	ret = getnameinfo((struct sockaddr *) &ci->peer_addr,
+			  sizeof(ci->peer_addr), host, sizeof(host), NULL, 0,
+			  NI_NUMERICHOST);
+	if (ret) {
+		eprintf("getnameinfo: %m\n");
+		return 0;
+	}
+	return snprintf(buf, rest, "RDMA IP Address: %s", host);
+}
+
+static void iscsi_rdma_event_modify(struct iscsi_connection *conn, int events)
+{
+	struct conn_info *ci = conn->trans_data;
+
+	if (events & EPOLLOUT) {
+		/* with multiple commands queued, may already be on list */
+		if (list_empty(&ci->conn_tx_ready)) {
+			dprintf("tx ready adding %p\n", ci);
+			list_add(&ci->conn_tx_ready, &conn_tx_ready);
+		}
+		num_tx_ready = 1;
+	} else {
+		dprintf("tx ready removing %p\n", ci);
+		list_del_init(&ci->conn_tx_ready);
+	}
+}
+
+static void *iscsi_rdma_malloc(struct iscsi_connection *iscsi_conn, size_t sz)
+{
+	struct mempool *mem;
+	struct conn_info *ci = iscsi_conn->trans_data;
+	struct iser_device *dev = ci->dev;
+
+	if (list_empty(&dev->mempool_free)) {
+		/* XXX: take slow path: allocate and register */
+		eprintf("free list empty\n");
+		exit(1);
+	}
+
+	if (sz > MEMPOOL_SIZE) {
+		eprintf("size %zu too big\n", sz);
+		exit(1);
+	}
+
+	mem = list_entry(dev->mempool_free.next, typeof(*mem), list);
+	list_del(&mem->list);
+	list_add(&mem->list, &dev->mempool_alloc);
+	dprintf("malloc %p sz %zu\n", mem->buf, sz);
+	return mem->buf;
+}
+
+static void iscsi_rdma_free(struct iscsi_connection *iscsi_conn, void *buf)
+{
+	int found = 0;
+	struct mempool *mem;
+	struct conn_info *ci = iscsi_conn->trans_data;
+	struct iser_device *dev = ci->dev;
+
+	list_for_each_entry(mem, &dev->mempool_alloc, list) {
+		if (mem->buf == buf) {
+			found = 1;
+			break;
+		}
+	}
+	dprintf("free %p\n", mem->buf);
+	if (!found) {
+		eprintf("couldn't locate buf %p\n", buf);
+		exit(1);
+	}
+	list_del(&mem->list);
+	list_add(&mem->list, &dev->mempool_free);
+}
+
+static int iscsi_rdma_getsockname(struct iscsi_connection *conn,
+				  struct sockaddr *sa, socklen_t *len)
+{
+	struct conn_info *ci = conn->trans_data;
+
+	if (*len > sizeof(ci->self_addr))
+		*len = sizeof(ci->self_addr);
+	memcpy(sa, &ci->self_addr, *len);
+	return 0;
+}
+
+static int iscsi_rdma_getpeername(struct iscsi_connection *conn,
+				  struct sockaddr *sa, socklen_t *len)
+{
+	struct conn_info *ci = conn->trans_data;
+
+	if (*len > sizeof(ci->peer_addr))
+		*len = sizeof(ci->peer_addr);
+	memcpy(sa, &ci->peer_addr, *len);
+	return 0;
+}
+
+struct iscsi_transport iscsi_iser = {
+	.name			= "iser",
+	.rdma			= 1,
+	.task_trans_len		= sizeof(struct iser_task),
+	.ep_init		= iscsi_rdma_init,
+	.ep_conn_init		= iscsi_rdma_conn_init,
+	.ep_task_init		= iscsi_iser_task_init,
+	.ep_read		= iscsi_iser_read,
+	.ep_write_begin		= iscsi_iser_write_begin,
+	.ep_write_end		= iscsi_iser_write_end,
+	.ep_rdma_read		= iscsi_rdma_rdma_read,
+	.ep_rdma_write		= iscsi_rdma_rdma_write,
+	.ep_conn_close		= iscsi_rdma_conn_close,
+	.ep_conn_free		= iscsi_rdma_conn_free,
+	.ep_show		= iscsi_rdma_show,
+	.ep_event_modify	= iscsi_rdma_event_modify,
+	.ep_malloc		= iscsi_rdma_malloc,
+	.ep_free		= iscsi_rdma_free,
+	.ep_getsockname		= iscsi_rdma_getsockname,
+	.ep_getpeername		= iscsi_rdma_getpeername,
+};
+
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 805b296..7f882fa 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -2003,6 +2003,29 @@ int iscsi_tx_handler(struct iscsi_connection *conn)
 			goto out;
 	}
 
+	/*
+	 * For rdma, grab the data-in or r2t packet and covert to
+	 * an RDMA operation.
+	 */
+	if (conn->tp->rdma && conn->state == STATE_SCSI) {
+		switch (conn->rsp.bhs.opcode) {
+		case ISCSI_OP_R2T:
+			ret = conn->tp->ep_rdma_read(conn);
+			if (ret < 0)  /* wait for free slot */
+				goto out;
+			goto finish;
+
+		case ISCSI_OP_SCSI_DATA_IN:
+			ret = conn->tp->ep_rdma_write(conn);
+			if (ret < 0)
+				goto out;
+			goto finish;
+
+		default:
+			break;
+		}
+	}
+
 again:
 	switch (conn->tx_iostate) {
 	case IOSTATE_TX_BHS:
@@ -2095,6 +2118,8 @@ again:
 	}
 
 	conn->tp->ep_write_end(conn);
+
+finish:
 	cmnd_finish(conn);
 
 	switch (conn->state) {
diff --git a/usr/iscsi/transport.c b/usr/iscsi/transport.c
index ba232ed..e17b554 100644
--- a/usr/iscsi/transport.c
+++ b/usr/iscsi/transport.c
@@ -29,6 +29,9 @@
 
 struct iscsi_transport *iscsi_transports[] = {
 	&iscsi_tcp,
+#ifdef ISCSI_RDMA
+	&iscsi_iser,
+#endif
 	NULL,
 };
 
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index f35d9d7..db5beb0 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -19,6 +19,8 @@ struct iscsi_transport {
 	size_t (*ep_write_begin) (struct iscsi_connection *conn, void *buf,
 				  size_t nbytes);
 	void (*ep_write_end) (struct iscsi_connection *conn);
+	int (*ep_rdma_read) (struct iscsi_connection *conn);
+	int (*ep_rdma_write) (struct iscsi_connection *conn);
 	void (*ep_conn_close) (struct iscsi_connection *conn);
 	void (*ep_conn_free) (struct iscsi_connection *conn);
 	int (*ep_show) (struct iscsi_connection *conn, char *buf, int rest);
@@ -32,5 +34,6 @@ struct iscsi_transport {
 };
 
 extern struct iscsi_transport iscsi_tcp;
+extern struct iscsi_transport iscsi_iser;
 
 #endif
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:20:44 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:20:44 -0400
Subject: [Stgt-devel] [PATCH 10/20] iser connection transport data
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <29cd088b80c82ce8b050b01e22d1e54121024f68.1192554396.git.pw@osc.edu>

Add a private data field to iscsi_connection to hold state for the
transport, and allocate room for it at connection allocation time.

Move the TCP socket fd from generic code into this private data region.

Also virtualize getsockname and getpeername as TCP and RDMA determine
those IP addresses differently.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/conn.c      |   21 +++++++-------
 usr/iscsi/iscsi_tcp.c |   72 ++++++++++++++++++++++++++++++++++++------------
 usr/iscsi/iscsid.c    |   58 +++++++++++++++++++-------------------
 usr/iscsi/iscsid.h    |   14 +++++-----
 usr/iscsi/session.c   |    2 +-
 usr/iscsi/target.c    |   10 +++---
 usr/iscsi/transport.h |   20 +++++++++----
 7 files changed, 120 insertions(+), 77 deletions(-)

diff --git a/usr/iscsi/conn.c b/usr/iscsi/conn.c
index fcd2385..1e9dace 100644
--- a/usr/iscsi/conn.c
+++ b/usr/iscsi/conn.c
@@ -42,11 +42,11 @@ void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_session *se
 	list_add(&conn->clist, &session->conn_list);
 }
 
-struct iscsi_connection *conn_alloc(void)
+struct iscsi_connection *conn_alloc(unsigned int trans_len)
 {
 	struct iscsi_connection *conn;
 
-	conn = zalloc(sizeof(*conn));
+	conn = zalloc(sizeof(*conn) + trans_len);
 	if (!conn)
 		return NULL;
 
@@ -69,6 +69,9 @@ struct iscsi_connection *conn_alloc(void)
 	INIT_LIST_HEAD(&conn->clist);
 	INIT_LIST_HEAD(&conn->tx_clist);
 
+	if (trans_len)
+		conn->trans_data = &conn[1];
+
 	return conn;
 }
 
@@ -87,12 +90,11 @@ static void conn_free(struct iscsi_connection *conn)
 		session_put(session);
 }
 
-void conn_close(struct iscsi_connection *conn, int fd)
+void conn_close(struct iscsi_connection *conn)
 {
 	struct iscsi_task *task, *tmp;
 
-	tgt_event_del(fd);
-	conn->tp->ep_close(fd);
+	conn->tp->ep_close(conn);
 
 	dprintf("connection closed\n");
 
@@ -166,13 +168,10 @@ struct iscsi_connection *conn_find(struct iscsi_session *session, uint32_t cid)
 	return NULL;
 }
 
-int conn_take_fd(struct iscsi_connection *conn, int fd)
+int conn_take_fd(struct iscsi_connection *conn)
 {
-	uint64_t sid = sid64(conn->isid, conn->tsih);
-
-	dprintf("conn_take_fd: %d %u %u %u %" PRIx64 "\n",
-		  fd, conn->cid, conn->stat_sn, conn->exp_stat_sn, sid);
+	dprintf("%u %u %u %" PRIx64 "\n", conn->cid, conn->stat_sn,
+		conn->exp_stat_sn, sid64(conn->isid, conn->tsih));
 	conn->session->conn_cnt++;
-
 	return 0;
 }
diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 7e0ab90..33cd6f8 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -42,6 +42,10 @@
 
 static void iscsi_tcp_event_handler(int fd, int events, void *data);
 
+struct tcp_conn_info {
+	int fd;
+};
+
 static int set_keepalive(int fd)
 {
 	int ret, opt;
@@ -74,6 +78,7 @@ static void accept_connection(int afd, int events, void *data)
 	struct sockaddr_storage from;
 	socklen_t namesize;
 	struct iscsi_connection *conn;
+	struct tcp_conn_info *tci;
 	int fd, err;
 
 	dprintf("%d\n", afd);
@@ -89,11 +94,12 @@ static void accept_connection(int afd, int events, void *data)
 	if (err)
 		goto out;
 
-	conn = conn_alloc();
+	conn = conn_alloc(sizeof(*tci));
 	if (!conn)
 		goto out;
 
-	conn->fd = fd;
+	tci = conn->trans_data;
+	tci->fd = fd;
 	conn->tp = &iscsi_tcp;
 
 	conn_read_pdu(conn);
@@ -116,16 +122,16 @@ static void iscsi_tcp_event_handler(int fd, int events, void *data)
 	struct iscsi_connection *conn = (struct iscsi_connection *) data;
 
 	if (events & EPOLLIN)
-		iscsi_rx_handler(fd, conn);
+		iscsi_rx_handler(conn);
 
 	if (conn->state == STATE_CLOSE)
 		dprintf("connection closed\n");
 
 	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
-		iscsi_tx_handler(fd, conn);
+		iscsi_tx_handler(conn);
 
 	if (conn->state == STATE_CLOSE) {
-		conn_close(conn, fd);
+		conn_close(conn);
 		dprintf("connection closed\n");
 	}
 }
@@ -204,38 +210,49 @@ static int iscsi_tcp_init(void)
 	return !nr_sock;
 }
 
-static size_t iscsi_tcp_read (int ep, void *buf, size_t nbytes)
+static size_t iscsi_tcp_read(struct iscsi_connection *conn, void *buf,
+			     size_t nbytes)
 {
-	return read(ep, buf, nbytes);
+	struct tcp_conn_info *tci = conn->trans_data;
+	return read(tci->fd, buf, nbytes);
 }
 
-static size_t iscsi_tcp_write_begin(int ep, void *buf, size_t nbytes)
+static size_t iscsi_tcp_write_begin(struct iscsi_connection *conn, void *buf,
+				    size_t nbytes)
 {
+	struct tcp_conn_info *tci = conn->trans_data;
 	int opt = 1;
-	setsockopt(ep, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
-	return write(ep, buf, nbytes);
+
+	setsockopt(tci->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+	return write(tci->fd, buf, nbytes);
 }
 
-static void iscsi_tcp_write_end(int ep)
+static void iscsi_tcp_write_end(struct iscsi_connection *conn)
 {
+	struct tcp_conn_info *tci = conn->trans_data;
 	int opt = 0;
-	setsockopt(ep, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
+
+	setsockopt(tci->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
 }
 
-static size_t iscsi_tcp_close(int ep)
+static size_t iscsi_tcp_close(struct iscsi_connection *conn)
 {
-	return close(ep);
+	struct tcp_conn_info *tci = conn->trans_data;
+
+	tgt_event_del(tci->fd);
+	return close(tci->fd);
 }
 
-static int iscsi_tcp_show(int ep, char *buf, int rest)
+static int iscsi_tcp_show(struct iscsi_connection *conn, char *buf, int rest)
 {
+	struct tcp_conn_info *tci = conn->trans_data;
 	int err, total = 0;
 	socklen_t slen;
 	char dst[INET6_ADDRSTRLEN];
 	struct sockaddr_storage from;
 
 	slen = sizeof(from);
-	err = getpeername(ep, (struct sockaddr *) &from, &slen);
+	err = getpeername(tci->fd, (struct sockaddr *) &from, &slen);
 	if (err < 0) {
 		eprintf("%m\n");
 		return 0;
@@ -253,11 +270,12 @@ static int iscsi_tcp_show(int ep, char *buf, int rest)
 	return total > 0 ? total : 0;
 }
 
-void iscsi_event_modify(int fd, int events)
+void iscsi_event_modify(struct iscsi_connection *conn, int events)
 {
 	int ret;
+	struct tcp_conn_info *tci = conn->trans_data;
 
-	ret = tgt_event_modify(fd, events);
+	ret = tgt_event_modify(tci->fd, events);
 	if (ret)
 		eprintf("tgt_event_modify failed\n");
 }
@@ -274,6 +292,22 @@ void iscsi_tcp_free(struct iscsi_connection *conn __attribute__((unused)),
 	free(buf);
 }
 
+int iscsi_tcp_getsockname(struct iscsi_connection *conn, struct sockaddr *sa,
+			  socklen_t *len)
+{
+	struct tcp_conn_info *tci = conn->trans_data;
+
+	return getsockname(tci->fd, sa, len);
+}
+
+int iscsi_tcp_getpeername(struct iscsi_connection *conn, struct sockaddr *sa,
+			  socklen_t *len)
+{
+	struct tcp_conn_info *tci = conn->trans_data;
+
+	return getpeername(tci->fd, sa, len);
+}
+
 struct iscsi_transport iscsi_tcp = {
 	.name			= "iscsi",
 	.rdma			= 0,
@@ -286,4 +320,6 @@ struct iscsi_transport iscsi_tcp = {
 	.ep_event_modify	= iscsi_event_modify,
 	.ep_malloc		= iscsi_tcp_malloc,
 	.ep_free		= iscsi_tcp_free,
+	.ep_getsockname		= iscsi_tcp_getsockname,
+	.ep_getpeername		= iscsi_tcp_getpeername,
 };
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 85c7724..51d9bd9 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -435,7 +435,7 @@ static void login_start(struct iscsi_connection *conn)
 			return;
 		}
 
-		if (ip_acl(conn->tid, conn->fd)) {
+		if (ip_acl(conn->tid, conn)) {
 			rsp->status_class = ISCSI_STATUS_CLS_INITIATOR_ERR;
 			rsp->status_detail = ISCSI_LOGIN_STATUS_TGT_NOT_FOUND;
 			conn->state = STATE_EXIT;
@@ -687,7 +687,8 @@ static void text_scan_text(struct iscsi_connection *conn)
 			blen = sizeof(buf);
 
 			slen = sizeof(ss);
-			getsockname(conn->fd, (struct sockaddr *) &ss, &slen);
+			conn->tp->ep_getsockname(conn, (struct sockaddr *) &ss,
+						 &slen);
 			if (ss.ss_family == AF_INET6) {
 				*p++ = '[';
 				blen--;
@@ -1037,7 +1038,7 @@ static int iscsi_scsi_cmd_done(uint64_t nid, int result, struct scsi_cmd *scmd)
 	}
 
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
-	task->conn->tp->ep_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+	task->conn->tp->ep_event_modify(task->conn, EPOLLIN | EPOLLOUT);
 
 	return 0;
 }
@@ -1167,7 +1168,7 @@ int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 	task->offset = 0;  /* for use as transmit pointer for data-ins */
 	err = iscsi_target_cmd_queue(task);
 no_queuing:
-	conn->tp->ep_event_modify(conn->fd, EPOLLIN | EPOLLOUT);
+	conn->tp->ep_event_modify(conn, EPOLLIN | EPOLLOUT);
 
 	return err;
 }
@@ -1197,7 +1198,7 @@ static int iscsi_tm_done(struct mgmt_req *mreq)
 		break;
 	}
 	list_add_tail(&task->c_list, &task->conn->tx_clist);
-	task->conn->tp->ep_event_modify(task->conn->fd, EPOLLIN | EPOLLOUT);
+	task->conn->tp->ep_event_modify(task->conn, EPOLLIN | EPOLLOUT);
 	return 0;
 }
 
@@ -1253,8 +1254,7 @@ static int iscsi_task_execute(struct iscsi_task *task)
 	case ISCSI_OP_NOOP_OUT:
 	case ISCSI_OP_LOGOUT:
 		list_add_tail(&task->c_list, &task->conn->tx_clist);
-		task->conn->tp->ep_event_modify(task->conn->fd,
-						EPOLLIN | EPOLLOUT);
+		task->conn->tp->ep_event_modify(task->conn, EPOLLIN | EPOLLOUT);
 		break;
 	case ISCSI_OP_SCSI_CMD:
 		/* convenient directionality for our internal use */
@@ -1274,7 +1274,7 @@ static int iscsi_task_execute(struct iscsi_task *task)
 		err = iscsi_tm_execute(task);
 		if (err) {
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
-			task->conn->tp->ep_event_modify(task->conn->fd,
+			task->conn->tp->ep_event_modify(task->conn,
 							EPOLLIN | EPOLLOUT);
 		}
 		break;
@@ -1719,15 +1719,15 @@ static int iscsi_task_tx_start(struct iscsi_connection *conn)
 
 nodata:
 	dprintf("no more data\n");
-	conn->tp->ep_event_modify(conn->fd, EPOLLIN);
+	conn->tp->ep_event_modify(conn, EPOLLIN);
 	return -EAGAIN;
 }
 
-static int do_recv(int fd, struct iscsi_connection *conn, int next_state)
+static int do_recv(struct iscsi_connection *conn, int next_state)
 {
 	int ret;
 
-	ret = conn->tp->ep_read(fd, conn->rx_buffer, conn->rx_size);
+	ret = conn->tp->ep_read(conn, conn->rx_buffer, conn->rx_size);
 	if (!ret) {
 		conn->state = STATE_CLOSE;
 		return 0;
@@ -1746,7 +1746,7 @@ static int do_recv(int fd, struct iscsi_connection *conn, int next_state)
 	return ret;
 }
 
-void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
+void iscsi_rx_handler(struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -1760,7 +1760,7 @@ void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
 again:
 	switch (conn->rx_iostate) {
 	case IOSTATE_RX_BHS:
-		ret = do_recv(fd, conn, IOSTATE_RX_INIT_AHS);
+		ret = do_recv(conn, IOSTATE_RX_INIT_AHS);
 		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_AHS)
 			break;
 	case IOSTATE_RX_INIT_AHS:
@@ -1797,7 +1797,7 @@ again:
 		else if (conn->rx_iostate != IOSTATE_RX_AHS)
 			break;
 	case IOSTATE_RX_AHS:
-		ret = do_recv(fd, conn, hdigest ?
+		ret = do_recv(conn, hdigest ?
 			      IOSTATE_RX_INIT_HDIGEST : IOSTATE_RX_INIT_DATA);
 		if (ret <= 0)
 			break;
@@ -1810,7 +1810,7 @@ again:
 		conn->rx_size = sizeof(conn->rx_digest);
 		conn->rx_iostate = IOSTATE_RX_HDIGEST;
 	case IOSTATE_RX_HDIGEST:
-		ret = do_recv(fd, conn, IOSTATE_RX_CHECK_HDIGEST);
+		ret = do_recv(conn, IOSTATE_RX_CHECK_HDIGEST);
 		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_CHECK_HDIGEST)
 			break;
 	case IOSTATE_RX_CHECK_HDIGEST:
@@ -1836,7 +1836,7 @@ again:
 			break;
 		}
 	case IOSTATE_RX_DATA:
-		ret = do_recv(fd, conn, ddigest ?
+		ret = do_recv(conn, ddigest ?
 			      IOSTATE_RX_INIT_DDIGEST : IOSTATE_RX_END);
 		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_INIT_DDIGEST)
 			break;
@@ -1845,7 +1845,7 @@ again:
 		conn->rx_size = sizeof(conn->rx_digest);
 		conn->rx_iostate = IOSTATE_RX_DDIGEST;
 	case IOSTATE_RX_DDIGEST:
-		ret = do_recv(fd, conn, IOSTATE_RX_CHECK_DDIGEST);
+		ret = do_recv(conn, IOSTATE_RX_CHECK_DDIGEST);
 		if (ret <= 0 || conn->rx_iostate != IOSTATE_RX_CHECK_DDIGEST)
 			break;
 	case IOSTATE_RX_CHECK_DDIGEST:
@@ -1883,18 +1883,18 @@ again:
 			conn_read_pdu(conn);
 	} else {
 		conn_write_pdu(conn);
-		conn->tp->ep_event_modify(fd, EPOLLOUT);
+		conn->tp->ep_event_modify(conn, EPOLLOUT);
 		ret = cmnd_execute(conn);
 		if (ret)
 			conn->state = STATE_CLOSE;
 	}
 }
 
-static int do_send(int fd, struct iscsi_connection *conn, int next_state)
+static int do_send(struct iscsi_connection *conn, int next_state)
 {
 	int ret;
 again:
-	ret = conn->tp->ep_write_begin(fd, conn->tx_buffer, conn->tx_size);
+	ret = conn->tp->ep_write_begin(conn, conn->tx_buffer, conn->tx_size);
 	if (ret < 0) {
 		if (errno != EINTR && errno != EAGAIN)
 			conn->state = STATE_CLOSE;
@@ -1913,7 +1913,7 @@ again:
 	return 0;
 }
 
-void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
+void iscsi_tx_handler(struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -1933,7 +1933,7 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 
 	switch (conn->tx_iostate) {
 	case IOSTATE_TX_BHS:
-		ret = do_send(fd, conn, IOSTATE_TX_INIT_AHS);
+		ret = do_send(conn, IOSTATE_TX_INIT_AHS);
 		if (ret < 0)
 			break;
 	case IOSTATE_TX_INIT_AHS:
@@ -1962,7 +1962,7 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		conn->tx_buffer = conn->tx_digest;
 		conn->tx_size = sizeof(conn->tx_digest);
 	case IOSTATE_TX_HDIGEST:
-		ret = do_send(fd, conn, IOSTATE_TX_INIT_DATA);
+		ret = do_send(conn, IOSTATE_TX_INIT_DATA);
 		if (ret < 0)
 			break;
 	case IOSTATE_TX_INIT_DATA:
@@ -1983,7 +1983,7 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		if (conn->tx_iostate != IOSTATE_TX_DATA)
 			break;
 	case IOSTATE_TX_DATA:
-		ret = do_send(fd, conn, ddigest ?
+		ret = do_send(conn, ddigest ?
 			      IOSTATE_TX_INIT_DDIGEST : IOSTATE_TX_END);
 		if (ret < 0)
 			return;
@@ -1998,7 +1998,7 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		conn->tx_buffer = conn->tx_digest;
 		conn->tx_size = sizeof(conn->tx_digest);
 	case IOSTATE_TX_DDIGEST:
-		ret = do_send(fd, conn, IOSTATE_TX_END);
+		ret = do_send(conn, IOSTATE_TX_END);
 		break;
 	default:
 		eprintf("error %d %d\n", conn->state, conn->tx_iostate);
@@ -2016,18 +2016,18 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		exit(1);
 	}
 
-	conn->tp->ep_write_end(fd);
+	conn->tp->ep_write_end(conn);
 	cmnd_finish(conn);
 
 	switch (conn->state) {
 	case STATE_KERNEL:
-		ret = conn_take_fd(conn, fd);
+		ret = conn_take_fd(conn);
 		if (ret)
 			conn->state = STATE_CLOSE;
 		else {
 			conn->state = STATE_SCSI;
 			conn_read_pdu(conn);
-			conn->tp->ep_event_modify(fd, EPOLLIN);
+			conn->tp->ep_event_modify(conn, EPOLLIN);
 		}
 		break;
 	case STATE_EXIT:
@@ -2038,7 +2038,7 @@ void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 		break;
 	default:
 		conn_read_pdu(conn);
-		conn->tp->ep_event_modify(fd, EPOLLIN);
+		conn->tp->ep_event_modify(conn, EPOLLIN);
 		break;
 	}
 }
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 524c2f3..d4b4799 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -134,7 +134,6 @@ struct iscsi_connection {
 	int state;
 	int rx_iostate;
 	int tx_iostate;
-	int fd;
 	int refcount;
 
 	struct list_head clist;
@@ -185,6 +184,7 @@ struct iscsi_connection {
 	} auth;
 
 	struct iscsi_transport *tp;
+	void *trans_data;   /* transport specific data */
 };
 
 #define STATE_FREE		0
@@ -250,20 +250,20 @@ extern struct list_head iscsi_targets_list;
 extern int cmnd_exec_auth_chap(struct iscsi_connection *conn);
 
 /* conn.c */
-extern struct iscsi_connection *conn_alloc(void);
-extern void conn_close(struct iscsi_connection *conn, int fd);
+extern struct iscsi_connection *conn_alloc(unsigned int trans_len);
+extern void conn_close(struct iscsi_connection *conn);
 extern void conn_put(struct iscsi_connection *conn);
 extern int conn_get(struct iscsi_connection *conn);
 extern struct iscsi_connection * conn_find(struct iscsi_session *session, uint32_t cid);
-extern int conn_take_fd(struct iscsi_connection *conn, int fd);
+extern int conn_take_fd(struct iscsi_connection *conn);
 extern void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_session *session);
 
 /* iscsid.c */
 extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
 extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
 extern void conn_read_pdu(struct iscsi_connection *conn);
-extern void iscsi_tx_handler(int fd, struct iscsi_connection *conn);
-extern void iscsi_rx_handler(int fd, struct iscsi_connection *conn);
+extern void iscsi_tx_handler(struct iscsi_connection *conn);
+extern void iscsi_rx_handler(struct iscsi_connection *conn);
 extern int iscsi_scsi_cmd_execute(struct iscsi_task *task);
 
 /* iscsid.c iscsi_task */
@@ -279,7 +279,7 @@ extern void session_put(struct iscsi_session *session);
 struct iscsi_target * target_find_by_name(const char *name);
 struct iscsi_target * target_find_by_id(int tid);
 extern void target_list_build(struct iscsi_connection *, char *, char *);
-extern int ip_acl(int tid, int fd);
+extern int ip_acl(int tid, struct iscsi_connection *conn);
 extern int iscsi_target_create(struct target *);
 extern void iscsi_target_destroy(int);
 extern int iscsi_target_show(int mode, int tid, uint64_t sid, uint32_t cid,
diff --git a/usr/iscsi/session.c b/usr/iscsi/session.c
index dfb94d0..3b1650d 100644
--- a/usr/iscsi/session.c
+++ b/usr/iscsi/session.c
@@ -103,7 +103,7 @@ int session_create(struct iscsi_connection *conn)
 	}
 
 	memset(addr, 0, sizeof(addr));
-	conn->tp->ep_show(conn->fd, addr, sizeof(addr));
+	conn->tp->ep_show(conn, addr, sizeof(addr));
 
 	snprintf(session->info, 1024, _TAB3 "Initiator: %s\n"
 		 _TAB3 "Connection: %u\n"
diff --git a/usr/iscsi/target.c b/usr/iscsi/target.c
index 2653839..ab0685f 100644
--- a/usr/iscsi/target.c
+++ b/usr/iscsi/target.c
@@ -115,7 +115,7 @@ static int address_match(struct sockaddr *sa1, struct sockaddr *sa2)
 	return 0;
 }
 
-static int ip_match(int fd, char *address)
+static int ip_match(struct iscsi_connection *conn, char *address)
 {
 	struct sockaddr_storage from;
 	struct addrinfo hints, *res;
@@ -124,7 +124,7 @@ static int ip_match(int fd, char *address)
 	int err;
 
 	len = sizeof(from);
-	err = getpeername(fd, (struct sockaddr *) &from, &len);
+	err = conn->tp->ep_getpeername(conn, (struct sockaddr *) &from, &len);
 	if (err < 0)
 		return -EPERM;
 
@@ -173,7 +173,7 @@ out:
 	return err;
 }
 
-int ip_acl(int tid, int fd)
+int ip_acl(int tid, struct iscsi_connection *conn)
 {
 	int idx, err;
 	char *addr;
@@ -183,7 +183,7 @@ int ip_acl(int tid, int fd)
 		if (!addr)
 			break;
 
-		err = ip_match(fd, addr);
+		err = ip_match(conn, addr);
 		if (!err)
 			return 0;
 	}
@@ -198,7 +198,7 @@ void target_list_build(struct iscsi_connection *conn, char *addr, char *name)
 		if (name && strcmp(tgt_targetname(target->tid), name))
 			continue;
 
-		if (ip_acl(target->tid, conn->fd))
+		if (ip_acl(target->tid, conn))
 			continue;
 
 		if (isns_scn_access(target->tid, conn->initiator))
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index c37d0da..c1e9dc1 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -1,6 +1,8 @@
 #ifndef __TRANSPORT_H
 #define __TRANSPORT_H
 
+#include <sys/socket.h>
+
 struct iscsi_connection;
 
 struct iscsi_transport {
@@ -8,14 +10,20 @@ struct iscsi_transport {
 	int rdma;
 
 	int (*ep_init) (void);
-	size_t (*ep_read) (int ep, void *buf, size_t nbytes);
-	size_t (*ep_write_begin) (int ep, void *buf, size_t nbytes);
-	void (*ep_write_end)(int ep);
-	size_t (*ep_close) (int ep);
-	int (*ep_show) (int ep, char *buf, int rest);
-	void (*ep_event_modify) (int ep, int events);
+	size_t (*ep_read) (struct iscsi_connection *conn, void *buf,
+			   size_t nbytes);
+	size_t (*ep_write_begin) (struct iscsi_connection *conn, void *buf,
+				  size_t nbytes);
+	void (*ep_write_end) (struct iscsi_connection *conn);
+	size_t (*ep_close) (struct iscsi_connection *conn);
+	int (*ep_show) (struct iscsi_connection *conn, char *buf, int rest);
+	void (*ep_event_modify) (struct iscsi_connection *conn, int events);
 	void *(*ep_malloc) (struct iscsi_connection *conn, size_t sz);
 	void (*ep_free) (struct iscsi_connection *conn, void *buf);
+	int (*ep_getsockname) (struct iscsi_connection *conn,
+			       struct sockaddr *sa, socklen_t *len);
+	int (*ep_getpeername) (struct iscsi_connection *conn,
+			       struct sockaddr *sa, socklen_t *len);
 };
 
 extern struct iscsi_transport iscsi_tcp;
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:19:03 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:19:03 -0400
Subject: [Stgt-devel] [PATCH 04/20] iser bidi alloc read buf
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <fbce48d03005d95a2bdd5de062bbf5595cc75f85.1192554396.git.pw@osc.edu>

Allocate the read buffer for bidirectional commands in the transport to
pass down to devices.  A device can fill and return this buffer in
task->uaddr, and thus choose to do the read or write processing in any
order.  Unfortunately, this allocation can not be combined with the task
and task->data allocation as the bidi read size is not known until after
AHS processing.

Necessary for iscsi RDMA transport to be able to provide its own buffers
for the read phase too.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c |   27 +++++++++++++++++++--------
 usr/tgtd.h         |    2 ++
 2 files changed, 21 insertions(+), 8 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 69832b2..5d90b06 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -988,6 +988,8 @@ void iscsi_free_task(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 
+	if (task->addr && task->addr != (unsigned long) task->data)
+		free((void *) (unsigned long) task->addr);
 	free(task);
 	/* from alloc */
 	conn_put(conn);
@@ -1003,10 +1005,6 @@ static void iscsi_free_cmd_task(struct iscsi_task *task)
 	target_cmd_done(&task->scmd);
 
 	list_del(&task->c_hlist);
-	if (task->data) {
-		if ((unsigned long) task->data != task->addr)
-			free((void *) (unsigned long) task->addr);
-	}
 	iscsi_free_task(task);
 }
 
@@ -1069,7 +1067,6 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 	struct scsi_cmd *scmd = &task->scmd;
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
-	unsigned long uaddr = (unsigned long) task->data;
 	uint32_t data_len;
 	uint8_t *ahs;
 	int ahslen;
@@ -1112,18 +1109,32 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 
 	/* figure out incoming (write) and outgoing (read) sizes */
 	data_len = 0;
+	scmd->bidi_uaddr = 0;
+	scmd->bidi_len = 0;
+	task->read_len = 0;
 	task->write_len = 0;
+
 	if (task->dir == WRITE || task->dir == BIDIRECTIONAL) {
 		task->write_len = ntohl(req->data_length);
 		data_len = task->write_len;
 	}
-	task->read_len = 0;
 	if (task->dir == BIDIRECTIONAL && ahslen >= 8) {
 		struct iscsi_rlength_ahdr *ahs_bidi = (void *) ahs;
 		if (ahs_bidi->ahstype == ISCSI_AHSTYPE_RLENGTH) {
 			task->read_len = ntohl(ahs_bidi->read_length);
 			dprintf("bidi read len %u\n", task->read_len);
 		}
+		if (task->read_len) {
+			uint32_t len;
+			void *buf;
+
+			len = roundup(task->read_len, 4);
+			buf = malloc(len);
+			if (!buf)
+				return -ENOMEM;
+			scmd->bidi_uaddr = (unsigned long) buf;
+			scmd->bidi_len = task->read_len;
+		}
 	}
 	if (task->dir == READ) {
 		task->read_len = ntohl(req->data_length);
@@ -1132,10 +1143,10 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 
 	memcpy(scmd->lun, task->req.lun, sizeof(scmd->lun));
 	scmd->rw = req->flags & ISCSI_FLAG_CMD_WRITE;
-	scmd->len = ntohl(req->data_length);
+	scmd->len = data_len;
 	scmd->attribute = cmd_attr(task);
 	scmd->tag = req->itt;
-	scmd->uaddr = uaddr;
+	scmd->uaddr = (unsigned long) task->data;
 
 	return target_cmd_queue(conn->session->target->tid, scmd);
 }
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 1f8e33b..1f5b41f 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -143,6 +143,8 @@ struct scsi_cmd {
 
 	uint64_t uaddr;
 	uint32_t len;
+	uint64_t bidi_uaddr;  /* for read part when bidi */
+	uint32_t bidi_len;
 	int mmapped;
 	struct scsi_lu *dev;
 	unsigned long state;
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:20:22 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:20:22 -0400
Subject: [Stgt-devel] [PATCH 09/20] iser event handler to tcp
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <4c49de1d38fc3ccd34899fb12a7be1c8c31563d4.1192554396.git.pw@osc.edu>

Move iscsi_event_handler to iscsi_tcp.c as it is TCP-specific.  RDMA will
have its own event handler.  Both will call into iscsi_tx_handler and
iscsi_rx_handler, which are now exported, along with iscsi_scsi_cmd_execute
that will be needed when an RDMA read collects all the write data.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |   23 ++++++++++++++++++++++-
 usr/iscsi/iscsid.c    |   25 +++----------------------
 usr/iscsi/iscsid.h    |    4 +++-
 3 files changed, 28 insertions(+), 24 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 0d189c7..7e0ab90 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -40,6 +40,8 @@
 #define LISTEN_MAX		4
 #define INCOMING_MAX		32
 
+static void iscsi_tcp_event_handler(int fd, int events, void *data);
+
 static int set_keepalive(int fd)
 {
 	int ret, opt;
@@ -97,7 +99,7 @@ static void accept_connection(int afd, int events, void *data)
 	conn_read_pdu(conn);
 	set_non_blocking(fd);
 
-	err = tgt_event_add(fd, EPOLLIN, iscsi_event_handler, conn);
+	err = tgt_event_add(fd, EPOLLIN, iscsi_tcp_event_handler, conn);
 	if (err)
 		goto free_conn;
 
@@ -109,6 +111,25 @@ out:
 	return;
 }
 
+static void iscsi_tcp_event_handler(int fd, int events, void *data)
+{
+	struct iscsi_connection *conn = (struct iscsi_connection *) data;
+
+	if (events & EPOLLIN)
+		iscsi_rx_handler(fd, conn);
+
+	if (conn->state == STATE_CLOSE)
+		dprintf("connection closed\n");
+
+	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
+		iscsi_tx_handler(fd, conn);
+
+	if (conn->state == STATE_CLOSE) {
+		conn_close(conn, fd);
+		dprintf("connection closed\n");
+	}
+}
+
 static int iscsi_tcp_init(void)
 {
 	struct addrinfo hints, *res, *res0;
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 59f226c..85c7724 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -1151,7 +1151,7 @@ static int iscsi_target_cmd_queue(struct iscsi_task *task)
 	return target_cmd_queue(conn->session->target->tid, scmd);
 }
 
-static int iscsi_scsi_cmd_execute(struct iscsi_task *task)
+int iscsi_scsi_cmd_execute(struct iscsi_task *task)
 {
 	struct iscsi_connection *conn = task->conn;
 	struct iscsi_cmd *req = (struct iscsi_cmd *) &task->req;
@@ -1746,7 +1746,7 @@ static int do_recv(int fd, struct iscsi_connection *conn, int next_state)
 	return ret;
 }
 
-static void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
+void iscsi_rx_handler(int fd, struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -1913,7 +1913,7 @@ again:
 	return 0;
 }
 
-static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
+void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -2043,25 +2043,6 @@ static void iscsi_tx_handler(int fd, struct iscsi_connection *conn)
 	}
 }
 
-void iscsi_event_handler(int fd, int events, void *data)
-{
-	struct iscsi_connection *conn = (struct iscsi_connection *) data;
-
-	if (events & EPOLLIN)
-		iscsi_rx_handler(fd, conn);
-
-	if (conn->state == STATE_CLOSE)
-		dprintf("connection closed\n");
-
-	if (conn->state != STATE_CLOSE && events & EPOLLOUT)
-		iscsi_tx_handler(fd, conn);
-
-	if (conn->state == STATE_CLOSE) {
-		conn_close(conn, fd);
-		dprintf("connection closed\n");
-	}
-}
-
 struct tgt_driver iscsi = {
 	.name			= "iscsi",
 	.use_kernel		= 0,
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index 2f6c7c8..524c2f3 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -259,10 +259,12 @@ extern int conn_take_fd(struct iscsi_connection *conn, int fd);
 extern void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_session *session);
 
 /* iscsid.c */
-extern void iscsi_event_handler(int fd, int events, void *data);
 extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
 extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
 extern void conn_read_pdu(struct iscsi_connection *conn);
+extern void iscsi_tx_handler(int fd, struct iscsi_connection *conn);
+extern void iscsi_rx_handler(int fd, struct iscsi_connection *conn);
+extern int iscsi_scsi_cmd_execute(struct iscsi_task *task);
 
 /* iscsid.c iscsi_task */
 extern void iscsi_free_task(struct iscsi_task *task);
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:21:20 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:21:20 -0400
Subject: [Stgt-devel] [PATCH 11/20] iser connection init
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <b05bdb66b7262eb86d1b956ba4fc2dda46f8e2b6.1192554396.git.pw@osc.edu>

After successful negotiation, call into the transport to allocate resources
or otherwise ready the switch to full feature mode.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsi_tcp.c |    6 ++++++
 usr/iscsi/iscsid.c    |   19 ++++++++++++++++++-
 usr/iscsi/transport.h |    1 +
 3 files changed, 25 insertions(+), 1 deletions(-)

diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 33cd6f8..566dd9e 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -210,6 +210,11 @@ static int iscsi_tcp_init(void)
 	return !nr_sock;
 }
 
+static int iscsi_tcp_conn_init(struct iscsi_connection *conn)
+{
+	return 0;
+}
+
 static size_t iscsi_tcp_read(struct iscsi_connection *conn, void *buf,
 			     size_t nbytes)
 {
@@ -312,6 +317,7 @@ struct iscsi_transport iscsi_tcp = {
 	.name			= "iscsi",
 	.rdma			= 0,
 	.ep_init		= iscsi_tcp_init,
+	.ep_conn_init		= iscsi_tcp_conn_init,
 	.ep_read		= iscsi_tcp_read,
 	.ep_write_begin		= iscsi_tcp_write_begin,
 	.ep_write_end		= iscsi_tcp_write_end,
diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index 51d9bd9..27b17f4 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -469,8 +469,22 @@ static void login_start(struct iscsi_connection *conn)
 
 static void login_finish(struct iscsi_connection *conn)
 {
+	struct iscsi_login_rsp *rsp = (struct iscsi_login_rsp *) &conn->rsp.bhs;
+	int ret;
+
 	switch (conn->session_type) {
 	case SESSION_NORMAL:
+		/*
+		 * Allocate transport resources for this connection.
+		 */
+		ret = conn->tp->ep_conn_init(conn);
+		if (ret) {
+			rsp->flags = 0;
+			rsp->status_class = ISCSI_STATUS_CLS_TARGET_ERR;
+			rsp->status_detail = ISCSI_LOGIN_STATUS_NO_RESOURCES;
+			conn->state = STATE_EXIT;
+			break;
+		}
 		if (!conn->session)
 			session_create(conn);
 		memcpy(conn->isid, conn->session->isid, sizeof(conn->isid));
@@ -637,8 +651,11 @@ static void cmnd_exec_login(struct iscsi_connection *conn)
 			default:
 				goto init_err;
 			}
-			if (!stay && !nsg_disagree)
+			if (!stay && !nsg_disagree) {
 				login_finish(conn);
+				if (rsp->status_class)
+					return;
+			}
 			break;
 		default:
 			goto init_err;
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index c1e9dc1..3421371 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -10,6 +10,7 @@ struct iscsi_transport {
 	int rdma;
 
 	int (*ep_init) (void);
+	int (*ep_conn_init) (struct iscsi_connection *conn);
 	size_t (*ep_read) (struct iscsi_connection *conn, void *buf,
 			   size_t nbytes);
 	size_t (*ep_write_begin) (struct iscsi_connection *conn, void *buf,
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:21:22 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:21:22 -0400
Subject: [Stgt-devel] [PATCH 13/20] iser close free
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <c55f7b196b716514adc886ae99f0042ef5ee81f1.1192554396.git.pw@osc.edu>

Separate transport close operation from the free operation, as RDMA will
initiate a close, but must not free resources until all references to
the connection have gone away.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/conn.c      |    3 ++-
 usr/iscsi/iscsi_tcp.c |   12 +++++++++---
 usr/iscsi/transport.h |    3 ++-
 3 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/usr/iscsi/conn.c b/usr/iscsi/conn.c
index 1e9dace..9b0c3b9 100644
--- a/usr/iscsi/conn.c
+++ b/usr/iscsi/conn.c
@@ -80,6 +80,7 @@ static void conn_free(struct iscsi_connection *conn)
 	struct iscsi_session *session = conn->session;
 
 	dprintf("freeing connection\n");
+	conn->tp->ep_conn_free(conn);
 	list_del(&conn->clist);
 	free(conn->req_buffer);
 	free(conn->rsp_buffer);
@@ -94,7 +95,7 @@ void conn_close(struct iscsi_connection *conn)
 {
 	struct iscsi_task *task, *tmp;
 
-	conn->tp->ep_close(conn);
+	conn->tp->ep_conn_close(conn);
 
 	dprintf("connection closed\n");
 
diff --git a/usr/iscsi/iscsi_tcp.c b/usr/iscsi/iscsi_tcp.c
index 53cf0e5..f03caa5 100644
--- a/usr/iscsi/iscsi_tcp.c
+++ b/usr/iscsi/iscsi_tcp.c
@@ -244,12 +244,17 @@ static void iscsi_tcp_write_end(struct iscsi_connection *conn)
 	setsockopt(tci->fd, SOL_TCP, TCP_CORK, &opt, sizeof(opt));
 }
 
-static size_t iscsi_tcp_close(struct iscsi_connection *conn)
+static void iscsi_tcp_conn_close(struct iscsi_connection *conn)
 {
 	struct tcp_conn_info *tci = conn->trans_data;
 
 	tgt_event_del(tci->fd);
-	return close(tci->fd);
+	close(tci->fd);
+}
+
+static void iscsi_tcp_conn_free(struct iscsi_connection *conn
+				__attribute__((unused)))
+{
 }
 
 static int iscsi_tcp_show(struct iscsi_connection *conn, char *buf, int rest)
@@ -327,7 +332,8 @@ struct iscsi_transport iscsi_tcp = {
 	.ep_read		= iscsi_tcp_read,
 	.ep_write_begin		= iscsi_tcp_write_begin,
 	.ep_write_end		= iscsi_tcp_write_end,
-	.ep_close		= iscsi_tcp_close,
+	.ep_conn_close		= iscsi_tcp_conn_close,
+	.ep_conn_free		= iscsi_tcp_conn_free,
 	.ep_show		= iscsi_tcp_show,
 	.ep_event_modify	= iscsi_event_modify,
 	.ep_malloc		= iscsi_tcp_malloc,
diff --git a/usr/iscsi/transport.h b/usr/iscsi/transport.h
index a8b8680..f35d9d7 100644
--- a/usr/iscsi/transport.h
+++ b/usr/iscsi/transport.h
@@ -19,7 +19,8 @@ struct iscsi_transport {
 	size_t (*ep_write_begin) (struct iscsi_connection *conn, void *buf,
 				  size_t nbytes);
 	void (*ep_write_end) (struct iscsi_connection *conn);
-	size_t (*ep_close) (struct iscsi_connection *conn);
+	void (*ep_conn_close) (struct iscsi_connection *conn);
+	void (*ep_conn_free) (struct iscsi_connection *conn);
 	int (*ep_show) (struct iscsi_connection *conn, char *buf, int rest);
 	void (*ep_event_modify) (struct iscsi_connection *conn, int events);
 	void *(*ep_malloc) (struct iscsi_connection *conn, size_t sz);
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:18:57 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:18:57 -0400
Subject: [Stgt-devel] [PATCH 02/20] iser counter events
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <dd2479de1f0ef5cc0e6e83fea0bb1da41f4c31a5.1192554396.git.pw@osc.edu>

Like fd event handling, also handle integer counter events.  This will
be used in RDMA to make progress on a connection, necessary because
RDMA API does not have a file descriptor that can be used with poll
to detect connection writability.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/tgtd.c |   70 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++---
 usr/tgtd.h |    4 +++
 2 files changed, 70 insertions(+), 4 deletions(-)

diff --git a/usr/tgtd.c b/usr/tgtd.c
index 42e21f4..6744534 100644
--- a/usr/tgtd.c
+++ b/usr/tgtd.c
@@ -41,9 +41,15 @@
 #define MAX_FDS	4096
 
 struct tgt_event {
-	event_handler_t *handler;
+	union {
+		event_handler_t *handler;
+		counter_event_handler_t *counter_handler;
+	};
+	union {
+		int fd;
+		int *counter;
+	};
 	void *data;
-	int fd;
 	struct list_head e_list;
 };
 
@@ -52,6 +58,7 @@ unsigned long pagesize, pageshift, pagemask;
 static int ep_fd;
 static char program_name[] = "tgtd";
 static LIST_HEAD(tgt_events_list);
+static LIST_HEAD(tgt_counter_events_list);
 
 static struct option const long_options[] =
 {
@@ -129,6 +136,22 @@ int tgt_event_add(int fd, int events, event_handler_t handler, void *data)
 	return err;
 }
 
+int tgt_counter_event_add(int *counter, counter_event_handler_t handler,
+			  void *data)
+{
+	struct tgt_event *tev;
+
+	tev = zalloc(sizeof(*tev));
+	if (!tev)
+		return -ENOMEM;
+
+	tev->data = data;
+	tev->counter_handler = handler;
+	tev->counter = counter;
+	list_add(&tev->e_list, &tgt_counter_events_list);
+	return 0;
+}
+
 static struct tgt_event *tgt_event_lookup(int fd)
 {
 	struct tgt_event *tev;
@@ -140,6 +163,17 @@ static struct tgt_event *tgt_event_lookup(int fd)
 	return NULL;
 }
 
+static struct tgt_event *tgt_counter_event_lookup(int *counter)
+{
+	struct tgt_event *tev;
+
+	list_for_each_entry(tev, &tgt_counter_events_list, e_list) {
+		if (tev->counter == counter)
+			return tev;
+	}
+	return NULL;
+}
+
 void tgt_event_del(int fd)
 {
 	struct tgt_event *tev;
@@ -155,6 +189,20 @@ void tgt_event_del(int fd)
 	free(tev);
 }
 
+void tgt_counter_event_del(int *counter)
+{
+	struct tgt_event *tev;
+
+	tev = tgt_counter_event_lookup(counter);
+	if (!tev) {
+		eprintf("Cannot find counter event %p\n", counter);
+		return;
+	}
+
+	list_del(&tev->e_list);
+	free(tev);
+}
+
 int tgt_event_modify(int fd, int events)
 {
 	struct epoll_event ev;
@@ -174,11 +222,25 @@ int tgt_event_modify(int fd, int events)
 
 static void event_loop(void)
 {
-	int nevent, i, timeout = TGTD_TICK_PERIOD * 1000;
+	int nevent, i, done, timeout = TGTD_TICK_PERIOD * 1000;
 	struct epoll_event events[1024];
-	struct tgt_event *tev;
+	struct tgt_event *tev, *tevn;
 
 retry:
+	/*
+	 * Check the counter events to see if they have any work to run.
+	 */
+	do {
+		done = 1;
+		list_for_each_entry_safe(tev, tevn, &tgt_counter_events_list,
+					e_list) {
+			if (*tev->counter) {
+				done = 0;
+				tev->counter_handler(tev->counter, tev->data);
+			}
+		}
+	} while (!done);
+
 	nevent = epoll_wait(ep_fd, events, ARRAY_SIZE(events), timeout);
 	if (nevent < 0) {
 		if (errno != EINTR) {
diff --git a/usr/tgtd.h b/usr/tgtd.h
index 8d5b2b6..1f8e33b 100644
--- a/usr/tgtd.h
+++ b/usr/tgtd.h
@@ -209,8 +209,12 @@ extern int tgt_unbind_host_to_target(int tid, int host_no);
 extern int tgt_bound_target_lookup(int host_no);
 
 typedef void (event_handler_t)(int fd, int events, void *data);
+typedef void (counter_event_handler_t)(int *counter, void *data);
 extern int tgt_event_add(int fd, int events, event_handler_t handler, void *data);
+extern int tgt_counter_event_add(int *counter, counter_event_handler_t handler,
+				 void *data);
 extern void tgt_event_del(int fd);
+extern void tgt_counter_event_del(int *counter);
 extern int tgt_event_modify(int fd, int events);
 extern int target_cmd_queue(int tid, struct scsi_cmd *cmd);
 extern void target_cmd_done(struct scsi_cmd *cmd);
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:18:55 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:18:55 -0400
Subject: [Stgt-devel] [PATCH 01/20] iser docs
Message-ID: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>

A document describing what iSCSI on RDMA is about, how it is
implemented in tgtd, and how to use it.  Also things that
should be fixed someday.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 doc/README.iser |  258 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 258 insertions(+), 0 deletions(-)
 create mode 100644 doc/README.iser

diff --git a/doc/README.iser b/doc/README.iser
new file mode 100644
index 0000000..d9e3487
--- /dev/null
+++ b/doc/README.iser
@@ -0,0 +1,258 @@
+iSCSI Extensions for RDMA (iSER)
+================================
+
+Background
+----------
+
+There is a draft specification at ietf.org to extend the iSCSI protocol
+to work on RDMA-capable networks as well as on traditional TCP/IP.  The
+current version is:
+
+	"iSCSI Extensions for RDMA Specification", Mike Ko, 20-Oct-05,
+	<draft-ietf-ips-iser-06.txt>
+
+RDMA stands for Remote Direct Memory Access, a way of accessing memory
+of a remote node directly through the network without involving the
+processor of that remote node.  Many network devices implement some form
+of RDMA.  Two of the more popular network devices are InfiniBand (IB)
+and iWARP.  IB uses its own physical and network layer, while iWARP sits
+on top of TCP/IP (or SCTP).
+
+Using these devices requires a new application programming interface
+(API).  The Linux kernel has many components of the OpenFabrics software
+stack, including APIs for access from user space and drivers for some
+popular RDMA-capable NICs, including IB cards with the Mellanox chipset
+and iWARP cards from NetEffect, Chelsio, and Ammasso.  Most Linux
+distributions ship the user space libraries for device access and RDMA
+connection management.
+
+
+RDMA in tgtd
+------------
+
+The Linux kernel can act as a SCSI initiator on the iSER transport, but
+not as a target.  tgtd is a user space target that supports multiple
+transports, including iSCSI/TCP, and now iSER on RDMA devices.
+
+The iSER code was written by researchers at the Ohio Supercomputer
+Center in early 2007:
+
+	Dennis Dalessandro <dennis at osc.edu>
+	Ananth Devulapalli <ananth at osc.edu>
+	Pete Wyckoff <pw at osc.edu>
+
+We wanted to use a faster transport to test the capabilities of an
+object-based storage device (OSD) emulator we had previously written.
+Our cluster has InfiniBand cards, and while running TCP/IP over IB is
+possible, the performance is not nearly as good as using native IB
+directly.
+
+A report describing this implementation and some performance results
+will appear in IEEE conference proceedings as:
+
+	Dennis Dalessandro, Ananth Devulapalli and Pete Wyckoff,
+	iSER Storage Target for Object-based Storage Devices,
+	Proceedings of MSST'07, SNAPI Workshop, San Diego, CA,
+	September 2007.
+
+and is available at:
+
+	http://www.osc.edu/~pw/papers/iser-snapi07.pdf
+
+The code mostly lives in iscsi/iscsi_rdma.c, with a few places in
+iscsi/iscsid.c that check if the transport is RDMA or not and behave
+accordingly.  iSCSI already had the idea of a transport, with just the
+single TCP one defined.  We added the RDMA transport and virtualized
+some more functions where TCP and RDMA behave differently.
+
+
+Design Issues
+-------------
+
+In general, a SCSI system includes two components, an initiator and a
+target. The initiator submits commands and awaits responses.  The target
+services commands from initiators and returns responses.  Data may flow
+from the initiator, from the client, or both (bidirectional).  The iSER
+specification requires all data transfers to be started by the target,
+regardless of direction.  In a read operation, the target uses RDMA
+Write to move data to the initiator, while a write operation uses RDMA
+Read to fetch data from the initiator.
+
+
+1. Memory registration
+
+One of the most severe stumbling blocks in moving any application to
+take advantage of RDMA features is memory registration.  Before using
+RDMA, both the sending and receiving buffers must be registered with the
+operating system.  This operation ensures that the underlying hardware
+pages will not be modified during the transfer, and provides the
+physical addresses of the buffers to the network card.  However, the
+process itself is time consuming, and CPU intensive.  Previous
+investigations have shown that for InfiniBand, with a nominal transfer
+rate of 900 MB/s, the throughput drops to around 500 MB/s when memory
+registration and deregistration are included in the critical path.
+
+Our target implementation uses pre-registered buffers for RDMA
+operations.  In general such a scheme is difficult to justify due to the
+large per-connection resource requirements.  However, in this
+application it may be appropriate.  Since the target always initiates
+RDMA operations and never advertises RDMA buffers, it can securely use
+one pool of buffers for multiple clients and can manage its memory
+resources explicitly.  Also, the architecture of the code is such that
+the iSCSI layer dictates incoming and outgoing buffer locations to the
+storage device layer, so supplying a registered buffer is relatively
+easy.
+
+
+2. Event management
+
+There is a mismatch between what the tgtd event framework assumes and
+what the RDMA notification interface provides.  The existing TCP-based
+iSCSI target code has one file descriptor per connection and it is
+driven by readability or writeability of the socket.  A single poll
+system call returns which sockets can be serviced, driving the TCP code
+to read or write as appropriate.  The RDMA interface can be used in
+accordance with this design by requesting interrupts from the network
+card on work request completions.  Notifications appear on the file
+descriptor that represents a completion queue to which all RDMA events
+are delivered.
+
+However, the existing sockets-based code goes beyond this and changes
+the bitmask of requested events to control its code flow.  For instance,
+after it finishes sending a response, it will modify the bitmask to only
+look for readability.  Even if the socket is writeable, there is no data
+to write, hence polling for that status is not useful.  The code also
+disables new message arrival during command execution as a sort of
+exclusion facility, again by modifying the bitmask.  We cannot do this
+with the RDMA interface.  Hence we must maintain an active list of tasks
+that have data to write and drive a progress engine to service them.
+The need for progress is tracked by a counter, and the tgtd event loop
+checks this counter and calls into the iSER-specific while the counter
+is still non-zero.  tgtd will block in the poll call when it must wait
+on network activity.  No dedicated thread is needed for iSER.
+
+
+3. Padding
+
+The iSCSI specification clearly states that all segments in the protocol
+data unit (PDU) must be individually padded to four-byte boundaries.
+However, the iSER specification remains mute on the subject of padding.
+It is clear from an implementation perspective that padding data
+segments is both unnecessary and would add considerable overhead to
+implement.  (Possibly a memory copy or extra SG entry on the initiator
+when sending directly from user memory.)   RDMA is used to move all
+data, with byte granularity provided by the network.  The need for
+padding in the TCP case was motivated by the optional marker support to
+work around the limitations of the streaming mode of TCP.  IB and iWARP
+are message-based networks and would never need markers.  And finally,
+the Linux initiator does not add padding either.
+
+
+Using iSER
+----------
+
+Compile tgtd with "make ISCSI=1 ISCSI_RDMA=1" to build iSCSI and iSER.
+You'll need to have two libraries installed on your system:
+libibverbs.so and librdmacm.so.  If they are installed in the normal
+system paths (/usr/include and /usr/lib or /usr/lib64), they will be
+found automatically.  Otherwise, edit CFLAGS and LIBS in usr/Makefile
+near ISCSI_RDMA to specify the paths by hand, e.g., for a /usr/local
+install, it should look like:
+
+	ifneq ($(ISCSI_RDMA),)
+	CFLAGS += -DISCSI_RDMA -I/usr/local/include
+	TGTD_OBJS += iscsi/iscsi_rdma.o
+	LIBS += -L/usr/local/lib -libverbs -lrdmacm
+	endif
+
+(You may possibly also have to set, e.g., LD_LIBRARY_PATH=/usr/local/lib
+in your environment to use the libibverbs.so and librdmacm.so shared
+libraries at runtime.)
+
+The target will listen on all TCP interfaces (as usual), as well as all
+RDMA devices.  Both use the same default iSCSI port, 3260.  Clients on
+TCP or RDMA will connect to the same tgtd instance.
+
+Start the daemon (as root):
+
+	./tgtd
+
+It will send messages to syslog.  You can add "-d 9" to turn on debug
+messages.
+
+Configure the running target with one or more devices, using the tgtadm
+program you just built (also as root).  Full information is in
+doc/README.iscsi.  Here is a quick-start guide:
+
+	dd if=/dev/zero bs=1k count=1 seek=1048575 of=/tmp/tid1lun1
+	./tgtadm --lld iscsi --mode target \
+		 --op new --tid 1 --targetname $(hostname)
+	./tgtadm --lld iscsi --mode target \
+		 --op bind --tid 1 --initiator-address ALL
+	./tgtadm --lld iscsi --mode logicalunit \
+		 --op new --tid 1 --lun 1 --backing-store /tmp/tid1lun1
+
+To make your initiator use RDMA, make sure the "ib_iser" module is
+loaded in your kernel.  Then do discovery as usual, over TCP:
+
+	iscsiadm -m discovery -t sendtargets -p $targetip
+
+where $targetip is the ethernet address of your IPoIB device.  Discovery
+traffic will use IPoIB, but login and full feature phase will use RDMA
+natively.
+
+Then do something like the following to change the transport type:
+
+	iscsiadm -m node -p $targetip -T $targetname --op update \
+	    -n node.transport_name -v iser
+
+Next, login as usual:
+
+	iscsiadm -m node -p $targetip -T $targetname --login
+
+And access the new block device, e.g. /dev/sdb.
+
+
+Errata
+------
+
+There is a major bug in the mthca driver in linux kernels before 2.6.21.
+This includes the popular rhel5 kernels, such as 2.6.18-8.1.6.el5 and
+possibly later.  The critical commit is:
+
+    608d8268be392444f825b4fc8fc7c8b509627129
+    IB/mthca: Fix data corruption after FMR unmap on Sinai
+
+If you use single-port memfree cards, SCSI read operations will
+frequently result in randomly corrupted memory, leading to bad
+application data or unexplainable kernel crashes.  Older kernels are
+also missing some nice iSCSI changes that avoids crashes in some
+situations where the target goes away.  Stock kernel.org linux
+2.6.22-rc5 and 2.6.23-rc6 have been tested and are known to work.
+
+The Linux kernel iSER initiator is currently lacking support for
+bidirectional transfers, and for extended command descriptors (CDBs).
+We'll send the patches for these soon.
+
+The Linux kernel iSER initiator uses a different header structure on its
+packets than is in the iSER draft specification.  This is described in
+an InfiniBand document and is required for that network, which only
+supports for Zero-Based Addressing.  If you are using a non-IB initiator
+that doesn't need this header extension, it won't work with tgtd.  There
+may be some way to negotiate the header format.  Using iWARP hardware
+devices with the Linux kernel iSER initiator also will not work due to
+its reliance on fast memory registration (FMR), an InfiniBand-only feature.
+
+The current code sizes its per-connection resource consumption based on
+negotiatied parameters.  However, the Linux iSER initiator does not
+support negotiation of MaxOutstandingUnexpectedPDUs, so that value is
+hard-coded in the target.  Also, open-iscsi is hard-coded with a very
+small value of TargetRecvDataSegmentLength, so even though the target
+would be willing to accept a larger size, it cannot.  This may limit
+performance of small transfers on high-speed networks:  transfers bigger
+than 8 kB, but not large enough to amortize a round-trip for RDMA setup.
+
+The data structures for connection management in the iSER code are
+desgined to handle multiple devices, but have never been tested with
+such hardware.
+
-- 
1.5.3.4



From pw at osc.edu  Tue Oct 16 17:21:25 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Tue, 16 Oct 2007 11:21:25 -0400
Subject: [Stgt-devel] [PATCH 17/20] iser iscsid changes
In-Reply-To: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
Message-ID: <c8f7231fcf0c79e8655d8fb14debb8dba03d4c81.1192554396.git.pw@osc.edu>

Handle the special cases for RDMA in core iscsid code.  These changes
all look at conn->tp->rdma and do not affect TCP code.

    - track RDMA setting at session and verify conns are compatible
    - no status collapse on final data packet
    - all data-in transmits must reenable TX for conn
    - TX state machine finishes tasks without going through epoll
    - TX handler returns status to trigger RDMA flow control

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/iscsi/iscsid.c  |   42 ++++++++++++++++++++++++++++++++----------
 usr/iscsi/iscsid.h  |    5 ++++-
 usr/iscsi/session.c |    2 ++
 3 files changed, 38 insertions(+), 11 deletions(-)

diff --git a/usr/iscsi/iscsid.c b/usr/iscsi/iscsid.c
index d7c7128..805b296 100644
--- a/usr/iscsi/iscsid.c
+++ b/usr/iscsi/iscsid.c
@@ -508,8 +508,21 @@ static void login_finish(struct iscsi_connection *conn)
 			conn->state = STATE_EXIT;
 			break;
 		}
-		if (!conn->session)
+		if (!conn->session) {
 			session_create(conn);
+		} else {
+			if (conn->tp->rdma ^ conn->session->rdma) {
+				eprintf("new conn rdma %d, but session %d\n",
+					conn->tp->rdma, conn->session->rdma);
+				rsp->flags = 0;
+				rsp->status_class =
+					ISCSI_STATUS_CLS_INITIATOR_ERR;
+				rsp->status_detail =
+					ISCSI_LOGIN_STATUS_INVALID_REQUEST;
+				conn->state = STATE_EXIT;
+				break;
+			}
+		}
 		memcpy(conn->isid, conn->session->isid, sizeof(conn->isid));
 		conn->tsih = conn->session->tsih;
 		break;
@@ -958,7 +971,8 @@ static int iscsi_data_rsp_build(struct iscsi_task *task)
 		rsp->flags = ISCSI_FLAG_CMD_FINAL;
 
 		/* collapse status into final packet if successful */
-		if (task->result == 0 && task->dir != BIDIRECTIONAL) {
+		if (task->result == 0 && task->dir != BIDIRECTIONAL &&
+		    !conn->tp->rdma) {
 			rsp->flags |= ISCSI_FLAG_DATA_STATUS;
 			rsp->cmd_status = task->result;
 			rsp->statsn = cpu_to_be32(conn->stat_sn++);
@@ -1695,7 +1709,7 @@ static int iscsi_scsi_cmd_tx_done(struct iscsi_connection *conn)
 		break;
 	case ISCSI_OP_SCSI_DATA_IN:
 		if (task->offset < task->len || task->result != 0
-		   || task->dir == BIDIRECTIONAL) {
+		   || task->dir == BIDIRECTIONAL || conn->tp->rdma) {
 			dprintf("more data or sense or bidir %x\n", hdr->itt);
 			list_add_tail(&task->c_list, &task->conn->tx_clist);
 			return 0;
@@ -1971,7 +1985,7 @@ again:
 	return 0;
 }
 
-void iscsi_tx_handler(struct iscsi_connection *conn)
+int iscsi_tx_handler(struct iscsi_connection *conn)
 {
 	int ret = 0, hdigest, ddigest;
 	uint32_t crc;
@@ -1986,9 +2000,10 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 	if (conn->state == STATE_SCSI && !conn->tx_task) {
 		ret = iscsi_task_tx_start(conn);
 		if (ret)
-			return;
+			goto out;
 	}
 
+again:
 	switch (conn->tx_iostate) {
 	case IOSTATE_TX_BHS:
 		ret = do_send(conn, IOSTATE_TX_INIT_AHS);
@@ -2045,7 +2060,7 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 		ret = do_send(conn, ddigest ?
 			      IOSTATE_TX_INIT_DDIGEST : IOSTATE_TX_END);
 		if (ret < 0)
-			return;
+			goto out;
 		if (conn->tx_iostate != IOSTATE_TX_INIT_DDIGEST)
 			break;
 	case IOSTATE_TX_INIT_DDIGEST:
@@ -2064,10 +2079,14 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 		exit(1);
 	}
 
-	if (ret < 0 ||
-	    conn->tx_iostate != IOSTATE_TX_END ||
-	    conn->state == STATE_CLOSE)
-		return;
+	if (ret < 0 || conn->state == STATE_CLOSE)
+		goto out;
+
+	if (conn->tx_iostate != IOSTATE_TX_END) {
+		if (conn->tp->rdma)
+			goto again;  /* avoid event loop, just push */
+		goto out;
+	}
 
 	if (conn->tx_size) {
 		eprintf("error %d %d %d\n", conn->state, conn->tx_iostate,
@@ -2100,6 +2119,9 @@ void iscsi_tx_handler(struct iscsi_connection *conn)
 		conn->tp->ep_event_modify(conn, EPOLLIN);
 		break;
 	}
+
+out:
+	return ret;
 }
 
 struct tgt_driver iscsi = {
diff --git a/usr/iscsi/iscsid.h b/usr/iscsi/iscsid.h
index c1fab67..57f6f6d 100644
--- a/usr/iscsi/iscsid.h
+++ b/usr/iscsi/iscsid.h
@@ -91,6 +91,9 @@ struct iscsi_session {
 	struct param session_param[ISCSI_PARAM_MAX];
 
 	char *info;
+
+	/* if this session uses rdma connections */
+	int rdma;
 };
 
 struct iscsi_task {
@@ -263,7 +266,7 @@ extern void conn_add_to_session(struct iscsi_connection *conn, struct iscsi_sess
 extern char *text_key_find(struct iscsi_connection *conn, char *searchKey);
 extern void text_key_add(struct iscsi_connection *conn, char *key, char *value);
 extern void conn_read_pdu(struct iscsi_connection *conn);
-extern void iscsi_tx_handler(struct iscsi_connection *conn);
+extern int iscsi_tx_handler(struct iscsi_connection *conn);
 extern void iscsi_rx_handler(struct iscsi_connection *conn);
 extern int iscsi_scsi_cmd_execute(struct iscsi_task *task);
 
diff --git a/usr/iscsi/session.c b/usr/iscsi/session.c
index 3b1650d..028d538 100644
--- a/usr/iscsi/session.c
+++ b/usr/iscsi/session.c
@@ -128,6 +128,8 @@ int session_create(struct iscsi_connection *conn)
 	memcpy(session->isid, conn->isid, sizeof(session->isid));
 	session->tsih = last_tsih = tsih;
 
+	session->rdma = conn->tp->rdma;
+
 	conn_add_to_session(conn, session);
 
 	dprintf("session_create: %#" PRIx64 "\n", sid64(conn->isid, session->tsih));
-- 
1.5.3.4



From albert.pauw at gmail.com  Sat Oct 20 09:57:39 2007
From: albert.pauw at gmail.com (Albert Pauw)
Date: Sat, 20 Oct 2007 09:57:39 +0200
Subject: [Stgt-devel] discovery not working anymore?
Message-ID: <4719B4F3.6020401@gmail.com>

If I remember correctly I had used iscsiadm -m discovery -p <IP> before 
on the tgt target, which worked.

However, I noticed that using the latest SVN version I can't get the 
discovery to work and detect the target. I tried with both open-iscsi 
and tgt on the same machine as using separate machines for them, but it 
didn't make a difference.

Albert

P.S. open-iscsi works fine discovering the targets on iscsi-target and 
Wasabi, so it looks like the problem lies with tgt.

Here's the setup I used:

#!/bin/sh

tgtadm --lld iscsi --mode target --op new --tid 1 -T 
iqn.2007-09.net.homeunix.pauw:blue.stgt.disk
tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 0 --name 
scsi_id --value "CONTROLLER"
tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 0 --name 
scsi_sn --value "001"
#
# Define backing-store
#
tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 1 
--backing-store /root/disk.bin --device-type disk
#
# Define SCSI ID (max 23 characters)
tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1 \
         --params 
vendor_id=SEAGATE,product_id=HD100,product_rev=0001,removable=0,sense_format=0
#
tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1 --name 
scsi_id --value "HARDDISK"
#
# Define SCSI SN (max 23 characters)
#
tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1 --name 
scsi_sn --value "001"
#
# Define who can connect
#
tgtadm --lld iscsi --mode target --op bind   --tid 1 -I All
#
# Set iSCSI parameters
#
tgtadm --lld iscsi --mode target --op update --tid 1 --name 
MaxConnections --value 1
tgtadm --lld iscsi --mode target --op update --tid 1 --name 
MaxRecvDataSegmentLength --value 262144
tgtadm --lld iscsi --mode target --op update --tid 1 --name 
MaxXmitDataSegmentLength --value 262144
tgtadm --lld iscsi --mode target --op update --tid 1 --name 
FirstBurstLength --value 262144
tgtadm --lld iscsi --mode target --op update --tid 1 --name 
MaxBurstLength --value 262144
tgtadm --lld iscsi --mode target --op update --tid 1 --name 
DefaultTime2Wait --value 2
tgtadm --lld iscsi --mode target --op update --tid 1 --name 
DefaultTime2Retain --value 20
tgtadm --lld iscsi --mode target --op update --tid 1 --name 
MaxOutstandingR2T --value 8
tgtadm --lld iscsi --mode target --op update --tid 1 --name 
DataPDUInOrder --value "Yes"
tgtadm --lld iscsi --mode target --op update --tid 1 --name 
DataSequenceInOrder --value "Yes"
tgtadm --lld iscsi --mode target --op update --tid 1 --name 
ErrorRecoveryLevel --value 0
tgtadm --lld iscsi --mode target --op update --tid 1 --name HeaderDigest 
--value "None"
tgtadm --lld iscsi --mode target --op update --tid 1 --name DataDigest 
--value "None"


From erezz at Voltaire.COM  Sun Oct 21 17:07:28 2007
From: erezz at Voltaire.COM (Erez Zilber)
Date: Sun, 21 Oct 2007 17:07:28 +0200
Subject: [Stgt-devel] Which kernel should be used for stgt?
Message-ID: <471B6B30.30501@Voltaire.COM>

Hi,

So far, I ran stgt only over the kernel from the linux-2.6-target git 
tree. Can I run it over any kernel >= 2.6.20? Can I also run it over any 
major distro? SLES 10 sp1? RHEL 5? RHEL 5.1?

BTW - are there any planned changes for the kernel code? Is stgt 
progress done only in userspace now?

Thanks,
Erez


From michaelc at cs.wisc.edu  Sun Oct 21 21:18:23 2007
From: michaelc at cs.wisc.edu (Mike Christie)
Date: Sun, 21 Oct 2007 14:18:23 -0500
Subject: [Stgt-devel] Which kernel should be used for stgt?
In-Reply-To: <471B6B30.30501@Voltaire.COM>
References: <471B6B30.30501@Voltaire.COM>
Message-ID: <471BA5FF.9080202@cs.wisc.edu>

Erez Zilber wrote:
> Hi,
> 
> So far, I ran stgt only over the kernel from the linux-2.6-target git 
> tree. Can I run it over any kernel >= 2.6.20? Can I also run it over any 
> major distro? SLES 10 sp1? RHEL 5? RHEL 5.1?

It depends on what target you want to run. Are you just wanting to run 
the iscsi/iser parts? You did not want to run ibm vscsi did you?

> 
> BTW - are there any planned changes for the kernel code? Is stgt 
> progress done only in userspace now?
> 

For targets that require hardware like lpfc or qla2xxx, there will be 
some kernel bits like the scsi_tgt_* code and LLD driver changes. But a 
good chunk like is still in userspace.

For targets like software iscsi, it is all userspace.


From fujita.tomonori at lab.ntt.co.jp  Mon Oct 22 08:49:57 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 22 Oct 2007 15:49:57 +0900
Subject: [Stgt-devel] discovery not working anymore?
In-Reply-To: <4719B4F3.6020401@gmail.com>
References: <4719B4F3.6020401@gmail.com>
Message-ID: <20071022154957Z.fujita.tomonori@lab.ntt.co.jp>

On Sat, 20 Oct 2007 09:57:39 +0200
Albert Pauw <albert.pauw at gmail.com> wrote:

> If I remember correctly I had used iscsiadm -m discovery -p <IP> before 
> on the tgt target, which worked.
> 
> However, I noticed that using the latest SVN version I can't get the 
> discovery to work and detect the target. I tried with both open-iscsi 
> and tgt on the same machine as using separate machines for them, but it 
> didn't make a difference.
> 
> Albert
> 
> P.S. open-iscsi works fine discovering the targets on iscsi-target and 
> Wasabi, so it looks like the problem lies with tgt.
> 
> Here's the setup I used:
> 
> #!/bin/sh
> 
> tgtadm --lld iscsi --mode target --op new --tid 1 -T 
> iqn.2007-09.net.homeunix.pauw:blue.stgt.disk
> tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 0 --name 
> scsi_id --value "CONTROLLER"
> tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 0 --name 
> scsi_sn --value "001"
> #
> # Define backing-store
> #
> tgtadm --lld iscsi --mode logicalunit --op new --tid 1 --lun 1 
> --backing-store /root/disk.bin --device-type disk
> #
> # Define SCSI ID (max 23 characters)
> tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1 \
>          --params 
> vendor_id=SEAGATE,product_id=HD100,product_rev=0001,removable=0,sense_format=0
> #
> tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1 --name 
> scsi_id --value "HARDDISK"
> #
> # Define SCSI SN (max 23 characters)
> #
> tgtadm --lld iscsi --mode logicalunit --op update --tid 1 --lun 1 --name 
> scsi_sn --value "001"
> #
> # Define who can connect
> #
> tgtadm --lld iscsi --mode target --op bind   --tid 1 -I All

tgtadm --lld iscsi --mode target --op bind   --tid 1 -I ALL

?


From erezz at Voltaire.COM  Mon Oct 22 09:03:41 2007
From: erezz at Voltaire.COM (Erez Zilber)
Date: Mon, 22 Oct 2007 09:03:41 +0200
Subject: [Stgt-devel] Which kernel should be used for stgt?
In-Reply-To: <471BA5FF.9080202@cs.wisc.edu>
References: <471B6B30.30501@Voltaire.COM> <471BA5FF.9080202@cs.wisc.edu>
Message-ID: <471C4B4D.3070707@Voltaire.COM>

Mike Christie wrote:
> Erez Zilber wrote:
>> Hi,
>>
>> So far, I ran stgt only over the kernel from the linux-2.6-target git 
>> tree. Can I run it over any kernel >= 2.6.20? Can I also run it over 
>> any major distro? SLES 10 sp1? RHEL 5? RHEL 5.1?
>
> It depends on what target you want to run. Are you just wanting to run 
> the iscsi/iser parts? You did not want to run ibm vscsi did you?

Currently, I'm just interested in running iSCSI over iSER.

Thanks,
Erez


From fujita.tomonori at lab.ntt.co.jp  Mon Oct 22 09:10:14 2007
From: fujita.tomonori at lab.ntt.co.jp (FUJITA Tomonori)
Date: Mon, 22 Oct 2007 16:10:14 +0900
Subject: [Stgt-devel] Which kernel should be used for stgt?
In-Reply-To: <471C4B4D.3070707@Voltaire.COM>
References: <471B6B30.30501@Voltaire.COM> <471BA5FF.9080202@cs.wisc.edu>
	<471C4B4D.3070707@Voltaire.COM>
Message-ID: <20071022161014W.fujita.tomonori@lab.ntt.co.jp>

On Mon, 22 Oct 2007 09:03:41 +0200
Erez Zilber <erezz at Voltaire.COM> wrote:

> Mike Christie wrote:
> > Erez Zilber wrote:
> >> Hi,
> >>
> >> So far, I ran stgt only over the kernel from the linux-2.6-target git 
> >> tree. Can I run it over any kernel >= 2.6.20? Can I also run it over 
> >> any major distro? SLES 10 sp1? RHEL 5? RHEL 5.1?
> >
> > It depends on what target you want to run. Are you just wanting to run 
> > the iscsi/iser parts? You did not want to run ibm vscsi did you?
> 
> Currently, I'm just interested in running iSCSI over iSER.

RHEL 5.1 beta includes tgt (iSCSI support).


From rcj at linux.vnet.ibm.com  Tue Oct 23 23:14:01 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Tue, 23 Oct 2007 16:14:01 -0500
Subject: [Stgt-devel] [Patch 0/4] bs_mmap / kreq_send threading
Message-ID: <20071023211400.GA6091@linux.vnet.ibm.com>

A little threading work like we have in bs_sync for bs_mmap.  The mmap
can be taken care of with a small pool of worker threads this way.

After the mmap the completed commands enter back into the main tgtd
thread and would be sent to the kernel for in-kernel drivers through
kreq_send.  Unfortunately kreq_send can sleep in blk_rq_map_user or
scsi_map_user_pages and hold up processing in tgtd.  So kreq_send can
add the command to a list and hand it off to a small thread pool to
process sending the replies to the kernel.

I've also included a kernel patch for our tree to change the processing
of command from userspace such that it only processes one command per
write.  This allows us to thread the blk_rq_map_user/scsi_map_user_pages
calls with our thread pool.

Last patch changes the way we open the backed device in the bs_mmap code
to add O_SYNC.

Regards,
Robert Jennings

---
Robert C. Jennings <rcjenn at us.ibm.com>
IBM Linux Technology Center, Austin
+1.512.838.4964 (t/l 678.4964)


From rcj at linux.vnet.ibm.com  Tue Oct 23 23:19:36 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Tue, 23 Oct 2007 16:19:36 -0500
Subject: [Stgt-devel] [Patch 1/4] bs_mmap threading
In-Reply-To: <20071023211400.GA6091@linux.vnet.ibm.com>
References: <20071023211400.GA6091@linux.vnet.ibm.com>
Message-ID: <20071023211936.GB6091@linux.vnet.ibm.com>


Process command submission in the mmap backing store with worker threads
just as we have in bs_sync.

---
 usr/Makefile  |    1 +
 usr/bs_mmap.c |  301 +++++++++++++++++++++++++++++++++++++++++++++++++++++-----
 usr/mmc.c     |    1 -
 usr/sbc.c     |    1 -
 4 files changed, 277 insertions(+), 27 deletions(-)

Index: b/usr/Makefile
===================================================================
--- a/usr/Makefile
+++ b/usr/Makefile
@@ -29,6 +29,7 @@ ifneq ($(IBMVIO),)
 CFLAGS += -DIBMVIO -DUSE_KERNEL
 TGTD_OBJS += $(addprefix ibmvio/, ibmvio.o)
 TGTD_OBJS += bs_mmap.o tgtif.o
+LIBS += -lpthread
 endif
 
 ifneq ($(ISCSI),)
Index: b/usr/bs_mmap.c
===================================================================
--- a/usr/bs_mmap.c
+++ b/usr/bs_mmap.c
@@ -27,53 +27,303 @@
 #include <string.h>
 #include <unistd.h>
 #include <sys/mman.h>
+#include <pthread.h>
+#include <sys/epoll.h>
+#include <linux/fs.h>
 
 #include "list.h"
 #include "util.h"
 #include "tgtd.h"
 #include "scsi.h"
 
+#define NR_WORKER_THREADS	4
+
+struct bs_mmap_info {
+	pthread_t ack_thread;
+	pthread_t worker_thread[NR_WORKER_THREADS];
+
+	/* protected by pipe (command_fd) */
+	struct list_head ack_list;
+
+	pthread_cond_t finished_cond;
+	pthread_mutex_t finished_lock;
+	struct list_head finished_list;
+
+	/* workers sleep on this and are signaled by tgtd */
+	pthread_cond_t pending_cond;
+	/* locked by tgtd and workers */
+	pthread_mutex_t pending_lock;
+	/* protected by pending_lock */
+	struct list_head pending_list;
+
+	int command_fd[2];
+	int done_fd[2];
+
+	int stop;
+};
+
+static void *bs_mmap_ack_fn(void *arg)
+{
+	struct bs_mmap_info *info = arg;
+	int command, ret, nr;
+	struct scsi_cmd *cmd;
+
+retry:
+	ret = read(info->command_fd[0], &command, sizeof(command));
+	if (ret < 0) {
+		eprintf("ack pthread will be dead, %m\n");
+		if (errno == EAGAIN || errno == EINTR)
+			goto retry;
+
+		goto out;
+	}
+
+	pthread_mutex_lock(&info->finished_lock);
+retest:
+	if (list_empty(&info->finished_list)) {
+		pthread_cond_wait(&info->finished_cond, &info->finished_lock);
+		goto retest;
+	}
+
+	while (!list_empty(&info->finished_list)) {
+		cmd = list_entry(info->finished_list.next,
+		                 struct scsi_cmd, bs_list);
+
+		dprintf("found %p\n", cmd);
+
+		list_del(&cmd->bs_list);
+		list_add(&cmd->bs_list, &info->ack_list);
+	}
+
+	pthread_mutex_unlock(&info->finished_lock);
+
+	nr = 1;
+rewrite:
+	ret = write(info->done_fd[1], &nr, sizeof(nr));
+	if (ret < 0) {
+		eprintf("can't ack tgtd, %m\n");
+		if (errno == EAGAIN || errno == EINTR)
+			goto rewrite;
+
+		goto out;
+	}
+
+	goto retry;
+out:
+	return NULL;
+}
+
+#define pgcnt(size, offset)	((((size) + ((offset) & (pagesize - 1))) + (pagesize - 1)) >> pageshift)
+
+static void *bs_mmap_worker_fn(void *arg)
+{
+	struct bs_mmap_info *info = arg;
+	struct scsi_cmd *cmd;
+	int fd, ret = 0;
+	void *p;
+
+	while (1) {
+		pthread_mutex_lock(&info->pending_lock);
+retest:
+		if (list_empty(&info->pending_list)) {
+			pthread_cond_wait(&info->pending_cond,
+			                  &info->pending_lock);
+			if (info->stop) {
+				pthread_mutex_unlock(&info->pending_lock);
+				break;
+			}
+			goto retest;
+		}
+
+		cmd = list_entry(info->pending_list.next,
+		                 struct scsi_cmd, bs_list);
+
+		dprintf("got %p\n", cmd);
+
+		list_del(&cmd->bs_list);
+		pthread_mutex_unlock(&info->pending_lock);
+
+		fd = cmd->dev->fd;
+
+		if (cmd->scb[0] == SYNCHRONIZE_CACHE ||
+		    cmd->scb[0] == SYNCHRONIZE_CACHE_16)
+			ret = fsync(fd);
+		else if (cmd->uaddr)
+			cmd->uaddr += cmd->offset;
+		else {
+			p = mmap64(NULL,
+				   pgcnt(cmd->len,
+			              cmd->offset) << pageshift,
+			              PROT_READ | PROT_WRITE,
+			              MAP_SHARED, fd,
+			              cmd->offset & ~((1ULL << pageshift) - 1));
+
+			cmd->uaddr = (unsigned long) p +
+			              (cmd->offset & (pagesize - 1));
+			if (p == MAP_FAILED) {
+				ret = -EINVAL;
+				eprintf("%" PRIx64 " %u %" PRIu64 "\n",
+				        cmd->uaddr, cmd->len, cmd->offset);
+			} else {
+				cmd->mmapped = 1;
+				ret = 0;
+			}
+		}
+
+		dprintf("%" PRIx64 " %u %" PRIu64 "\n", cmd->uaddr, cmd->len, cmd->offset);
+
+		if (ret) {
+			cmd->rw = READ;
+			cmd->offset = 0;
+			cmd->len = 0;
+			cmd->result = SAM_STAT_CHECK_CONDITION;
+			sense_data_build(cmd, HARDWARE_ERROR,
+			                 ASC_INTERNAL_TGT_FAILURE);
+		} else {
+			cmd->result = SAM_STAT_GOOD;
+		}
+
+		pthread_mutex_lock(&info->finished_lock);
+		list_add(&cmd->bs_list, &info->finished_list);
+		pthread_mutex_unlock(&info->finished_lock);
+
+		pthread_cond_signal(&info->finished_cond);
+	}
+
+	return NULL;
+}
+
+static void bs_mmap_handler (int fd, int events, void *data)
+{
+	struct bs_mmap_info *info = data;
+	struct scsi_cmd *cmd;
+	int nr_events, ret;
+	ret = read(info->done_fd[0], &nr_events, sizeof (nr_events));
+	if (ret < 0)
+	{
+		eprintf("wrong wakeup\n");
+		return;
+	}
+
+	while (!list_empty(&info->ack_list))
+	{
+		cmd = list_entry(info->ack_list.next,
+		                 struct scsi_cmd, bs_list);
+
+		dprintf("back to tgtd, %p\n", cmd);
+
+		list_del(&cmd->bs_list);
+		target_cmd_io_done(cmd, cmd->result);
+	}
+
+	write(info->command_fd[1], &nr_events, sizeof (nr_events));
+}
+
 static int bs_mmap_open(struct scsi_lu *lu, char *path, int *fd, uint64_t *size)
 {
+	int i, ret;
+	struct bs_mmap_info *info =
+		(struct bs_mmap_info *) ((char *)lu + sizeof(*lu));
+
+	INIT_LIST_HEAD(&info->ack_list);
+	INIT_LIST_HEAD(&info->finished_list);
+	INIT_LIST_HEAD(&info->pending_list);
+
 	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
+	if (*fd < 0)
+		return *fd;
+
+	pthread_cond_init(&info->finished_cond, NULL);
+	pthread_cond_init(&info->pending_cond, NULL);
 
-	return *fd >= 0 ? 0 : *fd;
+	pthread_mutex_init(&info->finished_lock, NULL);
+	pthread_mutex_init(&info->pending_lock, NULL);
+
+	ret = pipe(info->command_fd);
+	if (ret)
+		goto close_dev_fd;
+
+	ret = pipe(info->done_fd);
+	if (ret)
+		goto close_command_fd;
+
+	ret = tgt_event_add(info->done_fd[0], EPOLLIN, bs_mmap_handler, info);
+	if (ret)
+		goto close_done_fd;
+
+	ret = pthread_create(&info->ack_thread, NULL, bs_mmap_ack_fn, info);
+	if (ret)
+		goto event_del;
+
+	for (i = 0; i < ARRAY_SIZE(info->worker_thread); i++) {
+		ret = pthread_create(&info->worker_thread[i], NULL,
+		                     bs_mmap_worker_fn, info);
+	}
+
+	write(info->command_fd[1], &ret, sizeof(ret));
+
+	return 0;
+event_del:
+	tgt_event_del(info->done_fd[0]);
+close_done_fd:
+	close(info->done_fd[0]);
+	close(info->done_fd[1]);
+close_command_fd:
+	close(info->command_fd[0]);
+	close(info->command_fd[1]);
+close_dev_fd:
+	close(*fd);
+	pthread_cond_destroy(&info->finished_cond);
+	pthread_cond_destroy(&info->pending_cond);
+	pthread_mutex_destroy(&info->finished_lock);
+	pthread_mutex_destroy(&info->pending_lock);
+
+	return -1;
 }
 
 static void bs_mmap_close(struct scsi_lu *lu)
 {
+	int i;
+	struct bs_mmap_info *info =
+	        (struct bs_mmap_info *) ((char *)lu + sizeof(*lu));
+
+	pthread_cancel(info->ack_thread);
+	pthread_join(info->ack_thread, NULL);
+
+	info->stop = 1;
+	pthread_cond_broadcast(&info->pending_cond);
+
+	for (i = 0; i < ARRAY_SIZE(info->worker_thread); i++)
+		pthread_join(info->worker_thread[i], NULL);
+
+	pthread_cond_destroy(&info->finished_cond);
+	pthread_cond_destroy(&info->pending_cond);
+
+	pthread_mutex_destroy(&info->finished_lock);
+	pthread_mutex_destroy(&info->pending_lock);
+
 	close(lu->fd);
 }
 
-#define pgcnt(size, offset)	((((size) + ((offset) & (pagesize - 1))) + (pagesize - 1)) >> pageshift)
-
 static int bs_mmap_cmd_submit(struct scsi_cmd *cmd)
 {
-	int fd = cmd->dev->fd, ret = 0;
-	void *p;
+	struct scsi_lu *lu = cmd->dev;
+	struct bs_mmap_info *info =
+	        (struct bs_mmap_info *)((char *)lu + sizeof(*lu));
 
-	if (cmd->scb[0] == SYNCHRONIZE_CACHE ||
-	    cmd->scb[0] == SYNCHRONIZE_CACHE_16)
-		return fsync(fd);
-
-	if (cmd->uaddr)
-		cmd->uaddr += cmd->offset;
-	else {
-		p = mmap64(NULL, pgcnt(cmd->len, cmd->offset) << pageshift,
-			   PROT_READ | PROT_WRITE, MAP_SHARED, fd,
-			   cmd->offset & ~((1ULL << pageshift) - 1));
-
-		cmd->uaddr = (unsigned long) p + (cmd->offset & (pagesize - 1));
-		if (p == MAP_FAILED) {
-			ret = -EINVAL;
-			eprintf("%" PRIx64 " %u %" PRIu64 "\n", cmd->uaddr,
-				cmd->len, cmd->offset);
-		}
-	}
+	dprintf("%d %d %u %"  PRIx64 " %" PRIx64 " %p\n", lu->fd, cmd->rw,
+	        cmd->len, cmd->uaddr, cmd->offset, cmd);
+
+	pthread_mutex_lock(&info->pending_lock);
+
+	list_add(&cmd->bs_list, &info->pending_list);
+
+	pthread_mutex_unlock(&info->pending_lock);
+	pthread_cond_signal(&info->pending_cond);
 
-	dprintf("%" PRIx64 " %u %" PRIu64 "\n", cmd->uaddr, cmd->len, cmd->offset);
+	cmd->async = 1;
 
-	return ret;
+	return 0;
 }
 
 static int bs_mmap_cmd_done(struct scsi_cmd *cmd)
@@ -97,6 +347,7 @@ static int bs_mmap_cmd_done(struct scsi_
 }
 
 struct backingstore_template mmap_bst = {
+	.bs_datasize		= sizeof(struct bs_mmap_info),
 	.bs_open		= bs_mmap_open,
 	.bs_close		= bs_mmap_close,
 	.bs_cmd_submit		= bs_mmap_cmd_submit,
Index: b/usr/mmc.c
===================================================================
--- a/usr/mmc.c
+++ b/usr/mmc.c
@@ -58,7 +58,6 @@ static int mmc_rw(int host_no, struct sc
 		sense_data_build(cmd, ILLEGAL_REQUEST, ASC_LUN_NOT_SUPPORTED);
 		return SAM_STAT_CHECK_CONDITION;
 	} else {
-		cmd->mmapped = 1;
 		return SAM_STAT_GOOD;
 	}
 	return 0;
Index: b/usr/sbc.c
===================================================================
--- a/usr/sbc.c
+++ b/usr/sbc.c
@@ -70,7 +70,6 @@ static int sbc_rw(int host_no, struct sc
 		key = HARDWARE_ERROR;
 		asc = ASC_INTERNAL_TGT_FAILURE;
 	} else {
-		cmd->mmapped = 1;
 		return SAM_STAT_GOOD;
 	}
 


From rcj at linux.vnet.ibm.com  Tue Oct 23 23:29:08 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Tue, 23 Oct 2007 16:29:08 -0500
Subject: [Stgt-devel] [Patch 2/4] kreq_send threading
In-Reply-To: <20071023211400.GA6091@linux.vnet.ibm.com>
References: <20071023211400.GA6091@linux.vnet.ibm.com>
Message-ID: <20071023212908.GC6091@linux.vnet.ibm.com>

Add a set of worker threads to send data back to the kernel.  The kernel
can sleep during our write() call while it maps pages.  This should help
eliminate this bottleneck in the codepath.

Signed-off-by: rcj at linux.vnet.ibm.com

---
 usr/tgtif.c |   76 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 71 insertions(+), 5 deletions(-)

Index: tgt/usr/tgtif.c
===================================================================
--- tgt.orig/usr/tgtif.c	2007-10-23 15:58:37.000000000 -0500
+++ tgt/usr/tgtif.c	2007-10-23 16:26:08.000000000 -0500
@@ -23,6 +23,7 @@
 #include <fcntl.h>
 #include <getopt.h>
 #include <inttypes.h>
+#include <pthread.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -45,10 +46,20 @@
 #define barrier() __asm__ __volatile__("": : :"memory")
 
 struct uring {
+	pthread_mutex_t idx_lock;
 	uint32_t idx;
 	char *buf;
 };
 
+#define NR_WORKER_THREADS	4
+struct kreq_send_worker_info {
+	pthread_t thread[NR_WORKER_THREADS];
+
+	pthread_cond_t cond;
+	pthread_mutex_t lock;
+	int outstanding;
+} kreq_send_worker;
+
 static struct uring kuring, ukring;
 static int chrfd;
 
@@ -70,22 +81,50 @@
 	return (struct tgt_event *) (ring->buf + pos);
 }
 
+static void *kreq_send_worker_fn(void *arg)
+{
+	while (1) {
+		pthread_mutex_lock(&kreq_send_worker.lock);
+test:
+		if(!kreq_send_worker.outstanding) {
+			pthread_cond_wait(&kreq_send_worker.cond,
+			                  &kreq_send_worker.lock);
+			goto test;
+		}
+
+		kreq_send_worker.outstanding--;
+		pthread_mutex_unlock(&kreq_send_worker.lock);
+		write(chrfd, &kreq_send_worker.outstanding, 1);
+	}
+}
+
 static int kreq_send(struct tgt_event *p)
 {
 	struct tgt_event *ev;
+	int ret = 0;
 
+	pthread_mutex_lock(&ukring.idx_lock);
 	ev = head_ring_hdr(&ukring);
-	if (ev->hdr.status)
-		return -ENOMEM;
+	if (ev->hdr.status) {
+		pthread_mutex_unlock(&ukring.idx_lock);
+		ret = -ENOMEM;
+		goto out;
+	}
 
 	ring_index_inc(&ukring);
+	pthread_mutex_unlock(&ukring.idx_lock);;
 
 	memcpy(ev, p, sizeof(*p));
 	barrier();
 	ev->hdr.status = 1;
-	write(chrfd, ev, 1);
 
-	return 0;
+	pthread_mutex_lock(&kreq_send_worker.lock);
+	kreq_send_worker.outstanding++;
+	pthread_mutex_unlock(&kreq_send_worker.lock);
+	pthread_cond_signal(&kreq_send_worker.cond);
+
+out:
+	return ret;
 }
 
 int kspace_send_tsk_mgmt_res(struct mgmt_req *mreq)
@@ -330,7 +369,7 @@
 
 int kreq_init(void)
 {
-	int err, size = TGT_RING_SIZE;
+	int i, err, size = TGT_RING_SIZE;
 	char *buf;
 
 	err = tgt_miscdev_init(CHRDEV_PATH, &chrfd);
@@ -355,7 +394,19 @@
 	kuring.buf = buf;
 	ukring.buf = buf + size;
 
+	pthread_cond_init(&kreq_send_worker.cond, NULL);
+	pthread_mutex_init(&kreq_send_worker.lock, NULL);
+	kreq_send_worker.outstanding = 0;
+	for (i = 0; i < NR_WORKER_THREADS; i++) {
+		err = pthread_create(&kreq_send_worker.thread[i], NULL,
+		                     kreq_send_worker_fn, NULL);
+		if (err)
+			goto out;
+	}
+
 	err = tgt_event_add(chrfd, EPOLLIN, kern_event_handler, NULL);
+
+out:
 	if (err)
 		close(chrfd);
 	return err;


From rcj at linux.vnet.ibm.com  Tue Oct 23 23:31:36 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Tue, 23 Oct 2007 16:31:36 -0500
Subject: [Stgt-devel] [Patch 3/4] (kernel) tgt_write process one entry
In-Reply-To: <20071023211400.GA6091@linux.vnet.ibm.com>
References: <20071023211400.GA6091@linux.vnet.ibm.com>
Message-ID: <20071023213136.GD6091@linux.vnet.ibm.com>


The tgt_write operation will process only one target event when 
it is called rather than processing all outstanding events.  Added
locking to protect the ring index pointer.

This will call copy_from_user or scsi_map_user_pages, both of which
can sleep.  We need to operate in user context but by processing all
outstanding requests before returning from the write in a single 
thread, the user process is held in the write for a very long period 
of time and we can't process more than one at a time.  With this change
we can alter the userspace code to write from multiple threads.

---
 drivers/scsi/scsi_tgt_if.c |   31 +++++++++++++++++++------------
 1 file changed, 19 insertions(+), 12 deletions(-)

Index: b/drivers/scsi/scsi_tgt_if.c
===================================================================
--- a/drivers/scsi/scsi_tgt_if.c
+++ b/drivers/scsi/scsi_tgt_if.c
@@ -239,19 +239,26 @@ static ssize_t tgt_write(struct file *fi
 {
 	struct tgt_event *ev;
 	struct tgt_ring *ring = &rx_ring;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ring->tr_lock, flags);
+
+	ev = tgt_head_event(ring, ring->tr_idx);
+
+	if (!ev->hdr.status) {
+		spin_unlock_irqrestore(&ring->tr_lock, flags);
+		eprintk("no valid tgt_event found during tgt_write\n");
+		return count;
+	}
+
+	tgt_ring_idx_inc(ring);
+
+	spin_unlock_irqrestore(&ring->tr_lock, flags);
+
+	event_recv_msg(ev);
 
-	while (1) {
-		ev = tgt_head_event(ring, ring->tr_idx);
-		/* do we need this? */
-		flush_dcache_page(virt_to_page(ev));
-
-		if (!ev->hdr.status)
-			break;
-
-		tgt_ring_idx_inc(ring);
-		event_recv_msg(ev);
-		ev->hdr.status = 0;
-	};
+	ev->hdr.status = 0;
+	flush_dcache_page(virt_to_page(ev));
 
 	return count;
 }


From rcj at linux.vnet.ibm.com  Tue Oct 23 23:32:21 2007
From: rcj at linux.vnet.ibm.com (Robert Jennings)
Date: Tue, 23 Oct 2007 16:32:21 -0500
Subject: [Stgt-devel] [Patch 4/4] bs_mmap add O_SYNC to open()
In-Reply-To: <20071023211400.GA6091@linux.vnet.ibm.com>
References: <20071023211400.GA6091@linux.vnet.ibm.com>
Message-ID: <20071023213221.GE6091@linux.vnet.ibm.com>

Add the O_SYNC flag to the open() call.

Signed-off-by: rcj at linux.vnet.ibm.com

---
 usr/bs_mmap.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

Index: tgt/usr/bs_mmap.c
===================================================================
--- tgt.orig/usr/bs_mmap.c	2007-10-23 11:14:56.000000000 -0500
+++ tgt/usr/bs_mmap.c	2007-10-23 15:52:58.000000000 -0500
@@ -229,7 +229,7 @@
 	INIT_LIST_HEAD(&info->finished_list);
 	INIT_LIST_HEAD(&info->pending_list);
 
-	*fd = backed_file_open(path, O_RDWR| O_LARGEFILE, size);
+	*fd = backed_file_open(path, O_RDWR | O_LARGEFILE | O_SYNC, size);
 	if (*fd < 0)
 		return *fd;
 


From michaelc at cs.wisc.edu  Wed Oct 24 23:52:55 2007
From: michaelc at cs.wisc.edu (Mike Christie)
Date: Wed, 24 Oct 2007 16:52:55 -0500
Subject: [Stgt-devel] Which kernel should be used for stgt?
In-Reply-To: <471C4B4D.3070707@Voltaire.COM>
References: <471B6B30.30501@Voltaire.COM> <471BA5FF.9080202@cs.wisc.edu>
	<471C4B4D.3070707@Voltaire.COM>
Message-ID: <471FBEB7.5040406@cs.wisc.edu>

Erez Zilber wrote:
> Mike Christie wrote:
>> Erez Zilber wrote:
>>> Hi,
>>>
>>> So far, I ran stgt only over the kernel from the linux-2.6-target git 
>>> tree. Can I run it over any kernel >= 2.6.20? Can I also run it over 
>>> any major distro? SLES 10 sp1? RHEL 5? RHEL 5.1?
>>
>> It depends on what target you want to run. Are you just wanting to run 
>> the iscsi/iser parts? You did not want to run ibm vscsi did you?
> 
> Currently, I'm just interested in running iSCSI over iSER.
> 

tgt does not need any target specific kernel parts like the scsi_tgt_lib 
module (maybe we are still bringing in headers during compilation - I do 
not remember).

And you would know best what infinniband bits you need.

That should be it I think.


From tomof at acm.org  Thu Oct 25 00:11:55 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Thu, 25 Oct 2007 07:11:55 +0900
Subject: [Stgt-devel] Which kernel should be used for stgt?
In-Reply-To: <471FBEB7.5040406@cs.wisc.edu>
References: <471BA5FF.9080202@cs.wisc.edu> <471C4B4D.3070707@Voltaire.COM>
	<471FBEB7.5040406@cs.wisc.edu>
Message-ID: <20071025071406N.tomof@acm.org>

On Wed, 24 Oct 2007 16:52:55 -0500
Mike Christie <michaelc at cs.wisc.edu> wrote:

> Erez Zilber wrote:
> > Mike Christie wrote:
> >> Erez Zilber wrote:
> >>> Hi,
> >>>
> >>> So far, I ran stgt only over the kernel from the linux-2.6-target git 
> >>> tree. Can I run it over any kernel >= 2.6.20? Can I also run it over 
> >>> any major distro? SLES 10 sp1? RHEL 5? RHEL 5.1?
> >>
> >> It depends on what target you want to run. Are you just wanting to run 
> >> the iscsi/iser parts? You did not want to run ibm vscsi did you?
> > 
> > Currently, I'm just interested in running iSCSI over iSER.
> > 
> 
> tgt does not need any target specific kernel parts like the scsi_tgt_lib 
> module (maybe we are still bringing in headers during compilation - I do 
> not remember).

You can compile the iSCSI code without tgt's kernel headers.


From erezz at voltaire.com  Thu Oct 25 16:11:34 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Thu, 25 Oct 2007 16:11:34 +0200
Subject: [Stgt-devel] iSER for stgt - wiki page
Message-ID: <4720A416.8010503@voltaire.com>

The following wiki page is a quick start guide for running an iSCSI over
iSER target through the open-source stgt project:


https://wiki.openfabrics.org/tiki-index.php?page=ISER-target


For more information about stgt: http://stgt.berlios.de/


I hope that you find it helpful.


-- 

____________________________________________________________

Erez Zilber | 972-9-971-7689

Software Engineer, Storage Solutions

Voltaire ? _The Grid Backbone_

__

www.voltaire.com <http://www.voltaire.com/>





From ssufficool at rov.sbcounty.gov  Sat Oct 27 00:31:28 2007
From: ssufficool at rov.sbcounty.gov (Sufficool, Stanley)
Date: Fri, 26 Oct 2007 15:31:28 -0700
Subject: [Stgt-devel] [ofa-general] iSER for stgt - wiki page
In-Reply-To: <4720A416.8010503@voltaire.com>
Message-ID: <C2F174F99918D54CA2A96E57C5079B6F35512B@sbc-exmsg2.sbcounty.gov>

Does anyone know a source for Windows initiators for iSER?

-----Original Message-----
From: general-bounces at lists.openfabrics.org
[mailto:general-bounces at lists.openfabrics.org] On Behalf Of Erez Zilber
Sent: Thursday, October 25, 2007 7:12 AM
To: ewg at lists.openfabrics.org; general at lists.openfabrics.org;
stgt-devel at lists.berlios.de; open-iscsi at googlegroups.com
Subject: [ofa-general] iSER for stgt - wiki page



The following wiki page is a quick start guide for running an iSCSI over
iSER target through the open-source stgt project:


https://wiki.openfabrics.org/tiki-index.php?page=ISER-target


For more information about stgt: http://stgt.berlios.de/


I hope that you find it helpful.


-- 

____________________________________________________________

Erez Zilber | 972-9-971-7689

Software Engineer, Storage Solutions

Voltaire - _The Grid Backbone_

__

www.voltaire.com <http://www.voltaire.com/>




--~--~---------~--~----~------------~-------~--~----~
You received this message because you are subscribed to the Google
Groups "open-iscsi" group. To post to this group, send email to
open-iscsi at googlegroups.com To unsubscribe from this group, send email
to open-iscsi-unsubscribe at googlegroups.com
For more options, visit this group at
http://groups.google.com/group/open-iscsi
-~----------~----~----~----~------~----~------~--~---

_______________________________________________
general mailing list
general at lists.openfabrics.org
http://lists.openfabrics.org/cgi-bin/mailman/listinfo/general

To unsubscribe, please visit
http://openib.org/mailman/listinfo/openib-general


From tomof at acm.org  Sat Oct 27 16:56:15 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 27 Oct 2007 23:56:15 +0900
Subject: [Stgt-devel] [PATCH 02/20] iser counter events
In-Reply-To: <dd2479de1f0ef5cc0e6e83fea0bb1da41f4c31a5.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
	<dd2479de1f0ef5cc0e6e83fea0bb1da41f4c31a5.1192554396.git.pw@osc.edu>
Message-ID: <20071027225926P.tomof@acm.org>

On Tue, 16 Oct 2007 11:18:57 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Like fd event handling, also handle integer counter events.  This will
> be used in RDMA to make progress on a connection, necessary because
> RDMA API does not have a file descriptor that can be used with poll
> to detect connection writability.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/tgtd.c |   70 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++---
>  usr/tgtd.h |    4 +++
>  2 files changed, 70 insertions(+), 4 deletions(-)

Applied, thanks.

I like to have one integrated notification mechanism rather than two
different mechanisms in the future but it's ok for the moment.



From tomof at acm.org  Sat Oct 27 16:56:16 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 27 Oct 2007 23:56:16 +0900
Subject: [Stgt-devel] [PATCH 03/20] iser transport buf
In-Reply-To: <f17443cbe8da015aee7d63a04e7f4ee6094cc831.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
	<f17443cbe8da015aee7d63a04e7f4ee6094cc831.1192554396.git.pw@osc.edu>
Message-ID: <20071027230604S.tomof@acm.org>

On Tue, 16 Oct 2007 11:18:57 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> For RDMA, it is often nice to use data from a pool of pre-registered
> buffers.  To do this, the transport allocates memory for a response and
> passes it down to the devices to fill.  Some operations, though,
> allocate their own buffers and return that new memory instead.  These
> are usually small and the allocation is just done for convenience to
> avoid length bounds checking.  Copy the data into the provided transport
> buffer instead.

Do you really need pre-registered buffers for INQUERY, non I/O
commands?

Using pre-registerd buffers might make the code simpler than handling
both pre-registerd and normal buffers, but we already need to handle
something like that for mmapped I/Os.


> Also fixes some leaks of these extra buffers in error paths, and cleans
> up unreachable code in ibmvio inquiry.

Can you send a separate patch to do that?


From tomof at acm.org  Sat Oct 27 16:56:17 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 27 Oct 2007 23:56:17 +0900
Subject: [Stgt-devel] [PATCH 04/20] iser bidi alloc read buf
In-Reply-To: <fbce48d03005d95a2bdd5de062bbf5595cc75f85.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
	<fbce48d03005d95a2bdd5de062bbf5595cc75f85.1192554396.git.pw@osc.edu>
Message-ID: <20071027231647F.tomof@acm.org>

On Tue, 16 Oct 2007 11:19:03 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Allocate the read buffer for bidirectional commands in the transport to
> pass down to devices.  A device can fill and return this buffer in
> task->uaddr, and thus choose to do the read or write processing in any

Where do you free bidi buffer?

Please don't forget that bidi support isn't only for iSER. everyone
needs it.

The current buffer management is not clean so feel free to rewrite it
before iSER if you want.


> order.  Unfortunately, this allocation can not be combined with the task
> and task->data allocation as the bidi read size is not known until after
> AHS processing.

We need to change task->data allocation since we need aligned buffer
for DIO. The iSCSI driver uses page cache buf IET experience tells
me that we need to support DIO too.


From tomof at acm.org  Sat Oct 27 16:56:19 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 27 Oct 2007 23:56:19 +0900
Subject: [Stgt-devel] [PATCH 07/20] iser virtualize event modify
In-Reply-To: <6f71376b0db8fe6819ff2577abe75d5f2c6b7fae.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
	<6f71376b0db8fe6819ff2577abe75d5f2c6b7fae.1192554396.git.pw@osc.edu>
Message-ID: <20071027232820C.tomof@acm.org>

On Tue, 16 Oct 2007 11:19:51 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Make event modification a transport-specific operation.  TCP
> has a nice transmit flow control mechanism that relies on
> checking that the socket is writeable.  RDMA cannot take
> advantage of this.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsi_tcp.c |   26 ++++++++++++++++++--------
>  usr/iscsi/iscsid.c    |   20 +++++++++++---------
>  usr/iscsi/transport.h |    1 +
>  3 files changed, 30 insertions(+), 17 deletions(-)

Applied, thanks.


From tomof at acm.org  Sat Oct 27 16:56:17 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 27 Oct 2007 23:56:17 +0900
Subject: [Stgt-devel] [PATCH 05/20] iser cpu to be 64
In-Reply-To: <e5cfc5455c00b450121a9f6c6e80f6643cecf0bd.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
	<e5cfc5455c00b450121a9f6c6e80f6643cecf0bd.1192554396.git.pw@osc.edu>
Message-ID: <20071027231930S.tomof@acm.org>

On Tue, 16 Oct 2007 11:19:05 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Define underscore-free 64-bit versions of CPU to big-endian conversions,
> for consistency with the rest of iscsi.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsid.h |    2 ++
>  1 files changed, 2 insertions(+), 0 deletions(-)

Applied.


From tomof at acm.org  Sat Oct 27 16:56:18 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 27 Oct 2007 23:56:18 +0900
Subject: [Stgt-devel] [PATCH 06/20] iser list del init
In-Reply-To: <bdd74df53ac270f481d5932040e662cf94951660.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
	<bdd74df53ac270f481d5932040e662cf94951660.1192554396.git.pw@osc.edu>
Message-ID: <20071027231941X.tomof@acm.org>

On Tue, 16 Oct 2007 11:19:07 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Add this handy function for removing an item from a list and
> initializing its list pointers.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/list.h |    6 ++++++
>  1 files changed, 6 insertions(+), 0 deletions(-)

Applied.


From tomof at acm.org  Sat Oct 27 16:56:19 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sat, 27 Oct 2007 23:56:19 +0900
Subject: [Stgt-devel] [PATCH 09/20] iser event handler to tcp
In-Reply-To: <4c49de1d38fc3ccd34899fb12a7be1c8c31563d4.1192554396.git.pw@osc.edu>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
	<4c49de1d38fc3ccd34899fb12a7be1c8c31563d4.1192554396.git.pw@osc.edu>
Message-ID: <20071027235719N.tomof@acm.org>

On Tue, 16 Oct 2007 11:20:22 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Move iscsi_event_handler to iscsi_tcp.c as it is TCP-specific.  RDMA will
> have its own event handler.  Both will call into iscsi_tx_handler and
> iscsi_rx_handler, which are now exported, along with iscsi_scsi_cmd_execute
> that will be needed when an RDMA read collects all the write data.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/iscsi/iscsi_tcp.c |   23 ++++++++++++++++++++++-
>  usr/iscsi/iscsid.c    |   25 +++----------------------
>  usr/iscsi/iscsid.h    |    4 +++-
>  3 files changed, 28 insertions(+), 24 deletions(-)

Applied, thanks.


From pw at osc.edu  Sat Oct 27 20:56:23 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 27 Oct 2007 14:56:23 -0400
Subject: [Stgt-devel] [PATCH 03/20] iser transport buf
In-Reply-To: <20071027230604S.tomof@acm.org>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
	<f17443cbe8da015aee7d63a04e7f4ee6094cc831.1192554396.git.pw@osc.edu>
	<20071027230604S.tomof@acm.org>
Message-ID: <20071027185623.GA30411@osc.edu>

tomof at acm.org wrote on Sat, 27 Oct 2007 23:56 +0900:
> On Tue, 16 Oct 2007 11:18:57 -0400
> Pete Wyckoff <pw at osc.edu> wrote:
> 
> > For RDMA, it is often nice to use data from a pool of pre-registered
> > buffers.  To do this, the transport allocates memory for a response and
> > passes it down to the devices to fill.  Some operations, though,
> > allocate their own buffers and return that new memory instead.  These
> > are usually small and the allocation is just done for convenience to
> > avoid length bounds checking.  Copy the data into the provided transport
> > buffer instead.
> 
> Do you really need pre-registered buffers for INQUERY, non I/O
> commands?

To send the data, it must be in a registered buffer.  We preregister
some for this purpose.  The other way is to dynamically register
the buffer, then deregister it after tha data has been transferred.
This adds lots of overhead, especially in the small IO case (like
inquiry), and code complexity.

Currently iscsi_alloc_task() uses malloc() to get a buffer big
enough for the incoming command and any data that will be returned
such as the inquiry result.  The approach in RDMA is to make sure
that the allocation comes from the preregistered area.  TCP just
uses malloc() as before.

IO operations like in bs_sync will copy data into the cmd->uaddr
(same as iscsi's task->data).  Some inquiry-like routines allocate a
page-size buffer themselves with valloc() to avoid lots of little
bounds checks, and return this instead of using the provided
cmd->uaddr.  But this avoids our preregistered buffer space.

So the new approach in these inquiry-like routines is to continue to
valloc() a page to hold the generated data and fill it, but then
invoke a new helper "spc_return_buf()" that copies data from the
valloc()-ed area into cmd->uaddr.

> Using pre-registerd buffers might make the code simpler than handling
> both pre-registerd and normal buffers, but we already need to handle
> something like that for mmapped I/Os.

Only bs_mmap handles cmd->mmaped.  It appears to be not for use with
iscsi.

The modifications to inquiry only happen if cmd->uaddr is non-NULL.

> > Also fixes some leaks of these extra buffers in error paths, and cleans
> > up unreachable code in ibmvio inquiry.
> 
> Can you send a separate patch to do that?

Split up into two prior patches.

		-- Pete


From pw at osc.edu  Sat Oct 27 20:34:49 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 27 Oct 2007 14:34:49 -0400
Subject: [Stgt-devel] [PATCH 1/2] ibmvio unreachable code
In-Reply-To: <20071027185623.GA30411@osc.edu>
References: <20071027185623.GA30411@osc.edu>
Message-ID: <a53ed3b232b5ad556065c0f5199b1505800ab7f7.1193511441.git.pw@osc.edu>

Move code around to remove unreachable bits.  Swap EVPD conditional so
that spc_inquiry returns immediately.  Note that ret is always
SAM_STAT_GOOD because __ibmvio_inquiry can not fail.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/ibmvio/ibmvio.c |   10 ++--------
 1 files changed, 2 insertions(+), 8 deletions(-)

diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index cdd3782..5836498 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -139,7 +139,6 @@ static int __ibmvio_inquiry(int host_no, struct scsi_cmd *cmd, uint8_t *data)
 
 static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 {
-	int ret = SAM_STAT_CHECK_CONDITION;
 	uint8_t *data, *scb = cmd->scb;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
@@ -157,15 +156,10 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 
 	dprintf("%x %x\n", scb[1], scb[2]);
 
-	if (!(scb[1] & 0x3)) {
-		cmd->len = __ibmvio_inquiry(host_no, cmd, data);
-		ret = SAM_STAT_GOOD;
-	} else
+	if (scb[1] & 0x3)
 		return spc_inquiry(host_no, cmd);
 
-	if (ret != SAM_STAT_GOOD)
-		goto sense;
-
+	cmd->len = __ibmvio_inquiry(host_no, cmd, data);
 	cmd->len = min_t(int, cmd->len, scb[4]);
 	cmd->uaddr = (unsigned long) data;
 
-- 
1.5.3.4



From pw at osc.edu  Sat Oct 27 20:34:53 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 27 Oct 2007 14:34:53 -0400
Subject: [Stgt-devel] [PATCH 2/2] plug valloc leaks
In-Reply-To: <a53ed3b232b5ad556065c0f5199b1505800ab7f7.1193511441.git.pw@osc.edu>
References: <a53ed3b232b5ad556065c0f5199b1505800ab7f7.1193511441.git.pw@osc.edu>
Message-ID: <72018d8916d8da8cf3eb71e957458f1a99f4e7e6.1193511441.git.pw@osc.edu>

A few inquiry and related handlers do not release their valloc-ed pages
in error paths.  Fix these.

ibmvio inquiry:  only alloc when needed for __ibmvio_inquiry, not for
spc_inquiry.

smc read element status:  inspect reserved byte first, free for
unknown element type.

spc inquiry:  free in error path.

spc mode sense:  free in sense for a few failure cases.

Signed-off-by: Pete Wyckoff <pw at osc.edu>
---
 usr/ibmvio/ibmvio.c |   10 +++++-----
 usr/smc.c           |    7 ++++---
 usr/spc.c           |    8 ++++++--
 3 files changed, 15 insertions(+), 10 deletions(-)

diff --git a/usr/ibmvio/ibmvio.c b/usr/ibmvio/ibmvio.c
index 5836498..0e6b256 100644
--- a/usr/ibmvio/ibmvio.c
+++ b/usr/ibmvio/ibmvio.c
@@ -146,6 +146,11 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	if (((scb[1] & 0x3) == 0x3) || (!(scb[1] & 0x3) && scb[2]))
 		goto sense;
 
+	dprintf("%x %x\n", scb[1], scb[2]);
+
+	if (scb[1] & 0x3)
+		return spc_inquiry(host_no, cmd);
+
 	data = valloc(pagesize);
 	if (!data) {
 		key = HARDWARE_ERROR;
@@ -154,11 +159,6 @@ static int ibmvio_inquiry(int host_no, struct scsi_cmd *cmd)
 	}
 	memset(data, 0, pagesize);
 
-	dprintf("%x %x\n", scb[1], scb[2]);
-
-	if (scb[1] & 0x3)
-		return spc_inquiry(host_no, cmd);
-
 	cmd->len = __ibmvio_inquiry(host_no, cmd, data);
 	cmd->len = min_t(int, cmd->len, scb[4]);
 	cmd->uaddr = (unsigned long) data;
diff --git a/usr/smc.c b/usr/smc.c
index df38b25..9d55992 100644
--- a/usr/smc.c
+++ b/usr/smc.c
@@ -273,6 +273,9 @@ static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
 		goto sense;
 	}
 
+	if (scb[11])	/* Reserved byte */
+		goto sense;
+
 	data = valloc(pagesize);
 	if (!data) {
 		dprintf("valloc(%lu) failed\n", pagesize);
@@ -282,9 +285,6 @@ static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
 	}
 	memset(data, 0, pagesize);
 
-	if (scb[11])	/* Reserved byte */
-		goto sense;
-
 	switch(element_type) {
 	case ELEMENT_ANY:
 		/* Return element in type order */
@@ -333,6 +333,7 @@ static int smc_read_element_status(int host_no, struct scsi_cmd *cmd)
 						  dvcid, voltag);
 		break;
 	default:
+		free(data);
 		goto sense;
 		break;
 	}
diff --git a/usr/spc.c b/usr/spc.c
index 45a0430..3e1f65e 100644
--- a/usr/spc.c
+++ b/usr/spc.c
@@ -234,8 +234,10 @@ int spc_inquiry(int host_no, struct scsi_cmd *cmd)
 		}
 	}
 
-	if (ret != SAM_STAT_GOOD)
+	if (ret != SAM_STAT_GOOD) {
+		free(data);
 		goto sense;
+	}
 
 	cmd->len = min_t(int, len, scb[4]);
 	cmd->uaddr = (unsigned long) data;
@@ -373,7 +375,7 @@ static int build_mode_page(uint8_t *data, struct mode_pg *pg)
 int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 {
 	int len = 0;
-	uint8_t *data, *scb, mode6, dbd, pcode, subpcode;
+	uint8_t *data = NULL, *scb, mode6, dbd, pcode, subpcode;
 	uint16_t alloc_len;
 	unsigned char key = ILLEGAL_REQUEST;
 	uint16_t asc = ASC_INVALID_FIELD_IN_CDB;
@@ -441,6 +443,8 @@ int spc_mode_sense(int host_no, struct scsi_cmd *cmd)
 	return SAM_STAT_GOOD;
 
 sense:
+	if (data)
+		free(data);
 	cmd->len = 0;
 	sense_data_build(cmd, key, asc);
 	return SAM_STAT_CHECK_CONDITION;
-- 
1.5.3.4



From pw at osc.edu  Sat Oct 27 23:29:47 2007
From: pw at osc.edu (Pete Wyckoff)
Date: Sat, 27 Oct 2007 17:29:47 -0400
Subject: [Stgt-devel] [PATCH 04/20] iser bidi alloc read buf
In-Reply-To: <20071027231647F.tomof@acm.org>
References: <2beef6fd41305fae52a1692d649646f3a0e05cf9.1192554396.git.pw@osc.edu>
	<fbce48d03005d95a2bdd5de062bbf5595cc75f85.1192554396.git.pw@osc.edu>
	<20071027231647F.tomof@acm.org>
Message-ID: <20071027212947.GA30638@osc.edu>

tomof at acm.org wrote on Sat, 27 Oct 2007 23:56 +0900:
> On Tue, 16 Oct 2007 11:19:03 -0400
> Pete Wyckoff <pw at osc.edu> wrote:
> 
> > Allocate the read buffer for bidirectional commands in the transport to
> > pass down to devices.  A device can fill and return this buffer in
> > task->uaddr, and thus choose to do the read or write processing in any
> 
> Where do you free bidi buffer?

The bs sets cmd->uaddr to be the data-in buffer (from initiator
point of view) as it returns.  iscsi puts this in task->addr then
later frees it if (task->addr != task->data).  Yeah, kind of
complex.

Write command:  single allocation: task plus data-out all in one go.
    bs is given task->data, does not change cmd->uaddr.  Single free
    of task releases it.

Read command:  single alloction:  task plus expected data-in size.
    bs is given task->data, fills it, does not change cmd->uaddr.
    Single free.

(Inquiry etc look like read, and used to return a new cmd->uaddr,
    requiring a second free.  But now use given task->data after
    iser-transport-buf is applied.)

Bidi command:  two allocations: task plus data-out, expected
    data-in.  bs is given task->data as cmd->uaddr, and the
    buffer for the data-in as cmd->bidi_uaddr.  It sets cmd->uaddr
    to cmd->bidi_uaddr as it finishes, then iscsi frees that and
    the task.

Before this patch, bidi started out like write, but then the bs
would malloc a new buffer for the read result and return that in
cmd->uaddr.  iscsi_free_task() sees task->addr != task->data and
frees that as well as task, just like old inquiry implementation.
Change here is to make sure we can use a preallocated buffer from
the transport if one is given.

> Please don't forget that bidi support isn't only for iSER. everyone
> needs it.

Yes, we got bidi working back in March 2007 and use it every day,
without iSER.  Unfortunately the only bidi user is in our
out-of-tree OSD code.  We're releasing the software OSD target
library soon, then could add the backing store code to stgt,
dependent on the presence of that library.

> The current buffer management is not clean so feel free to rewrite it
> before iSER if you want.

I would be willing to do this, but don't have a better suggestion
yet.  Any ideas welcome.  Difficulty is supporting both bidi-aware
and non-aware bs, and pre-malloc and non-pre-malloc transports.  All
while minimizing the number of malloc operations per command.

> > order.  Unfortunately, this allocation can not be combined with the task
> > and task->data allocation as the bidi read size is not known until after
> > AHS processing.
> 
> We need to change task->data allocation since we need aligned buffer
> for DIO. The iSCSI driver uses page cache buf IET experience tells
> me that we need to support DIO too.

As in bs_xen?  Do you think the DIO alignment needs could fit into
the framework described above?  Or does the BS somehow need to tell
the transport what to allocate, to get alignment space?  That would
definitely affect any proposed buffer mgmt rewrite.

		-- Pete


From tomof at acm.org  Sun Oct 28 06:46:19 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 28 Oct 2007 14:46:19 +0900
Subject: [Stgt-devel] [PATCH 2/2] plug valloc leaks
In-Reply-To: <72018d8916d8da8cf3eb71e957458f1a99f4e7e6.1193511441.git.pw@osc.edu>
References: <a53ed3b232b5ad556065c0f5199b1505800ab7f7.1193511441.git.pw@osc.edu>
	<72018d8916d8da8cf3eb71e957458f1a99f4e7e6.1193511441.git.pw@osc.edu>
Message-ID: <20071028133919N.tomof@acm.org>

On Sat, 27 Oct 2007 14:34:53 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> A few inquiry and related handlers do not release their valloc-ed pages
> in error paths.  Fix these.
> 
> ibmvio inquiry:  only alloc when needed for __ibmvio_inquiry, not for
> spc_inquiry.
> 
> smc read element status:  inspect reserved byte first, free for
> unknown element type.
> 
> spc inquiry:  free in error path.
> 
> spc mode sense:  free in sense for a few failure cases.
> 
> Signed-off-by: Pete Wyckoff <pw at osc.edu>
> ---
>  usr/ibmvio/ibmvio.c |   10 +++++-----
>  usr/smc.c           |    7 ++++---
>  usr/spc.c           |    8 ++++++--
>  3 files changed, 15 insertions(+), 10 deletions(-)

Applied, thanks a lot!


From tomof at acm.org  Sun Oct 28 06:46:18 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 28 Oct 2007 14:46:18 +0900
Subject: [Stgt-devel] [PATCH 1/2] ibmvio unreachable code
In-Reply-To: <a53ed3b232b5ad556065c0f5199b1505800ab7f7.1193511441.git.pw@osc.edu>
References: <20071027185623.GA30411@osc.edu>
	<a53ed3b232b5ad556065c0f5199b1505800ab7f7.1193511441.git.pw@osc.edu>
Message-ID: <20071028133905S.tomof@acm.org>

On Sat, 27 Oct 2007 14:34:49 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> Move code around to remove unreachable bits.  Swap EVPD conditional so
> that spc_inquiry returns immediately.  Note that ret is always
> SAM_STAT_GOOD because __ibmvio_inquiry can not fail.

Applied, thanks.

I need to fix __ibmvio_inquiry (which might fail though pretty
rarely).


From tomof at acm.org  Sun Oct 28 06:46:20 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 28 Oct 2007 14:46:20 +0900
Subject: [Stgt-devel] [PATCH 04/20] iser bidi alloc read buf
In-Reply-To: <20071027212947.GA30638@osc.edu>
References: <fbce48d03005d95a2bdd5de062bbf5595cc75f85.1192554396.git.pw@osc.edu>
	<20071027231647F.tomof@acm.org> <20071027212947.GA30638@osc.edu>
Message-ID: <20071028144731U.tomof@acm.org>

On Sat, 27 Oct 2007 17:29:47 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> tomof at acm.org wrote on Sat, 27 Oct 2007 23:56 +0900:
> > On Tue, 16 Oct 2007 11:19:03 -0400
> > Pete Wyckoff <pw at osc.edu> wrote:
> > 
> > > Allocate the read buffer for bidirectional commands in the transport to
> > > pass down to devices.  A device can fill and return this buffer in
> > > task->uaddr, and thus choose to do the read or write processing in any
> > 
> > Where do you free bidi buffer?
> 
> The bs sets cmd->uaddr to be the data-in buffer (from initiator
> point of view) as it returns.  iscsi puts this in task->addr then
> later frees it if (task->addr != task->data).  Yeah, kind of
> complex.

Yeah, I really messed up the data buffer handling and bidi will make
it worse.


> Write command:  single allocation: task plus data-out all in one go.
>     bs is given task->data, does not change cmd->uaddr.  Single free
>     of task releases it.
> 
> Read command:  single alloction:  task plus expected data-in size.
>     bs is given task->data, fills it, does not change cmd->uaddr.
>     Single free.
> 
> (Inquiry etc look like read, and used to return a new cmd->uaddr,
>     requiring a second free.  But now use given task->data after
>     iser-transport-buf is applied.)
> 
> Bidi command:  two allocations: task plus data-out, expected
>     data-in.  bs is given task->data as cmd->uaddr, and the
>     buffer for the data-in as cmd->bidi_uaddr.  It sets cmd->uaddr
>     to cmd->bidi_uaddr as it finishes, then iscsi frees that and
>     the task.
> 
> Before this patch, bidi started out like write, but then the bs
> would malloc a new buffer for the read result and return that in
> cmd->uaddr.  iscsi_free_task() sees task->addr != task->data and
> frees that as well as task, just like old inquiry implementation.
> Change here is to make sure we can use a preallocated buffer from
> the transport if one is given.

Would scsi_data_buffer in scsi-ml to make the code more simple? I have
no problem with adding two scsi_data_buffer structures to scsi_cmnd.

struct scsi_cmnd {
       struct scsi_data_buffer data_in;
       struct scsi_data_buffer data_out;

And we add some accessors. iSCSI code should not access to them
directly.

Another thing that I'd like to is moving the buffer management from
iSCSI code as much as possible. We will have more software target
drivers like SRP and FCoE. They need bidi too and we need clean and
simple buffer management.


> > Please don't forget that bidi support isn't only for iSER. everyone
> > needs it.
> 
> Yes, we got bidi working back in March 2007 and use it every day,
> without iSER.  Unfortunately the only bidi user is in our
> out-of-tree OSD code.  We're releasing the software OSD target
> library soon, then could add the backing store code to stgt,
> dependent on the presence of that library.

Great, I'm looking forward to OSD code.


> > The current buffer management is not clean so feel free to rewrite it
> > before iSER if you want.
> 
> I would be willing to do this, but don't have a better suggestion
> yet.  Any ideas welcome.  Difficulty is supporting both bidi-aware
> and non-aware bs, and pre-malloc and non-pre-malloc transports.  All
> while minimizing the number of malloc operations per command.
> 
> > > order.  Unfortunately, this allocation can not be combined with the task
> > > and task->data allocation as the bidi read size is not known until after
> > > AHS processing.
> > 
> > We need to change task->data allocation since we need aligned buffer
> > for DIO. The iSCSI driver uses page cache buf IET experience tells
> > me that we need to support DIO too.
> 
> As in bs_xen?  Do you think the DIO alignment needs could fit into
> the framework described above?  Or does the BS somehow need to tell
> the transport what to allocate, to get alignment space?  That would
> definitely affect any proposed buffer mgmt rewrite.

Please forget bs_xen. We could remove it. :)

iSCSI seems to need DIO. It turned out that several people have
problems with IET default I/O scheme using page cache.

And yes, DIO needs aligment buffer. So as I wrote in another mail,
pre-allocated aligned buffer would work for DIO.


From tomof at acm.org  Sun Oct 28 06:46:19 2007
From: tomof at acm.org (FUJITA Tomonori)
Date: Sun, 28 Oct 2007 14:46:19 +0900
Subject: [Stgt-devel] [PATCH 03/20] iser transport buf
In-Reply-To: <20071027185623.GA30411@osc.edu>
References: <f17443cbe8da015aee7d63a04e7f4ee6094cc831.1192554396.git.pw@osc.edu>
	<20071027230604S.tomof@acm.org> <20071027185623.GA30411@osc.edu>
Message-ID: <20071028135818Y.tomof@acm.org>

On Sat, 27 Oct 2007 14:56:23 -0400
Pete Wyckoff <pw at osc.edu> wrote:

> tomof at acm.org wrote on Sat, 27 Oct 2007 23:56 +0900:
> > On Tue, 16 Oct 2007 11:18:57 -0400
> > Pete Wyckoff <pw at osc.edu> wrote:
> > 
> > > For RDMA, it is often nice to use data from a pool of pre-registered
> > > buffers.  To do this, the transport allocates memory for a response and
> > > passes it down to the devices to fill.  Some operations, though,
> > > allocate their own buffers and return that new memory instead.  These
> > > are usually small and the allocation is just done for convenience to
> > > avoid length bounds checking.  Copy the data into the provided transport
> > > buffer instead.
> > 
> > Do you really need pre-registered buffers for INQUERY, non I/O
> > commands?
> 
> To send the data, it must be in a registered buffer.  We preregister
> some for this purpose.  The other way is to dynamically register
> the buffer, then deregister it after tha data has been transferred.
> This adds lots of overhead, especially in the small IO case (like
> inquiry), and code complexity.

Sorry, I should have explained better. I meant to dynamic
registeration. BTW, I'm familiar with RDMA transfer since I had been
working on RDMA technology, lightweight protocols like VIA. And you
know, ibmvstgt uses RDMA.

What I asked is that we could use pre-registered buffers for I/Os
(read/write) and dynamic registered buffer for non I/O commands like
INQUIRY. As I said and (you said), it might lead to complexity but we
have sense buffer in scsi_cmnd so you need dynamic registration
anyway?


> Currently iscsi_alloc_task() uses malloc() to get a buffer big
> enough for the incoming command and any data that will be returned
> such as the inquiry result.  The approach in RDMA is to make sure
> that the allocation comes from the preregistered area.  TCP just
> uses malloc() as before.

As I wrote in another mail, tcp also might need pre-registered memory
mechanism for DIO.


> IO operations like in bs_sync will copy data into the cmd->uaddr
> (same as iscsi's task->data).  Some inquiry-like routines allocate a
> page-size buffer themselves with valloc() to avoid lots of little
> bounds checks, and return this instead of using the provided
> cmd->uaddr.  But this avoids our preregistered buffer space.
> 
> So the new approach in these inquiry-like routines is to continue to
> valloc() a page to hold the generated data and fill it, but then
> invoke a new helper "spc_return_buf()" that copies data from the
> valloc()-ed area into cmd->uaddr.
> 
> > Using pre-registerd buffers might make the code simpler than handling
> > both pre-registerd and normal buffers, but we already need to handle
> > something like that for mmapped I/Os.
> 
> Only bs_mmap handles cmd->mmaped.  It appears to be not for use with
> iscsi.
> 
> The modifications to inquiry only happen if cmd->uaddr is non-NULL.
> 
> > > Also fixes some leaks of these extra buffers in error paths, and cleans
> > > up unreachable code in ibmvio inquiry.
> > 
> > Can you send a separate patch to do that?
> 
> Split up into two prior patches.

Thanks, applied.


From erezz at voltaire.com  Sun Oct 28 09:10:06 2007
From: erezz at voltaire.com (Erez Zilber)
Date: Sun, 28 Oct 2007 10:10:06 +0200
Subject: [Stgt-devel] [ofa-general] iSER for stgt - wiki page
In-Reply-To: <C2F174F99918D54CA2A96E57C5079B6F35512B@sbc-exmsg2.sbcounty.gov>
References: <C2F174F99918D54CA2A96E57C5079B6F35512B@sbc-exmsg2.sbcounty.gov>
Message-ID: <472443DE.8080503@voltaire.com>

Sufficool, Stanley wrote:

> Does anyone know a source for Windows initiators for iSER?
>

Currently, there's no open-source iSER initiator for Windows. However,
we (Voltaire) are working on it.

-- 

____________________________________________________________

Erez Zilber | 972-9-971-7689

Software Engineer, Storage Solutions

Voltaire ? _The Grid Backbone_

__

www.voltaire.com <http://www.voltaire.com/>





